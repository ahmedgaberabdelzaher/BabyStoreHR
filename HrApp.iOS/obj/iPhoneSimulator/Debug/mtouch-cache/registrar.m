#define DEBUG 1
#include <xamarin/xamarin.h>
#include "registrar.h"
extern "C" {
static void native_to_managed_trampoline_1 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_2 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	xamarin_framework_peer_waypoint ();
	mt_dummy_use (retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_3 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_4 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_5 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_6 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_7 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_8 (id self, SEL _cmd, MonoMethod **managed_method_ptr, bool* call_super, uint32_t token_ref)
{
	MonoClass *declaring_type = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	declaring_type = mono_method_get_class (managed_method);
	mthis = xamarin_new_nsobject (self, declaring_type, &exception_gchandle);
	xamarin_mono_object_release (&declaring_type);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return self;
}


static NSInteger native_to_managed_trampoline_9 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_10 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_11 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1D97A22 /* UIKit.UIApplicationRestorationHandler ObjCRuntime.Trampolines/NIDUIApplicationRestorationHandler::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_12 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_13 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_14 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1D00522 /* System.Action`1<UIKit.UIBackgroundFetchResult> ObjCRuntime.Trampolines/NIDActionArity1V21::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static NSUInteger native_to_managed_trampoline_15 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_16 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoClass *declaring_type = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	declaring_type = mono_method_get_class (managed_method);
	mthis = xamarin_new_nsobject (self, declaring_type, &exception_gchandle);
	xamarin_mono_object_release (&declaring_type);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return self;
}


static void native_to_managed_trampoline_17 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, int p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_18 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, int p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_19 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, int p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_20 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_21 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_22 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id* p2, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *mobj2 = NULL;
	MonoObject *mobj_out2 = NULL;
	void * handle2 = NULL;
	MonoClass *declaring_type = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	mobj_out2 = mobj2;
	arg_ptrs [2] = (int *) &mobj_out2;

	declaring_type = mono_method_get_class (managed_method);
	mthis = xamarin_new_nsobject (self, declaring_type, &exception_gchandle);
	xamarin_mono_object_release (&declaring_type);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (mobj_out2 != NULL) {
		handle2 = xamarin_get_nsobject_handle (mobj_out2);
		xamarin_mono_object_release (&mobj_out2);
	}
	if (p2 != NULL)
		*p2 = (id) handle2;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return self;
}


static float native_to_managed_trampoline_23 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_24 (id self, SEL _cmd, MonoMethod **managed_method_ptr, float p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static CGAffineTransform native_to_managed_trampoline_25 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGAffineTransform res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGAffineTransform *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_26 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGAffineTransform p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_27 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static CGRect native_to_managed_trampoline_28 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_29 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static CGPoint native_to_managed_trampoline_30 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGPoint res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGPoint *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_31 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_32 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		xamarin_framework_peer_waypoint ();
		if (retobj != NULL) {
			bool retained = xamarin_attempt_retain_nsobject (retval, &exception_gchandle);
			if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
			if (retained) {
				[retobj autorelease];
			}
			mt_dummy_use (retval);
			res = retobj;
		} else {
			res = NULL;
		}
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_33 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	MonoType *type0;
	MonoObject *inobj0 = NULL;
	MonoReflectionType *reflectiontype0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	type0 = xamarin_get_parameter_type (managed_method, 0);
	reflectiontype0 = mono_type_get_object (mono_domain_get (), type0);
	inobj0 = xamarin_get_inative_object_dynamic (p0, false, reflectiontype0, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = inobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&type0);
	xamarin_mono_object_release (&inobj0);
	xamarin_mono_object_release (&reflectiontype0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_34 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	xamarin_framework_peer_waypoint ();
	mt_dummy_use (retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_35 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	MonoArray *marr0 = NULL;
	NSArray *arr0 = NULL;
	MonoType *paramtype0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arr0 = p0;
	xamarin_check_objc_type (p0, [NSArray class], _cmd, self, 0, managed_method);
	paramtype0 = xamarin_get_parameter_type (managed_method, 0);
	marr0 = xamarin_nsarray_to_managed_nsobject_array (arr0, paramtype0, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = marr0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&marr0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_36 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_37 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_38 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	MonoString *a0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	a0 = xamarin_nsstring_to_string (NULL, p0);
	arg_ptrs [0] = a0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&a0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_39 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	void * a2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_40 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, void * p2, uint32_t token_ref)
{
	MonoString *a0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	void * a2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	a0 = xamarin_nsstring_to_string (NULL, p0);
	arg_ptrs [0] = a0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&a0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_41 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoType *type1;
	MonoObject *inobj1 = NULL;
	MonoReflectionType *reflectiontype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	type1 = xamarin_get_parameter_type (managed_method, 1);
	reflectiontype1 = mono_type_get_object (mono_domain_get (), type1);
	inobj1 = xamarin_get_inative_object_dynamic (p1, false, reflectiontype1, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&type1);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&reflectiontype1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_42 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SEL p0, uint32_t token_ref)
{
	MonoObject *a0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	a0 = p0 ? xamarin_get_selector (p0, &exception_gchandle) : NULL;
	arg_ptrs [0] = a0;
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&a0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_43 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoType *type1;
	MonoObject *inobj1 = NULL;
	MonoReflectionType *reflectiontype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	type1 = xamarin_get_parameter_type (managed_method, 1);
	reflectiontype1 = mono_type_get_object (mono_domain_get (), type1);
	inobj1 = xamarin_get_inative_object_dynamic (p1, false, reflectiontype1, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&type1);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&reflectiontype1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_44 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, int p2, int p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoType *type1;
	MonoObject *inobj1 = NULL;
	MonoReflectionType *reflectiontype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	type1 = xamarin_get_parameter_type (managed_method, 1);
	reflectiontype1 = mono_type_get_object (mono_domain_get (), type1);
	inobj1 = xamarin_get_inative_object_dynamic (p1, false, reflectiontype1, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&type1);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&reflectiontype1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_45 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, int p2, int p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoType *type1;
	MonoObject *inobj1 = NULL;
	MonoReflectionType *reflectiontype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	type1 = xamarin_get_parameter_type (managed_method, 1);
	reflectiontype1 = mono_type_get_object (mono_domain_get (), type1);
	inobj1 = xamarin_get_inative_object_dynamic (p1, false, reflectiontype1, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&type1);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&reflectiontype1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_46 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_47 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QuickLook.QLPreviewItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_48 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QuickLook.QLPreviewItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static CGRect native_to_managed_trampoline_49 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id* p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *mobj2 = NULL;
	MonoObject *mobj_out2 = NULL;
	NSObject *nsobj2 = NULL;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	void * handle2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QuickLook.QLPreviewItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	if (p2 != NULL)
		nsobj2 = *(NSObject **) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr (nsobj2, false, paramtype2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the byref parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	mobj_out2 = mobj2;
	arg_ptrs [2] = (int *) &mobj_out2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (mobj_out2 != NULL) {
		handle2 = xamarin_get_nsobject_handle (mobj_out2);
		xamarin_mono_object_release (&mobj_out2);
	}
	if (p2 != NULL)
		*p2 = (id) handle2;

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static NSInteger native_to_managed_trampoline_50 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QuickLook.QLPreviewItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_51 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *inobj2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	inobj2 = xamarin_get_inative_object_static (p2, false, 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QuickLook.QLPreviewItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = inobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&inobj2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_52 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QuickLook.QLPreviewItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_53 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QuickLook.QLPreviewItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_54 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static UIEdgeInsets native_to_managed_trampoline_55 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	UIEdgeInsets res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(UIEdgeInsets *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_56 (id self, SEL _cmd, MonoMethod **managed_method_ptr, UIEdgeInsets p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_57 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	unsigned long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_58 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_59 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static Class native_to_managed_trampoline_60 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	MonoString *a0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	a0 = xamarin_nsstring_to_string (NULL, p0);
	arg_ptrs [0] = a0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}

exception_handling:
	xamarin_mono_object_release (&a0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_61 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF0922 /* System.Action`1<PassKit.PKPaymentAuthorizationStatus> ObjCRuntime.Trampolines/NIDActionArity1V221::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_62 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF0022 /* System.Action`1<PassKit.PKPaymentAuthorizationResult> ObjCRuntime.Trampolines/NIDActionArity1V222::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_63 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF1222 /* System.Action`1<PassKit.PKPaymentRequestCouponCodeUpdate> ObjCRuntime.Trampolines/NIDActionArity1V227::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_64 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *del1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		del1 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF1B22 /* System.Action`1<PassKit.PKPaymentRequestMerchantSessionUpdate> ObjCRuntime.Trampolines/NIDActionArity1V226::Create(System.IntPtr) */ , 1, p1, &exception_gchandle);
		arg_ptrs [1] = del1;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&del1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_65 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF3F22 /* System.Action`1<PassKit.PKPaymentSummaryItem[]> ObjCRuntime.Trampolines/NIDActionArity1V225::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_66 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF2422 /* System.Action`1<PassKit.PKPaymentRequestPaymentMethodUpdate> ObjCRuntime.Trampolines/NIDActionArity1V223::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_67 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoType *type1;
	MonoObject *inobj1 = NULL;
	MonoReflectionType *reflectiontype1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	type1 = xamarin_get_parameter_type (managed_method, 1);
	reflectiontype1 = mono_type_get_object (mono_domain_get (), type1);
	inobj1 = xamarin_get_inative_object_dynamic (p1, false, reflectiontype1, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C55522 /* PassKit.PKPaymentShippingAddressSelected ObjCRuntime.Trampolines/NIDPKPaymentShippingAddressSelected::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&type1);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&reflectiontype1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_68 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C55522 /* PassKit.PKPaymentShippingAddressSelected ObjCRuntime.Trampolines/NIDPKPaymentShippingAddressSelected::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_69 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF2D22 /* System.Action`1<PassKit.PKPaymentRequestShippingContactUpdate> ObjCRuntime.Trampolines/NIDActionArity1V224::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_70 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C55E22 /* PassKit.PKPaymentShippingMethodSelected ObjCRuntime.Trampolines/NIDPKPaymentShippingMethodSelected::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_71 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CF3622 /* System.Action`1<PassKit.PKPaymentRequestShippingMethodUpdate> ObjCRuntime.Trampolines/NIDActionArity1V228::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static NSInteger native_to_managed_trampoline_72 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSUInteger p1, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_73 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void ** p0, NSUInteger* p1, uint32_t token_ref)
{
	void ** a0 = 0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	*p0 = a0;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_74 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_75 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, void * p1, void * p2, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	void * a1 = p1;
	void * a2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &a1;
	arg_ptrs [2] = &a2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_76 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, NSInteger p1, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGFloat native_to_managed_trampoline_77 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static UIOffset native_to_managed_trampoline_78 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	UIOffset res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(UIOffset *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_79 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	long long nativeEnum1 = p1;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_80 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSUInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	unsigned long long nativeEnum1 = p1;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_81 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGFloat p0, NSInteger p1, uint32_t token_ref)
{
	long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_82 (id self, SEL _cmd, MonoMethod **managed_method_ptr, UIOffset p0, NSInteger p1, uint32_t token_ref)
{
	long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_83 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSUInteger p1, NSInteger p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	unsigned long long nativeEnum1 = p1;
	long long nativeEnum2 = p2;
	long long nativeEnum3 = p3;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;
	arg_ptrs [3] = &nativeEnum3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_84 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_85 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSUInteger p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	unsigned long long nativeEnum2 = p2;
	unsigned long long nativeEnum3 = p3;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;
	arg_ptrs [3] = &nativeEnum3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_86 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoType *paramtype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	xamarin_check_objc_type (p1, [NSArray class], _cmd, self, 1, managed_method);
	paramtype1 = xamarin_get_parameter_type (managed_method, 1);
	marr1 = xamarin_nsarray_to_managed_inativeobject_array_static (arr1, paramtype1, NULL, 0xD6C22 /* MapKit.IMKAnnotation */ , 0xD6E22 /* MapKit.MKAnnotationWrapper */ , &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = marr1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&marr1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_87 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoType *paramtype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	xamarin_check_objc_type (p1, [NSArray class], _cmd, self, 1, managed_method);
	paramtype1 = xamarin_get_parameter_type (managed_method, 1);
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, paramtype1, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&marr1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_88 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSUInteger p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	unsigned long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_89 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xD6C22 /* MapKit.IMKAnnotation */, 0xD6E22 /* MapKit.MKAnnotationWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_90 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xD6C22 /* MapKit.IMKAnnotation */, 0xD6E22 /* MapKit.MKAnnotationWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_91 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0xDC322 /* MapKit.IMKOverlay */, 0xDC522 /* MapKit.MKOverlayWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_92 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	nsobj0 = [nsobj0 copy];
	[nsobj0 autorelease];
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_93 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, void * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	void * a3 = p3;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &a3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_94 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoString *a2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	a2 = xamarin_nsstring_to_string (NULL, p2);
	arg_ptrs [2] = a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&a2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_95 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoClass *paramclass3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
		paramclass3 = mono_class_from_mono_type (paramtype3);
		xamarin_verify_parameter (mobj3, _cmd, self, nsobj3, 3, paramclass3, managed_method);
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&paramtype3);
	xamarin_mono_object_release (&mobj3);
	xamarin_mono_object_release (&paramclass3);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_96 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_97 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_98 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_99 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	xamarin_check_objc_type (p1, [NSArray class], _cmd, self, 1, managed_method);
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&marr1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_100 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_101 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static Class native_to_managed_trampoline_102 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	arr2 = p2;
	xamarin_check_objc_type (p2, [NSArray class], _cmd, self, 2, managed_method);
	marr2 = xamarin_nsarray_to_managed_string_array (arr2, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = marr2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&marr2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_103 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, NULL, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_104 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, void * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	void * a3 = p3;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &a3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_105 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_106 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_107 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_108 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, unsigned int p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_109 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	long long nativeEnum1 = p1;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_110 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	xamarin_check_objc_type (p1, [NSArray class], _cmd, self, 1, managed_method);
	paramtype1 = xamarin_get_parameter_type (managed_method, 1);
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, paramtype1, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = marr1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&marr1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_111 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, unsigned short p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_112 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, CGFloat p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_113 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_114 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_115 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_116 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, NSInteger p1, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_117 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	long long nativeEnum1 = p1;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_118 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, BOOL p1, id p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoType *paramtype2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arr2 = p2;
	xamarin_check_objc_type (p2, [NSArray class], _cmd, self, 2, managed_method);
	paramtype2 = xamarin_get_parameter_type (managed_method, 2);
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, paramtype2, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = marr2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&marr2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static NSInteger native_to_managed_trampoline_119 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static NSInteger native_to_managed_trampoline_120 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static NSUInteger native_to_managed_trampoline_121 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_122 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, CGRect* p1, id* p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *mobj2 = NULL;
	MonoObject *mobj_out2 = NULL;
	NSObject *nsobj2 = NULL;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	void * handle2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1;
	if (p2 != NULL)
		nsobj2 = *(NSObject **) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr (nsobj2, false, paramtype2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the byref parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	mobj_out2 = mobj2;
	arg_ptrs [2] = (int *) &mobj_out2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (mobj_out2 != NULL) {
		handle2 = xamarin_get_nsobject_handle (mobj_out2);
		xamarin_mono_object_release (&mobj_out2);
	}
	if (p2 != NULL)
		*p2 = (id) handle2;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static NSInteger native_to_managed_trampoline_123 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoType *paramtype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	xamarin_check_objc_type (p1, [NSArray class], _cmd, self, 1, managed_method);
	paramtype1 = xamarin_get_parameter_type (managed_method, 1);
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, paramtype1, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = marr1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&marr1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_124 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoType *paramtype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	xamarin_check_objc_type (p1, [NSArray class], _cmd, self, 1, managed_method);
	paramtype1 = xamarin_get_parameter_type (managed_method, 1);
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, paramtype1, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = marr1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&marr1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGFloat native_to_managed_trampoline_125 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_126 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, NSUInteger p1, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	unsigned long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_127 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, NSUInteger p1, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	unsigned long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static UIOffset native_to_managed_trampoline_128 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	UIOffset res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(UIOffset *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_129 (id self, SEL _cmd, MonoMethod **managed_method_ptr, UIOffset p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_130 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	long long nativeEnum1 = p1;
	unsigned long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_131 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSUInteger p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	unsigned long long nativeEnum1 = p1;
	unsigned long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_132 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSRange p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	a2 = xamarin_nsstring_to_string (NULL, p2);
	arg_ptrs [2] = a2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static UIOffset native_to_managed_trampoline_133 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, NSInteger p1, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	UIOffset res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(UIOffset *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_134 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, NSUInteger p1, NSInteger p2, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	unsigned long long nativeEnum1 = p1;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_135 (id self, SEL _cmd, MonoMethod **managed_method_ptr, UIOffset p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	long long nativeEnum1 = p1;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_136 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSUInteger p1, NSUInteger p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	unsigned long long nativeEnum1 = p1;
	unsigned long long nativeEnum2 = p2;
	long long nativeEnum3 = p3;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &nativeEnum2;
	arg_ptrs [3] = &nativeEnum3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_137 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, CGPoint p1, CGPoint* p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_138 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, CGFloat p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_139 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_140 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSRange p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	long long nativeEnum3 = p3;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &nativeEnum3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_141 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSUInteger p1, NSRange p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	unsigned long long nativeEnum1 = p1;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_142 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, CGPoint p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23E722 /* UIKit.IUIDynamicItem */, 0x23E922 /* UIKit.UIDynamicItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_143 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, CGPoint p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *inobj2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23E722 /* UIKit.IUIDynamicItem */, 0x23E922 /* UIKit.UIDynamicItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	inobj2 = xamarin_get_inative_object_static (p2, false, 0x23E722 /* UIKit.IUIDynamicItem */, 0x23E922 /* UIKit.UIDynamicItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = inobj2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&inobj2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_144 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23E722 /* UIKit.IUIDynamicItem */, 0x23E922 /* UIKit.UIDynamicItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_145 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *inobj2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23E722 /* UIKit.IUIDynamicItem */, 0x23E922 /* UIKit.UIDynamicItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	inobj2 = xamarin_get_inative_object_static (p2, false, 0x23E722 /* UIKit.IUIDynamicItem */, 0x23E922 /* UIKit.UIDynamicItemWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = inobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&inobj2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_146 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, SEL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *a1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	arg_ptrs [1] = a1;
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGRect native_to_managed_trampoline_147 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGSize native_to_managed_trampoline_148 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_149 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGSize p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_150 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_151 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_152 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoType *paramtype1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	xamarin_check_objc_type (p1, [NSArray class], _cmd, self, 1, managed_method);
	paramtype1 = xamarin_get_parameter_type (managed_method, 1);
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, paramtype1, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = marr1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&marr1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static CGFloat native_to_managed_trampoline_153 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_154 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGFloat p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_155 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		xamarin_framework_peer_waypoint ();
		if (retobj != NULL) {
			bool retained = xamarin_attempt_retain_nsobject (retval, &exception_gchandle);
			if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
			if (retained) {
				[retobj autorelease];
			}
			mt_dummy_use (retval);
			res = retobj;
		} else {
			res = NULL;
		}
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_156 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x26D922 /* UIKit.IUIViewControllerAnimatedTransitioning */, 0x26DB22 /* UIKit.UIViewControllerAnimatedTransitioningWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		xamarin_framework_peer_waypoint ();
		if (retobj != NULL) {
			bool retained = xamarin_attempt_retain_nsobject (retval, &exception_gchandle);
			if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
			if (retained) {
				[retobj autorelease];
			}
			mt_dummy_use (retval);
			res = retobj;
		} else {
			res = NULL;
		}
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_157 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoType *paramtype2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arr2 = p2;
	xamarin_check_objc_type (p2, [NSArray class], _cmd, self, 2, managed_method);
	paramtype2 = xamarin_get_parameter_type (managed_method, 2);
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, paramtype2, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = marr2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&marr2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_158 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoClass *paramclass3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arr2 = p2;
	xamarin_check_objc_type (p2, [NSArray class], _cmd, self, 2, managed_method);
	paramtype2 = xamarin_get_parameter_type (managed_method, 2);
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, paramtype2, NULL, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = marr2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
		paramclass3 = mono_class_from_mono_type (paramtype3);
		xamarin_verify_parameter (mobj3, _cmd, self, nsobj3, 3, paramclass3, managed_method);
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&marr2);
	xamarin_mono_object_release (&paramtype3);
	xamarin_mono_object_release (&mobj3);
	xamarin_mono_object_release (&paramclass3);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_159 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSRange p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_160 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *del3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		del3 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C98422 /* System.Action`1<Foundation.NSUrlSessionResponseDisposition> ObjCRuntime.Trampolines/NIDActionArity1V60::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		arg_ptrs [3] = del3;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&del3);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_161 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *del3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		del3 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C8EB22 /* System.Action`1<Foundation.NSCachedUrlResponse> ObjCRuntime.Trampolines/NIDActionArity1V58::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		arg_ptrs [3] = del3;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&del3);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_162 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, id p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoClass *paramclass3 = NULL;
	MonoObject *del4 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
		paramclass3 = mono_class_from_mono_type (paramtype3);
		xamarin_verify_parameter (mobj3, _cmd, self, nsobj3, 3, paramclass3, managed_method);
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		del4 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C97B22 /* System.Action`1<Foundation.NSUrlRequest> ObjCRuntime.Trampolines/NIDActionArity1V3::Create(System.IntPtr) */ , 4, p4, &exception_gchandle);
		arg_ptrs [4] = del4;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [4] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&paramtype3);
	xamarin_mono_object_release (&mobj3);
	xamarin_mono_object_release (&paramclass3);
	xamarin_mono_object_release (&del4);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_163 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *del3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		del3 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1D3DA22 /* System.Action`2<Foundation.NSUrlSessionAuthChallengeDisposition,Foundation.NSUrlCredential> ObjCRuntime.Trampolines/NIDActionArity2V11::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		arg_ptrs [3] = del3;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&del3);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_164 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_165 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_166 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_167 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	xamarin_framework_peer_waypoint ();
	mt_dummy_use (retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGSize native_to_managed_trampoline_168 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGSize p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_169 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static CGSize native_to_managed_trampoline_170 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGSize p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_171 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SEL p0, id p1, uint32_t token_ref)
{
	MonoObject *a0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	a0 = p0 ? xamarin_get_selector (p0, &exception_gchandle) : NULL;
	arg_ptrs [0] = a0;
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&a0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGFloat native_to_managed_trampoline_172 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_173 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_174 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static NSInteger native_to_managed_trampoline_175 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static NSArray * native_to_managed_trampoline_176 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = xamarin_managed_string_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	xamarin_framework_peer_waypoint ();
	mt_dummy_use (retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_177 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static UIEdgeInsets native_to_managed_trampoline_178 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	UIEdgeInsets res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(UIEdgeInsets *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGFloat native_to_managed_trampoline_179 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_180 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static CGSize native_to_managed_trampoline_181 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_182 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static NSInteger native_to_managed_trampoline_183 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_184 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static NSInteger native_to_managed_trampoline_185 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_186 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_187 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGSize native_to_managed_trampoline_188 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_189 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, bool* call_super, uint32_t token_ref)
{
	MonoClass *declaring_type = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	arg_ptrs [0] = &p0;

	declaring_type = mono_method_get_class (managed_method);
	mthis = xamarin_new_nsobject (self, declaring_type, &exception_gchandle);
	xamarin_mono_object_release (&declaring_type);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return self;
}


static CGPoint native_to_managed_trampoline_190 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, CGPoint p1, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGPoint res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGPoint *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGPoint native_to_managed_trampoline_191 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGPoint res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGPoint *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_192 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_193 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	xamarin_framework_peer_waypoint ();
	mt_dummy_use (retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_194 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, double p1, uint32_t token_ref)
{
	long long nativeEnum0 = p0;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_195 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGSize p0, id p1, uint32_t token_ref)
{
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x26EC22 /* UIKit.IUIViewControllerTransitionCoordinator */, 0x26EE22 /* UIKit.UIViewControllerTransitionCoordinatorWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_196 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (created1) {
		xamarin_dispose (mobj1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_197 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static CGRect native_to_managed_trampoline_198 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_199 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_200 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_201 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_202 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_203 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	unsigned long long nativeEnum2 = p2;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23D722 /* UIKit.IUIDragSession */, 0x23D822 /* UIKit.UIDragSessionWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_204 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23D722 /* UIKit.IUIDragSession */, 0x23D822 /* UIKit.UIDragSessionWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	xamarin_framework_peer_waypoint ();
	mt_dummy_use (retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static BOOL native_to_managed_trampoline_205 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23E022 /* UIKit.IUIDropSession */, 0x23E122 /* UIKit.UIDropSessionWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_206 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23E022 /* UIKit.IUIDropSession */, 0x23E122 /* UIKit.UIDropSessionWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_207 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *inobj1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	inobj1 = xamarin_get_inative_object_static (p1, false, 0x23E022 /* UIKit.IUIDropSession */, 0x23E122 /* UIKit.UIDropSessionWrapper */, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_waypoint ();
		[retobj retain];
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_208 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, id p1, uint32_t token_ref)
{
	MonoObject *del1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	if (p1) {
		del1 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C74422 /* System.Action ObjCRuntime.Trampolines/NIDAction::Create(System.IntPtr) */ , 1, p1, &exception_gchandle);
		arg_ptrs [1] = del1;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&del1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_209 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	long long nativeEnum1 = p1;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoClass *paramclass3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
		paramclass3 = mono_class_from_mono_type (paramtype3);
		xamarin_verify_parameter (mobj3, _cmd, self, nsobj3, 3, paramclass3, managed_method);
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		xamarin_framework_peer_waypoint ();
		if (retobj != NULL) {
			bool retained = xamarin_attempt_retain_nsobject (retval, &exception_gchandle);
			if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
			if (retained) {
				[retobj autorelease];
			}
			mt_dummy_use (retval);
			res = retobj;
		} else {
			res = NULL;
		}
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&paramtype3);
	xamarin_mono_object_release (&mobj3);
	xamarin_mono_object_release (&paramclass3);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static id native_to_managed_trampoline_210 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	xamarin_framework_peer_waypoint ();
	mt_dummy_use (retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_211 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1D0E622 /* System.Action`1<WebKit.WKNavigationActionPolicy> ObjCRuntime.Trampolines/NIDActionArity1V267::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_212 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *del3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		del3 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C74422 /* System.Action ObjCRuntime.Trampolines/NIDAction::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		arg_ptrs [3] = del3;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&del3);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_213 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoClass *paramclass2 = NULL;
	MonoObject *del3 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
		paramclass2 = mono_class_from_mono_type (paramtype2);
		xamarin_verify_parameter (mobj2, _cmd, self, nsobj2, 2, paramclass2, managed_method);
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		del3 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CFAB22 /* System.Action`1<System.Boolean> ObjCRuntime.Trampolines/NIDActionArity1V4::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		arg_ptrs [3] = del3;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&paramtype2);
	xamarin_mono_object_release (&mobj2);
	xamarin_mono_object_release (&paramclass2);
	xamarin_mono_object_release (&del3);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_214 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, id p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoString *a1 = NULL;
	MonoString *a2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoClass *paramclass3 = NULL;
	MonoObject *del4 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	a1 = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [1] = a1;
	a2 = xamarin_nsstring_to_string (NULL, p2);
	arg_ptrs [2] = a2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
		paramclass3 = mono_class_from_mono_type (paramtype3);
		xamarin_verify_parameter (mobj3, _cmd, self, nsobj3, 3, paramclass3, managed_method);
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		del4 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1CFC622 /* System.Action`1<System.String> ObjCRuntime.Trampolines/NIDActionArity1V63::Create(System.IntPtr) */ , 4, p4, &exception_gchandle);
		arg_ptrs [4] = del4;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [4] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&a1);
	xamarin_mono_object_release (&a2);
	xamarin_mono_object_release (&paramtype3);
	xamarin_mono_object_release (&mobj3);
	xamarin_mono_object_release (&paramclass3);
	xamarin_mono_object_release (&del4);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_215 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1D08C22 /* System.Action`1<UserNotifications.UNNotificationPresentationOptions> ObjCRuntime.Trampolines/NIDActionArity1V264::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_216 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *del2 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		del2 = xamarin_get_delegate_for_block_parameter (managed_method, 0x1C74422 /* System.Action ObjCRuntime.Trampolines/NIDAction::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		arg_ptrs [2] = del2;
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&del2);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_217 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static Class native_to_managed_trampoline_218 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	retval = mono_runtime_invoke (managed_method, NULL, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_219 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, id p1, id p2, id p3, id p4, id p5, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoType *type1;
	MonoObject *inobj1 = NULL;
	MonoReflectionType *reflectiontype1 = NULL;
	MonoType *type2;
	MonoObject *inobj2 = NULL;
	MonoReflectionType *reflectiontype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoClass *paramclass3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	MonoClass *paramclass4 = NULL;
	NSObject *nsobj5 = NULL;
	MonoObject *mobj5 = NULL;
	int32_t created5 = false;
	MonoType *paramtype5 = NULL;
	MonoClass *paramclass5 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [6];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	type1 = xamarin_get_parameter_type (managed_method, 1);
	reflectiontype1 = mono_type_get_object (mono_domain_get (), type1);
	inobj1 = xamarin_get_inative_object_dynamic (p1, false, reflectiontype1, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [1] = inobj1;
	type2 = xamarin_get_parameter_type (managed_method, 2);
	reflectiontype2 = mono_type_get_object (mono_domain_get (), type2);
	inobj2 = xamarin_get_inative_object_dynamic (p2, false, reflectiontype2, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [2] = inobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
		paramclass3 = mono_class_from_mono_type (paramtype3);
		xamarin_verify_parameter (mobj3, _cmd, self, nsobj3, 3, paramclass3, managed_method);
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype4, 4, true);
			goto exception_handling;
		}
		paramclass4 = mono_class_from_mono_type (paramtype4);
		xamarin_verify_parameter (mobj4, _cmd, self, nsobj4, 4, paramclass4, managed_method);
	}
	arg_ptrs [4] = mobj4;
	nsobj5 = (NSObject *) p5;
	if (nsobj5) {
		paramtype5 = xamarin_get_parameter_type (managed_method, 5);
		mobj5 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj5, false, paramtype5, &created5, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype5, 5, true);
			goto exception_handling;
		}
		paramclass5 = mono_class_from_mono_type (paramtype5);
		xamarin_verify_parameter (mobj5, _cmd, self, nsobj5, 5, paramclass5, managed_method);
	}
	arg_ptrs [5] = mobj5;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&type1);
	xamarin_mono_object_release (&inobj1);
	xamarin_mono_object_release (&reflectiontype1);
	xamarin_mono_object_release (&type2);
	xamarin_mono_object_release (&inobj2);
	xamarin_mono_object_release (&reflectiontype2);
	xamarin_mono_object_release (&paramtype3);
	xamarin_mono_object_release (&mobj3);
	xamarin_mono_object_release (&paramclass3);
	xamarin_mono_object_release (&paramtype4);
	xamarin_mono_object_release (&mobj4);
	xamarin_mono_object_release (&paramclass4);
	xamarin_mono_object_release (&paramtype5);
	xamarin_mono_object_release (&mobj5);
	xamarin_mono_object_release (&paramclass5);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static id native_to_managed_trampoline_220 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_221 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static double native_to_managed_trampoline_222 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	double res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	retval = mono_runtime_invoke (managed_method, NULL, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(double *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static int native_to_managed_trampoline_223 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	int res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(int *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_224 (id self, SEL _cmd, MonoMethod **managed_method_ptr, int p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static BOOL native_to_managed_trampoline_225 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoClass *paramclass0 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
		paramclass0 = mono_class_from_mono_type (paramtype0);
		xamarin_verify_parameter (mobj0, _cmd, self, nsobj0, 0, paramclass0, managed_method);
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, NULL, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&paramtype0);
	xamarin_mono_object_release (&mobj0);
	xamarin_mono_object_release (&paramclass0);
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static double native_to_managed_trampoline_226 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	MonoObject *retval = NULL;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	double res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

	res = *(double *) mono_object_unbox ((MonoObject *) retval);

exception_handling:
	xamarin_mono_object_release (&retval);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return res;
}


static void native_to_managed_trampoline_227 (id self, SEL _cmd, MonoMethod **managed_method_ptr, double p0, uint32_t token_ref)
{
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}


static void native_to_managed_trampoline_228 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoClass *paramclass1 = NULL;
	MonoObject *exception = NULL;
	MonoObject **exception_ptr = xamarin_is_managed_exception_marshaling_disabled () ? NULL : &exception;
	GCHandle exception_gchandle = INVALID_GCHANDLE;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MonoReflectionMethod *reflection_method = NULL;
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	}
	if (!managed_method) {
		GCHandle reflection_method_handle = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		reflection_method = (MonoReflectionMethod *) xamarin_gchandle_unwrap (reflection_method_handle);
		if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
		xamarin_mono_object_release_at_process_exit (managed_method);
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != INVALID_GCHANDLE) goto exception_handling;
	arg_ptrs [0] = &p0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != INVALID_GCHANDLE) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
		paramclass1 = mono_class_from_mono_type (paramtype1);
		xamarin_verify_parameter (mobj1, _cmd, self, nsobj1, 1, paramclass1, managed_method);
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, exception_ptr);
	if (exception != NULL) goto exception_handling;

exception_handling:
	xamarin_mono_object_release (&paramtype1);
	xamarin_mono_object_release (&mobj1);
	xamarin_mono_object_release (&paramclass1);
	xamarin_mono_object_release (&mthis);
	xamarin_mono_object_release (&reflection_method);

	MONO_THREAD_DETACH;
	if (exception_gchandle != INVALID_GCHANDLE)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	xamarin_process_managed_exception (exception);
	return;
}




@implementation Xamarin_Forms_Platform_iOS_NavigationRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) didRotateFromInterfaceOrientation:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x3452E);
	}

	-(NSArray *) popToRootViewControllerAnimated:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, 0x3472E);
	}

	-(UIViewController *) popViewControllerAnimated:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x3492E);
	}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x34B2E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x34C2E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x34D2E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x34E2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x34F2E);
	}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x3552E);
	}

	-(UIViewController *) childViewControllerForStatusBarHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x3762E);
	}

	-(UIViewController *) childViewControllerForHomeIndicatorAutoHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x3772E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3372E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UINavigationController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation HrApp_iOS_CustomNaviPageRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x600);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_NavigationRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) loadView
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x3942E);
	}

	-(void) viewWillLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x3952E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x3962E);
	}

	-(void) viewSafeAreaInsetsDidChange
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x3972E);
	}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x3992E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x39A2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x39B2E);
	}

	-(void) viewWillDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x39C2E);
	}

	-(NSInteger) preferredStatusBarUpdateAnimation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x3A22E);
	}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x3A32E);
	}

	-(BOOL) prefersStatusBarHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x3A82E);
	}

	-(BOOL) prefersHomeIndicatorAutoHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x3AE2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3892E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation HrApp_iOS_CustomPageRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x800);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_PageRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_WkWebViewRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) didMoveToWindow
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x77F2E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7832E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7732E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [WKWebView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation HrApp_iOS_CustomWebViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA00);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_WkWebViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1515122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation Xamarin_Forms_Platform_iOS_FormsApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIWindow *) window
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x902E);
	}

	-(void) setWindow:(UIWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x912E);
	}

	-(BOOL) application:(UIApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(void (^)(id *))p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_11 (self, _cmd, &managed_method, p0, p1, p2, 0x932E);
	}

	-(void) applicationDidEnterBackground:(UIApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x942E);
	}

	-(BOOL) application:(UIApplication *)p0 didFinishLaunchingWithOptions:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x952E);
	}

	-(void) applicationDidBecomeActive:(UIApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x962E);
	}

	-(void) applicationWillResignActive:(UIApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x972E);
	}

	-(void) application:(UIApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x982E);
	}

	-(void) applicationWillEnterForeground:(UIApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x992E);
	}

	-(BOOL) application:(UIApplication *)p0 willFinishLaunchingWithOptions:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x9A2E);
	}

	-(void) applicationWillTerminate:(UIApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x9B2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x922E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation AppDelegate {
}

	-(BOOL) application:(UIApplication *)p0 didFinishLaunchingWithOptions:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0xD00);
	}

	-(void) application:(UIApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xE00);
	}

	-(void) application:(UIApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xF00);
	}

	-(void) application:(UIApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1 fetchCompletionHandler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, p0, p1, p2, 0x1000);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1100);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_FormsApplicationDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MyViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1300);
	}

	-(void) didReceiveMemoryWarning
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1400);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1200);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__VisionKit_VNDocumentCameraViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WCSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SFSpeechRecognitionTaskDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1BA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SFSpeechRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1DB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__SharedWithYou_SWCollaborationViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x33322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__SharedWithYou_SWHighlightCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x35C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SFSafariViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x41122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewControllerDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x49E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4AD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4C222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PKPushRegistryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x59722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHContentEditingController {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x5AC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHLivePhotoViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x5D822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__PhotosUI_PHPickerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x61F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__PencilKit_PKCanvasViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x85322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetProviding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x97022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MSStickerBrowserViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA4622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__IntentsUI_INUIAddVoiceShortcutButtonDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB6522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__IntentsUI_INUIAddVoiceShortcutViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB7A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__IntentsUI_INUIEditVoiceShortcutViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB9122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EAAccessoryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC6622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EAWiFiUnconfiguredAccessoryBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCBA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CNContactPickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFEA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CNContactViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x102922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AutomaticAssessmentConfiguration_AEAssessmentSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x109F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation iAd_ADBannerViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x10F422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation iAd_ADInterstitialAd {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x112122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation iAd_ADInterstitialAdDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x113022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation iAd_ADInterstitialAdPresentationViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation VSAccountManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A0322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UNUserNotificationCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B8922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPaymentTransactionObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1C3F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKCloudServiceSetupViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1CE422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__StoreKit_SKOverlayDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1D2422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__StoreKit_SKPaymentQueueDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1D5B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1DDE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKProductsRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1DA622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKStoreProductViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1E1322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x218D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x227522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x23EA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__SensorKit_SRSensorReaderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2B2022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAnimatable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2F8622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2FCA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNActionable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x345522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAvoidOccluderConstraintDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x350822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNBoundingVolume {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x351D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNCameraControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x360C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNNodeRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x382822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x38C922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNProgramDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x39BF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneExportDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3A5022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3A9222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNShadable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3AC022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNTechniqueSupport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3B0622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation RPBroadcastActivityViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3BB422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation RPBroadcastControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3BCF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation RPPreviewViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3BFE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation RPScreenRecorderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3C2D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHPhotoLibraryChangeObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3E6822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFDocumentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x412222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x41C522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PKAddPassesViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x429722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PKAddPaymentPassViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x42D622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__PassKit_PKAddSecureElementPassViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x42F522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PKDisbursementAuthorizationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x437522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PKPaymentAuthorizationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x449B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PKPaymentAuthorizationViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x44FC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__PassKit_PKShareSecureElementPassViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x461A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__PassKit_PKVehicleConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x465E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NWTCPConnectionAuthenticationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x47D422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__NetworkExtension_NEAppPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x487B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__NearbyInteraction_NISessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x509122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCAdvertiserAssistantDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x536022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCBrowserViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x538122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceAdvertiserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x539B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x53B522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x53C722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MDLLightProbeIrradianceDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x563122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation MetalPerformanceShaders_MPSCnnConvolutionState {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSUInteger) sourceWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_15 (self, _cmd, &managed_method, 0x5E0722);
	}

	-(NSUInteger) sourceHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_15 (self, _cmd, &managed_method, 0x5E0822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__MetalPerformanceShaders_MPSCnnBatchNormalizationDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x602B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x602E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MPSCNNConvolutionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x60CE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__MetalPerformanceShaders_MPSCnnInstanceNormalizationDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x61D622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x61D922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x6DF022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__Metal_MTLCaptureScope {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x70AA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTLDrawable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x724A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UINavigationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15F7322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MFMailComposeViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x776D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface MessageUI_Mono_MFMailComposeViewControllerDelegate : NSObject<MFMailComposeViewControllerDelegate, UINavigationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) mailComposeController:(MFMailComposeViewController *)p0 didFinishWithResult:(int)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MessageUI_Mono_MFMailComposeViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) mailComposeController:(MFMailComposeViewController *)p0 didFinishWithResult:(int)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, p2, 0x773822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x773722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MFMessageComposeViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x777422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface MessageUI_Mono_MFMessageComposeViewControllerDelegate : NSObject<MFMessageComposeViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) messageComposeViewController:(MFMessageComposeViewController *)p0 didFinishWithResult:(int)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MessageUI_Mono_MFMessageComposeViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) messageComposeViewController:(MFMessageComposeViewController *)p0 didFinishWithResult:(int)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_18 (self, _cmd, &managed_method, p0, p1, 0x776922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x776822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MPPlayableContentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x78BA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MPPlayableContentDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x78C722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MPMediaPickerControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x79B422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__MediaPlayer_MPNowPlayingSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7AF322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKAnnotation {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7CCA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKLocalSearchCompleterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7DE022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__MapKit_MKLookAroundViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7E4F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKMapViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7FB322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKOverlay {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x801622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKReverseGeocoderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x812A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__JavaScriptCore_JSExport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x856A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation HMAccessoryBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9C5022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation HMAccessoryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9C8322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation HMCameraSnapshotControlDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9D0A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation HMCameraStreamControlDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9D2C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation HMHomeDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9E5822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation HMHomeManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9EAD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__HomeKit_HMNetworkConfigurationProfileDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9F0B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAgentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA78F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation GameKit_GKPeerPickerControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAA3822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation GameKit_GKPeerPickerController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAA4022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLocalPlayerListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAA4E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAE0122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface GameKit_Mono_GKSessionDelegate : NSObject<GKSessionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) session:(GKSession *)p0 peer:(NSString *)p1 didChangeState:(int)p2;
	-(void) session:(GKSession *)p0 didReceiveConnectionRequestFromPeer:(NSString *)p1;
	-(void) session:(GKSession *)p0 connectionWithPeerFailed:(NSString *)p1 withError:(NSError *)p2;
	-(void) session:(GKSession *)p0 didFailWithError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_Mono_GKSessionDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) session:(GKSession *)p0 peer:(NSString *)p1 didChangeState:(int)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, p1, p2, 0xAABA22);
	}

	-(void) session:(GKSession *)p0 didReceiveConnectionRequestFromPeer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0xAABB22);
	}

	-(void) session:(GKSession *)p0 connectionWithPeerFailed:(NSString *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, p1, p2, 0xAABC22);
	}

	-(void) session:(GKSession *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xAABD22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAAB922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAchievementViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xABB922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xABE722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xABF622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKFriendRequestComposeViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAC2322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKGameCenterControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAC2A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKInviteEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAC6022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLeaderboardViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xACF222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAD6722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xADB822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSavedGameListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xADF022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAE1A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAE2A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAE9222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKVoiceChatClient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAEAF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GLKNamedEffect {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB40E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GLKViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB49722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GLKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB49F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__WebKit_WKDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB5AA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKNavigationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB5FD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKScriptMessageHandler {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB64222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKUIDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB66F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface Foundation_NSDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) xamarinApplySelector;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xB81522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB81422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSActionDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xB81822);
	}
@end

@interface __MonoMac_NSSynchronizationContextDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xB81A22);
	}
@end

@interface __Xamarin_NSTimerActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) xamarinFireSelector:(NSTimer *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __Xamarin_NSTimerActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) xamarinFireSelector:(NSTimer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xB81C22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Foundation_NSAsyncDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
	-(id) init;
@end

@implementation Foundation_NSAsyncDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xB81F22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB81E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Foundation_NSDispatcher class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAsyncActionDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xB82122);
	}
@end

@interface __MonoMac_NSAsyncSynchronizationContextDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xB82322);
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFileManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBC6122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface Foundation_InternalNSNotificationHandler : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) post:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_InternalNSNotificationHandler {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) post:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xBF3722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCacheDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC7AE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCoding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC7E422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xC7E722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC82722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSExtensionRequestHandling {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC94722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFilePresenter {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC9BC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedArchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCAA522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedUnarchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCAB322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCE3322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMachPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCB7422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMetadataQueryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCC1022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMutableCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCC8B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCCE322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCCF722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCEF722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLAuthenticationChallengeSender {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCFBD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCFFB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCFEA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD00922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD0B822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionTaskDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD11D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD0A722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD0C322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD0D522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__Foundation_NSUrlSessionWebSocketDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD16322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUserActivityDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD19522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__Foundation_NSXpcListenerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD1C422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EKCalendarChooserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD44E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EKEventEditViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD47B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EKEventViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD49D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CoreTelephony_CTTelephonyNetworkInfoDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xDB6322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CSSearchableIndexDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xDD6E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CoreMotion_CMHeadphoneMotionManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xDE4B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CoreMidi_MidiCIProfileResponderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE15C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CoreML_MLCustomModel {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE47F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithModelDescription:(MLModelDescription *)p0 parameterDictionary:(NSDictionary <NSString *, NSObject *>*)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, p2, &call_super, 0xE48222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, MLModelDescription *, NSDictionary <NSString *, NSObject *>*, NSError **)) objc_msgSendSuper) (&super, @selector (initWithModelDescription:parameterDictionary:error:), p0, p1, p2);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CLLocationManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE74E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation CoreImage_CIAccordionFoldTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(float) bottomHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xE98A22);
	}

	-(void) setBottomHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xE98B22);
	}

	-(float) numberOfFolds
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xE98C22);
	}

	-(void) setNumberOfFolds:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xE98D22);
	}

	-(float) foldShadowAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xE98E22);
	}

	-(void) setFoldShadowAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xE98F22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE99022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xE99122);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE99222);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xE99322);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xE99422);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xE99522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE99622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE98422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE98722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICompositingFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF1522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAdditionCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE9AB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE9AE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE9C822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE9C422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineClamp {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE9B322);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xE9B422);
	}

	-(CGAffineTransform) transform
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_25 (self, _cmd, &managed_method, 0xE9B522);
	}

	-(void) setTransform:(CGAffineTransform)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, 0xE9B622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE9B722);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE9AF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE9B222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE9CD22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xE9CE22);
	}

	-(CGAffineTransform) transform
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_25 (self, _cmd, &managed_method, 0xE9CF22);
	}

	-(void) setTransform:(CGAffineTransform)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, 0xE9D022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE9D122);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE9C922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE9CC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTransform {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE9DC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE9DF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIReductionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFD2D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaAverage {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE9E422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE9E722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaHistogram {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xE9F622);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xE9F722);
	}

	-(NSInteger) count
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0xE9F822);
	}

	-(void) setCount:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, 0xE9F922);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE9FA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xE9FB22);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xE9FC22);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xE9FD22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE9FE22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE9EC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xE9EF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaLogarithmicHistogram {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEA1122);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEA1222);
	}

	-(NSInteger) count
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0xEA1322);
	}

	-(void) setCount:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, 0xEA1422);
	}

	-(float) minimumStop
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEA1522);
	}

	-(void) setMinimumStop:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEA1622);
	}

	-(float) maximumStop
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEA1722);
	}

	-(void) setMaximumStop:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEA1822);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA1922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEA1A22);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEA1B22);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEA1C22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA1D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA0D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEA1022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA3922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEA3A22);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEA3B22);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEA3C22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA3D22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA3422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEA3722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximumAlpha {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA4222);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEA4322);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEA4422);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEA4522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA4622);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA3E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEA4122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA5722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEA5822);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEA5922);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEA5A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA5B22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA5322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEA5622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimumAlpha {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA6022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEA6122);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEA6222);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEA6322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA6422);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA5C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEA5F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMax {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA7722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEA7822);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEA7922);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEA7A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA7B22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA7122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEA7422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMaxRed {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA8822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEA8922);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEA8A22);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEA8B22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEA8C22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA8222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEA8522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIImageGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF54322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAttributedTextImageGenerator {
}

	-(NSAttributedString *) text
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEAA122);
	}

	-(void) setText:(NSAttributedString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEAA222);
	}

	-(float) scaleFactor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEAA322);
	}

	-(void) setScaleFactor:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEAA422);
	}

	-(float) padding
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEAA522);
	}

	-(void) setPadding:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEAA622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEAA722);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEA9D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEAA022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED1D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAztecCodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEAC922);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEACA22);
	}

	-(float) correctionLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEACB22);
	}

	-(void) setCorrectionLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEACC22);
	}

	-(float) layers
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEACD22);
	}

	-(void) setLayers:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEACE22);
	}

	-(float) compactStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEACF22);
	}

	-(void) setCompactStyle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEAD022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEAD122);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEAC022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEAC322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarcodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIBarcodeDescriptor *) barcodeDescriptor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEAF522);
	}

	-(void) setBarcodeDescriptor:(CIBarcodeDescriptor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEAF622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEAF722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEAEC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEAEF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITransitionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x100DF22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x100E022);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x100E122);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x100E222);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x100E322);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x100E422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x100E522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x100DD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarsSwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEAFE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEB0122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBicubicScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEB2422);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEB2522);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEB2622);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEB2722);
	}

	-(float) aspectRatio
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEB2822);
	}

	-(void) setAspectRatio:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEB2922);
	}

	-(float) parameterB
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEB2A22);
	}

	-(void) setParameterB:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEB2B22);
	}

	-(float) parameterC
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEB2C22);
	}

	-(void) setParameterC:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEB2D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEB2E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEB1C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEB1F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEB4722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithMask {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEB8C22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEB8D22);
	}

	-(CIImage *) backgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEB8E22);
	}

	-(void) setBackgroundImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEB8F22);
	}

	-(CIImage *) maskImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEB9022);
	}

	-(void) setMaskImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEB9122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEB9222);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEB8522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEB8822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithAlphaMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEB7D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEB8022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithBlueMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEB8122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEB8422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithRedMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEBA122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEBA422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEBA922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEBAA22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBAB22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBAC22);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBAD22);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBAE22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEBAF22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEBA522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEBA822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF70F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBokehBlur {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEBC222);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEBC322);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBC422);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBC522);
	}

	-(float) ringAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBC622);
	}

	-(void) setRingAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBC722);
	}

	-(float) ringSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBC822);
	}

	-(void) setRingSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBC922);
	}

	-(float) softness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBCA22);
	}

	-(void) setSoftness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBCB22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEBCC22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEBBE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEBC122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBoxBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEBE722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEBE822);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBE922);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBEA22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEBEB22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEBE322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEBE622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDistortionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF0F722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortion {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEBFA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEBFB22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xEBFC22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xEBFD22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEBFE22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEBFF22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC0022);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC0122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC0222);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEBF622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEBF922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortionLinear {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC0722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEC0822);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xEC0922);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xEC0A22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC0B22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC0C22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC0D22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC0E22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC0F22);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC1022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC1122);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEC0322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEC0622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICameraCalibrationLensCorrection {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEC3A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEC3D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICheckerboardGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xEC4A22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xEC4B22);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC4C22);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEC4D22);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC4E22);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEC4F22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC5022);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC5122);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC5222);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC5322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC5422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEC4422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEC4722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircleSplashDistortion {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC6F22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEC7022);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xEC7122);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xEC7222);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC7322);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC7422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC7522);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEC6B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEC6E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDD722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC8822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEC8922);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xEC8A22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xEC8B22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC8C22);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC8D22);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEC8E22);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEC8F22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEC9022);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEC8422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEC8722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularWrap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xECA922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xECAA22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xECAB22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xECAC22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xECAD22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xECAE22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xECAF22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xECB022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xECB122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xECA322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xECA622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xECC422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xECC722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICmykHalftone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xECD422);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xECD522);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xECD622);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xECD722);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xECD822);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xECD922);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xECDA22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xECDB22);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xECDC22);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xECDD22);
	}

	-(float) grayComponentReplacement
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xECDE22);
	}

	-(void) setGrayComponentReplacement:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xECDF22);
	}

	-(float) underColorRemoval
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xECE022);
	}

	-(void) setUnderColorRemoval:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xECE122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xECE222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xECCC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xECCF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICode128BarcodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED0622);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED0722);
	}

	-(float) quietSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xED0822);
	}

	-(void) setQuietSpace:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xED0922);
	}

	-(float) barcodeHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xED0A22);
	}

	-(void) setBarcodeHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xED0B22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED0C22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED0122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED0422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorAbsoluteDifference {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED2522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED2622);
	}

	-(CIImage *) inputImage2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED2722);
	}

	-(void) setInputImage2:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED2822);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED2922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED2122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED2422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED3422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED3722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED3822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED3B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED4422);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED4522);
	}

	-(CIVector *) minComponents
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED4622);
	}

	-(void) setMinComponents:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED4722);
	}

	-(CIVector *) maxComponents
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED4822);
	}

	-(void) setMaxComponents:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED4922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED4A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED3C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED3F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorControls {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED5D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED5E22);
	}

	-(float) saturation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xED5F22);
	}

	-(void) setSaturation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xED6022);
	}

	-(float) brightness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xED6122);
	}

	-(void) setBrightness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xED6222);
	}

	-(float) contrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xED6322);
	}

	-(void) setContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xED6422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED6522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED5922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED5C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCrossPolynomial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED7D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED7E22);
	}

	-(CIVector *) redCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED7F22);
	}

	-(void) setRedCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED8022);
	}

	-(CIVector *) greenCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED8122);
	}

	-(void) setGreenCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED8222);
	}

	-(CIVector *) blueCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED8322);
	}

	-(void) setBlueCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED8422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED8522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED7822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED7B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCube {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xED9D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xED9E22);
	}

	-(float) cubeDimension
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xED9F22);
	}

	-(void) setCubeDimension:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEDA022);
	}

	-(NSData *) cubeData
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDA122);
	}

	-(void) setCubeData:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEDA222);
	}

	-(BOOL) extrapolate
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xEDA322);
	}

	-(void) setExtrapolate:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xEDA422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDA522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xED9822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xED9B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubesMixedWithMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDBA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEDBB22);
	}

	-(CIImage *) maskImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDBC22);
	}

	-(void) setMaskImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEDBD22);
	}

	-(float) cubeDimension
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEDBE22);
	}

	-(void) setCubeDimension:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEDBF22);
	}

	-(NSData *) cube0Data
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDC022);
	}

	-(void) setCube0Data:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEDC122);
	}

	-(NSData *) cube1Data
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDC222);
	}

	-(void) setCube1Data:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEDC322);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0xEDC422);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xEDC522);
	}

	-(BOOL) extrapolate
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xEDC622);
	}

	-(void) setExtrapolate:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xEDC722);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDC822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEDB622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEDB922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubeWithColorSpace {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDE922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEDEA22);
	}

	-(float) cubeDimension
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEDEB22);
	}

	-(void) setCubeDimension:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEDEC22);
	}

	-(NSData *) cubeData
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDED22);
	}

	-(void) setCubeData:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEDEE22);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0xEDEF22);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xEDF022);
	}

	-(BOOL) extrapolate
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xEDF122);
	}

	-(void) setExtrapolate:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xEDF222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEDF322);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEDE522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEDE822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCurves {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE0C22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE0D22);
	}

	-(NSData *) curvesData
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE0E22);
	}

	-(void) setCurvesData:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE0F22);
	}

	-(CIVector *) curvesDomain
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE1022);
	}

	-(void) setCurvesDomain:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE1122);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0xEE1222);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xEE1322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE1422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE0822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEE0B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE2722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEE2A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorInvert {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE2F22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE3022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE3122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE2B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEE2E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE4222);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE4322);
	}

	-(CIImage *) gradientImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE4422);
	}

	-(void) setGradientImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE4522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE4622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE3E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEE4122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMatrix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE5522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE5622);
	}

	-(CIVector *) RVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE5722);
	}

	-(void) setRVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE5822);
	}

	-(CIVector *) GVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE5922);
	}

	-(void) setGVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE5A22);
	}

	-(CIVector *) BVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE5B22);
	}

	-(void) setBVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE5C22);
	}

	-(CIVector *) AVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE5D22);
	}

	-(void) setAVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE5E22);
	}

	-(CIVector *) biasVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE5F22);
	}

	-(void) setBiasVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE6022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE6122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE5122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEE5422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMonochrome {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE8022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE8122);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE8222);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE8322);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEE8422);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEE8522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE8622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE7C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEE7F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPolynomial {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE9922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE9A22);
	}

	-(CIVector *) redCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE9B22);
	}

	-(void) setRedCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE9C22);
	}

	-(CIVector *) greenCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE9D22);
	}

	-(void) setGreenCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEE9E22);
	}

	-(CIVector *) blueCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEE9F22);
	}

	-(void) setBlueCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEEA022);
	}

	-(CIVector *) alphaCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEA122);
	}

	-(void) setAlphaCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEEA222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEA322);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE9522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEE9822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPosterize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEBE22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEEBF22);
	}

	-(float) levels
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEEC022);
	}

	-(void) setLevels:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEEC122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEC222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEEBA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEEBD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorThreshold {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEED122);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEED222);
	}

	-(float) threshold
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xEED322);
	}

	-(void) setThreshold:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xEED422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEED522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEECD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEED022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorThresholdOtsu {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEDA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEEDB22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEDC22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEED622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEED922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColumnAverage {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEF122);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEEF222);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xEEF322);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xEEF422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEEF522);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEEED22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEEF022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIComicEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEF0022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEF0122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEF0222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEEFC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEEFF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConstantColorGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF1B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF1E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionCore {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF6122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution3X3 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF4B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF4E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution5X5 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF4F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF5222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution7X7 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF5322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF5622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Horizontal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF5722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF5A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Vertical {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF5B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF5E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionRGB3X3 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEF8122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF7722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF7A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionRGB5X5 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEF8C22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF8222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF8522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionRGB7X7 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEF9722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF8D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF9022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionRGB9Horizontal {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEFA222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEF9822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEF9B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionRGB9Vertical {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEFAD22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEFA322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEFA622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICopyMachineTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEFAE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEFB122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICoreMLModelFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEFD222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEFD522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEFF022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEFF322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrystallize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xEFFE22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xEFFF22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF00022);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF00122);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF00222);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF00322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF00422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEFF822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xEFFB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDarkenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF01322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF01622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthBlurEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF02322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF02622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthDisparityConverter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF04B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthOfField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF05522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF05622);
	}

	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF05722);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF05822);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF05922);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF05A22);
	}

	-(float) saturation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF05B22);
	}

	-(void) setSaturation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF05C22);
	}

	-(float) unsharpMaskRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF05D22);
	}

	-(void) setUnsharpMaskRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF05E22);
	}

	-(float) unsharpMaskIntensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF05F22);
	}

	-(void) setUnsharpMaskIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF06022);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF06122);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF06222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF06322);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF04D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF05022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthToDisparity {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF08622);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF08722);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF08822);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF08222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF08522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDifferenceBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF08F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF09222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDiscBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF09722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF09822);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF09922);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF09A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF09B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF09322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF09622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisintegrateWithMaskTransition {
}

	-(CIImage *) maskImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF0AE22);
	}

	-(void) setMaskImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF0AF22);
	}

	-(float) shadowRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF0B022);
	}

	-(void) setShadowRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF0B122);
	}

	-(float) shadowDensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF0B222);
	}

	-(void) setShadowDensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF0B322);
	}

	-(CGPoint) shadowOffset
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF0B422);
	}

	-(void) setShadowOffset:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF0B522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF0B622);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF0A622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF0A922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisparityToDepth {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF0CD22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF0CE22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF0CF22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF0C922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF0CC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisplacementDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF0DA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF0DB22);
	}

	-(CIImage *) displacementImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF0DC22);
	}

	-(void) setDisplacementImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF0DD22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF0DE22);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF0DF22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF0E022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF0D622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF0D922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDissolveTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF0EF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF0F222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDither {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF10322);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF10422);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF10522);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF10622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF10722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF0FF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF10222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDivideBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF11222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF11522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDocumentEnhancer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF11A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF11B22);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF11C22);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF11D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF11E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF11622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF11922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDotScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF12D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF12E22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF12F22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF13022);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF13122);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF13222);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF13322);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF13422);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF13522);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF13622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF13722);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF12922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF12C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDroste {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF15622);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF15722);
	}

	-(CGPoint) insetPoint0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF15822);
	}

	-(void) setInsetPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF15922);
	}

	-(CGPoint) insetPoint1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF15A22);
	}

	-(void) setInsetPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF15B22);
	}

	-(float) strands
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF15C22);
	}

	-(void) setStrands:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF15D22);
	}

	-(float) periodicity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF15E22);
	}

	-(void) setPeriodicity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF15F22);
	}

	-(float) rotation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF16022);
	}

	-(void) setRotation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF16122);
	}

	-(float) zoom
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF16222);
	}

	-(void) setZoom:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF16322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF16422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF14E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF15122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgePreserveUpsampleFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF18722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF18822);
	}

	-(CIImage *) smallImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF18922);
	}

	-(void) setSmallImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF18A22);
	}

	-(float) spatialSigma
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF18B22);
	}

	-(void) setSpatialSigma:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF18C22);
	}

	-(float) lumaSigma
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF18D22);
	}

	-(void) setLumaSigma:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF18E22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF18F22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF18322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF18622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdges {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1A622);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF1A722);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF1A822);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF1A922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1AA22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF1A222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF1A522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgeWork {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1B922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF1BA22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF1BB22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF1BC22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1BD22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF1B522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF1B822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITileFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1007522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEightfoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1CC22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF1CD22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF1CE22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF1CF22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF1D022);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF1D122);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF1D222);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF1D322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1D422);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF1C822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF1CB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExclusionBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF1E722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF1EA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExposureAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1EF22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF1F022);
	}

	-(float) EV
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF1F122);
	}

	-(void) setEV:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF1F222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF1F322);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF1EB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF1EE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFaceBalance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF20022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFalseColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF21922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF21A22);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF21B22);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF21C22);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF21D22);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF21E22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF21F22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF21522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF21822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFlashTransition {
}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF2AE22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF2AF22);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xF2B022);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xF2B122);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF2B222);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF2B322);
	}

	-(float) maxStriationRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF2B422);
	}

	-(void) setMaxStriationRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF2B522);
	}

	-(float) striationStrength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF2B622);
	}

	-(void) setStriationStrength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF2B722);
	}

	-(float) striationContrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF2B822);
	}

	-(void) setStriationContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF2B922);
	}

	-(float) fadeThreshold
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF2BA22);
	}

	-(void) setFadeThreshold:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF2BB22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF2BC22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF2BD22);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF2BE22);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF2BF22);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF2C022);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF2C122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF2C222);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF2A222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF2A522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF30122);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF30222);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF30322);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF30422);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF30522);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF30622);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF30722);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF30822);
	}

	-(float) acuteAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF30922);
	}

	-(void) setAcuteAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF30A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF30B22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF2FD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF30022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldRotatedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF32622);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF32722);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF32822);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF32922);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF32A22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF32B22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF32C22);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF32D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF32E22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF32222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF32522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldTranslatedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF34522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF34622);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF34722);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF34822);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF34922);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF34A22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF34B22);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF34C22);
	}

	-(float) acuteAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF34D22);
	}

	-(void) setAcuteAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF34E22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF34F22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF34122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF34422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaborGradients {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF36A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF36B22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF36C22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF36622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF36922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGammaAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF37722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF37822);
	}

	-(float) power
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF37922);
	}

	-(void) setPower:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF37A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF37B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF37322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF37622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF38A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF38B22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF38C22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF38D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF38E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF38622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF38922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF39F22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF3A022);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3A122);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF3A222);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3A322);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF3A422);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF3A522);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF3A622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3A722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF39922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF39C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3C022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF3C122);
	}

	-(CIImage *) textureImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3C222);
	}

	-(void) setTextureImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF3C322);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF3C422);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF3C522);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF3C622);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF3C722);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3C822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF3BA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF3BD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassLozenge {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3E322);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF3E422);
	}

	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF3E522);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF3E622);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF3E722);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF3E822);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF3E922);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF3EA22);
	}

	-(float) refraction
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF3EB22);
	}

	-(void) setRefraction:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF3EC22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF3ED22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF3DB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF3DE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlideReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF40822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF40922);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF40A22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF40B22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF40C22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF40D22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF40E22);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF40F22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF41022);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF40422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF40722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF42722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF42822);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF42922);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF42A22);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF42B22);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF42C22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF42D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF42322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF42622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGuidedFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF43C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF43F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHardLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF44822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF44B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHatchedScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF45022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF45122);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF45222);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF45322);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF45422);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF45522);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF45622);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF45722);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF45822);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF45922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF45A22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF44C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF44F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHeightFieldFromMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF47522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF47622);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF47722);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF47822);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF47922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF47122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF47422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHexagonalPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF48A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF48B22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF48C22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF48D22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF48E22);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF48F22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF49022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF48422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF48722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHighlightShadowAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4A322);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF4A422);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4A522);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4A622);
	}

	-(float) shadowAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4A722);
	}

	-(void) setShadowAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4A822);
	}

	-(float) highlightAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4A922);
	}

	-(void) setHighlightAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4AA22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4AB22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF49F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF4A222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHistogramDisplayFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4C222);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF4C322);
	}

	-(float) height
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4C422);
	}

	-(void) setHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4C522);
	}

	-(float) highLimit
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4C622);
	}

	-(void) setHighLimit:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4C722);
	}

	-(float) lowLimit
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4C822);
	}

	-(void) setLowLimit:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4C922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4CA22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF4BE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF4C122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHoleDistortion {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4E122);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF4E222);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF4E322);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF4E422);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4E522);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4E622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4E722);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF4DD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF4E022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4FA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF4FB22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF4FC22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF4FD22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF4FE22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF4F622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF4F922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF50922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF50C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueSaturationValueGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(float) value
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF51122);
	}

	-(void) setValue:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF51222);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF51322);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF51422);
	}

	-(float) softness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF51522);
	}

	-(void) setSoftness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF51622);
	}

	-(float) dither
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF51722);
	}

	-(void) setDither:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF51822);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0xF51922);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xF51A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF51B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF50D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF51022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end


@implementation CoreImage_CIKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF5B522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF5B622);
	}

	-(NSInteger) count
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0xF5B722);
	}

	-(void) setCount:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, 0xF5B822);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF5B922);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF5BA22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF5BB22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF5BC22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF5BD22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF5AD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF5B022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrection {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF5DE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrectionCombined {
}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF5F722);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF5F822);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF5F922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF5FA22);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF5FB22);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF5FC22);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF5FD22);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF5FE22);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF5FF22);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF60022);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF60122);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF60222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF60322);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF5F222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF5F522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrectionHorizontal {
}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF61922);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF61A22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF61B22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF61C22);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF61D22);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF61E22);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF61F22);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF62022);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF62122);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF62222);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF62322);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF62422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF62522);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF61422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF61722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrectionVertical {
}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF63B22);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF63C22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF63D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF63E22);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF63F22);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF64022);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF64122);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF64222);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF64322);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF64422);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF64522);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF64622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF64722);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF63622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF63922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKMeans {
}

	-(CIImage *) inputMeans
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF66022);
	}

	-(void) setInputMeans:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF66122);
	}

	-(NSInteger) count
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0xF66222);
	}

	-(void) setCount:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, 0xF66322);
	}

	-(float) passes
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF66422);
	}

	-(void) setPasses:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF66522);
	}

	-(BOOL) perceptual
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xF66622);
	}

	-(void) setPerceptual:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xF66722);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF66822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF66922);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xF66A22);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xF66B22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF66C22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF65822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF65B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILabDeltaE {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF68722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF68822);
	}

	-(CIImage *) image2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF68922);
	}

	-(void) setImage2:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF68A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF68B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF68322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF68622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILanczosScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF69A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF69B22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF69C22);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF69D22);
	}

	-(float) aspectRatio
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF69E22);
	}

	-(void) setAspectRatio:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF69F22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF6A022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF69622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF69922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILenticularHaloGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF6B522);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF6B622);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF6B722);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF6B822);
	}

	-(float) haloRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6B922);
	}

	-(void) setHaloRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6BA22);
	}

	-(float) haloWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6BB22);
	}

	-(void) setHaloWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6BC22);
	}

	-(float) haloOverlap
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6BD22);
	}

	-(void) setHaloOverlap:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6BE22);
	}

	-(float) striationStrength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6BF22);
	}

	-(void) setStriationStrength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6C022);
	}

	-(float) striationContrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6C122);
	}

	-(void) setStriationContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6C222);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6C322);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6C422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF6C522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF6AF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF6B222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF6E822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF6EB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightTunnel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF6F222);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF6F322);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF6F422);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF6F522);
	}

	-(float) rotation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6F622);
	}

	-(void) setRotation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6F722);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF6F822);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF6F922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF6FA22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF6EC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF6EF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF71322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF71622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF71722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF71A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF72422);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF72522);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF72622);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF72722);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF72822);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF72922);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF72A22);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF72B22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF72C22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF71B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF71E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearLightBlendMode {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF74722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF73F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF74222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearToSRGBToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF74C22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF74D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF74E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF74822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF74B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineOverlay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF75922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF75A22);
	}

	-(float) NRNoiseLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF75B22);
	}

	-(void) setNRNoiseLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF75C22);
	}

	-(float) NRSharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF75D22);
	}

	-(void) setNRSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF75E22);
	}

	-(float) edgeIntensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF75F22);
	}

	-(void) setEdgeIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF76022);
	}

	-(float) threshold
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF76122);
	}

	-(void) setThreshold:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF76222);
	}

	-(float) contrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF76322);
	}

	-(void) setContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF76422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF76522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF75522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF75822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF78422);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF78522);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF78622);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF78722);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF78822);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF78922);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF78A22);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF78B22);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF78C22);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF78D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF78E22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF78022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF78322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILuminosityBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF7A522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF7A822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskedVariableBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7AD22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF7AE22);
	}

	-(CIImage *) mask
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7AF22);
	}

	-(void) setMask:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF7B022);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF7B122);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF7B222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7B322);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF7A922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF7AC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskToAlpha {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7C622);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF7C722);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7C822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF7C222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF7C522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7D322);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF7D422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7D522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF7CF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF7D222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF7DC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF7DF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMedianFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7E422);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF7E522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7E622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF7E022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF7E322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMeshGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF7F122);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF7F222);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7F322);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF7F422);
	}

	-(NSArray *) mesh
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, 0xF7F522);
	}

	-(void) setMesh:(NSArray *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0xF7F622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF7F722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF7ED22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF7F022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF80A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF80B22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF80C22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF80622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF80922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF81322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF81622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF81B22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF81C22);
	}

	-(CIImage *) backgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF81D22);
	}

	-(void) setBackgroundImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF81E22);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF81F22);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF82022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF82122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF81722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF81A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIModTransition {
}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF83622);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF83722);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF83822);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF83922);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF83A22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF83B22);
	}

	-(float) compression
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF83C22);
	}

	-(void) setCompression:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF83D22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF83E22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF83F22);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF84022);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF84122);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF84222);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF84322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF84422);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF83022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF83322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphology {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF85F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyGradient {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF86722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF86822);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF86922);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF86A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF86B22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF86322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF86622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMaximum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF87A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF87B22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF87C22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF87D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF87E22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF87622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF87922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMinimum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF88D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF88E22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF88F22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF89022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF89122);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF88922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF88C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyRectangle {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF89E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyRectangleMaximum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF8AC22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF8AD22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF8AE22);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF8AF22);
	}

	-(float) height
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF8B022);
	}

	-(void) setHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF8B122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF8B222);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF8A822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF8AB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyRectangleMinimum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF8C522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF8C622);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF8C722);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF8C822);
	}

	-(float) height
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF8C922);
	}

	-(void) setHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF8CA22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF8CB22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF8C122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF8C422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMotionBlur {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF8DE22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF8DF22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF8E022);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF8E122);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF8E222);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF8E322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF8E422);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF8DA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF8DD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF8F322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF8F622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF8F722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF8FA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartStretched {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF90522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF90622);
	}

	-(CGPoint) breakpoint0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF90722);
	}

	-(void) setBreakpoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF90822);
	}

	-(CGPoint) breakpoint1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF90922);
	}

	-(void) setBreakpoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF90A22);
	}

	-(CGPoint) growAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF90B22);
	}

	-(void) setGrowAmount:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF90C22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF90D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF8FB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF8FE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartTiled {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF92A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF92B22);
	}

	-(CGPoint) breakpoint0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF92C22);
	}

	-(void) setBreakpoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF92D22);
	}

	-(CGPoint) breakpoint1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF92E22);
	}

	-(void) setBreakpoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF92F22);
	}

	-(CGPoint) growAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF93022);
	}

	-(void) setGrowAmount:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF93122);
	}

	-(BOOL) flipYTiles
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xF93222);
	}

	-(void) setFlipYTiles:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xF93322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF93422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF92022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF92322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINoiseReduction {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF94F22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF95022);
	}

	-(float) noiseLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF95122);
	}

	-(void) setNoiseLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF95222);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF95322);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF95422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF95522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF94B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF94E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOpTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF96822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF96922);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xF96A22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xF96B22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF96C22);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF96D22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF96E22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF96F22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF97022);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF97122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF97222);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF96422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF96722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOverlayBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF98922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF98C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlTransition {
}

	-(CIImage *) backsideImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF99322);
	}

	-(void) setBacksideImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF99422);
	}

	-(CIImage *) shadingImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF99522);
	}

	-(void) setShadingImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF99622);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xF99722);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xF99822);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF99922);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF99A22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF99B22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF99C22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF99D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF99E22);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF99F22);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF9A022);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF9A122);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF9A222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF9A322);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF98D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF99022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlWithShadowTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) backsideImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF9CA22);
	}

	-(void) setBacksideImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF9CB22);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xF9CC22);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xF9CD22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF9CE22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF9CF22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF9D022);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF9D122);
	}

	-(float) shadowSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF9D222);
	}

	-(void) setShadowSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF9D322);
	}

	-(float) shadowAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF9D422);
	}

	-(void) setShadowAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF9D522);
	}

	-(CGRect) shadowExtent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xF9D622);
	}

	-(void) setShadowExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xF9D722);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF9D822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF9D922);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF9DA22);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xF9DB22);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xF9DC22);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xF9DD22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xF9DE22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF9C022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xF9C322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPaletteCentroid {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA0722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFA0822);
	}

	-(CIImage *) paletteImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA0922);
	}

	-(void) setPaletteImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFA0A22);
	}

	-(BOOL) perceptual
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xFA0B22);
	}

	-(void) setPerceptual:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xFA0C22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA0D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFA0322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFA0622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPalettize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA2022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFA2122);
	}

	-(CIImage *) paletteImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA2222);
	}

	-(void) setPaletteImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFA2322);
	}

	-(BOOL) perceptual
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xFA2422);
	}

	-(void) setPerceptual:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xFA2522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA2622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFA1C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFA1F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIParallelogramTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA3922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFA3A22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFA3B22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFA3C22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA3D22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA3E22);
	}

	-(float) acuteAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA3F22);
	}

	-(void) setAcuteAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA4022);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA4122);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA4222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA4322);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFA3522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFA3822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPdf417BarcodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA6B22);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFA6C22);
	}

	-(float) minWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA6D22);
	}

	-(void) setMinWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA6E22);
	}

	-(float) maxWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA6F22);
	}

	-(void) setMaxWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7022);
	}

	-(float) minHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7122);
	}

	-(void) setMinHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7222);
	}

	-(float) maxHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7322);
	}

	-(void) setMaxHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7422);
	}

	-(float) dataColumns
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7522);
	}

	-(void) setDataColumns:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7622);
	}

	-(float) rows
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7722);
	}

	-(void) setRows:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7822);
	}

	-(float) preferredAspectRatio
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7922);
	}

	-(void) setPreferredAspectRatio:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7A22);
	}

	-(float) compactionMode
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7B22);
	}

	-(void) setCompactionMode:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7C22);
	}

	-(float) compactStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7D22);
	}

	-(void) setCompactStyle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA7E22);
	}

	-(float) correctionLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA7F22);
	}

	-(void) setCorrectionLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA8022);
	}

	-(float) alwaysSpecifyCompaction
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFA8122);
	}

	-(void) setAlwaysSpecifyCompaction:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFA8222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFA8322);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFA5A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFA5D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPersonSegmentation {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFAC622);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFAC722);
	}

	-(NSUInteger) qualityLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_15 (self, _cmd, &managed_method, 0xFAC822);
	}

	-(void) setQualityLevel:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_36 (self, _cmd, &managed_method, p0, 0xFAC922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFACA22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFAC222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFAC522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB5722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFB5822);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB5922);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB5A22);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB5B22);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB5C22);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB5D22);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB5E22);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB5F22);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB6022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB6122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFB4922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFB4C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveCorrection {
}

	-(BOOL) crop
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xFAD922);
	}

	-(void) setCrop:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xFADA22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFADB22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFADC22);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFADD22);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFADE22);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFADF22);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFAE022);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFAE122);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFAE222);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFAE322);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFAE422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFAE522);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFAD522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFAD822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveRotate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFAFB22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFAFC22);
	}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFAFD22);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFAFE22);
	}

	-(float) pitch
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFAFF22);
	}

	-(void) setPitch:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFB0022);
	}

	-(float) yaw
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFB0122);
	}

	-(void) setYaw:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFB0222);
	}

	-(float) roll
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFB0322);
	}

	-(void) setRoll:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFB0422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB0522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFAF622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFAF922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTile {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB2822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFB2922);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB2A22);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB2B22);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB2C22);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB2D22);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB2E22);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB2F22);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB3022);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB3122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB3222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFB1C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFB1F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransformWithExtent {
}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xFB7422);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xFB7522);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB7622);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFB7722);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB7822);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB7922);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB7A22);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB7B22);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB7C22);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB7D22);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFB7E22);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFB7F22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB8022);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFB6E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFB7122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB9522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFB9622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFB9722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFB9322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectChrome {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFB9822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFB9B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectFade {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFB9C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFB9F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectInstant {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBA022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBA322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectMono {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBA422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBA722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectNoir {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBA822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBAB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectProcess {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBAC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBAF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTonal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBB622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBB922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTransfer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBBA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBBD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinchDistortion {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFBC222);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFBC322);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFBC422);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFBC522);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFBC622);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFBC722);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFBC822);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFBC922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFBCA22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBBE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBC122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBDD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBE022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFBE722);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFBE822);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFBE922);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFBEA22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFBEB22);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFBEC22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFBED22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBE122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBE422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPointillize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC0222);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFC0322);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFC0422);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFC0522);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFC0622);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFC0722);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC0822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFBFC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFBFF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIQRCodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC3722);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFC3822);
	}

	-(NSString *) correctionLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, 0xFC3922);
	}

	-(void) setCorrectionLevel:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, 0xFC3A22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC3B22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFC3222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFC3522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRadialGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFC4C22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFC4D22);
	}

	-(float) radius0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFC4E22);
	}

	-(void) setRadius0:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFC4F22);
	}

	-(float) radius1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFC5022);
	}

	-(void) setRadius1:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFC5122);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC5222);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFC5322);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC5422);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFC5522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC5622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFC4622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFC4922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRandomGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFC7122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFC6D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFC7022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRippleTransition {
}

	-(CIImage *) shadingImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFD6122);
	}

	-(void) setShadingImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFD6222);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFD6322);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFD6422);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xFD6522);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xFD6622);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFD6722);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFD6822);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFD6922);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFD6A22);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFD6B22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFD6C22);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFD6D22);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFD6E22);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFD6F22);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFD7022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFD7122);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFD5922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFD5C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRoundedRectangleGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xFD9422);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xFD9522);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFD9622);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFD9722);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFD9822);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFD9922);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFD9A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFD8E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFD9122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRowAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDAF22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFDB022);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xFDB122);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xFDB222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDB322);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFDA922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDAC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaliencyMapFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDBE22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFDBF22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDC022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFDBA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDBD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISampleNearest {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFDC722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDCA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaturationBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFDCD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDD022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFDD122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDD422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISepiaTone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDE522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFDE622);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFDE722);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFDE822);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDE922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFDE122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDE422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIShadedMaterial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDF822);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFDF922);
	}

	-(CIImage *) shadingImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDFA22);
	}

	-(void) setShadingImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFDFB22);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFDFC22);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFDFD22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFDFE22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFDF422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFDF722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISharpenLuminance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE1122);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFE1222);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFE1322);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFE1422);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFE1522);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFE1622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE1722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE0D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE1022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE2A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFE2B22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFE2C22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFE2D22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFE2E22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFE2F22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFE3022);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFE3122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE3222);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE2622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE2922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldRotatedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE4922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFE4A22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFE4B22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFE4C22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFE4D22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFE4E22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFE4F22);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFE5022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE5122);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE4522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE4822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISmoothLinearGradient {
}

	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFE6C22);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFE6D22);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFE6E22);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFE6F22);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE7022);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFE7122);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE7222);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFE7322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE7422);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE6422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE6722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISoftLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE8722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE8A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceAtopCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE8B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE8E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceInCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE8F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE9222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOutCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE9322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE9622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOverCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE9722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE9A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFE9F22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEA022);
	}

	-(CIColor *) centerColor1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEA122);
	}

	-(void) setCenterColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEA222);
	}

	-(CIColor *) replacementColor1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEA322);
	}

	-(void) setReplacementColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEA422);
	}

	-(float) closeness1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEA522);
	}

	-(void) setCloseness1:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEA622);
	}

	-(float) contrast1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEA722);
	}

	-(void) setContrast1:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEA822);
	}

	-(CIColor *) centerColor2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEA922);
	}

	-(void) setCenterColor2:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEAA22);
	}

	-(CIColor *) replacementColor2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEAB22);
	}

	-(void) setReplacementColor2:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEAC22);
	}

	-(float) closeness2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEAD22);
	}

	-(void) setCloseness2:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEAE22);
	}

	-(float) contrast2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEAF22);
	}

	-(void) setContrast2:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEB022);
	}

	-(CIColor *) centerColor3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEB122);
	}

	-(void) setCenterColor3:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEB222);
	}

	-(CIColor *) replacementColor3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEB322);
	}

	-(void) setReplacementColor3:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEB422);
	}

	-(float) closeness3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEB522);
	}

	-(void) setCloseness3:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEB622);
	}

	-(float) contrast3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEB722);
	}

	-(void) setContrast3:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEB822);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEB922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE9B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFE9E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotLight {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEF422);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEF522);
	}

	-(CIVector *) lightPosition
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEF622);
	}

	-(void) setLightPosition:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEF722);
	}

	-(CIVector *) lightPointsAt
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEF822);
	}

	-(void) setLightPointsAt:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEF922);
	}

	-(float) brightness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEFA22);
	}

	-(void) setBrightness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEFB22);
	}

	-(float) concentration
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFEFC22);
	}

	-(void) setConcentration:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFEFD22);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFEFE22);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFEFF22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF0022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFEF022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFEF322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISRGBToneCurveToLinear {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF1F22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFF2022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF2122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFF1B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFF1E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStarShineGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFF2E22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFF2F22);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF3022);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFF3122);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF3222);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF3322);
	}

	-(float) crossScale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF3422);
	}

	-(void) setCrossScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF3522);
	}

	-(float) crossAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF3622);
	}

	-(void) setCrossAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF3722);
	}

	-(float) crossOpacity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF3822);
	}

	-(void) setCrossOpacity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF3922);
	}

	-(float) crossWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF3A22);
	}

	-(void) setCrossWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF3B22);
	}

	-(float) epsilon
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF3C22);
	}

	-(void) setEpsilon:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF3D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF3E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFF2822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFF2B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStraightenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF6522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFF6622);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF6722);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF6822);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF6922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFF6122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFF6422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStretchCrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF7A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFF7B22);
	}

	-(CGPoint) size
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFF7C22);
	}

	-(void) setSize:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFF7D22);
	}

	-(float) cropAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF7E22);
	}

	-(void) setCropAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF7F22);
	}

	-(float) centerStretchAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFF8022);
	}

	-(void) setCenterStretchAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFF8122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF8222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFF7422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFF7722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStripesGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFF9B22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFF9C22);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF9D22);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFF9E22);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFF9F22);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFFA022);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFFA122);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFFA222);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFFA322);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFFA422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFFA522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFF9522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFF9822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISubtractBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFFBC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFFBF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISunbeamsGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xFFC822);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0xFFC922);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFFCA22);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xFFCB22);
	}

	-(float) sunRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFFCC22);
	}

	-(void) setSunRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFFCD22);
	}

	-(float) maxStriationRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFFCE22);
	}

	-(void) setMaxStriationRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFFCF22);
	}

	-(float) striationStrength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFFD022);
	}

	-(void) setStriationStrength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFFD122);
	}

	-(float) striationContrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFFD222);
	}

	-(void) setStriationContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFFD322);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0xFFD422);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0xFFD522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xFFD622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFFC022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFFC322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFFF522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0xFFF822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITemperatureAndTint {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1002322);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1002422);
	}

	-(CIVector *) neutral
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1002522);
	}

	-(void) setNeutral:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1002622);
	}

	-(CIVector *) targetNeutral
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1002722);
	}

	-(void) setTargetNeutral:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1002822);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1002922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1001F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1002222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITextImageGenerator {
}

	-(NSString *) text
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, 0x1004722);
	}

	-(void) setText:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, 0x1004822);
	}

	-(NSString *) fontName
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, 0x1004922);
	}

	-(void) setFontName:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, 0x1004A22);
	}

	-(float) fontSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1004B22);
	}

	-(void) setFontSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1004C22);
	}

	-(float) scaleFactor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1004D22);
	}

	-(void) setScaleFactor:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1004E22);
	}

	-(float) padding
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1004F22);
	}

	-(void) setPadding:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1005022);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1005122);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1004322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1004622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIThermal {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1006A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1006B22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1006C22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1006622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1006922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1008D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1008E22);
	}

	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1008F22);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1009022);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1009122);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1009222);
	}

	-(CGPoint) point2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1009322);
	}

	-(void) setPoint2:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1009422);
	}

	-(CGPoint) point3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1009522);
	}

	-(void) setPoint3:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1009622);
	}

	-(CGPoint) point4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1009722);
	}

	-(void) setPoint4:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1009822);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1009922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1007F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1008222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITorusLensDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x100BA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x100BB22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x100BC22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x100BD22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x100BE22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x100BF22);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x100C022);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x100C122);
	}

	-(float) refraction
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x100C222);
	}

	-(void) setRefraction:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x100C322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x100C422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x100B422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x100B722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x100FA22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x100FB22);
	}

	-(CGPoint) point
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x100FC22);
	}

	-(void) setPoint:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x100FD22);
	}

	-(float) size
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x100FE22);
	}

	-(void) setSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x100FF22);
	}

	-(float) rotation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1010022);
	}

	-(void) setRotation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1010122);
	}

	-(float) decay
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1010222);
	}

	-(void) setDecay:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1010322);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1010422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x100F422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x100F722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1011F22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1012022);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1012122);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1012222);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1012322);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1012422);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1012522);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1012622);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1012722);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1011B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1011E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwelvefoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1013E22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1013F22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1014022);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1014122);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1014222);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1014322);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1014422);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1014522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1014622);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1013A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1013D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwirlDistortion {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1015D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1015E22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1015F22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1016022);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1016122);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1016222);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1016322);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1016422);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1016522);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1015922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1015C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIUnsharpMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1018022);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1018122);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1018222);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1018322);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1018422);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1018522);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1018622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1017C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1017F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVibrance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1019922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1019A22);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1019B22);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1019C22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1019D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1019522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1019822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignette {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x101AC22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x101AD22);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x101AE22);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x101AF22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x101B022);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x101B122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x101B222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x101A822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x101AB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignetteEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x101B922);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x101BA22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x101BB22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x101BC22);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x101BD22);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x101BE22);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x101BF22);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x101C022);
	}

	-(float) falloff
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x101C122);
	}

	-(void) setFalloff:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x101C222);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x101C322);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x101B322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x101B622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVividLightBlendMode {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x101F022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x101E822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x101EB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVortexDistortion {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x101F522);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x101F622);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x101F722);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x101F822);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x101F922);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x101FA22);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x101FB22);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x101FC22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x101FD22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x101F122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x101F422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIWhitePointAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1021A22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1021B22);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1021C22);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1021D22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1021E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1021622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1021922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIXRay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1022D22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1022E22);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1022F22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1022922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1022C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIZoomBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1023C22);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1023D22);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1023E22);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1023F22);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_23 (self, _cmd, &managed_method, 0x1024022);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, 0x1024122);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1024222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1023622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1023922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFetchedResultsControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x10D0422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFetchedResultsSectionInfo {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x10D1522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBCentralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1119D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1121422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1124F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CALayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1143722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAAnimationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x114C422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAMediaTiming {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x115AF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation CloudKit_CKDiscoverUserInfosOperation {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x11ACA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CKOperation class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CKRecordValue {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x11D7922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CLSDataStoreDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x11EE122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1265E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPInstrumentClusterControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1276F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPInterfaceControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x127A222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPListTemplateDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1281A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPMapTemplateDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1289922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPPointOfInterestTemplateDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1295A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPSearchTemplateDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1297D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPSessionConfigurationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1299B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPTabBarTemplateDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x129B222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPTemplateApplicationDashboardSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x129D722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPTemplateApplicationInstrumentClusterSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x129F922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__CarPlay_CPTemplateApplicationSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x12A2222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CXCallDirectoryExtensionContextDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x12AF322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CXCallObserverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x12B1322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CXProviderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x12B7122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__BackgroundAssets_BADownloadManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x12C5922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AuthenticationServices_ASAccountAuthenticationModificationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x12C8F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AuthenticationServices_ASAuthorizationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x12D0322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIAdaptivePresentationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x136B522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface UIKit_UIControlEventProxy : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) BridgeSelector;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation UIKit_UIControlEventProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) BridgeSelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x13C0A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface __MonoTouch_UIImageStatusDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) Xamarin_Internal__image:(UIImage *)p0 didFinishSavingWithError:(NSError *)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoTouch_UIImageStatusDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) Xamarin_Internal__image:(UIImage *)p0 didFinishSavingWithError:(NSError *)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, p1, p2, 0x13FC822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPopoverPresentationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x141BA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface __MonoTouch_UIVideoStatusDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) Xamarin_Internal__video:(NSString *)p0 didFinishSavingWithError:(NSError *)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoTouch_UIVideoStatusDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) Xamarin_Internal__video:(NSString *)p0 didFinishSavingWithError:(NSError *)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_40 (self, _cmd, &managed_method, p0, p1, p2, 0x146FB22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSLayoutManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14CB222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextAttachmentContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14D7222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_NSTextContentManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14DD322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_NSTextContentStorageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14DF022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_NSTextLayoutManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14E6722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_NSTextSelectionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14EFD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextStorageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14F4B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_NSTextViewportLayoutControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14F7E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIAccelerometerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14FA722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIAccessibilityContainerDataTable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x14FBC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIActionSheetDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1505622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIActivityItemSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x150C022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIAlertViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1510922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIAppearanceContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1511522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIBarPositioning {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1525F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIBarPositioningDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1526522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UICalendarSelectionMultiDateDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x152CB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UICalendarSelectionSingleDateDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x152E222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UICalendarViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1531B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICloudSharingControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x153AD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICollectionViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1549122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICollectionViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x154C922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICollectionViewDelegateFlowLayout {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1550922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICollectionViewDragDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1554822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICollectionViewDropDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1556C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICollectionViewSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x155F322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICollisionBehaviorDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1568922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIColorPickerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x156A422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIContentContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1570322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIContextMenuInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1574C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UICoordinateSpace {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1576F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDocumentBrowserViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1583422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDocumentInteractionControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1588822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDocumentMenuDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1589D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDocumentPickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x158AA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDragInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1590522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDropInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1595C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDynamicAnimatorDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1598722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIDynamicItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x159A522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIEditMenuInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x159FD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIFindInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15A6222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIFontPickerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15B2822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIGestureRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15B5022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIImagePickerControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15BF022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIIndirectScribbleInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15C5322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UILargeContentViewerInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15D4F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UILayoutSupport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15D8522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UINavigationBarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15F6422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UINavigationItemRenameDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15FD222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIObjectRestoration {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x15FE922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPageViewControllerDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1602E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPageViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1603B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPencilInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x160A922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPickerViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x160E222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPickerViewAccessibilityDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x160C822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPickerViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x160D622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPickerViewModel {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x160EE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIPointerInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1613222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPopoverControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1618822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPreviewInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x161C922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPrinterPickerControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1622422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIPrintInteractionControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1626F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UISceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x163C422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIScreenshotServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1641E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIScribbleInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1643422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIScrollViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x164E122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIScrollViewAccessibilityDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x164CD22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UISearchBarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1650422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UISearchControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1652322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UISearchDisplayDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1653A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UISearchResultsUpdating {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1654D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UISearchTextFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1659122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UISheetPresentationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x165DA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UISplitViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x166D222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIStateRestoring {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1674722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITabBarControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1688822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITabBarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1689A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UITableViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1695222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITableViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1699A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITableViewDragDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x169F822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITableViewDropDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16A1C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITableViewSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16A8722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextDocumentProxy {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16B3622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextDragDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16B6422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextDropDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16BC922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16C3522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UITextFormattingCoordinatorDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16C5722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextInputDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16CD422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextInputTokenizer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16D0222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UITextInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16D4922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextPasteDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16D5B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITextViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16DCB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIToolbarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16DF222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIToolTipInteractionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16E1122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UITraitEnvironment {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16E3F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIVideoEditorControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16E9722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIViewControllerAnimatedTransitioning {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16ED522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIViewControllerContextTransitioning {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16EFA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIViewControllerInteractiveTransitioning {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16F1222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIViewControllerPreviewingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16F2B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIViewControllerTransitioningDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16F6722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UIWebViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1702222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__UIKit_UIWindowSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1706A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ABNewPersonViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1718822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AddressBookUI_InternalABNewPersonViewControllerDelegate : NSObject<ABNewPersonViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) newPersonViewController:(ABNewPersonViewController *)p0 didCompleteWithNewPerson:(id)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AddressBookUI_InternalABNewPersonViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) newPersonViewController:(ABNewPersonViewController *)p0 didCompleteWithNewPerson:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_41 (self, _cmd, &managed_method, p0, p1, 0x170B022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x170AF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ABPeoplePickerNavigationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1719222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AddressBookUI_InternalABPeoplePickerNavigationControllerDelegate : NSObject<ABPeoplePickerNavigationControllerDelegate, UINavigationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(void) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 didSelectPerson:(id)p1;
	-(BOOL) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 shouldContinueAfterSelectingPerson:(id)p1;
	-(BOOL) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 shouldContinueAfterSelectingPerson:(id)p1 property:(int)p2 identifier:(int)p3;
	-(void) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 didSelectPerson:(id)p1 property:(int)p2 identifier:(int)p3;
	-(void) peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AddressBookUI_InternalABPeoplePickerNavigationControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x170E122);
	}

	-(void) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 didSelectPerson:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_41 (self, _cmd, &managed_method, p0, p1, 0x170E322);
	}

	-(BOOL) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 shouldContinueAfterSelectingPerson:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, p1, 0x170E422);
	}

	-(BOOL) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 shouldContinueAfterSelectingPerson:(id)p1 property:(int)p2 identifier:(int)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_44 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x170E522);
	}

	-(void) peoplePickerNavigationController:(ABPeoplePickerNavigationController *)p0 didSelectPerson:(id)p1 property:(int)p2 identifier:(int)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_45 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x170E622);
	}

	-(void) peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x170E722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x170E222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ABPersonViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x171B422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AddressBookUI_InternalABPersonViewControllerDelegate : NSObject<ABPersonViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) personViewController:(ABPersonViewController *)p0 shouldPerformDefaultActionForPerson:(id)p1 property:(int)p2 identifier:(int)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AddressBookUI_InternalABPersonViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) personViewController:(ABPersonViewController *)p0 shouldPerformDefaultActionForPerson:(id)p1 property:(int)p2 identifier:(int)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_44 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1712522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1712422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ABUnknownPersonViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x171BC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AddressBookUI_InternalABUnknownPersonViewControllerDelegate : NSObject<ABUnknownPersonViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) unknownPersonViewController:(ABUnknownPersonViewController *)p0 didResolveToPerson:(id)p1;
	-(BOOL) unknownPersonViewController:(ABUnknownPersonViewController *)p0 shouldPerformDefaultActionForPerson:(id)p1 property:(int)p2 identifier:(int)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AddressBookUI_InternalABUnknownPersonViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) unknownPersonViewController:(ABUnknownPersonViewController *)p0 didResolveToPerson:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_41 (self, _cmd, &managed_method, p0, p1, 0x1715122);
	}

	-(BOOL) unknownPersonViewController:(ABUnknownPersonViewController *)p0 shouldPerformDefaultActionForPerson:(id)p1 property:(int)p2 identifier:(int)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_44 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1715222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1715022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AVKit_AVCustomRoutingControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1754722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPictureInPictureControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1758A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AVKit_AVPictureInPictureSampleBufferPlaybackDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1759F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x175C522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVRoutePickerViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x175F022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureAudioDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1793D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioPlayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17FC422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AVFoundation_InternalAVAudioPlayerDelegate : NSObject<AVAudioPlayerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1;
	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1;
	-(void) audioPlayerBeginInterruption:(AVAudioPlayer *)p0;
	-(void) audioPlayerEndInterruption:(AVAudioPlayer *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioPlayerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x17BAD22);
	}

	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x17BAE22);
	}

	-(void) audioPlayerBeginInterruption:(AVAudioPlayer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x17BAF22);
	}

	-(void) audioPlayerEndInterruption:(AVAudioPlayer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x17BB022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17BAC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioRecorderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1800422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AVFoundation_InternalAVAudioRecorderDelegate : NSObject<AVAudioRecorderDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1;
	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1;
	-(void) audioRecorderBeginInterruption:(AVAudioRecorder *)p0;
	-(void) audioRecorderEndInterruption:(AVAudioRecorder *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioRecorderDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x17BB222);
	}

	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x17BB322);
	}

	-(void) audioRecorderBeginInterruption:(AVAudioRecorder *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x17BB422);
	}

	-(void) audioRecorderEndInterruption:(AVAudioRecorder *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x17BB522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17BB122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1803522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AVFoundation_InternalAVAudioSessionDelegate : NSObject<AVAudioSessionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) beginInterruption;
	-(void) endInterruption;
	-(void) inputIsAvailableChanged:(BOOL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation AVFoundation_InternalAVAudioSessionDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) beginInterruption
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x17BC022);
	}

	-(void) endInterruption
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x17BC122);
	}

	-(void) inputIsAvailableChanged:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x17BC222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAssetDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17BEC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAssetResourceLoaderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17CF722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AVFoundation_AVAssetWriterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17DB622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAsynchronousKeyValueLoading {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17E2C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudio3DMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17E5F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioStereoMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1806522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureDataOutputSynchronizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1818522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureDepthDataOutputDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1819922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureFileOutputRecordingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1828622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureMetadataOutputObjectsDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1829A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCapturePhotoCaptureDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x182F222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureVideoDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1844C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVContentKeySessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x184F522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AVFoundation_AVPlaybackCoordinatorPlaybackControlDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x189B122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18A5A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemLegibleOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18A1A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataCollectorPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18A3022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18A4322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPullDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18A5322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__AVFoundation_AVPlayerPlaybackCoordinatorDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18A9522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVSpeechSynthesizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18B6622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVVideoCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18C1022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_iOS__ARKit_ARCoachingOverlayViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18E3722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ARSCNViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18FEC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ARSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1902C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ARSKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1907922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation UIKit_UIView_UIViewAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIColor *) backgroundColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B66722);
	}

	-(void) setBackgroundColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B66822);
	}

	-(UIColor *) tintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B66922);
	}

	-(void) setTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B66A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation SharedWithYou_SWAttributionView_SWAttributionViewAppearance {
}
@end

@implementation SharedWithYou_SWCollaborationView_SWCollaborationViewAppearance {
}
@end

@interface QuickLook_QLPreviewController__QLPreviewControllerDelegate : NSObject<QLPreviewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) previewControllerDidDismiss:(QLPreviewController *)p0;
	-(void) previewController:(QLPreviewController *)p0 didSaveEditedCopyOfPreviewItem:(id)p1 atURL:(NSURL *)p2;
	-(void) previewController:(QLPreviewController *)p0 didUpdateContentsOfPreviewItem:(id)p1;
	-(CGRect) previewController:(QLPreviewController *)p0 frameForPreviewItem:(id)p1 inSourceView:(UIView **)p2;
	-(NSInteger) previewController:(QLPreviewController *)p0 editingModeForPreviewItem:(id)p1;
	-(BOOL) previewController:(QLPreviewController *)p0 shouldOpenURL:(NSURL *)p1 forPreviewItem:(id)p2;
	-(UIImage *) previewController:(QLPreviewController *)p0 transitionImageForPreviewItem:(id)p1 contentRect:(CGRect)p2;
	-(UIView *) previewController:(QLPreviewController *)p0 transitionViewForPreviewItem:(id)p1;
	-(void) previewControllerWillDismiss:(QLPreviewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation QuickLook_QLPreviewController__QLPreviewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) previewControllerDidDismiss:(QLPreviewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A0F822);
	}

	-(void) previewController:(QLPreviewController *)p0 didSaveEditedCopyOfPreviewItem:(id)p1 atURL:(NSURL *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_47 (self, _cmd, &managed_method, p0, p1, p2, 0x1A0F922);
	}

	-(void) previewController:(QLPreviewController *)p0 didUpdateContentsOfPreviewItem:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_48 (self, _cmd, &managed_method, p0, p1, 0x1A0FA22);
	}

	-(CGRect) previewController:(QLPreviewController *)p0 frameForPreviewItem:(id)p1 inSourceView:(UIView **)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, p2, 0x1A0FB22);
	}

	-(NSInteger) previewController:(QLPreviewController *)p0 editingModeForPreviewItem:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_50 (self, _cmd, &managed_method, p0, p1, 0x1A0FC22);
	}

	-(BOOL) previewController:(QLPreviewController *)p0 shouldOpenURL:(NSURL *)p1 forPreviewItem:(id)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_51 (self, _cmd, &managed_method, p0, p1, p2, 0x1A0FD22);
	}

	-(UIImage *) previewController:(QLPreviewController *)p0 transitionImageForPreviewItem:(id)p1 contentRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_52 (self, _cmd, &managed_method, p0, p1, p2, 0x1A0FE22);
	}

	-(UIView *) previewController:(QLPreviewController *)p0 transitionViewForPreviewItem:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_53 (self, _cmd, &managed_method, p0, p1, 0x1A0FF22);
	}

	-(void) previewControllerWillDismiss:(QLPreviewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A10022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A0F722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PhotosUI_PHLivePhotoView_PHLivePhotoViewAppearance {
}
@end

@implementation UIKit_UIScrollView_UIScrollViewAppearance {
}
@end

@implementation PencilKit_PKCanvasView_PKCanvasViewAppearance {
}
@end

@implementation Messages_MSStickerBrowserView_MSStickerBrowserViewAppearance {
}
@end

@implementation Messages_MSStickerView_MSStickerViewAppearance {
}
@end

@implementation LinkPresentation_LPLinkView_LPLinkViewAppearance {
}
@end

@implementation UIKit_UIControl_UIControlAppearance {
}
@end

@implementation UIKit_UIButton_UIButtonAppearance {
}

	-(UIImage *) backgroundImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B4B322);
	}

	-(UIEdgeInsets) contentEdgeInsets
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_55 (self, _cmd, &managed_method, 0x1B4B422);
	}

	-(void) setContentEdgeInsets:(UIEdgeInsets)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, 0x1B4B522);
	}

	-(UIImage *) currentBackgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B4B622);
	}

	-(UIImage *) currentImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B4B722);
	}

	-(UIColor *) currentTitleColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B4B822);
	}

	-(UIColor *) currentTitleShadowColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B4B922);
	}

	-(UIImage *) imageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B4BA22);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B4BB22);
	}

	-(void) setImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B4BC22);
	}

	-(void) setPreferredSymbolConfiguration:(UIImageSymbolConfiguration *)p0 forImageInState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B4BD22);
	}

	-(void) setTitleColor:(UIColor *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B4BE22);
	}

	-(void) setTitleShadowColor:(UIColor *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B4BF22);
	}

	-(UIColor *) titleColorForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B4C022);
	}

	-(UIColor *) titleShadowColorForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B4C122);
	}
@end

@implementation IntentsUI_INUIAddVoiceShortcutButton_INUIAddVoiceShortcutButtonAppearance {
}
@end

@implementation HealthKitUI_HKActivityRingView_HKActivityRingViewAppearance {
}
@end

@interface ExternalAccessory_EAAccessory__EAAccessoryDelegate : NSObject<EAAccessoryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) accessoryDidDisconnect:(EAAccessory *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ExternalAccessory_EAAccessory__EAAccessoryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) accessoryDidDisconnect:(EAAccessory *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A16722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A16622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ExternalAccessory_EAWiFiUnconfiguredAccessoryBrowser__EAWiFiUnconfiguredAccessoryBrowserDelegate : NSObject<EAWiFiUnconfiguredAccessoryBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didFindUnconfiguredAccessories:(NSSet *)p1;
	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didFinishConfiguringAccessory:(EAWiFiUnconfiguredAccessory *)p1 withStatus:(NSInteger)p2;
	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didRemoveUnconfiguredAccessories:(NSSet *)p1;
	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didUpdateState:(NSInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ExternalAccessory_EAWiFiUnconfiguredAccessoryBrowser__EAWiFiUnconfiguredAccessoryBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didFindUnconfiguredAccessories:(NSSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A16F22);
	}

	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didFinishConfiguringAccessory:(EAWiFiUnconfiguredAccessory *)p1 withStatus:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_58 (self, _cmd, &managed_method, p0, p1, p2, 0x1A17022);
	}

	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didRemoveUnconfiguredAccessories:(NSSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A17122);
	}

	-(void) accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)p0 didUpdateState:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1A17222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A16E22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation CoreLocationUI_CLLocationButton_CLLocationButtonAppearance {
}
@end

@implementation CoreAudioKit_CAInterAppAudioSwitcherView_CAInterAppAudioSwitcherViewAppearance {
}
@end

@implementation CoreAudioKit_CAInterAppAudioTransportView_CAInterAppAudioTransportViewAppearance {
}
@end

@implementation iAd_ADBannerView_ADBannerViewAppearance {
}
@end

@implementation iAd_ADBannerView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x10DE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKRequest__SKRequestDelegate : NSObject<SKRequestDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1;
	-(void) requestDidFinish:(SKRequest *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation StoreKit_SKRequest__SKRequestDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A24822);
	}

	-(void) requestDidFinish:(SKRequest *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A24922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A24722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKProductsRequest__SKProductsRequestDelegate : StoreKit_SKRequest__SKRequestDelegate<SKProductsRequestDelegate, SKRequestDelegate> {
}
	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1;
	-(id) init;
@end

@implementation StoreKit_SKProductsRequest__SKProductsRequestDelegate {
}

	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A23E22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A23D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [StoreKit_SKRequest__SKRequestDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKStoreProductViewController__SKStoreProductViewControllerDelegate : NSObject<SKStoreProductViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) productViewControllerDidFinish:(SKStoreProductViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation StoreKit_SKStoreProductViewController__SKStoreProductViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) productViewControllerDidFinish:(SKStoreProductViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A24B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A24A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate : NSObject<SKPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) didBeginContact:(SKPhysicsContact *)p0;
	-(void) didEndContact:(SKPhysicsContact *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) didBeginContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A25D22);
	}

	-(void) didEndContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A25E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A25C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation SpriteKit_SKView_SKViewAppearance {
}
@end

@implementation SceneKit_SCNView_SCNViewAppearance {
}
@end

@interface SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate : NSObject<SCNPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A2C022);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A2C122);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A2C222);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A2BF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation ReplayKit_RPSystemBroadcastPickerView_RPSystemBroadcastPickerViewAppearance {
}
@end

@interface Photos_PHPhotoLibrary___phlib_observer : NSObject<PHPhotoLibraryChangeObserver> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) photoLibraryDidChange:(PHChange *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Photos_PHPhotoLibrary___phlib_observer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) photoLibraryDidChange:(PHChange *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A2FD22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface PdfKit_PdfView__PdfViewDelegate : NSObject<PDFViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1;
	-(void) PDFViewPerformFind:(PDFView *)p0;
	-(void) PDFViewPerformGoToPage:(PDFView *)p0;
	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfView__PdfViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A30822);
	}

	-(void) PDFViewPerformFind:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A30922);
	}

	-(void) PDFViewPerformGoToPage:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A30A22);
	}

	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A30B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A30722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PdfKit_PdfView_PdfViewAppearance {
}
@end

@interface PdfKit_PdfDocument__PdfDocumentDelegate : NSObject<PDFDocumentDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) documentDidBeginDocumentFind:(NSNotification *)p0;
	-(void) didMatchString:(PDFSelection *)p0;
	-(void) documentDidUnlock:(NSNotification *)p0;
	-(void) documentDidEndDocumentFind:(NSNotification *)p0;
	-(Class) classForAnnotationType:(NSString *)p0;
	-(void) documentDidFindMatch:(NSNotification *)p0;
	-(void) documentDidEndPageFind:(NSNotification *)p0;
	-(void) documentDidBeginPageFind:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfDocument__PdfDocumentDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) documentDidBeginDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A32622);
	}

	-(void) didMatchString:(PDFSelection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A32722);
	}

	-(void) documentDidUnlock:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A32822);
	}

	-(void) documentDidEndDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A32922);
	}

	-(Class) classForAnnotationType:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_60 (self, _cmd, &managed_method, p0, 0x1A32A22);
	}

	-(void) documentDidFindMatch:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A32B22);
	}

	-(void) documentDidEndPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A32C22);
	}

	-(void) documentDidBeginPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A32D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A32522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PdfKit_PdfThumbnailView_PdfThumbnailViewAppearance {
}
@end

@interface PassKit_PKPaymentAuthorizationViewController__PKPaymentAuthorizationViewControllerDelegate : NSObject<PKPaymentAuthorizationViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didAuthorizePayment:(PKPayment *)p1 completion:(void (^)(void *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didAuthorizePayment:(PKPayment *)p1 handler:(void (^)(void *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didChangeCouponCode:(NSString *)p1 handler:(void (^)(void *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didRequestMerchantSessionUpdate:(void (^)(void *))p1;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectPaymentMethod:(PKPaymentMethod *)p1 completion:(void (^)(void *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectPaymentMethod:(PKPaymentMethod *)p1 handler:(void (^)(void *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingAddress:(id)p1 completion:(void (^)(long long, id *, id *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingContact:(PKContact *)p1 completion:(void (^)(long long, id *, id *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingContact:(PKContact *)p1 handler:(void (^)(void *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingMethod:(PKShippingMethod *)p1 completion:(void (^)(long long, id *))p2;
	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingMethod:(PKShippingMethod *)p1 handler:(void (^)(void *))p2;
	-(void) paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)p0;
	-(void) paymentAuthorizationViewControllerWillAuthorizePayment:(PKPaymentAuthorizationViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PassKit_PKPaymentAuthorizationViewController__PKPaymentAuthorizationViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didAuthorizePayment:(PKPayment *)p1 completion:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_61 (self, _cmd, &managed_method, p0, p1, p2, 0x1A34922);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didAuthorizePayment:(PKPayment *)p1 handler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_62 (self, _cmd, &managed_method, p0, p1, p2, 0x1A34A22);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didChangeCouponCode:(NSString *)p1 handler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_63 (self, _cmd, &managed_method, p0, p1, p2, 0x1A34B22);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didRequestMerchantSessionUpdate:(void (^)(void *))p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_64 (self, _cmd, &managed_method, p0, p1, 0x1A34C22);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectPaymentMethod:(PKPaymentMethod *)p1 completion:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_65 (self, _cmd, &managed_method, p0, p1, p2, 0x1A34D22);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectPaymentMethod:(PKPaymentMethod *)p1 handler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_66 (self, _cmd, &managed_method, p0, p1, p2, 0x1A34E22);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingAddress:(id)p1 completion:(void (^)(long long, id *, id *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, p2, 0x1A34F22);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingContact:(PKContact *)p1 completion:(void (^)(long long, id *, id *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_68 (self, _cmd, &managed_method, p0, p1, p2, 0x1A35022);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingContact:(PKContact *)p1 handler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_69 (self, _cmd, &managed_method, p0, p1, p2, 0x1A35122);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingMethod:(PKShippingMethod *)p1 completion:(void (^)(long long, id *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_70 (self, _cmd, &managed_method, p0, p1, p2, 0x1A35222);
	}

	-(void) paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)p0 didSelectShippingMethod:(PKShippingMethod *)p1 handler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_71 (self, _cmd, &managed_method, p0, p1, p2, 0x1A35322);
	}

	-(void) paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A35422);
	}

	-(void) paymentAuthorizationViewControllerWillAuthorizePayment:(PKPaymentAuthorizationViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A35522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A34822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PassKit_PKAddPassButton_PKAddPassButtonAppearance {
}

	-(NSInteger) addPassButtonStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x1A35722);
	}

	-(void) setAddPassButtonStyle:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x1A35822);
	}
@end

@interface PassKit_PKAddPassesViewController__PKAddPassesViewControllerDelegate : NSObject<PKAddPassesViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) addPassesViewControllerDidFinish:(PKAddPassesViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PassKit_PKAddPassesViewController__PKAddPassesViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) addPassesViewControllerDidFinish:(PKAddPassesViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A35A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A35922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PassKit_PKIdentityButton_PKIdentityButtonAppearance {
}
@end

@implementation PassKit_PKPaymentButton_PKPaymentButtonAppearance {
}
@end

@interface System_Net_Http_NSUrlSessionHandler_WrappedNSInputStream : NSInputStream {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSUInteger) streamStatus;
	-(void) open;
	-(void) close;
	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1;
	-(BOOL) hasBytesAvailable;
	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1;
	-(NSObject *) propertyForKey:(NSString *)p0;
	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1;
	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2;
	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation System_Net_Http_NSUrlSessionHandler_WrappedNSInputStream {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSUInteger) streamStatus
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_15 (self, _cmd, &managed_method, 0x1A59522);
	}

	-(void) open
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1A59622);
	}

	-(void) close
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1A59722);
	}

	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, p1, 0x1A59822);
	}

	-(BOOL) hasBytesAvailable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x1A59922);
	}

	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_73 (self, _cmd, &managed_method, p0, p1, 0x1A59A22);
	}

	-(NSObject *) propertyForKey:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1A59B22);
	}

	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1A59C22);
	}

	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_75 (self, _cmd, &managed_method, p0, p1, p2, 0x1A59D22);
	}

	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1A59E22);
	}

	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1A59F22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation MetalKit_MTKView_MTKViewAppearance {
}
@end

@implementation MessageUI_MFMailComposeViewController_MFMailComposeViewControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation MessageUI_MFMessageComposeViewController_MFMessageComposeViewControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface MediaPlayer_MPMediaPickerController__MPMediaPickerControllerDelegate : NSObject<MPMediaPickerControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) mediaPicker:(MPMediaPickerController *)p0 didPickMediaItems:(MPMediaItemCollection *)p1;
	-(void) mediaPickerDidCancel:(MPMediaPickerController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MediaPlayer_MPMediaPickerController__MPMediaPickerControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) mediaPicker:(MPMediaPickerController *)p0 didPickMediaItems:(MPMediaItemCollection *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A6C622);
	}

	-(void) mediaPickerDidCancel:(MPMediaPickerController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A6C722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A6C522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MediaPlayer_MPVolumeView_MPVolumeViewAppearance {
}
@end

@implementation UIKit_UIBarItem_UIBarItemAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSDictionary *) titleTextAttributesForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B47C22);
	}

	-(void) setTitleTextAttributes:(NSDictionary *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B47D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation UIKit_UIBarButtonItem_UIBarButtonItemAppearance {
}

	-(UIImage *) backButtonBackgroundImageForState:(NSUInteger)p0 barMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_76 (self, _cmd, &managed_method, p0, p1, 0x1B46922);
	}

	-(CGFloat) backButtonBackgroundVerticalPositionAdjustmentForBarMetrics:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, 0x1B46A22);
	}

	-(UIOffset) backButtonTitlePositionAdjustmentForBarMetrics:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_78 (self, _cmd, &managed_method, p0, 0x1B46B22);
	}

	-(UIImage *) backgroundImageForState:(NSUInteger)p0 barMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_76 (self, _cmd, &managed_method, p0, p1, 0x1B46C22);
	}

	-(UIImage *) backgroundImageForState:(NSUInteger)p0 style:(NSInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_79 (self, _cmd, &managed_method, p0, p1, p2, 0x1B46D22);
	}

	-(CGFloat) backgroundVerticalPositionAdjustmentForBarMetrics:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, 0x1B46E22);
	}

	-(UIOffset) titlePositionAdjustmentForBarMetrics:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_78 (self, _cmd, &managed_method, p0, 0x1B46F22);
	}

	-(void) setBackButtonBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, p2, 0x1B47022);
	}

	-(void) setBackButtonBackgroundVerticalPositionAdjustment:(CGFloat)p0 forBarMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_81 (self, _cmd, &managed_method, p0, p1, 0x1B47122);
	}

	-(void) setBackButtonTitlePositionAdjustment:(UIOffset)p0 forBarMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, 0x1B47222);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, p2, 0x1B47322);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1 style:(NSInteger)p2 barMetrics:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B47422);
	}

	-(void) setBackgroundVerticalPositionAdjustment:(CGFloat)p0 forBarMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_81 (self, _cmd, &managed_method, p0, p1, 0x1B47522);
	}

	-(void) setTitlePositionAdjustment:(UIOffset)p0 forBarMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, 0x1B47622);
	}

	-(UIColor *) tintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B47722);
	}

	-(void) setTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B47822);
	}
@end

@implementation MapKit_MKUserTrackingBarButtonItem_MKUserTrackingBarButtonItemAppearance {
}
@end

@implementation MapKit_MKOverlayView_MKOverlayViewAppearance {
}
@end

@implementation MapKit_MKAnnotationView_MKAnnotationViewAppearance {
}
@end

@implementation MapKit_MKOverlayPathView_MKOverlayPathViewAppearance {
}
@end

@implementation MapKit_MKCircleView_MKCircleViewAppearance {
}
@end

@implementation MapKit_MKCompassButton_MKCompassButtonAppearance {
}
@end

@interface MapKit_MKMapView__MKMapViewDelegate : NSObject<MKMapViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 calloutAccessoryControlTapped:(UIControl *)p2;
	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3;
	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddOverlayViews:(MKOverlayView *)p1;
	-(void) mapView:(MKMapView *)p0 didChangeUserTrackingMode:(NSUInteger)p1 animated:(BOOL)p2;
	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didDeselectAnnotation:(id)p1;
	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1;
	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 didSelectAnnotation:(id)p1;
	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1;
	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1;
	-(MKOverlayView *) mapView:(MKMapView *)p0 viewForOverlay:(id)p1;
	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1;
	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0;
	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1;
	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1;
	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0;
	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0;
	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MapKit_MKMapView__MKMapViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 calloutAccessoryControlTapped:(UIControl *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A71222);
	}

	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_85 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1A71322);
	}

	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x1A71422);
	}

	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1A71522);
	}

	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1A71622);
	}

	-(void) mapView:(MKMapView *)p0 didAddOverlayViews:(MKOverlayView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A71722);
	}

	-(void) mapView:(MKMapView *)p0 didChangeUserTrackingMode:(NSUInteger)p1 animated:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, p1, p2, 0x1A71822);
	}

	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A71922);
	}

	-(void) mapView:(MKMapView *)p0 didDeselectAnnotation:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x1A71A22);
	}

	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A71B22);
	}

	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A71C22);
	}

	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x1A71D22);
	}

	-(void) mapView:(MKMapView *)p0 didSelectAnnotation:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x1A71E22);
	}

	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A71F22);
	}

	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A72022);
	}

	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A72122);
	}

	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x1A72222);
	}

	-(MKOverlayView *) mapView:(MKMapView *)p0 viewForOverlay:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_91 (self, _cmd, &managed_method, p0, p1, 0x1A72322);
	}

	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A72422);
	}

	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A72522);
	}

	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_91 (self, _cmd, &managed_method, p0, p1, 0x1A72622);
	}

	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x1A72722);
	}

	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x1A72822);
	}

	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A72922);
	}

	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A72A22);
	}

	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A72B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A71122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation MapKit_MKMapView_MKMapViewAppearance {
}
@end

@implementation MapKit_MKMarkerAnnotationView_MKMarkerAnnotationViewAppearance {
}

	-(UIImage *) glyphImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1A72E22);
	}

	-(void) setGlyphImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1A72F22);
	}

	-(NSString *) glyphText
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, 0x1A73022);
	}

	-(void) setGlyphText:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, 0x1A73122);
	}

	-(UIColor *) glyphTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1A73222);
	}

	-(void) setGlyphTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1A73322);
	}

	-(UIColor *) markerTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1A73422);
	}

	-(void) setMarkerTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1A73522);
	}

	-(UIImage *) selectedGlyphImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1A73622);
	}

	-(void) setSelectedGlyphImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1A73722);
	}
@end

@implementation MapKit_MKPinAnnotationView_MKPinAnnotationViewAppearance {
}

	-(UIColor *) pinTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1A73A22);
	}

	-(void) setPinTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A73B22);
	}
@end

@implementation MapKit_MKPolygonView_MKPolygonViewAppearance {
}
@end

@implementation MapKit_MKPolylineView_MKPolylineViewAppearance {
}
@end

@implementation MapKit_MKScaleView_MKScaleViewAppearance {
}
@end

@implementation MapKit_MKUserLocationView_MKUserLocationViewAppearance {
}
@end

@implementation MapKit_MKUserTrackingButton_MKUserTrackingButtonAppearance {
}
@end

@interface HomeKit_HMHome__HMHomeDelegate : NSObject<HMHomeDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) home:(HMHome *)p0 didAddAccessory:(HMAccessory *)p1;
	-(void) home:(HMHome *)p0 didAddActionSet:(HMActionSet *)p1;
	-(void) home:(HMHome *)p0 didAddRoom:(HMRoom *)p1;
	-(void) home:(HMHome *)p0 didAddRoom:(HMRoom *)p1 toZone:(HMZone *)p2;
	-(void) home:(HMHome *)p0 didAddService:(HMService *)p1 toServiceGroup:(HMServiceGroup *)p2;
	-(void) home:(HMHome *)p0 didAddServiceGroup:(HMServiceGroup *)p1;
	-(void) home:(HMHome *)p0 didAddTrigger:(HMTrigger *)p1;
	-(void) home:(HMHome *)p0 didAddUser:(HMUser *)p1;
	-(void) home:(HMHome *)p0 didAddZone:(HMZone *)p1;
	-(void) home:(HMHome *)p0 didEncounterError:(NSError *)p1 forAccessory:(HMAccessory *)p2;
	-(void) home:(HMHome *)p0 didRemoveAccessory:(HMAccessory *)p1;
	-(void) home:(HMHome *)p0 didRemoveActionSet:(HMActionSet *)p1;
	-(void) home:(HMHome *)p0 didRemoveRoom:(HMRoom *)p1;
	-(void) home:(HMHome *)p0 didRemoveRoom:(HMRoom *)p1 fromZone:(HMZone *)p2;
	-(void) home:(HMHome *)p0 didRemoveService:(HMService *)p1 fromServiceGroup:(HMServiceGroup *)p2;
	-(void) home:(HMHome *)p0 didRemoveServiceGroup:(HMServiceGroup *)p1;
	-(void) home:(HMHome *)p0 didRemoveTrigger:(HMTrigger *)p1;
	-(void) home:(HMHome *)p0 didRemoveUser:(HMUser *)p1;
	-(void) home:(HMHome *)p0 didRemoveZone:(HMZone *)p1;
	-(void) home:(HMHome *)p0 didUnblockAccessory:(HMAccessory *)p1;
	-(void) homeDidUpdateAccessControlForCurrentUser:(HMHome *)p0;
	-(void) home:(HMHome *)p0 didUpdateActionsForActionSet:(HMActionSet *)p1;
	-(void) home:(HMHome *)p0 didUpdateHomeHubState:(NSUInteger)p1;
	-(void) home:(HMHome *)p0 didUpdateNameForActionSet:(HMActionSet *)p1;
	-(void) homeDidUpdateName:(HMHome *)p0;
	-(void) home:(HMHome *)p0 didUpdateNameForRoom:(HMRoom *)p1;
	-(void) home:(HMHome *)p0 didUpdateNameForServiceGroup:(HMServiceGroup *)p1;
	-(void) home:(HMHome *)p0 didUpdateNameForTrigger:(HMTrigger *)p1;
	-(void) home:(HMHome *)p0 didUpdateNameForZone:(HMZone *)p1;
	-(void) home:(HMHome *)p0 didUpdateRoom:(HMRoom *)p1 forAccessory:(HMAccessory *)p2;
	-(void) homeDidUpdateSupportedFeatures:(HMHome *)p0;
	-(void) home:(HMHome *)p0 didUpdateTrigger:(HMTrigger *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation HomeKit_HMHome__HMHomeDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) home:(HMHome *)p0 didAddAccessory:(HMAccessory *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83522);
	}

	-(void) home:(HMHome *)p0 didAddActionSet:(HMActionSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83622);
	}

	-(void) home:(HMHome *)p0 didAddRoom:(HMRoom *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83722);
	}

	-(void) home:(HMHome *)p0 didAddRoom:(HMRoom *)p1 toZone:(HMZone *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A83822);
	}

	-(void) home:(HMHome *)p0 didAddService:(HMService *)p1 toServiceGroup:(HMServiceGroup *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A83922);
	}

	-(void) home:(HMHome *)p0 didAddServiceGroup:(HMServiceGroup *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83A22);
	}

	-(void) home:(HMHome *)p0 didAddTrigger:(HMTrigger *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83B22);
	}

	-(void) home:(HMHome *)p0 didAddUser:(HMUser *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83C22);
	}

	-(void) home:(HMHome *)p0 didAddZone:(HMZone *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83D22);
	}

	-(void) home:(HMHome *)p0 didEncounterError:(NSError *)p1 forAccessory:(HMAccessory *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A83E22);
	}

	-(void) home:(HMHome *)p0 didRemoveAccessory:(HMAccessory *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A83F22);
	}

	-(void) home:(HMHome *)p0 didRemoveActionSet:(HMActionSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84022);
	}

	-(void) home:(HMHome *)p0 didRemoveRoom:(HMRoom *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84122);
	}

	-(void) home:(HMHome *)p0 didRemoveRoom:(HMRoom *)p1 fromZone:(HMZone *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A84222);
	}

	-(void) home:(HMHome *)p0 didRemoveService:(HMService *)p1 fromServiceGroup:(HMServiceGroup *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A84322);
	}

	-(void) home:(HMHome *)p0 didRemoveServiceGroup:(HMServiceGroup *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84422);
	}

	-(void) home:(HMHome *)p0 didRemoveTrigger:(HMTrigger *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84522);
	}

	-(void) home:(HMHome *)p0 didRemoveUser:(HMUser *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84622);
	}

	-(void) home:(HMHome *)p0 didRemoveZone:(HMZone *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84722);
	}

	-(void) home:(HMHome *)p0 didUnblockAccessory:(HMAccessory *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84822);
	}

	-(void) homeDidUpdateAccessControlForCurrentUser:(HMHome *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A84922);
	}

	-(void) home:(HMHome *)p0 didUpdateActionsForActionSet:(HMActionSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84A22);
	}

	-(void) home:(HMHome *)p0 didUpdateHomeHubState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1A84B22);
	}

	-(void) home:(HMHome *)p0 didUpdateNameForActionSet:(HMActionSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84C22);
	}

	-(void) homeDidUpdateName:(HMHome *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A84D22);
	}

	-(void) home:(HMHome *)p0 didUpdateNameForRoom:(HMRoom *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84E22);
	}

	-(void) home:(HMHome *)p0 didUpdateNameForServiceGroup:(HMServiceGroup *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A84F22);
	}

	-(void) home:(HMHome *)p0 didUpdateNameForTrigger:(HMTrigger *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A85022);
	}

	-(void) home:(HMHome *)p0 didUpdateNameForZone:(HMZone *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A85122);
	}

	-(void) home:(HMHome *)p0 didUpdateRoom:(HMRoom *)p1 forAccessory:(HMAccessory *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A85222);
	}

	-(void) homeDidUpdateSupportedFeatures:(HMHome *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A85322);
	}

	-(void) home:(HMHome *)p0 didUpdateTrigger:(HMTrigger *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A85422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A83422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface HomeKit_HMAccessory__HMAccessoryDelegate : NSObject<HMAccessoryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) accessory:(HMAccessory *)p0 didAddProfile:(HMAccessoryProfile *)p1;
	-(void) accessory:(HMAccessory *)p0 didRemoveProfile:(HMAccessoryProfile *)p1;
	-(void) accessory:(HMAccessory *)p0 didUpdateAssociatedServiceTypeForService:(HMService *)p1;
	-(void) accessory:(HMAccessory *)p0 didUpdateFirmwareVersion:(NSString *)p1;
	-(void) accessoryDidUpdateName:(HMAccessory *)p0;
	-(void) accessory:(HMAccessory *)p0 didUpdateNameForService:(HMService *)p1;
	-(void) accessoryDidUpdateReachability:(HMAccessory *)p0;
	-(void) accessoryDidUpdateServices:(HMAccessory *)p0;
	-(void) accessory:(HMAccessory *)p0 service:(HMService *)p1 didUpdateValueForCharacteristic:(HMCharacteristic *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation HomeKit_HMAccessory__HMAccessoryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) accessory:(HMAccessory *)p0 didAddProfile:(HMAccessoryProfile *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A88222);
	}

	-(void) accessory:(HMAccessory *)p0 didRemoveProfile:(HMAccessoryProfile *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A88322);
	}

	-(void) accessory:(HMAccessory *)p0 didUpdateAssociatedServiceTypeForService:(HMService *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A88422);
	}

	-(void) accessory:(HMAccessory *)p0 didUpdateFirmwareVersion:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1A88522);
	}

	-(void) accessoryDidUpdateName:(HMAccessory *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A88622);
	}

	-(void) accessory:(HMAccessory *)p0 didUpdateNameForService:(HMService *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A88722);
	}

	-(void) accessoryDidUpdateReachability:(HMAccessory *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A88822);
	}

	-(void) accessoryDidUpdateServices:(HMAccessory *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A88922);
	}

	-(void) accessory:(HMAccessory *)p0 service:(HMService *)p1 didUpdateValueForCharacteristic:(HMCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A88A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A88122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface HomeKit_HMAccessoryBrowser__HMAccessoryBrowserDelegate : NSObject<HMAccessoryBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) accessoryBrowser:(HMAccessoryBrowser *)p0 didFindNewAccessory:(HMAccessory *)p1;
	-(void) accessoryBrowser:(HMAccessoryBrowser *)p0 didRemoveNewAccessory:(HMAccessory *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation HomeKit_HMAccessoryBrowser__HMAccessoryBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) accessoryBrowser:(HMAccessoryBrowser *)p0 didFindNewAccessory:(HMAccessory *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A89022);
	}

	-(void) accessoryBrowser:(HMAccessoryBrowser *)p0 didRemoveNewAccessory:(HMAccessory *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A89122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A88F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation HomeKit_HMCameraView_HMCameraViewAppearance {
}
@end

@interface HomeKit_HMHomeManager__HMHomeManagerDelegate : NSObject<HMHomeManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) homeManager:(HMHomeManager *)p0 didAddHome:(HMHome *)p1;
	-(void) homeManager:(HMHomeManager *)p0 didReceiveAddAccessoryRequest:(HMAddAccessoryRequest *)p1;
	-(void) homeManager:(HMHomeManager *)p0 didRemoveHome:(HMHome *)p1;
	-(void) homeManager:(HMHomeManager *)p0 didUpdateAuthorizationStatus:(NSUInteger)p1;
	-(void) homeManagerDidUpdateHomes:(HMHomeManager *)p0;
	-(void) homeManagerDidUpdatePrimaryHome:(HMHomeManager *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation HomeKit_HMHomeManager__HMHomeManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) homeManager:(HMHomeManager *)p0 didAddHome:(HMHome *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A89C22);
	}

	-(void) homeManager:(HMHomeManager *)p0 didReceiveAddAccessoryRequest:(HMAddAccessoryRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A89D22);
	}

	-(void) homeManager:(HMHomeManager *)p0 didRemoveHome:(HMHome *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A89E22);
	}

	-(void) homeManager:(HMHomeManager *)p0 didUpdateAuthorizationStatus:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1A89F22);
	}

	-(void) homeManagerDidUpdateHomes:(HMHomeManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A8A022);
	}

	-(void) homeManagerDidUpdatePrimaryHome:(HMHomeManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A8A122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A89B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MonoTouch_GKSession_ReceivedObject : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) receiveData:(NSData *)p0 fromPeer:(NSString *)p1 inSession:(GKSession *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MonoTouch_GKSession_ReceivedObject {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) receiveData:(NSData *)p0 fromPeer:(NSString *)p1 inSession:(GKSession *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1A95022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A94F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatch__GKMatchDelegate : NSObject<GKMatchDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2;
	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1;
	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2;
	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatch__GKMatchDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, p1, p2, 0x1A95822);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_95 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1A95922);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A95A22);
	}

	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A95B22);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1A95C22);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_96 (self, _cmd, &managed_method, p0, p1, 0x1A95D22);
	}

	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_97 (self, _cmd, &managed_method, p0, p1, p2, 0x1A95E22);
	}

	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_58 (self, _cmd, &managed_method, p0, p1, p2, 0x1A95F22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A95722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate : NSObject<GKGameCenterControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A98B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A98A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKAchievementViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate {
}

	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A97D22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A97C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation GameKit_GKAchievementViewController_GKAchievementViewControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate : NSObject<GKChallengeEventHandlerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0;
	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A98022);
	}

	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A98122);
	}

	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A98222);
	}

	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A98322);
	}

	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1A98422);
	}

	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1A98522);
	}

	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1A98622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A97F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate : NSObject<GKFriendRequestComposeViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A98822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A98722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation GameKit_GKFriendRequestComposeViewController_GKFriendRequestComposeViewControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKLeaderboardViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate {
}

	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A9AF22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A9AE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation GameKit_GKLeaderboardViewController_GKLeaderboardViewControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate : NSObject<GKMatchmakerViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1;
	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A9D022);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1A9D122);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A9D222);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_99 (self, _cmd, &managed_method, p0, p1, 0x1A9D322);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1A9D422);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1A9D522);
	}

	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1A9D622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1A9CF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation GameKit_GKTurnBasedMatchmakerViewController_GKTurnBasedMatchmakerViewControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface GLKit_GLKView__GLKViewDelegate : NSObject<GLKViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) glkView:(GLKView *)p0 drawInRect:(CGRect)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GLKit_GLKView__GLKViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) glkView:(GLKView *)p0 drawInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_100 (self, _cmd, &managed_method, p0, p1, 0x1AA3722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AA3622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation GLKit_GLKView_GLKViewAppearance {
}
@end

@implementation WebKit_WKWebView_WKWebViewAppearance {
}
@end

@interface Foundation_NSNetService__NSNetServiceDelegate : NSObject<NSNetServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) netServiceDidResolveAddress:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2;
	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1;
	-(void) netServiceDidPublish:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1;
	-(void) netServiceDidStop:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1;
	-(void) netServiceWillPublish:(NSNetService *)p0;
	-(void) netServiceWillResolve:(NSNetService *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetService__NSNetServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) netServiceDidResolveAddress:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AA8122);
	}

	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AA8222);
	}

	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AA8322);
	}

	-(void) netServiceDidPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AA8422);
	}

	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AA8522);
	}

	-(void) netServiceDidStop:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AA8622);
	}

	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AA8722);
	}

	-(void) netServiceWillPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AA8822);
	}

	-(void) netServiceWillResolve:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AA8922);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AA8022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate : NSObject<NSKeyedArchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1;
	-(void) archiverDidFinish:(NSKeyedArchiver *)p0;
	-(void) archiverWillFinish:(NSKeyedArchiver *)p0;
	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AAF222);
	}

	-(void) archiverDidFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AAF322);
	}

	-(void) archiverWillFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AAF422);
	}

	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AAF522);
	}

	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x1AAF622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AAF122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate : NSObject<NSKeyedUnarchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2;
	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1;
	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_102 (self, _cmd, &managed_method, p0, p1, p2, 0x1AAF822);
	}

	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x1AAF922);
	}

	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AAFA22);
	}

	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AAFB22);
	}

	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AAFC22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AAF722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSObject_Disposer : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	+(void) drain:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __NSObject_Disposer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	+(void) drain:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_103 (self, _cmd, &managed_method, p0, 0x1AB1E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AB1B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __XamarinObjectObserver : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __XamarinObjectObserver {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_104 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1AB2122);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Foundation_NSStream__NSStreamDelegate : NSObject<NSStreamDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSStream__NSStreamDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1AB3B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AB3A22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSCache__NSCacheDelegate : NSObject<NSCacheDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSCache__NSCacheDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AB6722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AB6622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSMetadataQuery__NSMetadataQueryDelegate : NSObject<NSMetadataQueryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSMetadataQuery__NSMetadataQueryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x1AB8C22);
	}

	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_105 (self, _cmd, &managed_method, p0, p1, p2, 0x1AB8D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AB8B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate : NSObject<NSNetServiceBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1;
	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_106 (self, _cmd, &managed_method, p0, p1, p2, 0x1AB9722);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_106 (self, _cmd, &managed_method, p0, p1, p2, 0x1AB9822);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, p1, p2, 0x1AB9922);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AB9A22);
	}

	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AB9B22);
	}

	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AB9C22);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, p1, p2, 0x1AB9D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AB9622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface EventKitUI_EKCalendarChooser__EKCalendarChooserDelegate : NSObject<EKCalendarChooserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) calendarChooserDidCancel:(EKCalendarChooser *)p0;
	-(void) calendarChooserDidFinish:(EKCalendarChooser *)p0;
	-(void) calendarChooserSelectionDidChange:(EKCalendarChooser *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation EventKitUI_EKCalendarChooser__EKCalendarChooserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) calendarChooserDidCancel:(EKCalendarChooser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AC0822);
	}

	-(void) calendarChooserDidFinish:(EKCalendarChooser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AC0922);
	}

	-(void) calendarChooserSelectionDidChange:(EKCalendarChooser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AC0A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AC0722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface EventKitUI_EKEventEditViewController__EKEventEditViewDelegate : NSObject<EKEventEditViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) eventEditViewController:(EKEventEditViewController *)p0 didCompleteWithAction:(NSInteger)p1;
	-(EKCalendar *) eventEditViewControllerDefaultCalendarForNewEvents:(EKEventEditViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation EventKitUI_EKEventEditViewController__EKEventEditViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) eventEditViewController:(EKEventEditViewController *)p0 didCompleteWithAction:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1AC0C22);
	}

	-(EKCalendar *) eventEditViewControllerDefaultCalendarForNewEvents:(EKEventEditViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1AC0D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AC0B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation EventKitUI_EKEventEditViewController_EKEventEditViewControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface EventKitUI_EKEventViewController__EKEventViewDelegate : NSObject<EKEventViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) eventViewController:(EKEventViewController *)p0 didCompleteWithAction:(NSInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation EventKitUI_EKEventViewController__EKEventViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) eventViewController:(EKEventViewController *)p0 didCompleteWithAction:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1AC1022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AC0F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreLocation_CLLocationManager__CLLocationManagerDelegate : NSObject<CLLocationManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1;
	-(void) locationManagerDidChangeAuthorization:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didFailRangingBeaconsForConstraint:(CLBeaconIdentityConstraint *)p1 error:(NSError *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didRangeBeacons:(NSArray *)p1 inRegion:(CLBeaconRegion *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didRangeBeacons:(NSArray *)p1 satisfyingConstraint:(CLBeaconIdentityConstraint *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didVisit:(CLVisit *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1;
	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1;
	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2;
	-(void) locationManager:(CLLocationManager *)p0 rangingBeaconsDidFailForRegion:(CLBeaconRegion *)p1 withError:(NSError *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1;
	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateHeading:(CLHeading *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreLocation_CLLocationManager__CLLocationManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, p1, 0x1ACC122);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1ACC222);
	}

	-(void) locationManagerDidChangeAuthorization:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1ACC322);
	}

	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_109 (self, _cmd, &managed_method, p0, p1, p2, 0x1ACC422);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFailRangingBeaconsForConstraint:(CLBeaconIdentityConstraint *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1ACC522);
	}

	-(void) locationManager:(CLLocationManager *)p0 didRangeBeacons:(NSArray *)p1 inRegion:(CLBeaconRegion *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_110 (self, _cmd, &managed_method, p0, p1, p2, 0x1ACC622);
	}

	-(void) locationManager:(CLLocationManager *)p0 didRangeBeacons:(NSArray *)p1 satisfyingConstraint:(CLBeaconIdentityConstraint *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_110 (self, _cmd, &managed_method, p0, p1, p2, 0x1ACC722);
	}

	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1ACC822);
	}

	-(void) locationManager:(CLLocationManager *)p0 didVisit:(CLVisit *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1ACC922);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1ACCA22);
	}

	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1ACCB22);
	}

	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1ACCC22);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1ACCD22);
	}

	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1ACCE22);
	}

	-(void) locationManager:(CLLocationManager *)p0 rangingBeaconsDidFailForRegion:(CLBeaconRegion *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1ACCF22);
	}

	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1ACD022);
	}

	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1ACD122);
	}

	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1ACD222);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateHeading:(CLHeading *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1ACD322);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1ACD422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1ACC022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBCentralManager__CBCentralManagerDelegate : NSObject<CBCentralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1;
	-(void) centralManager:(CBCentralManager *)p0 connectionEventDidOccur:(NSInteger)p1 forPeripheral:(CBPeripheral *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didUpdateANCSAuthorizationForPeripheral:(CBPeripheral *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3;
	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1;
	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0;
	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBCentralManager__CBCentralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE3122);
	}

	-(void) centralManager:(CBCentralManager *)p0 connectionEventDidOccur:(NSInteger)p1 forPeripheral:(CBPeripheral *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_109 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE3222);
	}

	-(void) centralManager:(CBCentralManager *)p0 didUpdateANCSAuthorizationForPeripheral:(CBPeripheral *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE3322);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE3422);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_95 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1AE3522);
	}

	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE3622);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1AE3722);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1AE3822);
	}

	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AE3922);
	}

	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE3A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AE3022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate : NSObject<CBPeripheralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1;
	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE3C22);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE3D22);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE3E22);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE3F22);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_111 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE4022);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_111 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE4122);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE4222);
	}

	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AE4322);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE4422);
	}

	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AE4522);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE4622);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1AE4722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AE3B22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheral__CBPeripheralDelegate : NSObject<CBPeripheralDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1;
	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0;
	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateName:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheral__CBPeripheralDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE4922);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE4A22);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE4B22);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE4C22);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE4D22);
	}

	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AE4E22);
	}

	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AE4F22);
	}

	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1AE5022);
	}

	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE5122);
	}

	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1AE5222);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE5322);
	}

	-(void) peripheralDidUpdateName:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AE5422);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE5522);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE5622);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE5722);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1AE5822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AE4822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreAnimation_CAAnimation__CAAnimationDelegate : NSObject<CAAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) animationDidStart:(CAAnimation *)p0;
	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreAnimation_CAAnimation__CAAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) animationDidStart:(CAAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1AE5A22);
	}

	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x1AE5B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1AE5922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIWindow_UIWindowAppearance {
}
@end

@implementation CarPlay_CPWindow_CPWindowAppearance {
}
@end

@implementation BusinessChat_BCChatButton_BCChatButtonAppearance {
}
@end

@implementation AuthenticationServices_ASAuthorizationAppleIdButton_ASAuthorizationAppleIdButtonAppearance {
}
@end

@interface UIKit_UIPreviewInteraction__UIPreviewInteractionDelegate : NSObject<UIPreviewInteractionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) previewInteractionDidCancel:(UIPreviewInteraction *)p0;
	-(void) previewInteraction:(UIPreviewInteraction *)p0 didUpdateCommitTransition:(CGFloat)p1 ended:(BOOL)p2;
	-(void) previewInteraction:(UIPreviewInteraction *)p0 didUpdatePreviewTransition:(CGFloat)p1 ended:(BOOL)p2;
	-(BOOL) previewInteractionShouldBegin:(UIPreviewInteraction *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIPreviewInteraction__UIPreviewInteractionDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) previewInteractionDidCancel:(UIPreviewInteraction *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B41822);
	}

	-(void) previewInteraction:(UIPreviewInteraction *)p0 didUpdateCommitTransition:(CGFloat)p1 ended:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_112 (self, _cmd, &managed_method, p0, p1, p2, 0x1B41922);
	}

	-(void) previewInteraction:(UIPreviewInteraction *)p0 didUpdatePreviewTransition:(CGFloat)p1 ended:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_112 (self, _cmd, &managed_method, p0, p1, p2, 0x1B41A22);
	}

	-(BOOL) previewInteractionShouldBegin:(UIPreviewInteraction *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B41B22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B41722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_FuncBoolDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) xamarinApplySelectorFunc:(UIAccessibilityCustomAction *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_FuncBoolDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) xamarinApplySelectorFunc:(UIAccessibilityCustomAction *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B42722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface UIKit_UIActionSheet__UIActionSheetDelegate : NSObject<UIActionSheetDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) actionSheetCancel:(UIActionSheet *)p0;
	-(void) actionSheet:(UIActionSheet *)p0 clickedButtonAtIndex:(NSInteger)p1;
	-(void) actionSheet:(UIActionSheet *)p0 didDismissWithButtonIndex:(NSInteger)p1;
	-(void) didPresentActionSheet:(UIActionSheet *)p0;
	-(void) actionSheet:(UIActionSheet *)p0 willDismissWithButtonIndex:(NSInteger)p1;
	-(void) willPresentActionSheet:(UIActionSheet *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation UIKit_UIActionSheet__UIActionSheetDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) actionSheetCancel:(UIActionSheet *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B42A22);
	}

	-(void) actionSheet:(UIActionSheet *)p0 clickedButtonAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x1B42B22);
	}

	-(void) actionSheet:(UIActionSheet *)p0 didDismissWithButtonIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x1B42C22);
	}

	-(void) didPresentActionSheet:(UIActionSheet *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B42D22);
	}

	-(void) actionSheet:(UIActionSheet *)p0 willDismissWithButtonIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x1B42E22);
	}

	-(void) willPresentActionSheet:(UIActionSheet *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B42F22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation UIKit_UIActionSheet_UIActionSheetAppearance {
}
@end

@interface UIKit_UIAlertView__UIAlertViewDelegate : NSObject<UIAlertViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) alertViewCancel:(UIAlertView *)p0;
	-(void) alertView:(UIAlertView *)p0 clickedButtonAtIndex:(NSInteger)p1;
	-(void) alertView:(UIAlertView *)p0 didDismissWithButtonIndex:(NSInteger)p1;
	-(void) didPresentAlertView:(UIAlertView *)p0;
	-(BOOL) alertViewShouldEnableFirstOtherButton:(UIAlertView *)p0;
	-(void) alertView:(UIAlertView *)p0 willDismissWithButtonIndex:(NSInteger)p1;
	-(void) willPresentAlertView:(UIAlertView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation UIKit_UIAlertView__UIAlertViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) alertViewCancel:(UIAlertView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B43822);
	}

	-(void) alertView:(UIAlertView *)p0 clickedButtonAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x1B43922);
	}

	-(void) alertView:(UIAlertView *)p0 didDismissWithButtonIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x1B43A22);
	}

	-(void) didPresentAlertView:(UIAlertView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B43B22);
	}

	-(BOOL) alertViewShouldEnableFirstOtherButton:(UIAlertView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B43C22);
	}

	-(void) alertView:(UIAlertView *)p0 willDismissWithButtonIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x1B43D22);
	}

	-(void) willPresentAlertView:(UIAlertView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B43E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation UIKit_UIAlertView_UIAlertViewAppearance {
}
@end

@interface UIKit_UIBarButtonItem_Callback : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) InvokeAction:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIBarButtonItem_Callback {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) InvokeAction:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B46722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B46622);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UICollectionView_UICollectionViewAppearance {
}
@end

@interface UIKit_UIDocumentMenuViewController__UIDocumentMenuDelegate : NSObject<UIDocumentMenuDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) documentMenu:(UIDocumentMenuViewController *)p0 didPickDocumentPicker:(UIDocumentPickerViewController *)p1;
	-(void) documentMenuWasCancelled:(UIDocumentMenuViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIDocumentMenuViewController__UIDocumentMenuDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) documentMenu:(UIDocumentMenuViewController *)p0 didPickDocumentPicker:(UIDocumentPickerViewController *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B4DF22);
	}

	-(void) documentMenuWasCancelled:(UIDocumentMenuViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B4E022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B4DE22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UIDocumentPickerViewController__UIDocumentPickerDelegate : NSObject<UIDocumentPickerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentAtURL:(NSURL *)p1;
	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentsAtURLs:(NSArray *)p1;
	-(void) documentPickerWasCancelled:(UIDocumentPickerViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIDocumentPickerViewController__UIDocumentPickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentAtURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B4E422);
	}

	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentsAtURLs:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1B4E522);
	}

	-(void) documentPickerWasCancelled:(UIDocumentPickerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B4E622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B4E322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation __UIGestureRecognizerToken {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B4F522);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __UIGestureRecognizerGenericCB : __UIGestureRecognizerToken {
}
	-(void) target:(UIGestureRecognizer *)p0;
@end

@implementation __UIGestureRecognizerGenericCB {
}

	-(void) target:(UIGestureRecognizer *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x1B4F722);
	}
@end

@implementation __UIGestureRecognizerParameterlessToken {
}

	-(void) target
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1B4F922);
	}
@end

@implementation __UIGestureRecognizerParametrizedToken {
}

	-(void) target:(UIGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B4FB22);
	}
@end

@interface UIKit_UIGestureRecognizer__UIGestureRecognizerDelegate : NSObject<UIGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)p1;
	-(BOOL) gestureRecognizerShouldBegin:(UIGestureRecognizer *)p0;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveEvent:(UIEvent *)p1;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceivePress:(UIPress *)p1;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveTouch:(UITouch *)p1;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIGestureRecognizer__UIGestureRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1B4FD22);
	}

	-(BOOL) gestureRecognizerShouldBegin:(UIGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B4FE22);
	}

	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1B4FF22);
	}

	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceivePress:(UIPress *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1B50022);
	}

	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveTouch:(UITouch *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1B50122);
	}

	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1B50222);
	}

	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1B50322);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B4FC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UIImagePickerController__UIImagePickerControllerDelegate : NSObject<UIImagePickerControllerDelegate, UINavigationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) imagePickerControllerDidCancel:(UIImagePickerController *)p0;
	-(void) imagePickerController:(UIImagePickerController *)p0 didFinishPickingImage:(UIImage *)p1 editingInfo:(NSDictionary *)p2;
	-(void) imagePickerController:(UIImagePickerController *)p0 didFinishPickingMediaWithInfo:(NSDictionary *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIImagePickerController__UIImagePickerControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) imagePickerControllerDidCancel:(UIImagePickerController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B55322);
	}

	-(void) imagePickerController:(UIImagePickerController *)p0 didFinishPickingImage:(UIImage *)p1 editingInfo:(NSDictionary *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1B55422);
	}

	-(void) imagePickerController:(UIImagePickerController *)p0 didFinishPickingMediaWithInfo:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B55522);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B55222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UINavigationBar_UINavigationBarAppearance {
}

	-(UIImage *) backIndicatorImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B56522);
	}

	-(void) setBackIndicatorImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B56622);
	}

	-(UIImage *) backIndicatorTransitionMaskImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B56722);
	}

	-(void) setBackIndicatorTransitionMaskImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B56822);
	}

	-(NSInteger) barStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x1B56922);
	}

	-(void) setBarStyle:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x1B56A22);
	}

	-(UIColor *) barTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B56B22);
	}

	-(void) setBarTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B56C22);
	}

	-(UINavigationBarAppearance *) compactAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B56D22);
	}

	-(void) setCompactAppearance:(UINavigationBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B56E22);
	}

	-(UINavigationBarAppearance *) compactScrollEdgeAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B56F22);
	}

	-(void) setCompactScrollEdgeAppearance:(UINavigationBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B57022);
	}

	-(UIImage *) backgroundImageForBarMetrics:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, 0x1B57122);
	}

	-(UIImage *) backgroundImageForBarPosition:(NSInteger)p0 barMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_116 (self, _cmd, &managed_method, p0, p1, 0x1B57222);
	}

	-(CGFloat) titleVerticalPositionAdjustmentForBarMetrics:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, 0x1B57322);
	}

	-(BOOL) prefersLargeTitles
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x1B57622);
	}

	-(void) setPrefersLargeTitles:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x1B57722);
	}

	-(UINavigationBarAppearance *) scrollEdgeAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B57822);
	}

	-(void) setScrollEdgeAppearance:(UINavigationBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B57922);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forBarMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1B57A22);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forBarPosition:(NSInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_117 (self, _cmd, &managed_method, p0, p1, p2, 0x1B57B22);
	}

	-(void) setTitleVerticalPositionAdjustment:(CGFloat)p0 forBarMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_81 (self, _cmd, &managed_method, p0, p1, 0x1B57C22);
	}

	-(UIImage *) shadowImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B57D22);
	}

	-(void) setShadowImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B57E22);
	}

	-(UINavigationBarAppearance *) standardAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B57F22);
	}

	-(void) setStandardAppearance:(UINavigationBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B58022);
	}

	-(BOOL) isTranslucent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x1B58322);
	}

	-(void) setTranslucent:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x1B58422);
	}

	-(NSDictionary *) largeTitleTextAttributes
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B58522);
	}

	-(void) setLargeTitleTextAttributes:(NSDictionary *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B58622);
	}

	-(NSDictionary *) titleTextAttributes
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B58722);
	}

	-(void) setTitleTextAttributes:(NSDictionary *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B58822);
	}
@end

@interface UIKit_UIPageViewController__UIPageViewControllerDelegate : NSObject<UIPageViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) pageViewController:(UIPageViewController *)p0 didFinishAnimating:(BOOL)p1 previousViewControllers:(NSArray *)p2 transitionCompleted:(BOOL)p3;
	-(NSInteger) pageViewControllerPreferredInterfaceOrientationForPresentation:(UIPageViewController *)p0;
	-(NSInteger) pageViewController:(UIPageViewController *)p0 spineLocationForInterfaceOrientation:(NSInteger)p1;
	-(NSUInteger) pageViewControllerSupportedInterfaceOrientations:(UIPageViewController *)p0;
	-(void) pageViewController:(UIPageViewController *)p0 willTransitionToViewControllers:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIPageViewController__UIPageViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) pageViewController:(UIPageViewController *)p0 didFinishAnimating:(BOOL)p1 previousViewControllers:(NSArray *)p2 transitionCompleted:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_118 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B58A22);
	}

	-(NSInteger) pageViewControllerPreferredInterfaceOrientationForPresentation:(UIPageViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x1B58B22);
	}

	-(NSInteger) pageViewController:(UIPageViewController *)p0 spineLocationForInterfaceOrientation:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_120 (self, _cmd, &managed_method, p0, p1, 0x1B58C22);
	}

	-(NSUInteger) pageViewControllerSupportedInterfaceOrientations:(UIPageViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_121 (self, _cmd, &managed_method, p0, 0x1B58D22);
	}

	-(void) pageViewController:(UIPageViewController *)p0 willTransitionToViewControllers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1B58E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B58922);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UIPageViewController__UIPageViewControllerDataSource : NSObject<UIPageViewControllerDataSource> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(UIViewController *) pageViewController:(UIPageViewController *)p0 viewControllerAfterViewController:(UIViewController *)p1;
	-(NSInteger) presentationCountForPageViewController:(UIPageViewController *)p0;
	-(NSInteger) presentationIndexForPageViewController:(UIPageViewController *)p0;
	-(UIViewController *) pageViewController:(UIPageViewController *)p0 viewControllerBeforeViewController:(UIViewController *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIPageViewController__UIPageViewControllerDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIViewController *) pageViewController:(UIPageViewController *)p0 viewControllerAfterViewController:(UIViewController *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x1B59022);
	}

	-(NSInteger) presentationCountForPageViewController:(UIPageViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x1B59122);
	}

	-(NSInteger) presentationIndexForPageViewController:(UIPageViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x1B59222);
	}

	-(UIViewController *) pageViewController:(UIPageViewController *)p0 viewControllerBeforeViewController:(UIViewController *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x1B59322);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B58F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIPickerView_UIPickerViewAppearance {
}
@end

@interface UIKit_UIPopoverController__UIPopoverControllerDelegate : NSObject<UIPopoverControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) popoverControllerDidDismissPopover:(UIPopoverController *)p0;
	-(BOOL) popoverControllerShouldDismissPopover:(UIPopoverController *)p0;
	-(void) popoverController:(UIPopoverController *)p0 willRepositionPopoverToRect:(CGRect*)p1 inView:(UIView **)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIPopoverController__UIPopoverControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) popoverControllerDidDismissPopover:(UIPopoverController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5A422);
	}

	-(BOOL) popoverControllerShouldDismissPopover:(UIPopoverController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B5A522);
	}

	-(void) popoverController:(UIPopoverController *)p0 willRepositionPopoverToRect:(CGRect*)p1 inView:(UIView **)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_122 (self, _cmd, &managed_method, p0, p1, p2, 0x1B5A622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B5A322);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UIPopoverPresentationController__UIPopoverPresentationControllerDelegate : NSObject<UIPopoverPresentationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) popoverPresentationControllerDidDismissPopover:(UIPopoverPresentationController *)p0;
	-(void) prepareForPopoverPresentation:(UIPopoverPresentationController *)p0;
	-(BOOL) popoverPresentationControllerShouldDismissPopover:(UIPopoverPresentationController *)p0;
	-(void) popoverPresentationController:(UIPopoverPresentationController *)p0 willRepositionPopoverToRect:(CGRect*)p1 inView:(UIView **)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIPopoverPresentationController__UIPopoverPresentationControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) popoverPresentationControllerDidDismissPopover:(UIPopoverPresentationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5A822);
	}

	-(void) prepareForPopoverPresentation:(UIPopoverPresentationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5A922);
	}

	-(BOOL) popoverPresentationControllerShouldDismissPopover:(UIPopoverPresentationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B5AA22);
	}

	-(void) popoverPresentationController:(UIPopoverPresentationController *)p0 willRepositionPopoverToRect:(CGRect*)p1 inView:(UIView **)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_122 (self, _cmd, &managed_method, p0, p1, p2, 0x1B5AB22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B5A722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UIPrintInteractionController__UIPrintInteractionControllerDelegate : NSObject<UIPrintInteractionControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSInteger) printInteractionController:(UIPrintInteractionController *)p0 chooseCutterBehavior:(NSArray *)p1;
	-(UIPrintPaper *) printInteractionController:(UIPrintInteractionController *)p0 choosePaper:(NSArray *)p1;
	-(CGFloat) printInteractionController:(UIPrintInteractionController *)p0 cutLengthForPaper:(UIPrintPaper *)p1;
	-(void) printInteractionControllerDidDismissPrinterOptions:(UIPrintInteractionController *)p0;
	-(void) printInteractionControllerDidFinishJob:(UIPrintInteractionController *)p0;
	-(void) printInteractionControllerDidPresentPrinterOptions:(UIPrintInteractionController *)p0;
	-(UIViewController *) printInteractionControllerParentViewController:(UIPrintInteractionController *)p0;
	-(void) printInteractionControllerWillDismissPrinterOptions:(UIPrintInteractionController *)p0;
	-(void) printInteractionControllerWillPresentPrinterOptions:(UIPrintInteractionController *)p0;
	-(void) printInteractionControllerWillStartJob:(UIPrintInteractionController *)p0;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIPrintInteractionController__UIPrintInteractionControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSInteger) printInteractionController:(UIPrintInteractionController *)p0 chooseCutterBehavior:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_123 (self, _cmd, &managed_method, p0, p1, 0x1B5AD22);
	}

	-(UIPrintPaper *) printInteractionController:(UIPrintInteractionController *)p0 choosePaper:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_124 (self, _cmd, &managed_method, p0, p1, 0x1B5AE22);
	}

	-(CGFloat) printInteractionController:(UIPrintInteractionController *)p0 cutLengthForPaper:(UIPrintPaper *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0x1B5AF22);
	}

	-(void) printInteractionControllerDidDismissPrinterOptions:(UIPrintInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5B022);
	}

	-(void) printInteractionControllerDidFinishJob:(UIPrintInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5B122);
	}

	-(void) printInteractionControllerDidPresentPrinterOptions:(UIPrintInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5B222);
	}

	-(UIViewController *) printInteractionControllerParentViewController:(UIPrintInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1B5B322);
	}

	-(void) printInteractionControllerWillDismissPrinterOptions:(UIPrintInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5B422);
	}

	-(void) printInteractionControllerWillPresentPrinterOptions:(UIPrintInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5B522);
	}

	-(void) printInteractionControllerWillStartJob:(UIPrintInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5B622);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1B5B722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B5AC22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UISearchBar_UISearchBarAppearance {
}

	-(UIImage *) backgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B5D722);
	}

	-(void) setBackgroundImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5D822);
	}

	-(UIImage *) backgroundImageForBarPosition:(NSInteger)p0 barMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_116 (self, _cmd, &managed_method, p0, p1, 0x1B5D922);
	}

	-(UIColor *) barTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B5DA22);
	}

	-(void) setBarTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5DB22);
	}

	-(UIImage *) imageForSearchBarIcon:(NSInteger)p0 state:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x1B5DC22);
	}

	-(UIOffset) positionAdjustmentForSearchBarIcon:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_78 (self, _cmd, &managed_method, p0, 0x1B5DD22);
	}

	-(UIImage *) scopeBarButtonBackgroundImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B5DE22);
	}

	-(UIImage *) scopeBarButtonDividerImageForLeftSegmentState:(NSUInteger)p0 rightSegmentState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x1B5DF22);
	}

	-(UIImage *) searchFieldBackgroundImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B5E022);
	}

	-(UIImage *) scopeBarBackgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B5E122);
	}

	-(void) setScopeBarBackgroundImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5E222);
	}

	-(UIOffset) searchFieldBackgroundPositionAdjustment
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_128 (self, _cmd, &managed_method, 0x1B5E322);
	}

	-(void) setSearchFieldBackgroundPositionAdjustment:(UIOffset)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, 0x1B5E422);
	}

	-(UIOffset) searchTextPositionAdjustment
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_128 (self, _cmd, &managed_method, 0x1B5E522);
	}

	-(void) setSearchTextPositionAdjustment:(UIOffset)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, 0x1B5E622);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forBarPosition:(NSInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_117 (self, _cmd, &managed_method, p0, p1, p2, 0x1B5E722);
	}

	-(void) setImage:(UIImage *)p0 forSearchBarIcon:(NSInteger)p1 state:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_130 (self, _cmd, &managed_method, p0, p1, p2, 0x1B5E822);
	}

	-(void) setPositionAdjustment:(UIOffset)p0 forSearchBarIcon:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, 0x1B5E922);
	}

	-(void) setScopeBarButtonBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B5EA22);
	}

	-(void) setScopeBarButtonDividerImage:(UIImage *)p0 forLeftSegmentState:(NSUInteger)p1 rightSegmentState:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, p2, 0x1B5EB22);
	}

	-(void) setSearchFieldBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B5EC22);
	}

	-(NSDictionary *) scopeBarButtonTitleTextAttributesForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B5ED22);
	}

	-(void) setScopeBarButtonTitleTextAttributes:(NSDictionary *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B5EE22);
	}
@end

@interface UIKit_UISearchBar__UISearchBarDelegate : NSObject<UISearchBarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) searchBarBookmarkButtonClicked:(UISearchBar *)p0;
	-(void) searchBarCancelButtonClicked:(UISearchBar *)p0;
	-(void) searchBarResultsListButtonClicked:(UISearchBar *)p0;
	-(void) searchBarTextDidBeginEditing:(UISearchBar *)p0;
	-(void) searchBarTextDidEndEditing:(UISearchBar *)p0;
	-(void) searchBarSearchButtonClicked:(UISearchBar *)p0;
	-(void) searchBar:(UISearchBar *)p0 selectedScopeButtonIndexDidChange:(NSInteger)p1;
	-(BOOL) searchBarShouldBeginEditing:(UISearchBar *)p0;
	-(BOOL) searchBar:(UISearchBar *)p0 shouldChangeTextInRange:(NSRange)p1 replacementText:(NSString *)p2;
	-(BOOL) searchBarShouldEndEditing:(UISearchBar *)p0;
	-(void) searchBar:(UISearchBar *)p0 textDidChange:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UISearchBar__UISearchBarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) searchBarBookmarkButtonClicked:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5F022);
	}

	-(void) searchBarCancelButtonClicked:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5F122);
	}

	-(void) searchBarResultsListButtonClicked:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5F222);
	}

	-(void) searchBarTextDidBeginEditing:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5F322);
	}

	-(void) searchBarTextDidEndEditing:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5F422);
	}

	-(void) searchBarSearchButtonClicked:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5F522);
	}

	-(void) searchBar:(UISearchBar *)p0 selectedScopeButtonIndexDidChange:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0x1B5F622);
	}

	-(BOOL) searchBarShouldBeginEditing:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B5F722);
	}

	-(BOOL) searchBar:(UISearchBar *)p0 shouldChangeTextInRange:(NSRange)p1 replacementText:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, p1, p2, 0x1B5F822);
	}

	-(BOOL) searchBarShouldEndEditing:(UISearchBar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B5F922);
	}

	-(void) searchBar:(UISearchBar *)p0 textDidChange:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1B5FA22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B5EF22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UISearchController___Xamarin_UISearchResultsUpdating : NSObject<UISearchResultsUpdating> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) updateSearchResultsForSearchController:(UISearchController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation UIKit_UISearchController___Xamarin_UISearchResultsUpdating {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) updateSearchResultsForSearchController:(UISearchController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B5FC22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation UIKit_UISegmentedControl_UISegmentedControlAppearance {
}

	-(UIOffset) contentPositionAdjustmentForSegmentType:(NSInteger)p0 barMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_133 (self, _cmd, &managed_method, p0, p1, 0x1B60022);
	}

	-(UIImage *) dividerImageForLeftSegmentState:(NSUInteger)p0 rightSegmentState:(NSUInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_134 (self, _cmd, &managed_method, p0, p1, p2, 0x1B60122);
	}

	-(UIImage *) backgroundImageForState:(NSUInteger)p0 barMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_76 (self, _cmd, &managed_method, p0, p1, 0x1B60222);
	}

	-(UIColor *) selectedSegmentTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B60322);
	}

	-(void) setSelectedSegmentTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B60422);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, p2, 0x1B60522);
	}

	-(void) setContentPositionAdjustment:(UIOffset)p0 forSegmentType:(NSInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_135 (self, _cmd, &managed_method, p0, p1, p2, 0x1B60622);
	}

	-(void) setDividerImage:(UIImage *)p0 forLeftSegmentState:(NSUInteger)p1 rightSegmentState:(NSUInteger)p2 barMetrics:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_136 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B60722);
	}

	-(NSDictionary *) titleTextAttributesForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B60822);
	}

	-(void) setTitleTextAttributes:(NSDictionary *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B60922);
	}
@end

@implementation UIKit_UITableView_UITableViewAppearance {
}

	-(UIColor *) sectionIndexBackgroundColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B60B22);
	}

	-(void) setSectionIndexBackgroundColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B60C22);
	}

	-(UIColor *) sectionIndexColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B60D22);
	}

	-(void) setSectionIndexColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B60E22);
	}

	-(UIColor *) sectionIndexTrackingBackgroundColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B60F22);
	}

	-(void) setSectionIndexTrackingBackgroundColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B61022);
	}

	-(UIColor *) separatorColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B61122);
	}

	-(void) setSeparatorColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B61222);
	}

	-(UIVisualEffect *) separatorEffect
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B61322);
	}

	-(void) setSeparatorEffect:(UIVisualEffect *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B61422);
	}

	-(UIEdgeInsets) separatorInset
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_55 (self, _cmd, &managed_method, 0x1B61522);
	}

	-(void) setSeparatorInset:(UIEdgeInsets)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, 0x1B61622);
	}
@end

@implementation UIKit_UITableViewCell_UITableViewCellAppearance {
}

	-(NSInteger) focusStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x1B61C22);
	}

	-(void) setFocusStyle:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x1B61D22);
	}

	-(UIEdgeInsets) separatorInset
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_55 (self, _cmd, &managed_method, 0x1B61E22);
	}

	-(void) setSeparatorInset:(UIEdgeInsets)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, 0x1B61F22);
	}
@end

@interface UIKit_UITextField__UITextFieldDelegate : NSObject<UITextFieldDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) textFieldDidEndEditing:(UITextField *)p0;
	-(void) textFieldDidEndEditing:(UITextField *)p0 reason:(NSInteger)p1;
	-(void) textFieldDidBeginEditing:(UITextField *)p0;
	-(BOOL) textFieldShouldBeginEditing:(UITextField *)p0;
	-(BOOL) textField:(UITextField *)p0 shouldChangeCharactersInRange:(NSRange)p1 replacementString:(NSString *)p2;
	-(BOOL) textFieldShouldClear:(UITextField *)p0;
	-(BOOL) textFieldShouldEndEditing:(UITextField *)p0;
	-(BOOL) textFieldShouldReturn:(UITextField *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UITextField__UITextFieldDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) textFieldDidEndEditing:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B62122);
	}

	-(void) textFieldDidEndEditing:(UITextField *)p0 reason:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1B62222);
	}

	-(void) textFieldDidBeginEditing:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B62322);
	}

	-(BOOL) textFieldShouldBeginEditing:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B62422);
	}

	-(BOOL) textField:(UITextField *)p0 shouldChangeCharactersInRange:(NSRange)p1 replacementString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, p1, p2, 0x1B62522);
	}

	-(BOOL) textFieldShouldClear:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B62622);
	}

	-(BOOL) textFieldShouldEndEditing:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B62722);
	}

	-(BOOL) textFieldShouldReturn:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B62822);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B62022);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UITextField_UITextFieldAppearance {
}
@end

@interface UIKit_UIScrollView__UIScrollViewDelegate : NSObject<UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) scrollViewDidEndDecelerating:(UIScrollView *)p0;
	-(void) scrollViewWillBeginDecelerating:(UIScrollView *)p0;
	-(void) scrollViewDidChangeAdjustedContentInset:(UIScrollView *)p0;
	-(void) scrollViewDidZoom:(UIScrollView *)p0;
	-(void) scrollViewDidEndDragging:(UIScrollView *)p0 willDecelerate:(BOOL)p1;
	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0;
	-(void) scrollViewDidEndScrollingAnimation:(UIScrollView *)p0;
	-(void) scrollViewDidScroll:(UIScrollView *)p0;
	-(void) scrollViewDidScrollToTop:(UIScrollView *)p0;
	-(BOOL) scrollViewShouldScrollToTop:(UIScrollView *)p0;
	-(UIView *) viewForZoomingInScrollView:(UIScrollView *)p0;
	-(void) scrollViewWillEndDragging:(UIScrollView *)p0 withVelocity:(CGPoint)p1 targetContentOffset:(CGPoint*)p2;
	-(void) scrollViewDidEndZooming:(UIScrollView *)p0 withView:(UIView *)p1 atScale:(CGFloat)p2;
	-(void) scrollViewWillBeginZooming:(UIScrollView *)p0 withView:(UIView *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIScrollView__UIScrollViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) scrollViewDidEndDecelerating:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78022);
	}

	-(void) scrollViewWillBeginDecelerating:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78122);
	}

	-(void) scrollViewDidChangeAdjustedContentInset:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78222);
	}

	-(void) scrollViewDidZoom:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78322);
	}

	-(void) scrollViewDidEndDragging:(UIScrollView *)p0 willDecelerate:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x1B78422);
	}

	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78522);
	}

	-(void) scrollViewDidEndScrollingAnimation:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78622);
	}

	-(void) scrollViewDidScroll:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78722);
	}

	-(void) scrollViewDidScrollToTop:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B78822);
	}

	-(BOOL) scrollViewShouldScrollToTop:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B78922);
	}

	-(UIView *) viewForZoomingInScrollView:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1B78A22);
	}

	-(void) scrollViewWillEndDragging:(UIScrollView *)p0 withVelocity:(CGPoint)p1 targetContentOffset:(CGPoint*)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_137 (self, _cmd, &managed_method, p0, p1, p2, 0x1B78B22);
	}

	-(void) scrollViewDidEndZooming:(UIScrollView *)p0 withView:(UIView *)p1 atScale:(CGFloat)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_138 (self, _cmd, &managed_method, p0, p1, p2, 0x1B78C22);
	}

	-(void) scrollViewWillBeginZooming:(UIScrollView *)p0 withView:(UIView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B78D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B77F22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UITextView__UITextViewDelegate : UIKit_UIScrollView__UIScrollViewDelegate<UITextViewDelegate, UIScrollViewDelegate> {
}
	-(void) textViewDidChange:(UITextView *)p0;
	-(void) textViewDidEndEditing:(UITextView *)p0;
	-(void) textViewDidBeginEditing:(UITextView *)p0;
	-(void) textViewDidChangeSelection:(UITextView *)p0;
	-(BOOL) textViewShouldBeginEditing:(UITextView *)p0;
	-(BOOL) textView:(UITextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementText:(NSString *)p2;
	-(BOOL) textViewShouldEndEditing:(UITextView *)p0;
	-(BOOL) textView:(UITextView *)p0 shouldInteractWithTextAttachment:(NSTextAttachment *)p1 inRange:(NSRange)p2;
	-(BOOL) textView:(UITextView *)p0 shouldInteractWithTextAttachment:(NSTextAttachment *)p1 inRange:(NSRange)p2 interaction:(NSInteger)p3;
	-(BOOL) textView:(UITextView *)p0 shouldInteractWithURL:(NSURL *)p1 inRange:(NSRange)p2;
	-(BOOL) textView:(UITextView *)p0 shouldInteractWithURL:(NSURL *)p1 inRange:(NSRange)p2 interaction:(NSInteger)p3;
	-(id) init;
@end

@implementation UIKit_UITextView__UITextViewDelegate {
}

	-(void) textViewDidChange:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B63322);
	}

	-(void) textViewDidEndEditing:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B63422);
	}

	-(void) textViewDidBeginEditing:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B63522);
	}

	-(void) textViewDidChangeSelection:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B63622);
	}

	-(BOOL) textViewShouldBeginEditing:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B63722);
	}

	-(BOOL) textView:(UITextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementText:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, p1, p2, 0x1B63822);
	}

	-(BOOL) textViewShouldEndEditing:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x1B63922);
	}

	-(BOOL) textView:(UITextView *)p0 shouldInteractWithTextAttachment:(NSTextAttachment *)p1 inRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_139 (self, _cmd, &managed_method, p0, p1, p2, 0x1B63A22);
	}

	-(BOOL) textView:(UITextView *)p0 shouldInteractWithTextAttachment:(NSTextAttachment *)p1 inRange:(NSRange)p2 interaction:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B63B22);
	}

	-(BOOL) textView:(UITextView *)p0 shouldInteractWithURL:(NSURL *)p1 inRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_139 (self, _cmd, &managed_method, p0, p1, p2, 0x1B63C22);
	}

	-(BOOL) textView:(UITextView *)p0 shouldInteractWithURL:(NSURL *)p1 inRange:(NSRange)p2 interaction:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B63D22);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B63222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIKit_UIScrollView__UIScrollViewDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UITextView_UITextViewAppearance {
}
@end

@implementation UIKit_UIToolbar_UIToolbarAppearance {
}

	-(NSInteger) barStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x1B64822);
	}

	-(void) setBarStyle:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x1B64922);
	}

	-(UIColor *) barTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B64A22);
	}

	-(void) setBarTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B64B22);
	}

	-(UIToolbarAppearance *) compactAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B64C22);
	}

	-(void) setCompactAppearance:(UIToolbarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B64D22);
	}

	-(UIToolbarAppearance *) compactScrollEdgeAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B64E22);
	}

	-(void) setCompactScrollEdgeAppearance:(UIToolbarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B64F22);
	}

	-(UIImage *) backgroundImageForToolbarPosition:(NSInteger)p0 barMetrics:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_116 (self, _cmd, &managed_method, p0, p1, 0x1B65022);
	}

	-(UIImage *) shadowImageForToolbarPosition:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, 0x1B65122);
	}

	-(UIToolbarAppearance *) scrollEdgeAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B65222);
	}

	-(void) setScrollEdgeAppearance:(UIToolbarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B65322);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forToolbarPosition:(NSInteger)p1 barMetrics:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_117 (self, _cmd, &managed_method, p0, p1, p2, 0x1B65422);
	}

	-(void) setShadowImage:(UIImage *)p0 forToolbarPosition:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1B65522);
	}

	-(UIToolbarAppearance *) standardAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B65622);
	}

	-(void) setStandardAppearance:(UIToolbarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B65722);
	}

	-(BOOL) isTranslucent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x1B65822);
	}

	-(void) setTranslucent:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x1B65922);
	}
@end

@interface UIKit_UIView__UIViewStaticCallback : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) start;
	-(void) end;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIView__UIViewStaticCallback {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) start
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1B66322);
	}

	-(void) end
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1B66422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B66222);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_NSTextStorage__NSTextStorageDelegate : NSObject<NSTextStorageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_NSTextStorage__NSTextStorageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_141 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B6F522);
	}

	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_141 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B6F622);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B6F422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface UIKit_UIAccelerometer__UIAccelerometerDelegate : NSObject<UIAccelerometerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) accelerometer:(UIAccelerometer *)p0 didAccelerate:(UIAcceleration *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIAccelerometer__UIAccelerometerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) accelerometer:(UIAccelerometer *)p0 didAccelerate:(UIAcceleration *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B6FC22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B6FB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIActivityIndicatorView_UIActivityIndicatorViewAppearance {
}

	-(UIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B6FE22);
	}

	-(void) setColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B6FF22);
	}
@end

@implementation UIKit_UICalendarView_UICalendarViewAppearance {
}
@end

@implementation UIKit_UICollectionReusableView_UICollectionReusableViewAppearance {
}
@end

@implementation UIKit_UICollectionViewCell_UICollectionViewCellAppearance {
}
@end

@implementation UIKit_UICollectionViewListCell_UICollectionViewListCellAppearance {
}
@end

@interface UIKit_UICollisionBehavior__UICollisionBehaviorDelegate : NSObject<UICollisionBehaviorDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) collisionBehavior:(UICollisionBehavior *)p0 beganContactForItem:(id)p1 withBoundaryIdentifier:(NSObject *)p2 atPoint:(CGPoint)p3;
	-(void) collisionBehavior:(UICollisionBehavior *)p0 beganContactForItem:(id)p1 withItem:(id)p2 atPoint:(CGPoint)p3;
	-(void) collisionBehavior:(UICollisionBehavior *)p0 endedContactForItem:(id)p1 withBoundaryIdentifier:(NSObject *)p2;
	-(void) collisionBehavior:(UICollisionBehavior *)p0 endedContactForItem:(id)p1 withItem:(id)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UICollisionBehavior__UICollisionBehaviorDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) collisionBehavior:(UICollisionBehavior *)p0 beganContactForItem:(id)p1 withBoundaryIdentifier:(NSObject *)p2 atPoint:(CGPoint)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_142 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B70922);
	}

	-(void) collisionBehavior:(UICollisionBehavior *)p0 beganContactForItem:(id)p1 withItem:(id)p2 atPoint:(CGPoint)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_143 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B70A22);
	}

	-(void) collisionBehavior:(UICollisionBehavior *)p0 endedContactForItem:(id)p1 withBoundaryIdentifier:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, p1, p2, 0x1B70B22);
	}

	-(void) collisionBehavior:(UICollisionBehavior *)p0 endedContactForItem:(id)p1 withItem:(id)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x1B70C22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B70822);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIColorWell_UIColorWellAppearance {
}
@end

@implementation UIKit_UIDatePicker_UIDatePickerAppearance {
}
@end

@interface UIKit_UIDocumentInteractionController__UIDocumentInteractionControllerDelegate : NSObject<UIDocumentInteractionControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) documentInteractionController:(UIDocumentInteractionController *)p0 canPerformAction:(SEL)p1;
	-(void) documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)p0;
	-(void) documentInteractionControllerDidDismissOptionsMenu:(UIDocumentInteractionController *)p0;
	-(void) documentInteractionControllerDidEndPreview:(UIDocumentInteractionController *)p0;
	-(void) documentInteractionController:(UIDocumentInteractionController *)p0 didEndSendingToApplication:(NSString *)p1;
	-(BOOL) documentInteractionController:(UIDocumentInteractionController *)p0 performAction:(SEL)p1;
	-(CGRect) documentInteractionControllerRectForPreview:(UIDocumentInteractionController *)p0;
	-(UIViewController *) documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)p0;
	-(UIView *) documentInteractionControllerViewForPreview:(UIDocumentInteractionController *)p0;
	-(void) documentInteractionControllerWillBeginPreview:(UIDocumentInteractionController *)p0;
	-(void) documentInteractionController:(UIDocumentInteractionController *)p0 willBeginSendingToApplication:(NSString *)p1;
	-(void) documentInteractionControllerWillPresentOpenInMenu:(UIDocumentInteractionController *)p0;
	-(void) documentInteractionControllerWillPresentOptionsMenu:(UIDocumentInteractionController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIDocumentInteractionController__UIDocumentInteractionControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) documentInteractionController:(UIDocumentInteractionController *)p0 canPerformAction:(SEL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x1B71E22);
	}

	-(void) documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B71F22);
	}

	-(void) documentInteractionControllerDidDismissOptionsMenu:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B72022);
	}

	-(void) documentInteractionControllerDidEndPreview:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B72122);
	}

	-(void) documentInteractionController:(UIDocumentInteractionController *)p0 didEndSendingToApplication:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1B72222);
	}

	-(BOOL) documentInteractionController:(UIDocumentInteractionController *)p0 performAction:(SEL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x1B72322);
	}

	-(CGRect) documentInteractionControllerRectForPreview:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x1B72422);
	}

	-(UIViewController *) documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1B72522);
	}

	-(UIView *) documentInteractionControllerViewForPreview:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1B72622);
	}

	-(void) documentInteractionControllerWillBeginPreview:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B72722);
	}

	-(void) documentInteractionController:(UIDocumentInteractionController *)p0 willBeginSendingToApplication:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1B72822);
	}

	-(void) documentInteractionControllerWillPresentOpenInMenu:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B72922);
	}

	-(void) documentInteractionControllerWillPresentOptionsMenu:(UIDocumentInteractionController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B72A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B71D22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIEventAttributionView_UIEventAttributionViewAppearance {
}
@end

@implementation UIKit_UIImageView_UIImageViewAppearance {
}
@end

@implementation UIKit_UIInputView_UIInputViewAppearance {
}
@end

@implementation UIKit_UILabel_UILabelAppearance {
}

	-(UIFont *) font
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B73722);
	}

	-(void) setFont:(UIFont *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B73822);
	}

	-(UIColor *) highlightedTextColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B73922);
	}

	-(void) setHighlightedTextColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B73A22);
	}

	-(UIColor *) shadowColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B73B22);
	}

	-(void) setShadowColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B73C22);
	}

	-(CGSize) shadowOffset
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, 0x1B73D22);
	}

	-(void) setShadowOffset:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_149 (self, _cmd, &managed_method, p0, 0x1B73E22);
	}

	-(UIColor *) textColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B73F22);
	}

	-(void) setTextColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B74022);
	}
@end

@implementation UIKit_UIListContentView_UIListContentViewAppearance {
}
@end

@implementation UIKit_UIPageControl_UIPageControlAppearance {
}

	-(UIColor *) currentPageIndicatorTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B74F22);
	}

	-(void) setCurrentPageIndicatorTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B75022);
	}

	-(UIColor *) pageIndicatorTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B75122);
	}

	-(void) setPageIndicatorTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B75222);
	}
@end

@implementation UIKit_UIPasteControl_UIPasteControlAppearance {
}
@end

@implementation UIKit_UIPopoverBackgroundView_UIPopoverBackgroundViewAppearance {
}
@end

@implementation UIKit_UIProgressView_UIProgressViewAppearance {
}

	-(UIImage *) progressImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B76622);
	}

	-(void) setProgressImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B76722);
	}

	-(UIColor *) progressTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B76822);
	}

	-(void) setProgressTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B76922);
	}

	-(UIImage *) trackImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B76A22);
	}

	-(void) setTrackImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B76B22);
	}

	-(UIColor *) trackTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B76C22);
	}

	-(void) setTrackTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B76D22);
	}
@end

@implementation UIKit_UIRefreshControl_UIRefreshControlAppearance {
}

	-(NSAttributedString *) attributedTitle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B76F22);
	}

	-(void) setAttributedTitle:(NSAttributedString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B77022);
	}
@end

@implementation UIKit_UISearchTextField_UISearchTextFieldAppearance {
}
@end

@implementation UIKit_UISlider_UISliderAppearance {
}

	-(UIImage *) maximumTrackImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B79122);
	}

	-(UIImage *) maximumValueImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B79222);
	}

	-(void) setMaximumValueImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B79322);
	}

	-(UIColor *) maximumTrackTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B79422);
	}

	-(void) setMaximumTrackTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B79522);
	}

	-(UIImage *) minimumTrackImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B79622);
	}

	-(UIImage *) minimumValueImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B79722);
	}

	-(void) setMinimumValueImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B79822);
	}

	-(UIColor *) minimumTrackTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B79922);
	}

	-(void) setMinimumTrackTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B79A22);
	}

	-(void) setMaximumTrackImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B79B22);
	}

	-(void) setMinimumTrackImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B79C22);
	}

	-(void) setThumbImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B79D22);
	}

	-(UIImage *) thumbImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B79E22);
	}

	-(UIColor *) thumbTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B79F22);
	}

	-(void) setThumbTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7A022);
	}
@end

@interface UIKit_UISplitViewController__UISplitViewControllerDelegate : NSObject<UISplitViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) splitViewController:(UISplitViewController *)p0 collapseSecondaryViewController:(UIViewController *)p1 ontoPrimaryViewController:(UIViewController *)p2;
	-(void) splitViewControllerDidCollapse:(UISplitViewController *)p0;
	-(void) splitViewControllerDidExpand:(UISplitViewController *)p0;
	-(BOOL) splitViewController:(UISplitViewController *)p0 showDetailViewController:(UIViewController *)p1 sender:(NSObject *)p2;
	-(BOOL) splitViewController:(UISplitViewController *)p0 showViewController:(UIViewController *)p1 sender:(NSObject *)p2;
	-(NSInteger) splitViewController:(UISplitViewController *)p0 displayModeForExpandingToProposedDisplayMode:(NSInteger)p1;
	-(NSInteger) splitViewControllerPreferredInterfaceOrientationForPresentation:(UISplitViewController *)p0;
	-(UIViewController *) primaryViewControllerForCollapsingSplitViewController:(UISplitViewController *)p0;
	-(UIViewController *) primaryViewControllerForExpandingSplitViewController:(UISplitViewController *)p0;
	-(NSInteger) targetDisplayModeForActionInSplitViewController:(UISplitViewController *)p0;
	-(NSInteger) splitViewController:(UISplitViewController *)p0 topColumnForCollapsingToProposedTopColumn:(NSInteger)p1;
	-(void) splitViewControllerInteractivePresentationGestureDidEnd:(UISplitViewController *)p0;
	-(void) splitViewControllerInteractivePresentationGestureWillBegin:(UISplitViewController *)p0;
	-(UIViewController *) splitViewController:(UISplitViewController *)p0 separateSecondaryViewControllerFromPrimaryViewController:(UIViewController *)p1;
	-(BOOL) splitViewController:(UISplitViewController *)p0 shouldHideViewController:(UIViewController *)p1 inOrientation:(NSInteger)p2;
	-(NSUInteger) splitViewControllerSupportedInterfaceOrientations:(UISplitViewController *)p0;
	-(void) splitViewController:(UISplitViewController *)p0 willChangeToDisplayMode:(NSInteger)p1;
	-(void) splitViewController:(UISplitViewController *)p0 willHideColumn:(NSInteger)p1;
	-(void) splitViewController:(UISplitViewController *)p0 willHideViewController:(UIViewController *)p1 withBarButtonItem:(UIBarButtonItem *)p2 forPopoverController:(UIPopoverController *)p3;
	-(void) splitViewController:(UISplitViewController *)p0 popoverController:(UIPopoverController *)p1 willPresentViewController:(UIViewController *)p2;
	-(void) splitViewController:(UISplitViewController *)p0 willShowColumn:(NSInteger)p1;
	-(void) splitViewController:(UISplitViewController *)p0 willShowViewController:(UIViewController *)p1 invalidatingBarButtonItem:(UIBarButtonItem *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UISplitViewController__UISplitViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) splitViewController:(UISplitViewController *)p0 collapseSecondaryViewController:(UIViewController *)p1 ontoPrimaryViewController:(UIViewController *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7A222);
	}

	-(void) splitViewControllerDidCollapse:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7A322);
	}

	-(void) splitViewControllerDidExpand:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7A422);
	}

	-(BOOL) splitViewController:(UISplitViewController *)p0 showDetailViewController:(UIViewController *)p1 sender:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7A522);
	}

	-(BOOL) splitViewController:(UISplitViewController *)p0 showViewController:(UIViewController *)p1 sender:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7A622);
	}

	-(NSInteger) splitViewController:(UISplitViewController *)p0 displayModeForExpandingToProposedDisplayMode:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_120 (self, _cmd, &managed_method, p0, p1, 0x1B7A722);
	}

	-(NSInteger) splitViewControllerPreferredInterfaceOrientationForPresentation:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x1B7A822);
	}

	-(UIViewController *) primaryViewControllerForCollapsingSplitViewController:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1B7A922);
	}

	-(UIViewController *) primaryViewControllerForExpandingSplitViewController:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1B7AA22);
	}

	-(NSInteger) targetDisplayModeForActionInSplitViewController:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x1B7AB22);
	}

	-(NSInteger) splitViewController:(UISplitViewController *)p0 topColumnForCollapsingToProposedTopColumn:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_120 (self, _cmd, &managed_method, p0, p1, 0x1B7AC22);
	}

	-(void) splitViewControllerInteractivePresentationGestureDidEnd:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7AD22);
	}

	-(void) splitViewControllerInteractivePresentationGestureWillBegin:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7AE22);
	}

	-(UIViewController *) splitViewController:(UISplitViewController *)p0 separateSecondaryViewControllerFromPrimaryViewController:(UIViewController *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x1B7AF22);
	}

	-(BOOL) splitViewController:(UISplitViewController *)p0 shouldHideViewController:(UIViewController *)p1 inOrientation:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_151 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7B022);
	}

	-(NSUInteger) splitViewControllerSupportedInterfaceOrientations:(UISplitViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_121 (self, _cmd, &managed_method, p0, 0x1B7B122);
	}

	-(void) splitViewController:(UISplitViewController *)p0 willChangeToDisplayMode:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1B7B222);
	}

	-(void) splitViewController:(UISplitViewController *)p0 willHideColumn:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1B7B322);
	}

	-(void) splitViewController:(UISplitViewController *)p0 willHideViewController:(UIViewController *)p1 withBarButtonItem:(UIBarButtonItem *)p2 forPopoverController:(UIPopoverController *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_95 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B7B422);
	}

	-(void) splitViewController:(UISplitViewController *)p0 popoverController:(UIPopoverController *)p1 willPresentViewController:(UIViewController *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7B522);
	}

	-(void) splitViewController:(UISplitViewController *)p0 willShowColumn:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x1B7B622);
	}

	-(void) splitViewController:(UISplitViewController *)p0 willShowViewController:(UIViewController *)p1 invalidatingBarButtonItem:(UIBarButtonItem *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7B722);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B7A122);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIStackView_UIStackViewAppearance {
}
@end

@implementation UIKit_UIStepper_UIStepperAppearance {
}

	-(UIImage *) backgroundImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B7BA22);
	}

	-(UIImage *) decrementImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B7BB22);
	}

	-(UIImage *) dividerImageForLeftSegmentState:(NSUInteger)p0 rightSegmentState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, 0x1B7BC22);
	}

	-(UIImage *) incrementImageForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B7BD22);
	}

	-(void) setBackgroundImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B7BE22);
	}

	-(void) setDecrementImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B7BF22);
	}

	-(void) setDividerImage:(UIImage *)p0 forLeftSegmentState:(NSUInteger)p1 rightSegmentState:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7C022);
	}

	-(void) setIncrementImage:(UIImage *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B7C122);
	}
@end

@implementation UIKit_UISwitch_UISwitchAppearance {
}

	-(UIImage *) offImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7C322);
	}

	-(void) setOffImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7C422);
	}

	-(UIImage *) onImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7C522);
	}

	-(void) setOnImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7C622);
	}

	-(UIColor *) onTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7C722);
	}

	-(void) setOnTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7C822);
	}

	-(UIColor *) thumbTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7C922);
	}

	-(void) setThumbTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7CA22);
	}
@end

@interface UIKit_UITabBar__UITabBarDelegate : NSObject<UITabBarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) tabBar:(UITabBar *)p0 didBeginCustomizingItems:(NSArray *)p1;
	-(void) tabBar:(UITabBar *)p0 didEndCustomizingItems:(NSArray *)p1 changed:(BOOL)p2;
	-(void) tabBar:(UITabBar *)p0 didSelectItem:(UITabBarItem *)p1;
	-(void) tabBar:(UITabBar *)p0 willBeginCustomizingItems:(NSArray *)p1;
	-(void) tabBar:(UITabBar *)p0 willEndCustomizingItems:(NSArray *)p1 changed:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UITabBar__UITabBarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) tabBar:(UITabBar *)p0 didBeginCustomizingItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1B7CC22);
	}

	-(void) tabBar:(UITabBar *)p0 didEndCustomizingItems:(NSArray *)p1 changed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7CD22);
	}

	-(void) tabBar:(UITabBar *)p0 didSelectItem:(UITabBarItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B7CE22);
	}

	-(void) tabBar:(UITabBar *)p0 willBeginCustomizingItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1B7CF22);
	}

	-(void) tabBar:(UITabBar *)p0 willEndCustomizingItems:(NSArray *)p1 changed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7D022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B7CB22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UITabBar_UITabBarAppearance {
}

	-(UIImage *) backgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7D222);
	}

	-(void) setBackgroundImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7D322);
	}

	-(NSInteger) barStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x1B7D422);
	}

	-(void) setBarStyle:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x1B7D522);
	}

	-(UIColor *) barTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7D622);
	}

	-(void) setBarTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7D722);
	}

	-(NSInteger) itemPositioning
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x1B7D822);
	}

	-(void) setItemPositioning:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x1B7D922);
	}

	-(CGFloat) itemSpacing
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x1B7DA22);
	}

	-(void) setItemSpacing:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x1B7DB22);
	}

	-(CGFloat) itemWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x1B7DC22);
	}

	-(void) setItemWidth:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x1B7DD22);
	}

	-(UITabBarAppearance *) scrollEdgeAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7DE22);
	}

	-(void) setScrollEdgeAppearance:(UITabBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B7DF22);
	}

	-(UIColor *) selectedImageTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7E022);
	}

	-(void) setSelectedImageTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7E122);
	}

	-(UIImage *) selectionIndicatorImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7E222);
	}

	-(void) setSelectionIndicatorImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7E322);
	}

	-(UIImage *) shadowImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7E422);
	}

	-(void) setShadowImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B7E522);
	}

	-(UITabBarAppearance *) standardAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7E622);
	}

	-(void) setStandardAppearance:(UITabBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B7E722);
	}

	-(UIColor *) unselectedItemTintColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7E822);
	}

	-(void) setUnselectedItemTintColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B7E922);
	}
@end

@interface UIKit_UITabBarController__UITabBarControllerDelegate : NSObject<UITabBarControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) tabBarController:(UITabBarController *)p0 didEndCustomizingViewControllers:(NSArray *)p1 changed:(BOOL)p2;
	-(id) tabBarController:(UITabBarController *)p0 animationControllerForTransitionFromViewController:(UIViewController *)p1 toViewController:(UIViewController *)p2;
	-(id) tabBarController:(UITabBarController *)p0 interactionControllerForAnimationController:(id)p1;
	-(NSInteger) tabBarControllerPreferredInterfaceOrientationForPresentation:(UITabBarController *)p0;
	-(void) tabBarController:(UITabBarController *)p0 willBeginCustomizingViewControllers:(NSArray *)p1;
	-(void) tabBarController:(UITabBarController *)p0 willEndCustomizingViewControllers:(NSArray *)p1 changed:(BOOL)p2;
	-(BOOL) tabBarController:(UITabBarController *)p0 shouldSelectViewController:(UIViewController *)p1;
	-(NSUInteger) tabBarControllerSupportedInterfaceOrientations:(UITabBarController *)p0;
	-(void) tabBarController:(UITabBarController *)p0 didSelectViewController:(UIViewController *)p1;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UITabBarController__UITabBarControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) tabBarController:(UITabBarController *)p0 didEndCustomizingViewControllers:(NSArray *)p1 changed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7EB22);
	}

	-(id) tabBarController:(UITabBarController *)p0 animationControllerForTransitionFromViewController:(UIViewController *)p1 toViewController:(UIViewController *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_155 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7EC22);
	}

	-(id) tabBarController:(UITabBarController *)p0 interactionControllerForAnimationController:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_156 (self, _cmd, &managed_method, p0, p1, 0x1B7ED22);
	}

	-(NSInteger) tabBarControllerPreferredInterfaceOrientationForPresentation:(UITabBarController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x1B7EE22);
	}

	-(void) tabBarController:(UITabBarController *)p0 willBeginCustomizingViewControllers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1B7EF22);
	}

	-(void) tabBarController:(UITabBarController *)p0 willEndCustomizingViewControllers:(NSArray *)p1 changed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x1B7F022);
	}

	-(BOOL) tabBarController:(UITabBarController *)p0 shouldSelectViewController:(UIViewController *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x1B7F122);
	}

	-(NSUInteger) tabBarControllerSupportedInterfaceOrientations:(UITabBarController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_121 (self, _cmd, &managed_method, p0, 0x1B7F222);
	}

	-(void) tabBarController:(UITabBarController *)p0 didSelectViewController:(UIViewController *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B7F322);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1B7F422);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B7EA22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UITabBarItem_UITabBarItemAppearance {
}

	-(UIColor *) badgeColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7F622);
	}

	-(void) setBadgeColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B7F722);
	}

	-(NSDictionary <NSString *, NSObject *>*) badgeTextAttributesForState:(NSUInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, 0x1B7F822);
	}

	-(UITabBarAppearance *) scrollEdgeAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7F922);
	}

	-(void) setScrollEdgeAppearance:(UITabBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B7FA22);
	}

	-(void) setBadgeTextAttributes:(NSDictionary *)p0 forState:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x1B7FB22);
	}

	-(UITabBarAppearance *) standardAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x1B7FC22);
	}

	-(void) setStandardAppearance:(UITabBarAppearance *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, 0x1B7FD22);
	}

	-(UIOffset) titlePositionAdjustment
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_128 (self, _cmd, &managed_method, 0x1B7FE22);
	}

	-(void) setTitlePositionAdjustment:(UIOffset)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, 0x1B7FF22);
	}
@end

@implementation UIKit_UITableViewHeaderFooterView_UITableViewHeaderFooterViewAppearance {
}
@end

@interface UIKit_UIVideoEditorController__UIVideoEditorControllerDelegate : NSObject<UIVideoEditorControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) videoEditorController:(UIVideoEditorController *)p0 didFailWithError:(NSError *)p1;
	-(void) videoEditorControllerDidCancel:(UIVideoEditorController *)p0;
	-(void) videoEditorController:(UIVideoEditorController *)p0 didSaveEditedVideoToPath:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIVideoEditorController__UIVideoEditorControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) videoEditorController:(UIVideoEditorController *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B80822);
	}

	-(void) videoEditorControllerDidCancel:(UIVideoEditorController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B80922);
	}

	-(void) videoEditorController:(UIVideoEditorController *)p0 didSaveEditedVideoToPath:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x1B80A22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B80722);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIVisualEffectView_UIVisualEffectViewAppearance {
}
@end

@interface UIKit_UIWebView__UIWebViewDelegate : NSObject<UIWebViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) webView:(UIWebView *)p0 didFailLoadWithError:(NSError *)p1;
	-(void) webViewDidStartLoad:(UIWebView *)p0;
	-(void) webViewDidFinishLoad:(UIWebView *)p0;
	-(BOOL) webView:(UIWebView *)p0 shouldStartLoadWithRequest:(NSURLRequest *)p1 navigationType:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation UIKit_UIWebView__UIWebViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) webView:(UIWebView *)p0 didFailLoadWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1B80D22);
	}

	-(void) webViewDidStartLoad:(UIWebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B80E22);
	}

	-(void) webViewDidFinishLoad:(UIWebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1B80F22);
	}

	-(BOOL) webView:(UIWebView *)p0 shouldStartLoadWithRequest:(NSURLRequest *)p1 navigationType:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_151 (self, _cmd, &managed_method, p0, p1, p2, 0x1B81022);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1B80C22);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation UIKit_UIWebView_UIWebViewAppearance {
}
@end

@implementation AddressBookUI_ABPeoplePickerNavigationController_ABPeoplePickerNavigationControllerAppearance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation AVKit_AVRoutePickerView_AVRoutePickerViewAppearance {
}
@end

@interface AVFoundation_AVCaptureFileOutput_recordingProxy : NSObject<AVCaptureFileOutputRecordingDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation AVFoundation_AVCaptureFileOutput_recordingProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_157 (self, _cmd, &managed_method, p0, p1, p2, 0x1B86D22);
	}

	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1B86E22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation AVFoundation_AVPlayerInterstitialEventObserver {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate : NSObject<AVSpeechSynthesizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didCancelSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didContinueSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didFinishSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didPauseSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didStartSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 willSpeakRangeOfSpeechString:(NSRange)p1 utterance:(AVSpeechUtterance *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didCancelSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1BAA522);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didContinueSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1BAA622);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didFinishSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1BAA722);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didPauseSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1BAA822);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didStartSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1BAA922);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 willSpeakRangeOfSpeechString:(NSRange)p1 utterance:(AVSpeechUtterance *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_159 (self, _cmd, &managed_method, p0, p1, p2, 0x1BAAA22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1BAA422);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation ARKit_ARCoachingOverlayView_ARCoachingOverlayViewAppearance {
}
@end

@implementation ARKit_ARSCNView_ARSCNViewAppearance {
}
@end

@implementation ARKit_ARSKView_ARSKViewAppearance {
}
@end

@interface System_Net_Http_NSUrlSessionHandler_NSUrlSessionHandlerDelegate : NSObject<NSURLSessionDataDelegate, NSURLSessionTaskDelegate, NSURLSessionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(void (^)(void *))p3;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(void (^)(void *))p3;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(void (^)(void *))p4;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(void (^)(void *, void *))p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation System_Net_Http_NSUrlSessionHandler_NSUrlSessionHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(void (^)(void *))p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_160 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1A55722);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A55822);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x1A55922);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(void (^)(void *))p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_161 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1A55B22);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(void (^)(void *))p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_162 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x1A55C22);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(void (^)(void *, void *))p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_163 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1A55D22);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_iOS7ButtonContainer : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_iOS7ButtonContainer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x5B2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_GlobalCloseContextGestureRecognizer : UIGestureRecognizer {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_GlobalCloseContextGestureRecognizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x6F2E);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x702E);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x712E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_PlatformRenderer : UIViewController {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSUInteger) supportedInterfaceOrientations;
	-(NSInteger) preferredInterfaceOrientationForPresentation;
	-(UIViewController *) childViewControllerForStatusBarHidden;
	-(UIViewController *) childViewControllerForStatusBarStyle;
	-(UIViewController *) childViewControllerForHomeIndicatorAutoHidden;
	-(BOOL) shouldAutorotate;
	-(BOOL) shouldAutorotateToInterfaceOrientation:(NSInteger)p0;
	-(BOOL) shouldAutomaticallyForwardRotationMethods;
	-(void) viewDidAppear:(BOOL)p0;
	-(void) viewDidLayoutSubviews;
	-(void) viewWillAppear:(BOOL)p0;
	-(void) viewDidLoad;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_PlatformRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSUInteger) supportedInterfaceOrientations
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_15 (self, _cmd, &managed_method, 0xDF2E);
	}

	-(NSInteger) preferredInterfaceOrientationForPresentation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0xE02E);
	}

	-(UIViewController *) childViewControllerForStatusBarHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE12E);
	}

	-(UIViewController *) childViewControllerForStatusBarStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE22E);
	}

	-(UIViewController *) childViewControllerForHomeIndicatorAutoHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0xE32E);
	}

	-(BOOL) shouldAutorotate
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xE42E);
	}

	-(BOOL) shouldAutorotateToInterfaceOrientation:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, 0xE52E);
	}

	-(BOOL) shouldAutomaticallyForwardRotationMethods
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xE62E);
	}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xE72E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xE82E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xE92E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xEA2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_VisualElementRenderer_1 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIColor *) backgroundColor
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_165 (self, _cmd, &managed_method, 0x1392E);
	}

	-(void) setBackgroundColor:(UIColor *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x13A2E);
	}

	-(BOOL) canBecomeFirstResponder
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_166 (self, _cmd, &managed_method, 0x1422E);
	}

	-(NSArray *) keyCommands
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_167 (self, _cmd, &managed_method, 0x1562E);
	}

	-(void) tabForward:(UIKeyCommand *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x1572E);
	}

	-(void) tabBackward:(UIKeyCommand *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x1582E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_168 (self, _cmd, &managed_method, p0, 0x15B2E);
	}

	-(void) layoutSubviews
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, 0x15C2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.VisualElementRenderer`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ViewRenderer_2 {
}

	-(void) layoutSubviews
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, 0x10F2E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_168 (self, _cmd, &managed_method, p0, 0x1102E);
	}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x11D2E);
	}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.ViewRenderer`2' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFC2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CellTableViewCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ActivityIndicatorRenderer {
}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x1EE2E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1EF2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1E82E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_BoxRenderer {
}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x1F12E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1F22E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1F02E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_VisualElementRenderer_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ButtonRenderer {
}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x1FC2E);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x1FE2E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1FF2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1FB2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_NoCaretField : UITextField {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGRect) caretRectForPosition:(UITextPosition *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_NoCaretField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGRect) caretRectForPosition:(UITextPosition *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x2362E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2352E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UITextField class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_DatePickerRendererBase_1 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.DatePickerRendererBase`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_DatePickerRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2372E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_DatePickerRendererBase_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EditorRendererBase_1 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.EditorRendererBase`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EditorRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x24B2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_EditorRendererBase_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EntryRendererBase_1 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.EntryRendererBase`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EntryRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2702E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_EntryRendererBase_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_HeaderWrapperView : UITableViewHeaderFooterView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_HeaderWrapperView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x3222E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_FormsRefreshControl {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) isHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x3342E);
	}

	-(void) setHidden:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x3352E);
	}

	-(void) beginRefreshing
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x3362E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ReadOnlyField : Xamarin_Forms_Platform_iOS_NoCaretField {
}
	-(BOOL) canPerformAction:(SEL)p0 withSender:(NSObject *)p1;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ReadOnlyField {
}

	-(BOOL) canPerformAction:(SEL)p0 withSender:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_171 (self, _cmd, &managed_method, p0, p1, 0x3B32E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3B22E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_NoCaretField class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PickerRendererBase_1 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.PickerRendererBase`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PickerRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3B42E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_PickerRendererBase_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ProgressBarRenderer {
}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x3CC2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3CB2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ScrollViewRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x3DD2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3D22E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIScrollView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_SearchBarRenderer {
}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x3FA2E);
	}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x3FB2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3F42E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_SliderRenderer {
}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x4112E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4102E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_StepperRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4232E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_SwitchRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x42C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TableViewModelRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x4662E);
	}

	-(CGFloat) tableView:(UITableView *)p0 heightForHeaderInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, p1, 0x4672E);
	}

	-(UIView *) tableView:(UITableView *)p0 viewForHeaderInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, 0x4682E);
	}

	-(void) tableView:(UITableView *)p0 willDisplayHeaderView:(UIView *)p1 forSection:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, p1, p2, 0x4692E);
	}

	-(NSInteger) numberOfSectionsInTableView:(UITableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x46B2E);
	}

	-(void) tableView:(UITableView *)p0 didSelectRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x46C2E);
	}

	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x46D2E);
	}

	-(NSArray *) sectionIndexTitlesForTableView:(UITableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, 0x46E2E);
	}

	-(NSString *) tableView:(UITableView *)p0 titleForHeaderInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x46F2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_UnEvenTableViewModelRenderer {
}

	-(CGFloat) tableView:(UITableView *)p0 heightForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0x4742E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TableViewRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x4772E);
	}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x47C2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4752E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TimePickerRendererBase_1 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.TimePickerRendererBase`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TimePickerRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4842E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_TimePickerRendererBase_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ItemsViewDelegator_2 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) scrollViewDidScroll:(UIScrollView *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x5892E);
	}

	-(UIEdgeInsets) collectionView:(UICollectionView *)p0 layout:(UICollectionViewLayout *)p1 insetForSectionAtIndex:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_178 (self, _cmd, &managed_method, p0, p1, p2, 0x58A2E);
	}

	-(CGFloat) collectionView:(UICollectionView *)p0 layout:(UICollectionViewLayout *)p1 minimumInteritemSpacingForSectionAtIndex:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, p2, 0x58B2E);
	}

	-(CGFloat) collectionView:(UICollectionView *)p0 layout:(UICollectionViewLayout *)p1 minimumLineSpacingForSectionAtIndex:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, p2, 0x58C2E);
	}

	-(void) collectionView:(UICollectionView *)p0 didEndDisplayingCell:(UICollectionViewCell *)p1 forItemAtIndexPath:(NSIndexPath *)p2
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_180 (self, _cmd, &managed_method, p0, p1, p2, 0x58D2E);
	}

	-(CGSize) collectionView:(UICollectionView *)p0 layout:(UICollectionViewLayout *)p1 sizeForItemAtIndexPath:(NSIndexPath *)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_181 (self, _cmd, &managed_method, p0, p1, p2, 0x5922E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CarouselViewDelegator {
}

	-(void) scrollViewDidScroll:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x4A02E);
	}

	-(void) scrollViewDidEndScrollingAnimation:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x4A12E);
	}

	-(void) scrollViewDidEndDecelerating:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x4A22E);
	}

	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x4A32E);
	}

	-(void) scrollViewDidEndDragging:(UIScrollView *)p0 willDecelerate:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x4A42E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ItemsViewRenderer_2 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.ItemsViewRenderer`2' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CarouselViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4A72E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ItemsViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_StructuredItemsViewRenderer_2 {
}

	-(void) layoutSubviews
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, 0x5AA2E);
	}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.StructuredItemsViewRenderer`2' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_SelectableItemsViewRenderer_2 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.SelectableItemsViewRenderer`2' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_GroupableItemsViewRenderer_2 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.GroupableItemsViewRenderer`2' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CollectionViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4B02E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_GroupableItemsViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ItemsViewController_1 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UICollectionViewCell *) collectionView:(UICollectionView *)p0 cellForItemAtIndexPath:(NSIndexPath *)p1
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_182 (self, _cmd, &managed_method, p0, p1, 0x5262E);
	}

	-(NSInteger) collectionView:(UICollectionView *)p0 numberOfItemsInSection:(NSInteger)p1
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_183 (self, _cmd, &managed_method, p0, p1, 0x5272E);
	}

	-(void) viewDidLoad
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, 0x52A2E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_184 (self, _cmd, &managed_method, p0, 0x52B2E);
	}

	-(void) viewWillLayoutSubviews
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, 0x52C2E);
	}

	-(NSInteger) numberOfSectionsInCollectionView:(UICollectionView *)p0
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_185 (self, _cmd, &managed_method, p0, 0x5332E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_StructuredItemsViewController_1 {
}

	-(void) viewWillLayoutSubviews
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, 0x59C2E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_SelectableItemsViewController_1 {
}

	-(void) collectionView:(UICollectionView *)p0 didSelectItemAtIndexPath:(NSIndexPath *)p1
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, 0x5702E);
	}

	-(void) collectionView:(UICollectionView *)p0 didDeselectItemAtIndexPath:(NSIndexPath *)p1
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, 0x5712E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_GroupableItemsViewController_1 {
}

	-(UICollectionReusableView *) collectionView:(UICollectionView *)p0 viewForSupplementaryElementOfKind:(NSString *)p1 atIndexPath:(NSIndexPath *)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_187 (self, _cmd, &managed_method, p0, p1, p2, 0x4C22E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_SelectableItemsViewDelegator_2 {
}

	-(void) collectionView:(UICollectionView *)p0 didSelectItemAtIndexPath:(NSIndexPath *)p1
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, 0x57B2E);
	}

	-(void) collectionView:(UICollectionView *)p0 didDeselectItemAtIndexPath:(NSIndexPath *)p1
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, 0x57C2E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_GroupableItemsViewDelegator_2 {
}

	-(CGSize) collectionView:(UICollectionView *)p0 layout:(UICollectionViewLayout *)p1 referenceSizeForHeaderInSection:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_188 (self, _cmd, &managed_method, p0, p1, p2, 0x4D22E);
	}

	-(CGSize) collectionView:(UICollectionView *)p0 layout:(UICollectionViewLayout *)p1 referenceSizeForFooterInSection:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_188 (self, _cmd, &managed_method, p0, p1, p2, 0x4D32E);
	}

	-(void) scrollViewDidEndScrollingAnimation:(UIScrollView *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x4D42E);
	}

	-(UIEdgeInsets) collectionView:(UICollectionView *)p0 layout:(UICollectionViewLayout *)p1 insetForSectionAtIndex:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_178 (self, _cmd, &managed_method, p0, p1, p2, 0x4D52E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ItemsViewCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x4F62E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UICollectionViewCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TemplatedCell {
}

	-(UICollectionViewLayoutAttributes *) preferredLayoutAttributesFittingAttributes:(UICollectionViewLayoutAttributes *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x62E2E);
	}

	-(BOOL) isSelected
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x6372E);
	}

	-(void) setSelected:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x6382E);
	}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x6282E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ItemsViewCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell : Xamarin_Forms_Platform_iOS_TemplatedCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x6402E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_TemplatedCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_HorizontalCell : Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_HorizontalCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x4DC2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_DefaultCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x5162E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ItemsViewCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_HorizontalDefaultSupplementalView : Xamarin_Forms_Platform_iOS_DefaultCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_HorizontalDefaultSupplementalView {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x4E02E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_DefaultCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_HorizontalSupplementaryView : Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_HorizontalSupplementaryView {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x4E42E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_HorizontalDefaultCell : Xamarin_Forms_Platform_iOS_DefaultCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_HorizontalDefaultCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x5182E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_DefaultCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell : Xamarin_Forms_Platform_iOS_TemplatedCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x6472E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_TemplatedCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_VerticalCell : Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_VerticalCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x5932E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_VerticalDefaultCell : Xamarin_Forms_Platform_iOS_DefaultCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_VerticalDefaultCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x5AB2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_DefaultCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ItemsViewLayout {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) flipsHorizontallyInOppositeLayoutDirection
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x5C32E);
	}

	-(BOOL) shouldInvalidateLayoutForPreferredLayoutAttributes:(UICollectionViewLayoutAttributes *)p0 withOriginalAttributes:(UICollectionViewLayoutAttributes *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x5CE2E);
	}

	-(CGPoint) targetContentOffsetForProposedContentOffset:(CGPoint)p0 withScrollingVelocity:(CGPoint)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_190 (self, _cmd, &managed_method, p0, p1, 0x5D32E);
	}

	-(UICollectionViewLayoutInvalidationContext *) invalidationContextForPreferredLayoutAttributes:(UICollectionViewLayoutAttributes *)p0 withOriginalAttributes:(UICollectionViewLayoutAttributes *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x5D62E);
	}

	-(void) prepareLayout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x5D72E);
	}

	-(void) prepareForCollectionViewUpdates:(NSArray *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x5D82E);
	}

	-(CGPoint) targetContentOffsetForProposedContentOffset:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x5D92E);
	}

	-(void) finalizeCollectionViewUpdates
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x5DA2E);
	}

	-(BOOL) shouldInvalidateLayoutForBoundsChange:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_192 (self, _cmd, &managed_method, p0, 0x5DF2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_GridViewLayout {
}

	-(CGSize) collectionViewContentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, 0x5B22E);
	}

	-(NSArray *) layoutAttributesForElementsInRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, 0x5B32E);
	}

	-(UICollectionViewLayoutInvalidationContext *) invalidationContextForPreferredLayoutAttributes:(UICollectionViewLayoutAttributes *)p0 withOriginalAttributes:(UICollectionViewLayoutAttributes *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x5B42E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ListViewLayout {
}
@end

@interface Xamarin_Forms_Platform_iOS_VerticalDefaultSupplementalView : Xamarin_Forms_Platform_iOS_DefaultCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_VerticalDefaultSupplementalView {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x6432E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_DefaultCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_VerticalSupplementaryView : Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell {
}
	-(id) initWithFrame:(CGRect)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_VerticalSupplementaryView {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x64A2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_FormsCAKeyFrameAnimation {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x6882E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CAKeyframeAnimation class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_FormsCheckBox {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) isEnabled
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x6952E);
	}

	-(void) setEnabled:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x6962E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x68B2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_FormsUIImageView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIImage *) image
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x6A22E);
	}

	-(void) setImage:(UIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x6A32E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x6A42E);
	}

	-(BOOL) isAnimating
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x6A82E);
	}

	-(void) startAnimating
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x6A92E);
	}

	-(void) stopAnimating
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x6AA2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x6A12E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIImageView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_NativeViewWrapperRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x6D12E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x6D22E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x6CF2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_PageContainer : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) isAccessibilityElement;
	-(void) setIsAccessibilityElement:(BOOL)p0;
	-(NSArray *) accessibilityElements;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_PageContainer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) isAccessibilityElement
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x6E02E);
	}

	-(void) setIsAccessibilityElement:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x6E12E);
	}

	-(NSArray *) accessibilityElements
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x6E22E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x6DF2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CheckBoxRendererBase_1 {
}

	-(void) layoutSubviews
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, 0x6E72E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_168 (self, _cmd, &managed_method, p0, 0x6E92E);
	}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.CheckBoxRendererBase`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7002E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7012E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7022E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7032E);
	}

	-(void) willRotateToInterfaceOrientation:(NSInteger)p0 duration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, 0x7042E);
	}

	-(UIViewController *) childViewControllerForStatusBarHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7132E);
	}

	-(UIViewController *) childViewControllerForHomeIndicatorAutoHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7142E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x6F32E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PhoneMasterDetailRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x71C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ChildViewController : UIViewController {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) viewDidLayoutSubviews;
	-(UIViewController *) childViewControllerForStatusBarStyle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ChildViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x73A2E);
	}

	-(UIViewController *) childViewControllerForStatusBarStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x73B2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x73C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7592E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x75A2E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x75B2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x75C2E);
	}

	-(void) viewWillDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x75E2E);
	}

	-(void) viewWillLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x75F2E);
	}

	-(void) willRotateToInterfaceOrientation:(NSInteger)p0 duration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, 0x7602E);
	}

	-(UIViewController *) childViewControllerForStatusBarHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7612E);
	}

	-(UIViewController *) childViewControllerForHomeIndicatorAutoHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7622E);
	}

	-(void) viewWillTransitionToSize:(CGSize)p0 withTransitionCoordinator:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_195 (self, _cmd, &managed_method, p0, p1, 0x7672E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x74E2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UISplitViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TabletMasterDetailRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7712E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellItemRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIViewController *) selectedViewController
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x82C2E);
	}

	-(void) setSelectedViewController:(UIViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x82D2E);
	}

	-(void) navigationController:(UINavigationController *)p0 didShowViewController:(UIViewController *)p1 animated:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_196 (self, _cmd, &managed_method, p0, p1, p2, 0x82E2E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x82F2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8302E);
	}

	-(void) viewWillLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8412E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellSearchResultsRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x8BD2E);
	}

	-(void) tableView:(UITableView *)p0 didSelectRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x8BE2E);
	}

	-(NSInteger) numberOfSectionsInTableView:(UITableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x8BF2E);
	}

	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x8C02E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellTableViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x93F2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TabletShellFlyoutRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x9642E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x9682E);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x9692E);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x96A2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x96E2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UISplitViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_UIContainerCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x97E2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_UIContainerView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) willMoveToSuperview:(UIView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x9912E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x9922E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_NativeViewPropertyListener : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_NativeViewPropertyListener {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_104 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x9D02E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CheckBoxRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA282E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_CheckBoxRendererBase_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CarouselViewLayout {
}

	-(void) prepareForCollectionViewUpdates:(NSArray *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0xA2E2E);
	}

	-(void) finalizeCollectionViewUpdates
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xA2F2E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CarouselViewController {
}

	-(UICollectionViewCell *) collectionView:(UICollectionView *)p0 cellForItemAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0xA322E);
	}

	-(NSInteger) collectionView:(UICollectionView *)p0 numberOfItemsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0xA332E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xA342E);
	}

	-(void) viewWillLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xA352E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xA362E);
	}

	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xA382E);
	}

	-(void) scrollViewDidEndDragging:(UIScrollView *)p0 willDecelerate:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0xA392E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CarouselTemplatedCell {
}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0xA6A2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_TemplatedCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_RefreshViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA732E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_IndicatorViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA8E2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_FormsPageControl : UIPageControl {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_FormsPageControl {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xAA52E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAA62E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIPageControl class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShapeRenderer_2 {
}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.iOS.ShapeRenderer`2' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShapeView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB0A2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShapeLayer {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xB0E2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB0D2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PathRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB202E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PathView {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB2A2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EllipseRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB2C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EllipseView {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB2E2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_LineRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB302E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_LineView {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB3C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PolygonRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB3D2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PolygonView {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB462E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PolylineRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB472E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_PolylineView {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB502E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_RectangleRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB512E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_RectangleView {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB582E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ShapeView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ShellFlyoutHeaderContainer : Xamarin_Forms_Platform_iOS_UIContainerView {
}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellFlyoutHeaderContainer {
}
@end

@interface Xamarin_Forms_Platform_iOS_ContextActionsCell_SelectGestureRecognizer : UITapGestureRecognizer {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ContextActionsCell_SelectGestureRecognizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBA62E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UITapGestureRecognizer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetController : UIAlertController {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSInteger) preferredStyle;
	-(void) willRotateToInterfaceOrientation:(NSInteger)p0 duration:(double)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSInteger) preferredStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0xBA92E);
	}

	-(void) willRotateToInterfaceOrientation:(NSInteger)p0 duration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, 0xBAA2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBAB2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIAlertController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetDelegate : NSObject<UIActionSheetDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) actionSheet:(UIActionSheet *)p0 clickedButtonAtIndex:(NSInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) actionSheet:(UIActionSheet *)p0 clickedButtonAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0xBAC2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBAD2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ContextActionsCell : UITableViewCell {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(CGSize) sizeThatFits:(CGSize)p0;
	-(void) removeFromSuperview;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ContextActionsCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x462E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x482E);
	}

	-(void) removeFromSuperview
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x492E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3E2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UITableViewCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ContextScrollViewDelegate : NSObject<UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0;
	-(void) scrollViewDidScroll:(UIScrollView *)p0;
	-(void) scrollViewWillEndDragging:(UIScrollView *)p0 withVelocity:(CGPoint)p1 targetContentOffset:(CGPoint*)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ContextScrollViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x622E);
	}

	-(void) scrollViewDidScroll:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x642E);
	}

	-(void) scrollViewWillEndDragging:(UIScrollView *)p0 withVelocity:(CGPoint)p1 targetContentOffset:(CGPoint*)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_137 (self, _cmd, &managed_method, p0, p1, p2, 0x662E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_Platform_DefaultRenderer : Xamarin_Forms_Platform_iOS_VisualElementRenderer_1 {
}
	-(UIView *) hitTest:(CGPoint)p0 withEvent:(UIEvent *)p1;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_Platform_DefaultRenderer {
}

	-(UIView *) hitTest:(CGPoint)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, 0xBCC2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBCD2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_VisualElementRenderer_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EntryCellRenderer_EntryCellTableViewCell {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xBF82E);
	}
@end

@interface Xamarin_Forms_Platform_iOS_ViewCellRenderer_ViewTableCell : UITableViewCell {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(CGSize) sizeThatFits:(CGSize)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ViewCellRenderer_ViewTableCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xC0A2E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0xC0B2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_CarouselPageRenderer_CarouselPageContainer : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_CarouselPageRenderer_CarouselPageContainer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xC382E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_CarouselPageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) didRotateFromInterfaceOrientation:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x21D2E);
	}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x21E2E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x21F2E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2202E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2212E);
	}

	-(void) viewDidUnload
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2222E);
	}

	-(void) willRotateToInterfaceOrientation:(NSInteger)p0 duration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, 0x2232E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x20E2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_EditorRendererBase_1_FormsUITextView : UITextView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGRect) frame;
	-(void) setFrame:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_EditorRendererBase_1_FormsUITextView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGRect) frame
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_198 (self, _cmd, &managed_method, 0xC3E2E);
	}

	-(void) setFrame:(CGRect)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_199 (self, _cmd, &managed_method, p0, 0xC3F2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_FrameRenderer_FrameView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) removeFromSuperview;
	-(BOOL) pointInside:(CGPoint)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_FrameRenderer_FrameView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) removeFromSuperview
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xC402E);
	}

	-(BOOL) pointInside:(CGPoint)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_200 (self, _cmd, &managed_method, p0, p1, 0xC412E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC422E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_FrameRenderer {
}

	-(void) addSubview:(UIView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x29D2E);
	}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x2A02E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2A22E);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x2A32E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x29C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_VisualElementRenderer_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ImageRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2A62E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_LabelRenderer_FormsLabel : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawTextInRect:(CGRect)p0;
	-(CGSize) sizeThatFits:(CGSize)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_LabelRenderer_FormsLabel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawTextInRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xC562E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0xC572E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_LabelRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2D12E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2CF2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ListViewRenderer_ListViewDataSource : NSObject<UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) scrollViewDidEndDragging:(UIScrollView *)p0 willDecelerate:(BOOL)p1;
	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0;
	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1;
	-(CGFloat) tableView:(UITableView *)p0 heightForHeaderInSection:(NSInteger)p1;
	-(UIView *) tableView:(UITableView *)p0 viewForHeaderInSection:(NSInteger)p1;
	-(void) tableView:(UITableView *)p0 didEndDisplayingHeaderView:(UIView *)p1 forSection:(NSInteger)p2;
	-(NSInteger) numberOfSectionsInTableView:(UITableView *)p0;
	-(void) tableView:(UITableView *)p0 didDeselectRowAtIndexPath:(NSIndexPath *)p1;
	-(void) tableView:(UITableView *)p0 didSelectRowAtIndexPath:(NSIndexPath *)p1;
	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1;
	-(void) scrollViewDidScroll:(UIScrollView *)p0;
	-(NSArray *) sectionIndexTitlesForTableView:(UITableView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ListViewRenderer_ListViewDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) scrollViewDidEndDragging:(UIScrollView *)p0 willDecelerate:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0xC6D2E);
	}

	-(void) scrollViewWillBeginDragging:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xC6E2E);
	}

	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0xC702E);
	}

	-(CGFloat) tableView:(UITableView *)p0 heightForHeaderInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, p1, 0xC712E);
	}

	-(UIView *) tableView:(UITableView *)p0 viewForHeaderInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, 0xC722E);
	}

	-(void) tableView:(UITableView *)p0 didEndDisplayingHeaderView:(UIView *)p1 forSection:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, p1, p2, 0xC732E);
	}

	-(NSInteger) numberOfSectionsInTableView:(UITableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0xC742E);
	}

	-(void) tableView:(UITableView *)p0 didDeselectRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xC762E);
	}

	-(void) tableView:(UITableView *)p0 didSelectRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xC772E);
	}

	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0xC782E);
	}

	-(void) scrollViewDidScroll:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xC792E);
	}

	-(NSArray *) sectionIndexTitlesForTableView:(UITableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, 0xC7A2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ListViewRenderer_UnevenListViewDataSource : Xamarin_Forms_Platform_iOS_ListViewRenderer_ListViewDataSource<UIScrollViewDelegate> {
}
	-(CGFloat) tableView:(UITableView *)p0 heightForRowAtIndexPath:(NSIndexPath *)p1;
@end

@implementation Xamarin_Forms_Platform_iOS_ListViewRenderer_UnevenListViewDataSource {
}

	-(CGFloat) tableView:(UITableView *)p0 heightForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0xC5F2E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ListViewRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2F82E);
	}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x2FE2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2F52E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_FormsUITableViewController : UITableViewController {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) viewWillAppear:(BOOL)p0;
	-(void) viewWillLayoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_FormsUITableViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x32A2E);
	}

	-(void) viewWillLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x32B2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_NavigationRenderer_FormsNavigationBar : UINavigationBar {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_NavigationRenderer_FormsNavigationBar {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCD42E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xCCB2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UINavigationBar class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_NavigationRenderer_Container : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGSize) intrinsicContentSize;
	-(CGRect) frame;
	-(void) setFrame:(CGRect)p0;
	-(CGSize) sizeThatFits:(CGSize)p0;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_NavigationRenderer_Container {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGSize) intrinsicContentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, 0xCD62E);
	}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xCDA2E);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xCDB2E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0xCDD2E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCDE2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_OpenGLViewRenderer_Delegate : NSObject<GLKViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) glkView:(GLKView *)p0 drawInRect:(CGRect)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_OpenGLViewRenderer_Delegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) glkView:(GLKView *)p0 drawInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_100 (self, _cmd, &managed_method, p0, p1, 0xCF72E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_OpenGLViewRenderer : Xamarin_Forms_Platform_iOS_ViewRenderer_2 {
}
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_OpenGLViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x37D2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_PickerRendererBase_1_PickerSource : NSObject<UIPickerViewDataSource, UIPickerViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSInteger) numberOfComponentsInPickerView:(UIPickerView *)p0;
	-(NSInteger) pickerView:(UIPickerView *)p0 numberOfRowsInComponent:(NSInteger)p1;
	-(NSString *) pickerView:(UIPickerView *)p0 titleForRow:(NSInteger)p1 forComponent:(NSInteger)p2;
	-(void) pickerView:(UIPickerView *)p0 didSelectRow:(NSInteger)p1 inComponent:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_PickerRendererBase_1_PickerSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSInteger) numberOfComponentsInPickerView:(UIPickerView *)p0
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_185 (self, _cmd, &managed_method, p0, 0xD082E);
	}

	-(NSInteger) pickerView:(UIPickerView *)p0 numberOfRowsInComponent:(NSInteger)p1
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_183 (self, _cmd, &managed_method, p0, p1, 0xD092E);
	}

	-(NSString *) pickerView:(UIPickerView *)p0 titleForRow:(NSInteger)p1 forComponent:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, p2, 0xD0A2E);
	}

	-(void) pickerView:(UIPickerView *)p0 didSelectRow:(NSInteger)p1 inComponent:(NSInteger)p2
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0xD0B2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_TabbedRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIViewController *) selectedViewController
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x4362E);
	}

	-(void) setSelectedViewController:(UIViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x4372E);
	}

	-(void) didRotateFromInterfaceOrientation:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0x4422E);
	}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x4432E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x4442E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x4452E);
	}

	-(UIViewController *) childViewControllerForStatusBarHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x44D2E);
	}

	-(UIViewController *) childViewControllerForHomeIndicatorAutoHidden
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x4502E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4352E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UITabBarController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_DragAndDropDelegate_CustomLocalStateData : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_DragAndDropDelegate_CustomLocalStateData {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD3C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_DragAndDropDelegate : NSObject<UIDragInteractionDelegate, UIDropInteractionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) dragInteraction:(UIDragInteraction *)p0 session:(id)p1 willEndWithOperation:(NSUInteger)p2;
	-(NSArray *) dragInteraction:(UIDragInteraction *)p0 itemsForBeginningSession:(id)p1;
	-(BOOL) dropInteraction:(UIDropInteraction *)p0 canHandleSession:(id)p1;
	-(void) dropInteraction:(UIDropInteraction *)p0 sessionDidExit:(id)p1;
	-(UIDropProposal *) dropInteraction:(UIDropInteraction *)p0 sessionDidUpdate:(id)p1;
	-(void) dropInteraction:(UIDropInteraction *)p0 performDrop:(id)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_DragAndDropDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) dragInteraction:(UIDragInteraction *)p0 session:(id)p1 willEndWithOperation:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_203 (self, _cmd, &managed_method, p0, p1, p2, 0x6502E);
	}

	-(NSArray *) dragInteraction:(UIDragInteraction *)p0 itemsForBeginningSession:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, p1, 0x6512E);
	}

	-(BOOL) dropInteraction:(UIDropInteraction *)p0 canHandleSession:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_205 (self, _cmd, &managed_method, p0, p1, 0x6522E);
	}

	-(void) dropInteraction:(UIDropInteraction *)p0 sessionDidExit:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x6532E);
	}

	-(UIDropProposal *) dropInteraction:(UIDropInteraction *)p0 sessionDidUpdate:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, 0x6542E);
	}

	-(void) dropInteraction:(UIDropInteraction *)p0 performDrop:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x6552E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x65C2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ModalWrapper : UIViewController<UIAdaptivePresentationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) presentationControllerDidDismiss:(UIPresentationController *)p0;
	-(void) dismissViewControllerAnimated:(BOOL)p0 completion:(void (^)())p1;
	-(NSUInteger) supportedInterfaceOrientations;
	-(BOOL) modalPresentationCapturesStatusBarAppearance;
	-(NSInteger) preferredInterfaceOrientationForPresentation;
	-(BOOL) shouldAutorotate;
	-(BOOL) shouldAutorotateToInterfaceOrientation:(NSInteger)p0;
	-(BOOL) shouldAutomaticallyForwardRotationMethods;
	-(void) viewDidLayoutSubviews;
	-(void) viewWillAppear:(BOOL)p0;
	-(void) viewDidLoad;
	-(UIViewController *) childViewControllerForStatusBarStyle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ModalWrapper {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) presentationControllerDidDismiss:(UIPresentationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x6752E);
	}

	-(void) dismissViewControllerAnimated:(BOOL)p0 completion:(void (^)())p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_208 (self, _cmd, &managed_method, p0, p1, 0x6762E);
	}

	-(NSUInteger) supportedInterfaceOrientations
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_15 (self, _cmd, &managed_method, 0x6772E);
	}

	-(BOOL) modalPresentationCapturesStatusBarAppearance
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x6782E);
	}

	-(NSInteger) preferredInterfaceOrientationForPresentation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0x6792E);
	}

	-(BOOL) shouldAutorotate
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x67A2E);
	}

	-(BOOL) shouldAutorotateToInterfaceOrientation:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, 0x67B2E);
	}

	-(BOOL) shouldAutomaticallyForwardRotationMethods
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x67C2E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x67D2E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x67E2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x6802E);
	}

	-(UIViewController *) childViewControllerForStatusBarStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x6812E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer_ChildViewController : UIViewController {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) viewDidLayoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer_ChildViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD682E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD692E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_EventedViewController_FlyoutView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD792E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD7B2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_EventedViewController : Xamarin_Forms_Platform_iOS_ChildViewController {
}
	-(void) viewDidAppear:(BOOL)p0;
	-(void) viewWillDisappear:(BOOL)p0;
	-(void) viewDidDisappear:(BOOL)p0;
	-(void) loadView;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_EventedViewController {
}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7462E);
	}

	-(void) viewWillDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7472E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7482E);
	}

	-(void) loadView
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7492E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7412E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ChildViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer_InnerDelegate : NSObject<UISplitViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) splitViewController:(UISplitViewController *)p0 shouldHideViewController:(UIViewController *)p1 inOrientation:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer_InnerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) splitViewController:(UISplitViewController *)p0 shouldHideViewController:(UIViewController *)p1 inOrientation:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_151 (self, _cmd, &managed_method, p0, p1, p2, 0xD7D2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellFlyoutContentRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewWillLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7E62E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7EA2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7EB2E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7ED2E);
	}

	-(void) viewWillDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7EE2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellFlyoutRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIViewController *) childViewControllerForStatusBarStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x80E2E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x80F2E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8102E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8112E);
	}

	-(NSArray *) keyCommands
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, 0x8182E);
	}

	-(void) tabForward:(UIKeyCommand *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x81B2E);
	}

	-(void) tabBackward:(UIKeyCommand *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x81C2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x8202E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellPageRendererTracker_TitleViewContainer {
}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xDB52E);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xDB62E);
	}

	-(void) willMoveToSuperview:(UIView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xDB72E);
	}

	-(CGSize) intrinsicContentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, 0xDB82E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0xDB92E);
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x88C2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x88D2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x8762E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellSectionRootHeader_ShellSectionHeaderCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) isSelected
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xDE02E);
	}

	-(void) setSelected:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xDE12E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xDE32E);
	}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0xDE42E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xDDE2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UICollectionViewCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0xDDF2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UICollectionViewCell class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellSectionRootHeader {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) collectionView:(UICollectionView *)p0 canMoveItemAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x8D22E);
	}

	-(UICollectionViewCell *) collectionView:(UICollectionView *)p0 cellForItemAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x8D32E);
	}

	-(NSInteger) collectionView:(UICollectionView *)p0 numberOfItemsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x8D42E);
	}

	-(void) collectionView:(UICollectionView *)p0 didDeselectItemAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x8D52E);
	}

	-(void) collectionView:(UICollectionView *)p0 didSelectItemAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x8D62E);
	}

	-(NSInteger) numberOfSectionsInCollectionView:(UICollectionView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x8D72E);
	}

	-(BOOL) collectionView:(UICollectionView *)p0 shouldSelectItemAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x8D82E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8D92E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8DA2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x8CA2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UICollectionViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellSectionRootRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8E92E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8EA2E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8EB2E);
	}

	-(void) viewSafeAreaInsetsDidChange
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8EC2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ShellSectionRenderer_GestureDelegate : NSObject<UIGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) gestureRecognizerShouldBegin:(UIGestureRecognizer *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ShellSectionRenderer_GestureDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) gestureRecognizerShouldBegin:(UIGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0xDEA2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ShellSectionRenderer_NavDelegate : NSObject<UINavigationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(id) navigationController:(UINavigationController *)p0 animationControllerForOperation:(NSInteger)p1 fromViewController:(UIViewController *)p2 toViewController:(UIViewController *)p3;
	-(void) navigationController:(UINavigationController *)p0 didShowViewController:(UIViewController *)p1 animated:(BOOL)p2;
	-(void) navigationController:(UINavigationController *)p0 willShowViewController:(UIViewController *)p1 animated:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ShellSectionRenderer_NavDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(id) navigationController:(UINavigationController *)p0 animationControllerForOperation:(NSInteger)p1 fromViewController:(UIViewController *)p2 toViewController:(UIViewController *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_209 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xDEC2E);
	}

	-(void) navigationController:(UINavigationController *)p0 didShowViewController:(UIViewController *)p1 animated:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_196 (self, _cmd, &managed_method, p0, p1, p2, 0xDED2E);
	}

	-(void) navigationController:(UINavigationController *)p0 willShowViewController:(UIViewController *)p1 animated:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_196 (self, _cmd, &managed_method, p0, p1, p2, 0xDEE2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellSectionRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) navigationBar:(UINavigationBar *)p0 shouldPopItem:(UINavigationItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x9062E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x9082E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x90A2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x90B2E);
	}

	-(NSArray *) popToRootViewControllerAnimated:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, 0x9162E);
	}

	-(NSArray *) viewControllers
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, 0x9222E);
	}

	-(void) setViewControllers:(NSArray *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x9232E);
	}

	-(NSArray *) popToViewController:(UIViewController *)p0 animated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_210 (self, _cmd, &managed_method, p0, p1, 0x9242E);
	}

	-(void) pushViewController:(UIViewController *)p0 animated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, 0x9252E);
	}

	-(UIViewController *) popViewControllerAnimated:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x9262E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ShellTableViewSource_SeparatorView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ShellTableViewSource_SeparatorView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xDFD2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xDFC2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ShellTableViewSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGFloat) tableView:(UITableView *)p0 heightForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0x94A2E);
	}

	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x94B2E);
	}

	-(CGFloat) tableView:(UITableView *)p0 heightForFooterInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, p1, 0x94D2E);
	}

	-(UIView *) tableView:(UITableView *)p0 viewForFooterInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, 0x94E2E);
	}

	-(NSInteger) numberOfSectionsInTableView:(UITableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x94F2E);
	}

	-(void) tableView:(UITableView *)p0 didSelectRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x9502E);
	}

	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x9512E);
	}

	-(void) scrollViewDidScroll:(UIScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x9522E);
	}

	-(void) tableView:(UITableView *)p0 willDisplayCell:(UITableViewCell *)p1 forRowAtIndexPath:(NSIndexPath *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x9532E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_ImageButtonRenderer {
}

	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x9AA2E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9A92E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_iOS_SwipeViewRenderer {
}

	-(void) willMoveToWindow:(UIWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xAAA2E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xAAB2E);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xAAF2E);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xAB02E);
	}

	-(UIView *) hitTest:(CGPoint)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, 0xAB22E);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xAA72E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_PrimaryToolbarItem : UIBarButtonItem {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_PrimaryToolbarItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem_SecondaryToolbarItemContent : UIControl {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) isEnabled;
	-(void) setEnabled:(BOOL)p0;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem_SecondaryToolbarItemContent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) isEnabled
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xE492E);
	}

	-(void) setEnabled:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xE4A2E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xE4F2E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE482E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIControl class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem : UIBarButtonItem {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_NavigationRenderer_SecondaryToolbar : UIToolbar {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSArray *) items;
	-(void) setItems:(NSArray *)p0;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_NavigationRenderer_SecondaryToolbar {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSArray *) items
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, 0xC9F2E);
	}

	-(void) setItems:(NSArray *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0xCA02E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCA12E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC9E2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIToolbar class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_NavigationRenderer_ParentingViewController : UIViewController {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) didRotateFromInterfaceOrientation:(NSInteger)p0;
	-(void) viewDidAppear:(BOOL)p0;
	-(void) viewDidDisappear:(BOOL)p0;
	-(void) viewWillLayoutSubviews;
	-(void) viewDidLayoutSubviews;
	-(void) viewDidLoad;
	-(void) viewWillAppear:(BOOL)p0;
	-(NSUInteger) supportedInterfaceOrientations;
	-(NSInteger) preferredInterfaceOrientationForPresentation;
	-(BOOL) shouldAutorotate;
	-(BOOL) shouldAutorotateToInterfaceOrientation:(NSInteger)p0;
	-(BOOL) shouldAutomaticallyForwardRotationMethods;
	-(void) didMoveToParentViewController:(UIViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_NavigationRenderer_ParentingViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) didRotateFromInterfaceOrientation:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_1 (self, _cmd, &managed_method, p0, 0xCA92E);
	}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xCAC2E);
	}

	-(void) viewDidDisappear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xCAD2E);
	}

	-(void) viewWillLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCAE2E);
	}

	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCAF2E);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCB02E);
	}

	-(void) viewWillAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0xCB12E);
	}

	-(NSUInteger) supportedInterfaceOrientations
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_15 (self, _cmd, &managed_method, 0xCC42E);
	}

	-(NSInteger) preferredInterfaceOrientationForPresentation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, 0xCC52E);
	}

	-(BOOL) shouldAutorotate
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xCC62E);
	}

	-(BOOL) shouldAutorotateToInterfaceOrientation:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, 0xCC72E);
	}

	-(BOOL) shouldAutomaticallyForwardRotationMethods
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xCC82E);
	}

	-(void) didMoveToParentViewController:(UIViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xCC92E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewNavigationDelegate : NSObject<WKNavigationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) webView:(WKWebView *)p0 didFailNavigation:(WKNavigation *)p1 withError:(NSError *)p2;
	-(void) webView:(WKWebView *)p0 didFailProvisionalNavigation:(WKNavigation *)p1 withError:(NSError *)p2;
	-(void) webView:(WKWebView *)p0 didFinishNavigation:(WKNavigation *)p1;
	-(void) webView:(WKWebView *)p0 didStartProvisionalNavigation:(WKNavigation *)p1;
	-(void) webView:(WKWebView *)p0 decidePolicyForNavigationAction:(WKNavigationAction *)p1 decisionHandler:(void (^)(void *))p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewNavigationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) webView:(WKWebView *)p0 didFailNavigation:(WKNavigation *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0xD802E);
	}

	-(void) webView:(WKWebView *)p0 didFailProvisionalNavigation:(WKNavigation *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0xD812E);
	}

	-(void) webView:(WKWebView *)p0 didFinishNavigation:(WKNavigation *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xD822E);
	}

	-(void) webView:(WKWebView *)p0 didStartProvisionalNavigation:(WKNavigation *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xD842E);
	}

	-(void) webView:(WKWebView *)p0 decidePolicyForNavigationAction:(WKNavigationAction *)p1 decisionHandler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_211 (self, _cmd, &managed_method, p0, p1, p2, 0xD852E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewUIDelegate : NSObject<WKUIDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) webView:(WKWebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WKFrameInfo *)p2 completionHandler:(void (^)())p3;
	-(void) webView:(WKWebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WKFrameInfo *)p2 completionHandler:(void (^)(void *))p3;
	-(void) webView:(WKWebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WKFrameInfo *)p3 completionHandler:(void (^)(void *))p4;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewUIDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) webView:(WKWebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WKFrameInfo *)p2 completionHandler:(void (^)())p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_212 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xD872E);
	}

	-(void) webView:(WKWebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WKFrameInfo *)p2 completionHandler:(void (^)(void *))p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_213 (self, _cmd, &managed_method, p0, p1, p2, p3, 0xD882E);
	}

	-(void) webView:(WKWebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WKFrameInfo *)p3 completionHandler:(void (^)(void *))p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_214 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0xD892E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD8F2E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end


@implementation Plugin_FirebasePushNotification_FirebasePushNotificationManager {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) userNotificationCenter:(UNUserNotificationCenter *)p0 willPresentNotification:(UNNotification *)p1 withCompletionHandler:(void (^)(void *))p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_215 (self, _cmd, &managed_method, p0, p1, p2, 0x6B42);
	}

	-(void) userNotificationCenter:(UNUserNotificationCenter *)p0 didReceiveNotificationResponse:(UNNotificationResponse *)p1 withCompletionHandler:(void (^)())p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_216 (self, _cmd, &managed_method, p0, p1, p2, 0x7842);
	}

	-(void) messaging:(id)p0 didReceiveRegistrationToken:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, 0x7942);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7E42);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation ApiDefinition__Firebase_CloudMessaging_MessagingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x9444);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop











@interface Xamarin_Essentials_ShareActivityItemSource : NSObject<UIActivityItemSource> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSObject *) activityViewController:(UIActivityViewController *)p0 itemForActivityType:(NSString *)p1;
	-(NSObject *) activityViewControllerPlaceholderItem:(UIActivityViewController *)p0;
	-(NSString *) activityViewController:(UIActivityViewController *)p0 subjectForActivityType:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Essentials_ShareActivityItemSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSObject *) activityViewController:(UIActivityViewController *)p0 itemForActivityType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x5624C);
	}

	-(NSObject *) activityViewControllerPlaceholderItem:(UIActivityViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x5634C);
	}

	-(NSString *) activityViewController:(UIActivityViewController *)p0 subjectForActivityType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_217 (self, _cmd, &managed_method, p0, p1, 0x5644C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Essentials_AuthManager : NSObject<ASAuthorizationControllerDelegate, ASAuthorizationControllerPresentationContextProviding> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(UIWindow *) presentationAnchorForAuthorizationController:(ASAuthorizationController *)p0;
	-(void) authorizationController:(ASAuthorizationController *)p0 didCompleteWithAuthorization:(ASAuthorization *)p1;
	-(void) authorizationController:(ASAuthorizationController *)p0 didCompleteWithError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Essentials_AuthManager {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIWindow *) presentationAnchorForAuthorizationController:(ASAuthorizationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x5674C);
	}

	-(void) authorizationController:(ASAuthorizationController *)p0 didCompleteWithAuthorization:(ASAuthorization *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x5684C);
	}

	-(void) authorizationController:(ASAuthorizationController *)p0 didCompleteWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x5694C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Essentials_SingleLocationListener : NSObject<CLLocationManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1;
	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Essentials_SingleLocationListener {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x57A4C);
	}

	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0x57B4C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x57C4C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Essentials_Contacts_ContactPickerDelegate : NSObject<CNContactPickerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) contactPickerDidCancel:(CNContactPickerViewController *)p0;
	-(void) contactPicker:(CNContactPickerViewController *)p0 didSelectContact:(CNContact *)p1;
	-(void) contactPicker:(CNContactPickerViewController *)p0 didSelectContactProperty:(CNContactProperty *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Essentials_Contacts_ContactPickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) contactPickerDidCancel:(CNContactPickerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1164C);
	}

	-(void) contactPicker:(CNContactPickerViewController *)p0 didSelectContact:(CNContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1174C);
	}

	-(void) contactPicker:(CNContactPickerViewController *)p0 didSelectContactProperty:(CNContactProperty *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x1184C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Essentials_FilePicker_PickerDelegate : NSObject<UIDocumentPickerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) documentPickerWasCancelled:(UIDocumentPickerViewController *)p0;
	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentsAtURLs:(NSArray *)p1;
	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentAtURL:(NSURL *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Essentials_FilePicker_PickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) documentPickerWasCancelled:(UIDocumentPickerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x1794C);
	}

	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentsAtURLs:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x17A4C);
	}

	-(void) documentPicker:(UIDocumentPickerViewController *)p0 didPickDocumentAtURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x17B4C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x17C4C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Essentials_MediaPicker_PhotoPickerDelegate : NSObject<UIImagePickerControllerDelegate, UINavigationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) imagePickerController:(UIImagePickerController *)p0 didFinishPickingMediaWithInfo:(NSDictionary *)p1;
	-(void) imagePickerControllerDidCancel:(UIImagePickerController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Essentials_MediaPicker_PhotoPickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) imagePickerController:(UIImagePickerController *)p0 didFinishPickingMediaWithInfo:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2714C);
	}

	-(void) imagePickerControllerDidCancel:(UIImagePickerController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x2724C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2734C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Essentials_Platform_UIPresentationControllerDelegate : NSObject<UIAdaptivePresentationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) presentationControllerDidDismiss:(UIPresentationController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Essentials_Platform_UIPresentationControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) presentationControllerDidDismiss:(UIPresentationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x3584C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x35A4C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Essentials_WebAuthenticator_NativeSFSafariViewControllerDelegate : NSObject<SFSafariViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) safariViewControllerDidFinish:(SFSafariViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Essentials_WebAuthenticator_NativeSFSafariViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) safariViewControllerDidFinish:(SFSafariViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x5284C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x5294C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Essentials_WebAuthenticator_ContextProvider : NSObject<ASWebAuthenticationPresentationContextProviding> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(UIWindow *) presentationAnchorForWebAuthenticationSession:(ASWebAuthenticationSession *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Essentials_WebAuthenticator_ContextProvider {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UIWindow *) presentationAnchorForWebAuthenticationSession:(ASWebAuthenticationSession *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x52D4C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_Essentials_Permissions_LocationWhenInUse_ManagerDelegate : NSObject<CLLocationManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1;
	-(void) locationManagerDidChangeAuthorization:(CLLocationManager *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Essentials_Permissions_LocationWhenInUse_ManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, p1, 0x2DA4C);
	}

	-(void) locationManagerDidChangeAuthorization:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x2DB4C);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2DC4C);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface OpenTK_Platform_iPhoneOS_CADisplayLinkTimeSource : NSObject {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) runIteration:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation OpenTK_Platform_iPhoneOS_CADisplayLinkTimeSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) runIteration:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x98F4E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation OpenTK_Platform_iPhoneOS_iPhoneOSGameView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	+(Class) layerClass
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_218 (self, _cmd, &managed_method, 0x9974E);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x9D34E);
	}

	-(void) willMoveToWindow:(UIWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x9DF4E);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x9954E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}

	-(id) initWithFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, &call_super, 0x9964E);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL, CGRect)) objc_msgSendSuper) (&super, @selector (initWithFrame:), p0);
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_PancakeView_iOS_PancakeViewRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x6850);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x6950);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7250);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeRoundedStackView : UIStackView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeRoundedStackView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xAB4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_iOS_UI_Views_SideMenuViewRenderer {
}

	-(void) addGestureRecognizer:(UIGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x19B4);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x16B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_VisualElementRenderer_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_iOS_Effects_TouchEventsGestureRecognizer : UIGestureRecognizer {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_CommunityToolkit_iOS_Effects_TouchEventsGestureRecognizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x78B4);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x79B4);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x7AB4);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x7BB4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_iOS_Effects_ShouldRecognizeSimultaneouslyRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x85B4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x86B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_UI_Views_PhotoCaptureDelegate : NSObject<AVCapturePhotoCaptureDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) captureOutput:(AVCapturePhotoOutput *)p0 willCapturePhotoForResolvedSettings:(AVCaptureResolvedPhotoSettings *)p1;
	-(void) captureOutput:(AVCapturePhotoOutput *)p0 didFinishProcessingPhotoSampleBuffer:(id)p1 previewPhotoSampleBuffer:(id)p2 resolvedSettings:(AVCaptureResolvedPhotoSettings *)p3 bracketSettings:(AVCaptureBracketedStillImageSettings *)p4 error:(NSError *)p5;
	-(void) captureOutput:(AVCapturePhotoOutput *)p0 didFinishCaptureForResolvedSettings:(AVCaptureResolvedPhotoSettings *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_CommunityToolkit_UI_Views_PhotoCaptureDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) captureOutput:(AVCapturePhotoOutput *)p0 willCapturePhotoForResolvedSettings:(AVCaptureResolvedPhotoSettings *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x4BCB4);
	}

	-(void) captureOutput:(AVCapturePhotoOutput *)p0 didFinishProcessingPhotoSampleBuffer:(id)p1 previewPhotoSampleBuffer:(id)p2 resolvedSettings:(AVCaptureResolvedPhotoSettings *)p3 bracketSettings:(AVCaptureBracketedStillImageSettings *)p4 error:(NSError *)p5
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_219 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, 0x4BDB4);
	}

	-(void) captureOutput:(AVCapturePhotoOutput *)p0 didFinishCaptureForResolvedSettings:(AVCaptureResolvedPhotoSettings *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, 0x4BEB4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4BFB4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_MediaElementRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4E0B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_SemanticOrderViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x523B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_ImageSwitcherRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x527B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ImageRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_TextSwitcherRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x52BB4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_LabelRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_UI_Views_Helpers_PaddedLabel : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGSize) intrinsicContentSize;
	-(void) drawTextInRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_CommunityToolkit_UI_Views_Helpers_PaddedLabel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGSize) intrinsicContentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, 0x54FB4);
	}

	-(void) drawTextInRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x550B4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBar_BaseSnackBarView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBar_BaseSnackBarView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBarViews_MessageSnackBarView : Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBar_BaseSnackBarView {
}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBarViews_MessageSnackBarView {
}
@end

@interface Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_ActionMessageSnackBarView : Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBarViews_MessageSnackBarView {
}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_ActionMessageSnackBarView {
}
@end

@interface Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeSnackButton : UIButton {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeSnackButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizer : UIGestureRecognizer {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x60B4);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x61B4);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x62B4);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x63B4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizerDelegate : NSObject<UIGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveTouch:(UITouch *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x67B4);
	}

	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveTouch:(UITouch *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x68B4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x69B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_CameraViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x491B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_FormsCameraView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x4A1B4);
	}

	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x4ACB4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x499B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_DrawingViewRenderer {
}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x4C4B4);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x4C5B4);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x4C6B4);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x4C7B4);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x4C8B4);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4C0B4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_CommunityToolkit_UI_Views_PopupRenderer_PopoverDelegate : NSObject<UIPopoverPresentationControllerDelegate, UIAdaptivePresentationControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSInteger) adaptivePresentationStyleForPresentationController:(UIPresentationController *)p0;
	-(void) presentationControllerDidDismiss:(UIPresentationController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_CommunityToolkit_UI_Views_PopupRenderer_PopoverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSInteger) adaptivePresentationStyleForPresentationController:(UIPresentationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0xB28B4);
	}

	-(void) presentationControllerDidDismiss:(UIPresentationController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xB29B4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xB2AB4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_CommunityToolkit_UI_Views_PopupRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) viewDidLayoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x50DB4);
	}

	-(void) viewDidAppear:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x50EB4);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x50AB4);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation ImageCircle_Forms_Plugin_iOS_ImageCircleRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x5C6);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ImageRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AiForms_Effects_iOS_NumberPickerSource : NSObject<UIPickerViewDataSource, UIPickerViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSInteger) numberOfComponentsInPickerView:(UIPickerView *)p0;
	-(NSInteger) pickerView:(UIPickerView *)p0 numberOfRowsInComponent:(NSInteger)p1;
	-(NSString *) pickerView:(UIPickerView *)p0 titleForRow:(NSInteger)p1 forComponent:(NSInteger)p2;
	-(void) pickerView:(UIPickerView *)p0 didSelectRow:(NSInteger)p1 inComponent:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AiForms_Effects_iOS_NumberPickerSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSInteger) numberOfComponentsInPickerView:(UIPickerView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, 0x38CA);
	}

	-(NSInteger) pickerView:(UIPickerView *)p0 numberOfRowsInComponent:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x39CA);
	}

	-(NSString *) pickerView:(UIPickerView *)p0 titleForRow:(NSInteger)p1 forComponent:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_220 (self, _cmd, &managed_method, p0, p1, p2, 0x3ACA);
	}

	-(void) pickerView:(UIPickerView *)p0 didSelectRow:(NSInteger)p1 inComponent:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_221 (self, _cmd, &managed_method, p0, p1, p2, 0x3BCA);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3ECA);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AiForms_Effects_iOS_PaddingLabel : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawTextInRect:(CGRect)p0;
	-(CGSize) intrinsicContentSize;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AiForms_Effects_iOS_PaddingLabel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawTextInRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x4CCA);
	}

	-(CGSize) intrinsicContentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, 0x4DCA);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4ECA);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UILabel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AiForms_Effects_iOS_NoCaretField : UITextField {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGRect) caretRectForPosition:(UITextPosition *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AiForms_Effects_iOS_NoCaretField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGRect) caretRectForPosition:(UITextPosition *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x6FCA);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x6ECA);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UITextField class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation AiForms_Effects_iOS_TouchEffectGestureRecognizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x8FCA);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x90CA);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x91CA);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x92CA);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation AiForms_Effects_iOS_AlwaysSimultaneouslyGestureRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0xA3CA);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA4CA);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end




@implementation Xamarin_IQBarButtonItem_IQBarButtonItemAppearance {
}
@end


@implementation Xamarin_IQPreviousNextView_IQPreviousNextViewAppearance {
}
@end


@implementation Xamarin_IQTextView_IQTextViewAppearance {
}
@end


@implementation Xamarin_IQTitleBarButtonItem_IQTitleBarButtonItemAppearance {
}
@end


@implementation Xamarin_IQToolbar_IQToolbarAppearance {
}
@end


@implementation Xamarin_UIView_IQToolbarAddition_UIView_IQToolbarAdditionAppearance {
}
@end

@implementation SVG_Forms_Plugin_iOS_SvgImageRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4CE);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ImageRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_InkViewPanGestureDelegate : NSObject<UIGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveTouch:(UITouch *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_InkViewPanGestureDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldReceiveTouch:(UITouch *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0x20CD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBorder : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBorder {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x21AD8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x21BD8);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x21CD8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x21DD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBubble : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBubble {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x238D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x239D8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x23AD8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x23BD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CustomViewHolder : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) willRemoveSubview:(UIView *)p0;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CustomViewHolder {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) willRemoveSubview:(UIView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x25FD8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x260D8);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x261D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CustomViewSelection : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CustomViewSelection {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x273D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_StampIcon : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_StampIcon {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x29BD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_TextBubbleView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_TextBubbleView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x2AED8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2AFD8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2B0D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2B1D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SelectionBorderView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SelectionBorderView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x2B4D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2B5D8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2B6D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2B7D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_TextSelectionView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_TextSelectionView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x2C1D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_TextView : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_TextView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2E6D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2E7D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ListPopupView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ListPopupView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x2F1D8);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2F2D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2F6D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PopupListCell : UITableViewCell {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PopupListCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2FAD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PopupListSource : NSObject<UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1;
	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1;
	-(void) tableView:(UITableView *)p0 didSelectRowAtIndexPath:(NSIndexPath *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PopupListSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x300D8);
	}

	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x301D8);
	}

	-(void) tableView:(UITableView *)p0 didSelectRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x302D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfWidget : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfWidget {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x304D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UILabel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfTextField : UITextView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(CGRect) caretRectForPosition:(UITextPosition *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfTextField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x325D8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x326D8);
	}

	-(CGRect) caretRectForPosition:(UITextPosition *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x327D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfTextFieldDelegate : NSObject<UITextViewDelegate, UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) textViewDidBeginEditing:(UITextView *)p0;
	-(void) textViewDidChange:(UITextView *)p0;
	-(void) textViewDidEndEditing:(UITextView *)p0;
	-(BOOL) textView:(UITextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementText:(NSString *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfTextFieldDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) textViewDidBeginEditing:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x337D8);
	}

	-(void) textViewDidChange:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x338D8);
	}

	-(void) textViewDidEndEditing:(UITextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x339D8);
	}

	-(BOOL) textView:(UITextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementText:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, p1, p2, 0x33AD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfCheckBox : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawTextInRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfCheckBox {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawTextInRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x353D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x354D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfComboBox : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfComboBox {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x372D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfListBox : UITableView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfListBox {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x39AD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ListBoxSource : NSObject<UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1;
	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ListBoxSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(UITableViewCell *) tableView:(UITableView *)p0 cellForRowAtIndexPath:(NSIndexPath *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x3A2D8);
	}

	-(NSInteger) tableView:(UITableView *)p0 numberOfRowsInSection:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, 0x3A3D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfRadioButton : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawTextInRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfRadioButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawTextInRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x3BDD8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x3BED8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectBorderView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectBorderView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x568D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x569D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x56AD8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x56BD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectionView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectionView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x5ACD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SignaturePad : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SignaturePad {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x5C4D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SignatureView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SignatureView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x5D4D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x5D5D8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x5D6D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x5D7D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface PdfContentView : CATiledLayer {
}
	@property (nonatomic, assign, readonly) double fadeDuration;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	+(double) fadeDuration;
	-(void) drawInContext:(id)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfContentView {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	+(double) fadeDuration
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_222 (self, _cmd, &managed_method, 0x665D8);
	}

	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x668D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x663D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CATiledLayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CurrentHighlightedView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation CurrentHighlightedView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_AlertViewDelegate : NSObject<UIAlertViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) alertViewShouldEnableFirstOtherButton:(UIAlertView *)p0;
	-(void) alertView:(UIAlertView *)p0 clickedButtonAtIndex:(NSInteger)p1;
	-(void) didPresentAlertView:(UIAlertView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_AlertViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) alertViewShouldEnableFirstOtherButton:(UIAlertView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0xA71D8);
	}

	-(void) alertView:(UIAlertView *)p0 clickedButtonAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, 0xA72D8);
	}

	-(void) didPresentAlertView:(UIAlertView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xA73D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_AlertViewTextBoxDelegate : NSObject<UITextFieldDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) textFieldShouldReturn:(UITextField *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_AlertViewTextBoxDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) textFieldShouldReturn:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0xA78D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CustomSearchRenderer : Xamarin_Forms_Platform_iOS_SearchBarRenderer {
}
	-(void) traitCollectionDidChange:(UITraitCollection *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CustomSearchRenderer {
}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xA7FD8);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA83D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_SearchBarRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CustomPageRenderer : Xamarin_Forms_Platform_iOS_EntryRenderer {
}
	-(void) traitCollectionDidChange:(UITraitCollection *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CustomPageRenderer {
}

	-(void) traitCollectionDidChange:(UITraitCollection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0xA84D8);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA88D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_EntryRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_EditTextPopup : UICollectionViewCell {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_EditTextPopup {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xA93D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_HyperlinkAnnotation : UIButton {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_HyperlinkAnnotation {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xA9DD8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_BubbleView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_BubbleView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xAACD8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xAADD8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xAAED8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xAAFD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_InkSetting : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) layoutSubviews;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_InkSetting {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xB43D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB44D8);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xB45D8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB46D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB47D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SelectBorderView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SelectBorderView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xB71D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB72D8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB73D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB74D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SelectionView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SelectionView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB8BD8);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xB8FD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PasswordDialogView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PasswordDialogView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBA6D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SfLabelRendererIOS : Xamarin_Forms_Platform_iOS_LabelRenderer {
}
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SfLabelRendererIOS {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBA9D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_LabelRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SfFontButtonRenderer : Xamarin_Forms_Platform_iOS_ButtonRenderer {
}
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SfFontButtonRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBAED8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ButtonRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SfPdfDocumentViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBAFD8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_MaterialSfPdfDocumentViewRenderer : Syncfusion_SfPdfViewer_XForms_iOS_SfPdfDocumentViewRenderer {
}
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_MaterialSfPdfDocumentViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xBF1D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Syncfusion_SfPdfViewer_XForms_iOS_SfPdfDocumentViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CustomStackLayoutRendereriOS : Xamarin_Forms_Platform_iOS_ViewRenderer_2 {
}
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CustomStackLayoutRendereriOS {
}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xC87D8);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC8AD8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SliderCustomRenderer : Xamarin_Forms_Platform_iOS_SliderRenderer {
}
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SliderCustomRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xC8DD8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_SliderRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ImageAndCanvasContainer : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ImageAndCanvasContainer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCA7D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PageScrollView : UIScrollView<UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PageScrollView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCC5D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PageScrollViewContainer : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PageScrollViewContainer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCDBD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SinglePageViewer : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) canBecomeFirstResponder;
	-(void) layoutSubviews;
	-(BOOL) canPerformAction:(SEL)p0 withSender:(NSObject *)p1;
	-(void) Action_1;
	-(void) Action_2;
	-(void) Action_3;
	-(void) Action_4;
	-(void) Action_5;
	-(void) Action_6;
	-(void) Action_7;
	-(void) Action_8;
	-(void) Action_9;
	-(void) Action_10;
	-(void) CopyAction;
	-(void) HighlightAction;
	-(void) UnderlineAction;
	-(void) StrikeoutAction;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SinglePageViewer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) canBecomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0xCF3D8);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD24D8);
	}

	-(BOOL) canPerformAction:(SEL)p0 withSender:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_171 (self, _cmd, &managed_method, p0, p1, 0xD25D8);
	}

	-(void) Action_1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD2DD8);
	}

	-(void) Action_2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD2ED8);
	}

	-(void) Action_3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD2FD8);
	}

	-(void) Action_4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD30D8);
	}

	-(void) Action_5
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD31D8);
	}

	-(void) Action_6
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD32D8);
	}

	-(void) Action_7
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD33D8);
	}

	-(void) Action_8
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD34D8);
	}

	-(void) Action_9
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD35D8);
	}

	-(void) Action_10
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD36D8);
	}

	-(void) CopyAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD37D8);
	}

	-(void) HighlightAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD38D8);
	}

	-(void) UnderlineAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD39D8);
	}

	-(void) StrikeoutAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD3AD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SfPdfVieweriOS : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SfPdfVieweriOS {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xD64D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PasswordTextFieldDelegate : NSObject<UITextFieldDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) textFieldShouldReturn:(UITextField *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PasswordTextFieldDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) textFieldShouldReturn:(UITextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, 0xD69D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PdfButton : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PdfButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x203D8);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x204D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_StampRendererView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_StampRendererView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x28FD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_SignatureField : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_SignatureField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x3D0D8);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x3D1D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ArrowAnnotationSettings : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ArrowAnnotationSettings {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x423D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x424D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x427D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_CircleAnnotationSettings : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_CircleAnnotationSettings {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x46CD8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x46DD8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x46ED8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_DummyView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_DummyView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x478D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_LineAnnotationSettings : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_LineAnnotationSettings {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x4BFD8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x4C0D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x4C1D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x48AD8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_PolygonAnnotationView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_PolygonAnnotationView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x502D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x507D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_RectangleAnnotationSettings : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_RectangleAnnotationSettings {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x554D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x556D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x557D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ShapeBubbleView : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ShapeBubbleView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x589D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x58AD8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x58BD8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x58CD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ImageViewEx : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) setNeedsDisplay;
	+(Class) layerClass;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ImageViewEx {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) setNeedsDisplay
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x674D8);
	}

	+(Class) layerClass
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_218 (self, _cmd, &managed_method, 0x675D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ScrollHead : UILabel {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ScrollHead {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x688D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x682D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UILabel class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_ScrollViewEx : UIScrollView<UIScrollViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGSize) contentSize;
	-(void) setContentSize:(CGSize)p0;
	-(BOOL) canBecomeFirstResponder;
	-(CGPoint) contentOffset;
	-(void) setContentOffset:(CGPoint)p0;
	-(BOOL) canPerformAction:(SEL)p0 withSender:(NSObject *)p1;
	-(void) layoutSubviews;
	-(void) CopyAction;
	-(void) HighlightAction;
	-(void) UnderlineAction;
	-(void) StrikeoutAction;
	-(void) Action_1;
	-(void) Action_2;
	-(void) Action_3;
	-(void) Action_4;
	-(void) Action_5;
	-(void) Action_6;
	-(void) Action_7;
	-(void) Action_8;
	-(void) Action_9;
	-(void) Action_10;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_ScrollViewEx {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGSize) contentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, 0x690D8);
	}

	-(void) setContentSize:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_149 (self, _cmd, &managed_method, p0, 0x691D8);
	}

	-(BOOL) canBecomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x692D8);
	}

	-(CGPoint) contentOffset
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x693D8);
	}

	-(void) setContentOffset:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x694D8);
	}

	-(BOOL) canPerformAction:(SEL)p0 withSender:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_171 (self, _cmd, &managed_method, p0, p1, 0x7B1D8);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7B6D8);
	}

	-(void) CopyAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7CCD8);
	}

	-(void) HighlightAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7CFD8);
	}

	-(void) UnderlineAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D0D8);
	}

	-(void) StrikeoutAction
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D1D8);
	}

	-(void) Action_1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D2D8);
	}

	-(void) Action_2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D3D8);
	}

	-(void) Action_3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D4D8);
	}

	-(void) Action_4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D5D8);
	}

	-(void) Action_5
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D6D8);
	}

	-(void) Action_6
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D7D8);
	}

	-(void) Action_7
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D8D8);
	}

	-(void) Action_8
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D9D8);
	}

	-(void) Action_9
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7DAD8);
	}

	-(void) Action_10
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7DBD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_StackViewEx : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(NSArray *) subviews;
	-(void) setNeedsDisplay;
	-(void) layoutSubviews;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_StackViewEx {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(NSArray *) subviews
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, 0x8F4D8);
	}

	-(void) setNeedsDisplay
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x909D8);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x90AD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x8F3D8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface TransparentCanvas : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) layoutSubviews;
	-(void) setNeedsDisplay;
	-(void) drawRect:(CGRect)p0;
	-(void) PerformCopy;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation TransparentCanvas {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x9A6D8);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x9A7D8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x9A8D8);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x9A9D8);
	}

	-(void) setNeedsDisplay
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x9AAD8);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x9ABD8);
	}

	-(void) PerformCopy
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x9CDD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@interface Syncfusion_SfPdfViewer_XForms_iOS_InkGroup : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfPdfViewer_XForms_iOS_InkGroup {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xB19D8);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB1AD8);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xB1BD8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xACDD8);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Bubble : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Bubble {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xC82D8);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation SfBusyIndicator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(int) AnimationType
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_223 (self, _cmd, &managed_method, 0x6DA);
	}

	-(void) setAnimationType:(int)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, 0x7DA);
	}

	-(void) awakeFromNib
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x1EDA);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x1FDA);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x20DA);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2DA);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIControl class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfBusyIndicator_iOS_SFBusyIndicator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1DA);
		if (call_super && rv) {
			struct objc_super super = {  rv, [SfBusyIndicator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_XForms_iOS_Graphics_SfGradientViewRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x6DC);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x7DC);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x11DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_XForms_iOS_Shimmer_SfShimmerRenderer {
}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0x27DC);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x28DC);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x2EDC);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x35DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_XForms_iOS_Shimmer_ShimmerViewRenderer : Xamarin_Forms_Platform_iOS_ViewRenderer {
}
	-(id) init;
@end

@implementation Syncfusion_XForms_iOS_Shimmer_ShimmerViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x36DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorderRenderer : Xamarin_Forms_Platform_iOS_ViewRenderer_2 {
}
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(id) init;
@end

@implementation Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorderRenderer {
}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x3ADC);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x3DDC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_XForms_iOS_TextInputLayout_InputLayoutToggleViewRenderer : Xamarin_Forms_Platform_iOS_ViewRenderer_2 {
}
	-(void) layoutSubviews;
	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1;
	-(id) init;
@end

@implementation Syncfusion_XForms_iOS_TextInputLayout_InputLayoutToggleViewRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x40DC);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x44DC);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x45DC);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x46DC);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x47DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_XForms_iOS_TextInputLayout_SfTextInputLayoutRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x58DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorder : UIView {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorder {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x5EDC);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}
@end

@implementation Syncfusion_XForms_iOS_TextInputLayout_InputLayoutClearButtonViewRenderer {
}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x73DC);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x76DC);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x77DC);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x78DC);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x79DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_XForms_iOS_Core_FontIconLabelRenderer : Xamarin_Forms_Platform_iOS_LabelRenderer {
}
	-(id) init;
@end

@implementation Syncfusion_XForms_iOS_Core_FontIconLabelRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x94DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_LabelRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_XForms_iOS_EffectsView_SfEffectsViewLayer : CALayer {
}
	@property (nonatomic, assign) CGFloat rippleradius;
	@property (nonatomic, assign) id rippleColor;
	@property (nonatomic, assign) id selectionColor;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGFloat) rippleradius;
	-(void) setRippleradius:(CGFloat)p0;
	-(id) rippleColor;
	-(void) setRippleColor:(id)p0;
	-(id) selectionColor;
	-(void) setSelectionColor:(id)p0;
	-(CGRect) frame;
	-(void) setFrame:(CGRect)p0;
	+(BOOL) needsDisplayForKey:(NSString *)p0;
	-(void) drawInContext:(id)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
	-(id) initWithLayer:(CALayer *)p0;
@end

@implementation Syncfusion_XForms_iOS_EffectsView_SfEffectsViewLayer {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGFloat) rippleradius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x12EDC);
	}

	-(void) setRippleradius:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x12FDC);
	}

	-(id) rippleColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x130DC);
	}

	-(void) setRippleColor:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x131DC);
	}

	-(id) selectionColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x132DC);
	}

	-(void) setSelectionColor:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x133DC);
	}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0x12ADC);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x12BDC);
	}

	+(BOOL) needsDisplayForKey:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_225 (self, _cmd, &managed_method, p0, 0x136DC);
	}

	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x139DC);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x128DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithLayer:(CALayer *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x129DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL, CALayer *)) objc_msgSendSuper) (&super, @selector (initWithLayer:), p0);
		}
		return rv;
	}
@end

@interface Syncfusion_XForms_iOS_Shimmer_ShimmerWaveLayer : CALayer {
}
	@property (nonatomic, assign) CGPoint rectPosition;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(CGPoint) rectPosition;
	-(void) setRectPosition:(CGPoint)p0;
	+(BOOL) needsDisplayForKey:(NSString *)p0;
	-(void) drawInContext:(id)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
	-(id) initWithLayer:(CALayer *)p0;
@end

@implementation Syncfusion_XForms_iOS_Shimmer_ShimmerWaveLayer {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGPoint) rectPosition
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1DDC);
	}

	-(void) setRectPosition:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x1EDC);
	}

	+(BOOL) needsDisplayForKey:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_225 (self, _cmd, &managed_method, p0, 0x1FDC);
	}

	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x21DC);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x19DC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithLayer:(CALayer *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, &call_super, 0x1ADC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL, CALayer *)) objc_msgSendSuper) (&super, @selector (initWithLayer:), p0);
		}
		return rv;
	}
@end

@implementation Syncfusion_XForms_iOS_Border_SfBorderRenderer {
}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x7FDC);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x8BDC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_XForms_iOS_EffectsView_SfEffectsViewRenderer {
}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0xCBDC);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0xCCDC);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xF5DC);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xF6DC);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xF7DC);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0xF8DC);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x11FDC);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderRenderer {
}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x14DE);
	}

	-(void) touchesMoved:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x15DE);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x16DE);
	}

	-(void) touchesCancelled:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x17DE);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x4DE);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderVisualRenderer : Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderRenderer {
}
	-(id) init;
@end

@implementation Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderVisualRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x18DE);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SfLabelItems {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x2E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SFLabelItems {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x1E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Syncfusion_SfRangeSlider_iOS_SfLabelItems class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SfRangeKnobLayer {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSublayers
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xCE0);
	}

	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xDE0);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation SfRangeSlider {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(CGFloat) Maximum
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x25E0);
	}

	-(void) setMaximum:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x26E0);
	}

	-(CGFloat) Minimum
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x27E0);
	}

	-(void) setMinimum:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x28E0);
	}

	-(CGFloat) TickLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x2BE0);
	}

	-(void) setTickLength:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x2CE0);
	}

	-(CGFloat) Value
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x31E0);
	}

	-(void) setValue:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x32E0);
	}

	-(CGFloat) RangeStart
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x35E0);
	}

	-(void) setRangeStart:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x36E0);
	}

	-(CGFloat) RangeEnd
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x37E0);
	}

	-(void) setRangeEnd:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x38E0);
	}

	-(CGFloat) TickFrequency
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x39E0);
	}

	-(void) setTickFrequency:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x3AE0);
	}

	-(UIColor *) LabelColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x3BE0);
	}

	-(void) setLabelColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x3CE0);
	}

	-(UIColor *) ThumbBorderColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x3DE0);
	}

	-(void) setThumbBorderColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x3EE0);
	}

	-(double) TrackCornerRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_226 (self, _cmd, &managed_method, 0x3FE0);
	}

	-(void) setTrackCornerRadius:(double)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_227 (self, _cmd, &managed_method, p0, 0x40E0);
	}

	-(CGFloat) ThumbBorderThickness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x41E0);
	}

	-(void) setThumbBorderThickness:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x42E0);
	}

	-(UIColor *) TrackColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x43E0);
	}

	-(void) setTrackColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x44E0);
	}

	-(NSString *) LabelFormat
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, 0x45E0);
	}

	-(void) setLabelFormat:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, 0x46E0);
	}

	-(CGFloat) TrackThickness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x49E0);
	}

	-(void) setTrackThickness:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x4AE0);
	}

	-(CGFloat) TrackSelectionThickness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, 0x4BE0);
	}

	-(void) setTrackSelectionThickness:(CGFloat)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, 0x4CE0);
	}

	-(UIColor *) TrackSelectionColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x4DE0);
	}

	-(void) setTrackSelectionColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x4EE0);
	}

	-(UIColor *) KnobColor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x4FE0);
	}

	-(void) setKnobColor:(UIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x50E0);
	}

	-(BOOL) ShowRange
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x5DE0);
	}

	-(void) setShowRange:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x5EE0);
	}

	-(BOOL) ShowValueLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x5FE0);
	}

	-(void) setShowValueLabel:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x60E0);
	}

	-(BOOL) IsDirectionalReversed
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x63E0);
	}

	-(void) setIsDirectionalReversed:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x64E0);
	}

	-(int) Orientation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_223 (self, _cmd, &managed_method, 0x6DE0);
	}

	-(void) setOrientation:(int)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, 0x6EE0);
	}

	-(int) TickPlacement
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_223 (self, _cmd, &managed_method, 0x71E0);
	}

	-(void) setTickPlacement:(int)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, 0x72E0);
	}

	-(int) ValuePlacement
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_223 (self, _cmd, &managed_method, 0x73E0);
	}

	-(void) setValuePlacement:(int)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, 0x74E0);
	}

	-(CGRect) frame
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0x77E0);
	}

	-(void) setFrame:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x78E0);
	}

	-(void) awakeFromNib
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8AE0);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x8BE0);
	}

	-(void) layoutSubviews
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8DE0);
	}

	-(UIView *) hitTest:(CGPoint)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, 0x8EE0);
	}

	-(void) touchesBegan:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x8FE0);
	}

	-(void) touchesEnded:(NSSet *)p0 withEvent:(UIEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, p1, 0x90E0);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xFE0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SFRangeSlider {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEE0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [SfRangeSlider class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SfRangeTickLayer {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xD7E0);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD4E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SfRangeTracker {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xDBE0);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xD8E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SfThumb {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}

	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xDDE0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SFThumb {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xDCE0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Syncfusion_SfRangeSlider_iOS_SfThumb class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SfThumbItem {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) drawRect:(CGRect)p0 forViewPrintFormatter:(UIViewPrintFormatter *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_228 (self, _cmd, &managed_method, p0, p1, 0xEFE0);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xEAE0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [UIView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Syncfusion_SfRangeSlider_iOS_SFThumbItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xE9E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Syncfusion_SfRangeSlider_iOS_SfThumbItem class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfRangeSlider_iOS_CustomRangePanGesture : NSObject<UIGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfRangeSlider_iOS_CustomRangePanGesture {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(BOOL) gestureRecognizer:(UIGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, 0xF0E0);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF1E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Syncfusion_SfRangeSlider_iOS_BalloonLayer : CALayer {
}
	-(GCHandle) xamarinGetGCHandle;
	-(bool) xamarinSetGCHandle: (GCHandle) gchandle flags: (enum XamarinGCHandleFlags) flags;
	-(enum XamarinGCHandleFlags) xamarinGetFlags;
	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags;
	-(void) layoutSublayers;
	-(void) drawInContext:(id)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Syncfusion_SfRangeSlider_iOS_BalloonLayer {
	XamarinObject __monoObjectGCHandle;
}
	-(GCHandle) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(bool) xamarinSetGCHandle: (GCHandle) gc_handle flags: (enum XamarinGCHandleFlags) flags
	{
		if (((flags & XamarinGCHandleFlags_InitialSet) == XamarinGCHandleFlags_InitialSet) && __monoObjectGCHandle.gc_handle != INVALID_GCHANDLE) {
			return false;
		}
		flags = (enum XamarinGCHandleFlags) (flags & ~XamarinGCHandleFlags_InitialSet);
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.flags = flags;
		__monoObjectGCHandle.native_object = self;
		return true;
	}

	-(enum XamarinGCHandleFlags) xamarinGetFlags
	{
		return __monoObjectGCHandle.flags;
	}

	-(void) xamarinSetFlags: (enum XamarinGCHandleFlags) flags
	{
		__monoObjectGCHandle.flags = flags;
	}


	-(void) layoutSublayers
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0xFDE0);
	}

	-(void) drawInContext:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0xFEE0);
	}
	-(BOOL) conformsToProtocol: (void *) protocol
	{
		GCHandle exception_gchandle;
		BOOL rv = xamarin_invoke_conforms_to_protocol (self, (Protocol *) protocol, &exception_gchandle);
		xamarin_process_managed_exception_gchandle (exception_gchandle);
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0xF2E0);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CALayer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation XamForms_Controls_iOS_CalendarButtonRenderer {
}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x2E2);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_8 (self, _cmd, &managed_method, &call_super, 0x7E2);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_iOS_ButtonRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

	static MTClassMap __xamarin_class_map [] = {
		{ NULL, 0x14E222 /* #0 'NSObject' => 'Foundation.NSObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255422 /* #1 'UIResponder' => 'UIKit.UIResponder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x218C22 /* #2 'UIViewController' => 'UIKit.UIViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x216422 /* #3 'UINavigationController' => 'UIKit.UINavigationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x502E /* #4 'Xamarin_Forms_Platform_iOS_NavigationRenderer' => 'Xamarin.Forms.Platform.iOS.NavigationRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x400 /* #5 'HrApp_iOS_CustomNaviPageRenderer' => 'HrApp.iOS.CustomNaviPageRenderer, HrApp.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x522E /* #6 'Xamarin_Forms_Platform_iOS_PageRenderer' => 'Xamarin.Forms.Platform.iOS.PageRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x500 /* #7 'HrApp_iOS_CustomPageRenderer' => 'HrApp.iOS.CustomPageRenderer, HrApp.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x218B22 /* #8 'UIView' => 'UIKit.UIView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144522 /* #9 'WKWebView' => 'WebKit.WKWebView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB22E /* #10 'Xamarin_Forms_Platform_iOS_WkWebViewRenderer' => 'Xamarin.Forms.Platform.iOS.WkWebViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x600 /* #11 'HrApp_iOS_CustomWebViewRenderer' => 'HrApp.iOS.CustomWebViewRenderer, HrApp.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x22CC22 /* #12 'UIApplicationDelegate' => 'UIKit.UIApplicationDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152E /* #13 'Xamarin_Forms_Platform_iOS_FormsApplicationDelegate' => 'Xamarin.Forms.Platform.iOS.FormsApplicationDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x800 /* #14 'AppDelegate' => 'HrApp.iOS.AppDelegate, HrApp.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x900 /* #15 'MyViewController' => 'HrApp.iOS.MyViewController, HrApp.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x822 /* #16 'VNDocumentCameraScan' => 'VisionKit.VNDocumentCameraScan, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x922 /* #17 'VNDocumentCameraViewController' => 'VisionKit.VNDocumentCameraViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD22 /* #18 'Xamarin_iOS__VisionKit_VNDocumentCameraViewControllerDelegate' => 'VisionKit.VNDocumentCameraViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1822 /* #19 'UTType' => 'UniformTypeIdentifiers.UTType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F22 /* #20 'WCSession' => 'WatchConnectivity.WCSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2422 /* #21 'WCSessionDelegate' => 'WatchConnectivity.WCSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2522 /* #22 'WCSessionFile' => 'WatchConnectivity.WCSessionFile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2622 /* #23 'WCSessionFileTransfer' => 'WatchConnectivity.WCSessionFileTransfer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2722 /* #24 'WCSessionUserInfoTransfer' => 'WatchConnectivity.WCSessionUserInfoTransfer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2822 /* #25 'SFAcousticFeature' => 'Speech.SFAcousticFeature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B22 /* #26 'SFSpeechRecognitionRequest' => 'Speech.SFSpeechRecognitionRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2922 /* #27 'SFSpeechAudioBufferRecognitionRequest' => 'Speech.SFSpeechAudioBufferRecognitionRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A22 /* #28 'SFSpeechRecognitionMetadata' => 'Speech.SFSpeechRecognitionMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C22 /* #29 'SFSpeechRecognitionResult' => 'Speech.SFSpeechRecognitionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D22 /* #30 'SFSpeechRecognitionTask' => 'Speech.SFSpeechRecognitionTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3122 /* #31 'SFSpeechRecognitionTaskDelegate' => 'Speech.SFSpeechRecognitionTaskDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3422 /* #32 'SFSpeechRecognizer' => 'Speech.SFSpeechRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3922 /* #33 'SFSpeechRecognizerDelegate' => 'Speech.SFSpeechRecognizerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3A22 /* #34 'SFSpeechURLRecognitionRequest' => 'Speech.SFSpeechUrlRecognitionRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3B22 /* #35 'SFTranscription' => 'Speech.SFTranscription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3C22 /* #36 'SFTranscriptionSegment' => 'Speech.SFTranscriptionSegment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D22 /* #37 'SFVoiceAnalytics' => 'Speech.SFVoiceAnalytics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F22 /* #38 'SNAudioStreamAnalyzer' => 'SoundAnalysis.SNAudioStreamAnalyzer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4022 /* #39 'SNClassification' => 'SoundAnalysis.SNClassification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4122 /* #40 'SNClassificationResult' => 'SoundAnalysis.SNClassificationResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4422 /* #41 'SNClassifySoundRequest' => 'SoundAnalysis.SNClassifySoundRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D22 /* #42 'SWHighlight' => 'SharedWithYou.SWHighlight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6722 /* #43 'SWCollaborationHighlight' => 'SharedWithYou.SWCollaborationHighlight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C22 /* #44 'Xamarin_iOS__SharedWithYou_SWCollaborationViewDelegate' => 'SharedWithYou.SWCollaborationViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7122 /* #45 'Xamarin_iOS__SharedWithYou_SWHighlightCenterDelegate' => 'SharedWithYou.SWHighlightCenterDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7322 /* #46 'SWHighlightChangeEvent' => 'SharedWithYou.SWHighlightChangeEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7722 /* #47 'SWHighlightMembershipEvent' => 'SharedWithYou.SWHighlightMembershipEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7922 /* #48 'SWHighlightMentionEvent' => 'SharedWithYou.SWHighlightMentionEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7A22 /* #49 'SWHighlightPersistenceEvent' => 'SharedWithYou.SWHighlightPersistenceEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C22 /* #50 'SWRemoveParticipantAlertController' => 'SharedWithYou.SWRemoveParticipantAlertController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7D22 /* #51 'STScreenTimeConfiguration' => 'ScreenTime.STScreenTimeConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E22 /* #52 'STScreenTimeConfigurationObserver' => 'ScreenTime.STScreenTimeConfigurationObserver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F22 /* #53 'STWebHistory' => 'ScreenTime.STWebHistory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8022 /* #54 'STWebpageController' => 'ScreenTime.STWebpageController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8322 /* #55 'SFAuthenticationSession' => 'SafariServices.SFAuthenticationSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8722 /* #56 'SFContentBlockerState' => 'SafariServices.SFContentBlockerState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8B22 /* #57 'SFSafariViewController' => 'SafariServices.SFSafariViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C22 /* #58 'SFSafariViewControllerActivityButton' => 'SafariServices.SFSafariViewControllerActivityButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D22 /* #59 'SFSafariViewControllerConfiguration' => 'SafariServices.SFSafariViewControllerConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9222 /* #60 'SFSafariViewControllerDelegate' => 'SafariServices.SFSafariViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9422 /* #61 'SFSafariViewControllerPrewarmingToken' => 'SafariServices.SFSafariViewControllerPrewarmingToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9522 /* #62 'SSReadingList' => 'SafariServices.SSReadingList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B22 /* #63 'QLThumbnailGenerationRequest' => 'QuickLookThumbnailing.QLThumbnailGenerationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F22 /* #64 'QLThumbnailRepresentation' => 'QuickLookThumbnailing.QLThumbnailRepresentation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA122 /* #65 'QLFilePreviewRequest' => 'QuickLook.QLFilePreviewRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA222 /* #66 'QLFileThumbnailRequest' => 'QuickLook.QLFileThumbnailRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA822 /* #67 'QLPreviewControllerDataSource' => 'QuickLook.QLPreviewControllerDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAC22 /* #68 'QLPreviewControllerDelegate' => 'QuickLook.QLPreviewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB222 /* #69 'QLPreviewItem' => 'QuickLook.QLPreviewItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB422 /* #70 'QLPreviewProvider' => 'QuickLook.QLPreviewProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB522 /* #71 'QLPreviewReply' => 'QuickLook.QLPreviewReply, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB622 /* #72 'QLPreviewReplyAttachment' => 'QuickLook.QLPreviewReplyAttachment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x270A22 /* #73 'UIWindowSceneActivationConfiguration' => 'UIKit.UIWindowSceneActivationConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB722 /* #74 'QLPreviewSceneActivationConfiguration' => 'QuickLook.QLPreviewSceneActivationConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB822 /* #75 'QLPreviewSceneOptions' => 'QuickLook.QLPreviewSceneOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB922 /* #76 'QLThumbnailProvider' => 'QuickLook.QLThumbnailProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBA22 /* #77 'QLThumbnailReply' => 'QuickLook.QLThumbnailReply, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD722 /* #78 'PKPushCredentials' => 'PushKit.PKPushCredentials, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD822 /* #79 'PKPushPayload' => 'PushKit.PKPushPayload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD922 /* #80 'PKPushRegistry' => 'PushKit.PKPushRegistry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDD22 /* #81 'PKPushRegistryDelegate' => 'PushKit.PKPushRegistryDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE122 /* #82 'PHContentEditingController' => 'PhotosUI.PHContentEditingController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157422 /* #83 'NSExtensionContext' => 'Foundation.NSExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE222 /* #84 'PHEditingExtensionContext' => 'PhotosUI.PHEditingExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE822 /* #85 'PHLivePhotoViewDelegate' => 'PhotosUI.PHLivePhotoViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEB22 /* #86 'PHPickerConfiguration' => 'PhotosUI.PHPickerConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEE22 /* #87 'PHPickerFilter' => 'PhotosUI.PHPickerFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF22 /* #88 'PHPickerResult' => 'PhotosUI.PHPickerResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF022 /* #89 'PHPickerViewController' => 'PhotosUI.PHPickerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF322 /* #90 'Xamarin_iOS__PhotosUI_PHPickerViewControllerDelegate' => 'PhotosUI.PHPickerViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B22 /* #91 'Xamarin_iOS__PencilKit_PKCanvasViewDelegate' => 'PencilKit.PKCanvasViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D22 /* #92 'PKDrawing' => 'PencilKit.PKDrawing, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15922 /* #93 'PKTool' => 'PencilKit.PKTool, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E22 /* #94 'PKEraserTool' => 'PencilKit.PKEraserTool, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15022 /* #95 'PKFloatRange' => 'PencilKit.PKFloatRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15122 /* #96 'PKInk' => 'PencilKit.PKInk, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15222 /* #97 'PKInkingTool' => 'PencilKit.PKInkingTool, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15522 /* #98 'PKLassoTool' => 'PencilKit.PKLassoTool, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15622 /* #99 'PKStroke' => 'PencilKit.PKStroke, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15722 /* #100 'PKStrokePath' => 'PencilKit.PKStrokePath, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15822 /* #101 'PKStrokePoint' => 'PencilKit.PKStrokePoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15A22 /* #102 'PKToolPicker' => 'PencilKit.PKToolPicker, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F22 /* #103 'OSLogEntry' => 'OSLog.OSLogEntry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16022 /* #104 'OSLogEntryActivity' => 'OSLog.OSLogEntryActivity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16122 /* #105 'OSLogEntryBoundary' => 'OSLog.OSLogEntryBoundary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16422 /* #106 'OSLogEntryLog' => 'OSLog.OSLogEntryLog, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16622 /* #107 'OSLogEntrySignpost' => 'OSLog.OSLogEntrySignpost, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157122 /* #108 'NSEnumerator' => 'Foundation.NSEnumerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16B22 /* #109 'OSLogEnumerator' => 'OSLog.OSLogEnumerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16D22 /* #110 'OSLogMessageComponent' => 'OSLog.OSLogMessageComponent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16F22 /* #111 'OSLogPosition' => 'OSLog.OSLogPosition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17022 /* #112 'OSLogStore' => 'OSLog.OSLogStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17322 /* #113 'NCWidgetController' => 'NotificationCenter.NCWidgetController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17822 /* #114 'NCWidgetProviding' => 'NotificationCenter.NCWidgetProviding, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17C22 /* #115 'NKAssetDownload' => 'NewsstandKit.NKAssetDownload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17F22 /* #116 'NKLibrary' => 'NewsstandKit.NKLibrary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18122 /* #117 'MSMessage' => 'Messages.MSMessage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18422 /* #118 'MSMessageLayout' => 'Messages.MSMessageLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18522 /* #119 'MSMessageLiveLayout' => 'Messages.MSMessageLiveLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18A22 /* #120 'MSMessagesAppViewController' => 'Messages.MSMessagesAppViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B22 /* #121 'MSMessageTemplateLayout' => 'Messages.MSMessageTemplateLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C22 /* #122 'MSSession' => 'Messages.MSSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18D22 /* #123 'MSSticker' => 'Messages.MSSticker, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18F22 /* #124 'MSStickerBrowserViewController' => 'Messages.MSStickerBrowserViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19222 /* #125 'MSStickerBrowserViewDataSource' => 'Messages.MSStickerBrowserViewDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19A22 /* #126 'LAAuthenticationRequirement' => 'LocalAuthentication.LAAuthenticationRequirement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19B22 /* #127 'LABiometryFallbackRequirement' => 'LocalAuthentication.LABiometryFallbackRequirement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A322 /* #128 'LARight' => 'LocalAuthentication.LARight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F22 /* #129 'LAPersistedRight' => 'LocalAuthentication.LAPersistedRight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B322 /* #130 'LPLinkMetadata' => 'LinkPresentation.LPLinkMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B922 /* #131 'Xamarin_iOS__IntentsUI_INUIAddVoiceShortcutButtonDelegate' => 'IntentsUI.INUIAddVoiceShortcutButtonDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB22 /* #132 'INUIAddVoiceShortcutViewController' => 'IntentsUI.INUIAddVoiceShortcutViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BE22 /* #133 'Xamarin_iOS__IntentsUI_INUIAddVoiceShortcutViewControllerDelegate' => 'IntentsUI.INUIAddVoiceShortcutViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BF22 /* #134 'INUIEditVoiceShortcutViewController' => 'IntentsUI.INUIEditVoiceShortcutViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C222 /* #135 'Xamarin_iOS__IntentsUI_INUIEditVoiceShortcutViewControllerDelegate' => 'IntentsUI.INUIEditVoiceShortcutViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD22 /* #136 'ILClassificationUIExtensionContext' => 'IdentityLookupUI.ILClassificationUIExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE22 /* #137 'ILClassificationUIExtensionViewController' => 'IdentityLookupUI.ILClassificationUIExtensionViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D222 /* #138 'ILClassificationRequest' => 'IdentityLookup.ILClassificationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF22 /* #139 'ILCallClassificationRequest' => 'IdentityLookup.ILCallClassificationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D422 /* #140 'ILCommunication' => 'IdentityLookup.ILCommunication, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D022 /* #141 'ILCallCommunication' => 'IdentityLookup.ILCallCommunication, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D322 /* #142 'ILClassificationResponse' => 'IdentityLookup.ILClassificationResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D522 /* #143 'ILMessageClassificationRequest' => 'IdentityLookup.ILMessageClassificationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D622 /* #144 'ILMessageCommunication' => 'IdentityLookup.ILMessageCommunication, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DA22 /* #145 'ILMessageFilterCapabilitiesQueryRequest' => 'IdentityLookup.ILMessageFilterCapabilitiesQueryRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DE22 /* #146 'ILMessageFilterExtension' => 'IdentityLookup.ILMessageFilterExtension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E222 /* #147 'ILMessageFilterQueryRequest' => 'IdentityLookup.ILMessageFilterQueryRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E322 /* #148 'ILMessageFilterQueryResponse' => 'IdentityLookup.ILMessageFilterQueryResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E522 /* #149 'ILNetworkResponse' => 'IdentityLookup.ILNetworkResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E722 /* #150 'FPUIActionExtensionContext' => 'FileProviderUI.FPUIActionExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E822 /* #151 'FPUIActionExtensionViewController' => 'FileProviderUI.FPUIActionExtensionViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EF22 /* #152 'EAAccessoryDelegate' => 'ExternalAccessory.EAAccessoryDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F322 /* #153 'EASession' => 'ExternalAccessory.EASession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F422 /* #154 'EAWiFiUnconfiguredAccessory' => 'ExternalAccessory.EAWiFiUnconfiguredAccessory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FB22 /* #155 'EAWiFiUnconfiguredAccessoryBrowserDelegate' => 'ExternalAccessory.EAWiFiUnconfiguredAccessoryBrowserDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25722 /* #156 'CHHapticDynamicParameter' => 'CoreHaptics.CHHapticDynamicParameter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25E22 /* #157 'CHHapticEvent' => 'CoreHaptics.CHHapticEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25F22 /* #158 'CHHapticEventParameter' => 'CoreHaptics.CHHapticEventParameter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26622 /* #159 'CHHapticParameterCurve' => 'CoreHaptics.CHHapticParameterCurve, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26722 /* #160 'CHHapticParameterCurveControlPoint' => 'CoreHaptics.CHHapticParameterCurveControlPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26822 /* #161 'CHHapticPattern' => 'CoreHaptics.CHHapticPattern, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26D22 /* #162 'AUAudioUnitViewConfiguration' => 'CoreAudioKit.AUAudioUnitViewConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26F22 /* #163 'AUGenericViewController' => 'CoreAudioKit.AUGenericViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27022 /* #164 'AUViewController' => 'CoreAudioKit.AUViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x260E22 /* #165 'UITableViewController' => 'UIKit.UITableViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27122 /* #166 'CABTMIDICentralViewController' => 'CoreAudioKit.CABTMidiCentralViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27222 /* #167 'CABTMIDILocalPeripheralViewController' => 'CoreAudioKit.CABTMidiLocalPeripheralViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27822 /* #168 'CNContactPickerDelegate' => 'ContactsUI.CNContactPickerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27922 /* #169 'CNContactPickerViewController' => 'ContactsUI.CNContactPickerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27A22 /* #170 'CNContactViewController' => 'ContactsUI.CNContactViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E22 /* #171 'CNContactViewControllerDelegate' => 'ContactsUI.CNContactViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28322 /* #172 'BGTask' => 'BackgroundTasks.BGTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27F22 /* #173 'BGAppRefreshTask' => 'BackgroundTasks.BGAppRefreshTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28422 /* #174 'BGTaskRequest' => 'BackgroundTasks.BGTaskRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28022 /* #175 'BGAppRefreshTaskRequest' => 'BackgroundTasks.BGAppRefreshTaskRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28122 /* #176 'BGProcessingTask' => 'BackgroundTasks.BGProcessingTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28222 /* #177 'BGProcessingTaskRequest' => 'BackgroundTasks.BGProcessingTaskRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28822 /* #178 'AEAssessmentApplication' => 'AutomaticAssessmentConfiguration.AEAssessmentApplication, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28922 /* #179 'AEAssessmentConfiguration' => 'AutomaticAssessmentConfiguration.AEAssessmentConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28C22 /* #180 'AEAssessmentParticipantConfiguration' => 'AutomaticAssessmentConfiguration.AEAssessmentParticipantConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28D22 /* #181 'AEAssessmentSession' => 'AutomaticAssessmentConfiguration.AEAssessmentSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29122 /* #182 'Xamarin_iOS__AutomaticAssessmentConfiguration_AEAssessmentSessionDelegate' => 'AutomaticAssessmentConfiguration.AEAssessmentSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29822 /* #183 'AAAttribution' => 'AdServices.AAAttribution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A022 /* #184 'iAd_ADBannerViewDelegate' => 'iAd.ADBannerViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x2A322 /* #185 'iAd_ADInterstitialAd' => 'iAd.ADInterstitialAd, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x2A722 /* #186 'iAd_ADInterstitialAdDelegate' => 'iAd.ADInterstitialAdDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x2A822 /* #187 'iAd_ADInterstitialAdPresentationViewController' => 'iAd.ADInterstitialAdPresentationViewController, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x2D022 /* #188 'VNCircle' => 'Vision.VNCircle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D122 /* #189 'VNRequest' => 'Vision.VNRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32B22 /* #190 'VNImageBasedRequest' => 'Vision.VNImageBasedRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D222 /* #191 'VNDetectBarcodesRequest' => 'Vision.VNDetectBarcodesRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33322 /* #192 'VNObservation' => 'Vision.VNObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D422 /* #193 'VNFeaturePrintObservation' => 'Vision.VNFeaturePrintObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D722 /* #194 'VNGeometryUtils' => 'Vision.VNGeometryUtils, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D822 /* #195 'VNVector' => 'Vision.VNVector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2EF22 /* #196 'VNDetectedObjectObservation' => 'Vision.VNDetectedObjectObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x34022 /* #197 'VNRectangleObservation' => 'Vision.VNRectangleObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DD22 /* #198 'VNBarcodeObservation' => 'Vision.VNBarcodeObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E122 /* #199 'VNClassificationObservation' => 'Vision.VNClassificationObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E222 /* #200 'VNClassifyImageRequest' => 'Vision.VNClassifyImageRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E422 /* #201 'VNContour' => 'Vision.VNContour, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E522 /* #202 'VNContoursObservation' => 'Vision.VNContoursObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E622 /* #203 'VNCoreMLFeatureValueObservation' => 'Vision.VNCoreMLFeatureValueObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E722 /* #204 'VNCoreMLModel' => 'Vision.VNCoreMLModel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E822 /* #205 'VNCoreMLRequest' => 'Vision.VNCoreMLRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2EC22 /* #206 'VNDetectContoursRequest' => 'Vision.VNDetectContoursRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2ED22 /* #207 'VNDetectDocumentSegmentationRequest' => 'Vision.VNDetectDocumentSegmentationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33522 /* #208 'VNPoint' => 'Vision.VNPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F122 /* #209 'VNDetectedPoint' => 'Vision.VNDetectedPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F222 /* #210 'VNDetectFaceCaptureQualityRequest' => 'Vision.VNDetectFaceCaptureQualityRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F422 /* #211 'VNDetectFaceLandmarksRequest' => 'Vision.VNDetectFaceLandmarksRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F622 /* #212 'VNDetectFaceRectanglesRequest' => 'Vision.VNDetectFaceRectanglesRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F822 /* #213 'VNDetectHorizonRequest' => 'Vision.VNDetectHorizonRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2FE22 /* #214 'VNDetectHumanRectanglesRequest' => 'Vision.VNDetectHumanRectanglesRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30022 /* #215 'VNDetectRectanglesRequest' => 'Vision.VNDetectRectanglesRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30222 /* #216 'VNDetectTextRectanglesRequest' => 'Vision.VNDetectTextRectanglesRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x34C22 /* #217 'VNStatefulRequest' => 'Vision.VNStatefulRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30422 /* #218 'VNDetectTrajectoriesRequest' => 'Vision.VNDetectTrajectoriesRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30922 /* #219 'VNFaceLandmarkRegion' => 'Vision.VNFaceLandmarkRegion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30A22 /* #220 'VNFaceLandmarks' => 'Vision.VNFaceLandmarks, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30B22 /* #221 'VNFaceLandmarks2D' => 'Vision.VNFaceLandmarks2D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30C22 /* #222 'VNFaceObservation' => 'Vision.VNFaceObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31022 /* #223 'VNGenerateAttentionBasedSaliencyImageRequest' => 'Vision.VNGenerateAttentionBasedSaliencyImageRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31222 /* #224 'VNGenerateImageFeaturePrintRequest' => 'Vision.VNGenerateImageFeaturePrintRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31422 /* #225 'VNGenerateObjectnessBasedSaliencyImageRequest' => 'Vision.VNGenerateObjectnessBasedSaliencyImageRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x34E22 /* #226 'VNTargetedImageRequest' => 'Vision.VNTargetedImageRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31622 /* #227 'VNGenerateOpticalFlowRequest' => 'Vision.VNGenerateOpticalFlowRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31922 /* #228 'VNGeneratePersonSegmentationRequest' => 'Vision.VNGeneratePersonSegmentationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33022 /* #229 'VNImageRegistrationRequest' => 'Vision.VNImageRegistrationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31C22 /* #230 'VNHomographicImageRegistrationRequest' => 'Vision.VNHomographicImageRegistrationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31E22 /* #231 'VNHorizonObservation' => 'Vision.VNHorizonObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32922 /* #232 'VNHumanObservation' => 'Vision.VNHumanObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32A22 /* #233 'VNImageAlignmentObservation' => 'Vision.VNImageAlignmentObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32D22 /* #234 'VNImageHomographicAlignmentObservation' => 'Vision.VNImageHomographicAlignmentObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33122 /* #235 'VNImageRequestHandler' => 'Vision.VNImageRequestHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33222 /* #236 'VNImageTranslationAlignmentObservation' => 'Vision.VNImageTranslationAlignmentObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33422 /* #237 'VNPixelBufferObservation' => 'Vision.VNPixelBufferObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33922 /* #238 'VNRecognizedObjectObservation' => 'Vision.VNRecognizedObjectObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33B22 /* #239 'VNRecognizedPoint' => 'Vision.VNRecognizedPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33C22 /* #240 'VNRecognizedText' => 'Vision.VNRecognizedText, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33D22 /* #241 'VNRecognizedTextObservation' => 'Vision.VNRecognizedTextObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33E22 /* #242 'VNRecognizeTextRequest' => 'Vision.VNRecognizeTextRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x34A22 /* #243 'VNSaliencyImageObservation' => 'Vision.VNSaliencyImageObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x34B22 /* #244 'VNSequenceRequestHandler' => 'Vision.VNSequenceRequestHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x34F22 /* #245 'VNTextObservation' => 'Vision.VNTextObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35122 /* #246 'VNTrackingRequest' => 'Vision.VNTrackingRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35222 /* #247 'VNTrackObjectRequest' => 'Vision.VNTrackObjectRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35422 /* #248 'VNTrackRectangleRequest' => 'Vision.VNTrackRectangleRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35622 /* #249 'VNTrajectoryObservation' => 'Vision.VNTrajectoryObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35722 /* #250 'VNTranslationalImageRegistrationRequest' => 'Vision.VNTranslationalImageRegistrationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35922 /* #251 'VNVideoProcessor' => 'Vision.VNVideoProcessor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35A22 /* #252 'VNVideoProcessorCadence' => 'Vision.VNVideoProcessorCadence, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35B22 /* #253 'VNVideoProcessorFrameRateCadence' => 'Vision.VNVideoProcessorFrameRateCadence, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35C22 /* #254 'VNVideoProcessorRequestProcessingOptions' => 'Vision.VNVideoProcessorRequestProcessingOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x35D22 /* #255 'VNVideoProcessorTimeIntervalCadence' => 'Vision.VNVideoProcessorTimeIntervalCadence, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x39C22 /* #256 'VSAccountMetadataRequest' => 'VideoSubscriberAccount.VSAccountMetadataRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x39F22 /* #257 'VSAccountApplicationProvider' => 'VideoSubscriberAccount.VSAccountApplicationProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3A422 /* #258 'VSAccountManagerDelegate' => 'VideoSubscriberAccount.VSAccountManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3A522 /* #259 'VSAccountManagerResult' => 'VideoSubscriberAccount.VSAccountManagerResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3A622 /* #260 'VSAccountMetadata' => 'VideoSubscriberAccount.VSAccountMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3A822 /* #261 'VSAccountProviderResponse' => 'VideoSubscriberAccount.VSAccountProviderResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3AF22 /* #262 'VSSubscription' => 'VideoSubscriberAccount.VSSubscription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3B122 /* #263 'VSSubscriptionRegistrationCenter' => 'VideoSubscriberAccount.VSSubscriptionRegistrationCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3B222 /* #264 'VSUserAccount' => 'VideoSubscriberAccount.VSUserAccount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3B722 /* #265 'UNNotificationAttachment' => 'UserNotifications.UNNotificationAttachment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D422 /* #266 'UNNotificationTrigger' => 'UserNotifications.UNNotificationTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3BB22 /* #267 'UNCalendarNotificationTrigger' => 'UserNotifications.UNCalendarNotificationTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3BE22 /* #268 'UNLocationNotificationTrigger' => 'UserNotifications.UNLocationNotificationTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3C922 /* #269 'UNNotificationContent' => 'UserNotifications.UNNotificationContent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3BF22 /* #270 'UNMutableNotificationContent' => 'UserNotifications.UNMutableNotificationContent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3C022 /* #271 'UNNotification' => 'UserNotifications.UNNotification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3C122 /* #272 'UNNotificationAction' => 'UserNotifications.UNNotificationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3C222 /* #273 'UNNotificationActionIcon' => 'UserNotifications.UNNotificationActionIcon, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3C722 /* #274 'UNNotificationCategory' => 'UserNotifications.UNNotificationCategory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3CE22 /* #275 'UNNotificationRequest' => 'UserNotifications.UNNotificationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3CF22 /* #276 'UNNotificationResponse' => 'UserNotifications.UNNotificationResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D022 /* #277 'UNNotificationServiceExtension' => 'UserNotifications.UNNotificationServiceExtension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D222 /* #278 'UNNotificationSettings' => 'UserNotifications.UNNotificationSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D322 /* #279 'UNNotificationSound' => 'UserNotifications.UNNotificationSound, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D522 /* #280 'UNPushNotificationTrigger' => 'UserNotifications.UNPushNotificationTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D722 /* #281 'UNTextInputNotificationAction' => 'UserNotifications.UNTextInputNotificationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D822 /* #282 'UNTextInputNotificationResponse' => 'UserNotifications.UNTextInputNotificationResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D922 /* #283 'UNTimeIntervalNotificationTrigger' => 'UserNotifications.UNTimeIntervalNotificationTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3DE22 /* #284 'UNUserNotificationCenterDelegate' => 'UserNotifications.UNUserNotificationCenterDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3E122 /* #285 'TWTweetComposeViewController' => 'Twitter.TWTweetComposeViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42F22 /* #286 'SKRequest' => 'StoreKit.SKRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3EC22 /* #287 'SKReceiptRefreshRequest' => 'StoreKit.SKReceiptRefreshRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41022 /* #288 'SKOverlayConfiguration' => 'StoreKit.SKOverlayConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3EE22 /* #289 'SKOverlayAppClipConfiguration' => 'StoreKit.SKOverlayAppClipConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3EF22 /* #290 'SKOverlayAppConfiguration' => 'StoreKit.SKOverlayAppConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F022 /* #291 'SKPayment' => 'StoreKit.SKPayment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F122 /* #292 'SKPaymentTransactionObserver' => 'StoreKit.SKPaymentTransactionObserver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F622 /* #293 'SKAdImpression' => 'StoreKit.SKAdImpression, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3FC22 /* #294 'SKArcadeService' => 'StoreKit.SKArcadeService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40922 /* #295 'SKCloudServiceSetupViewControllerDelegate' => 'StoreKit.SKCloudServiceSetupViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40A22 /* #296 'SKDownload' => 'StoreKit.SKDownload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40E22 /* #297 'SKMutablePayment' => 'StoreKit.SKMutablePayment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40F22 /* #298 'SKOverlay' => 'StoreKit.SKOverlay, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41422 /* #299 'Xamarin_iOS__StoreKit_SKOverlayDelegate' => 'StoreKit.SKOverlayDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41622 /* #300 'SKOverlayTransitionContext' => 'StoreKit.SKOverlayTransitionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41722 /* #301 'SKPaymentDiscount' => 'StoreKit.SKPaymentDiscount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41822 /* #302 'SKPaymentQueue' => 'StoreKit.SKPaymentQueue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41C22 /* #303 'Xamarin_iOS__StoreKit_SKPaymentQueueDelegate' => 'StoreKit.SKPaymentQueueDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41D22 /* #304 'SKPaymentTransaction' => 'StoreKit.SKPaymentTransaction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42122 /* #305 'SKProduct' => 'StoreKit.SKProduct, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42222 /* #306 'SKProductDiscount' => 'StoreKit.SKProductDiscount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43422 /* #307 'SKRequestDelegate' => 'StoreKit.SKRequestDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42A22 /* #308 'SKProductsRequestDelegate' => 'StoreKit.SKProductsRequestDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42B22 /* #309 'SKProductsResponse' => 'StoreKit.SKProductsResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42E22 /* #310 'SKProductSubscriptionPeriod' => 'StoreKit.SKProductSubscriptionPeriod, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43522 /* #311 'SKStorefront' => 'StoreKit.SKStorefront, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43B22 /* #312 'SKStoreProductViewControllerDelegate' => 'StoreKit.SKStoreProductViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43C22 /* #313 'SKStoreReviewController' => 'StoreKit.SKStoreReviewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43F22 /* #314 'SKAction' => 'SpriteKit.SKAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44322 /* #315 'SKNode' => 'SpriteKit.SKNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44122 /* #316 'SKFieldNode' => 'SpriteKit.SKFieldNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44222 /* #317 'SKKeyframeSequence' => 'SpriteKit.SKKeyframeSequence, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44422 /* #318 'SKShapeNode' => 'SpriteKit.SKShapeNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44522 /* #319 'SKUniform' => 'SpriteKit.SKUniform, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44622 /* #320 'SKVideoNode' => 'SpriteKit.SKVideoNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x48F22 /* #321 'SKWarpGeometry' => 'SpriteKit.SKWarpGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44722 /* #322 'SKWarpGeometryGrid' => 'SpriteKit.SKWarpGeometryGrid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44822 /* #323 'SK3DNode' => 'SpriteKit.SK3DNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44A22 /* #324 'SKAttribute' => 'SpriteKit.SKAttribute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44C22 /* #325 'SKAttributeValue' => 'SpriteKit.SKAttributeValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44D22 /* #326 'SKAudioNode' => 'SpriteKit.SKAudioNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44F22 /* #327 'SKCameraNode' => 'SpriteKit.SKCameraNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45022 /* #328 'SKConstraint' => 'SpriteKit.SKConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45122 /* #329 'SKCropNode' => 'SpriteKit.SKCropNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45222 /* #330 'SKEffectNode' => 'SpriteKit.SKEffectNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45322 /* #331 'SKEmitterNode' => 'SpriteKit.SKEmitterNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45622 /* #332 'SKLabelNode' => 'SpriteKit.SKLabelNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45822 /* #333 'SKLightNode' => 'SpriteKit.SKLightNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47822 /* #334 'SKTexture' => 'SpriteKit.SKTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45922 /* #335 'SKMutableTexture' => 'SpriteKit.SKMutableTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45D22 /* #336 'SKPhysicsBody' => 'SpriteKit.SKPhysicsBody, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45E22 /* #337 'SKPhysicsContact' => 'SpriteKit.SKPhysicsContact, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46222 /* #338 'SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsContactDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46322 /* #339 'SKPhysicsJoint' => 'SpriteKit.SKPhysicsJoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46422 /* #340 'SKPhysicsJointFixed' => 'SpriteKit.SKPhysicsJointFixed, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46522 /* #341 'SKPhysicsJointLimit' => 'SpriteKit.SKPhysicsJointLimit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46622 /* #342 'SKPhysicsJointPin' => 'SpriteKit.SKPhysicsJointPin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46722 /* #343 'SKPhysicsJointSliding' => 'SpriteKit.SKPhysicsJointSliding, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46822 /* #344 'SKPhysicsJointSpring' => 'SpriteKit.SKPhysicsJointSpring, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46A22 /* #345 'SKRange' => 'SpriteKit.SKRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46B22 /* #346 'SKReachConstraints' => 'SpriteKit.SKReachConstraints, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46C22 /* #347 'SKReferenceNode' => 'SpriteKit.SKReferenceNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46D22 /* #348 'SKRegion' => 'SpriteKit.SKRegion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46E22 /* #349 'SKRenderer' => 'SpriteKit.SKRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47022 /* #350 'SKScene' => 'SpriteKit.SKScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47422 /* #351 'SKSceneDelegate' => 'SpriteKit.SKSceneDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47622 /* #352 'SKShader' => 'SpriteKit.SKShader, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47722 /* #353 'SKSpriteNode' => 'SpriteKit.SKSpriteNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47D22 /* #354 'SKTileDefinition' => 'SpriteKit.SKTileDefinition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47F22 /* #355 'SKTileGroup' => 'SpriteKit.SKTileGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x48022 /* #356 'SKTileGroupRule' => 'SpriteKit.SKTileGroupRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x48122 /* #357 'SKTileMapNode' => 'SpriteKit.SKTileMapNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x48222 /* #358 'SKTileSet' => 'SpriteKit.SKTileSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x48422 /* #359 'SKTransformNode' => 'SpriteKit.SKTransformNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x48522 /* #360 'SKTransition' => 'SpriteKit.SKTransition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x48C22 /* #361 'SKViewDelegate' => 'SpriteKit.SKViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49822 /* #362 'SLComposeSheetConfigurationItem' => 'Social.SLComposeSheetConfigurationItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49922 /* #363 'SLComposeViewController' => 'Social.SLComposeViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49B22 /* #364 'SLComposeServiceViewController' => 'Social.SLComposeServiceViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C322 /* #365 'SWAction' => 'SharedWithYouCore.SWAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C622 /* #366 'SWCollaborationCoordinator' => 'SharedWithYouCore.SWCollaborationCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C722 /* #367 'SWCollaborationOption' => 'SharedWithYouCore.SWCollaborationOption, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C822 /* #368 'SWCollaborationOptionsGroup' => 'SharedWithYouCore.SWCollaborationOptionsGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C922 /* #369 'SWCollaborationOptionsPickerGroup' => 'SharedWithYouCore.SWCollaborationOptionsPickerGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CA22 /* #370 'SWCollaborationShareOptions' => 'SharedWithYouCore.SWCollaborationShareOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CB22 /* #371 'SWPerson' => 'SharedWithYouCore.SWPerson, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CC22 /* #372 'SWPersonIdentity' => 'SharedWithYouCore.SWPersonIdentity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CD22 /* #373 'SWPersonIdentityProof' => 'SharedWithYouCore.SWPersonIdentityProof, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CE22 /* #374 'SWSignedPersonIdentityProof' => 'SharedWithYouCore.SWSignedPersonIdentityProof, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CF22 /* #375 'SWStartCollaborationAction' => 'SharedWithYouCore.SWStartCollaborationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D022 /* #376 'SWUpdateCollaborationParticipantsAction' => 'SharedWithYouCore.SWUpdateCollaborationParticipantsAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D522 /* #377 'SRAmbientLightSample' => 'SensorKit.SRAmbientLightSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D722 /* #378 'SRApplicationUsage' => 'SensorKit.SRApplicationUsage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4DB22 /* #379 'SRDeletionRecord' => 'SensorKit.SRDeletionRecord, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4DC22 /* #380 'SRDevice' => 'SensorKit.SRDevice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4DF22 /* #381 'SRDeviceUsageReport' => 'SensorKit.SRDeviceUsageReport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E222 /* #382 'SRFetchRequest' => 'SensorKit.SRFetchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E322 /* #383 'SRFetchResult' => 'SensorKit.SRFetchResult`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E422 /* #384 'SRKeyboardMetrics' => 'SensorKit.SRKeyboardMetrics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E622 /* #385 'SRKeyboardProbabilityMetric' => 'SensorKit.SRKeyboardProbabilityMetric`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E822 /* #386 'SRMessagesUsageReport' => 'SensorKit.SRMessagesUsageReport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4EA22 /* #387 'SRNotificationUsage' => 'SensorKit.SRNotificationUsage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4EB22 /* #388 'SRPhoneUsageReport' => 'SensorKit.SRPhoneUsageReport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F122 /* #389 'Xamarin_iOS__SensorKit_SRSensorReaderDelegate' => 'SensorKit.SRSensorReaderDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F222 /* #390 'SRTextInputSession' => 'SensorKit.SRTextInputSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F422 /* #391 'SRVisit' => 'SensorKit.SRVisit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F522 /* #392 'SRWebUsage' => 'SensorKit.SRWebUsage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F622 /* #393 'SRWristDetection' => 'SensorKit.SRWristDetection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55722 /* #394 'SCNGeometry' => 'SceneKit.SCNGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x54E22 /* #395 'SCNText' => 'SceneKit.SCNText, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x54F22 /* #396 'SCNAnimatable' => 'SceneKit.SCNAnimatable, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55122 /* #397 'SCNSceneRenderer' => 'SceneKit.SCNSceneRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55822 /* #398 'SCNGeometrySource' => 'SceneKit.SCNGeometrySource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55D22 /* #399 'SCNParticleSystem' => 'SceneKit.SCNParticleSystem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55E22 /* #400 'SCNPhysicsShape' => 'SceneKit.SCNPhysicsShape, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56322 /* #401 'SCNScene' => 'SceneKit.SCNScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56622 /* #402 'SCNSceneSource' => 'SceneKit.SCNSceneSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56722 /* #403 'SCNSkinner' => 'SceneKit.SCNSkinner, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56822 /* #404 'SCNTechnique' => 'SceneKit.SCNTechnique, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59922 /* #405 'SCNConstraint' => 'SceneKit.SCNConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56C22 /* #406 'SCNAccelerationConstraint' => 'SceneKit.SCNAccelerationConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57022 /* #407 'SCNActionable' => 'SceneKit.SCNActionable, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57522 /* #408 'SCNAnimation' => 'SceneKit.SCNAnimation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57722 /* #409 'SCNAnimationPlayer' => 'SceneKit.SCNAnimationPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57B22 /* #410 'SCNAudioPlayer' => 'SceneKit.SCNAudioPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57C22 /* #411 'SCNAudioSource' => 'SceneKit.SCNAudioSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57D22 /* #412 'SCNAvoidOccluderConstraint' => 'SceneKit.SCNAvoidOccluderConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58122 /* #413 'SCNAvoidOccluderConstraintDelegate' => 'SceneKit.SCNAvoidOccluderConstraintDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58322 /* #414 'SCNBillboardConstraint' => 'SceneKit.SCNBillboardConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58722 /* #415 'SCNBoundingVolume' => 'SceneKit.SCNBoundingVolume, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58822 /* #416 'SCNBox' => 'SceneKit.SCNBox, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58C22 /* #417 'SCNCamera' => 'SceneKit.SCNCamera, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58F22 /* #418 'SCNCameraController' => 'SceneKit.SCNCameraController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59322 /* #419 'SCNCameraControllerDelegate' => 'SceneKit.SCNCameraControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59522 /* #420 'SCNCapsule' => 'SceneKit.SCNCapsule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59822 /* #421 'SCNCone' => 'SceneKit.SCNCone, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59B22 /* #422 'SCNCylinder' => 'SceneKit.SCNCylinder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59D22 /* #423 'SCNDistanceConstraint' => 'SceneKit.SCNDistanceConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A222 /* #424 'SCNFloor' => 'SceneKit.SCNFloor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A322 /* #425 'SCNGeometryElement' => 'SceneKit.SCNGeometryElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A722 /* #426 'SCNGeometryTessellator' => 'SceneKit.SCNGeometryTessellator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A922 /* #427 'SCNHitTestResult' => 'SceneKit.SCNHitTestResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5AB22 /* #428 'SCNIKConstraint' => 'SceneKit.SCNIKConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5AD22 /* #429 'SCNLevelOfDetail' => 'SceneKit.SCNLevelOfDetail, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5AE22 /* #430 'SCNLight' => 'SceneKit.SCNLight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B422 /* #431 'SCNLookAtConstraint' => 'SceneKit.SCNLookAtConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B522 /* #432 'SCNMaterial' => 'SceneKit.SCNMaterial, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B622 /* #433 'SCNMaterialProperty' => 'SceneKit.SCNMaterialProperty, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B722 /* #434 'SCNMorpher' => 'SceneKit.SCNMorpher, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5BE22 /* #435 'SCNNodeRendererDelegate' => 'SceneKit.SCNNodeRendererDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5C822 /* #436 'SCNParticlePropertyController' => 'SceneKit.SCNParticlePropertyController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5CB22 /* #437 'SCNPhysicsBehavior' => 'SceneKit.SCNPhysicsBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5CA22 /* #438 'SCNPhysicsBallSocketJoint' => 'SceneKit.SCNPhysicsBallSocketJoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5CC22 /* #439 'SCNPhysicsBody' => 'SceneKit.SCNPhysicsBody, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5CF22 /* #440 'SCNPhysicsConeTwistJoint' => 'SceneKit.SCNPhysicsConeTwistJoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5D022 /* #441 'SCNPhysicsContact' => 'SceneKit.SCNPhysicsContact, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5D422 /* #442 'SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsContactDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5D522 /* #443 'SCNPhysicsField' => 'SceneKit.SCNPhysicsField, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5D722 /* #444 'SCNPhysicsHingeJoint' => 'SceneKit.SCNPhysicsHingeJoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5DC22 /* #445 'SCNPhysicsSliderJoint' => 'SceneKit.SCNPhysicsSliderJoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5DF22 /* #446 'SCNPhysicsVehicle' => 'SceneKit.SCNPhysicsVehicle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E022 /* #447 'SCNPhysicsVehicleWheel' => 'SceneKit.SCNPhysicsVehicleWheel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E322 /* #448 'SCNPlane' => 'SceneKit.SCNPlane, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E422 /* #449 'SCNProgram' => 'SceneKit.SCNProgram, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E822 /* #450 'SCNProgramDelegate' => 'SceneKit.SCNProgramDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5EA22 /* #451 'SCNPyramid' => 'SceneKit.SCNPyramid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55B22 /* #452 'SCNNode' => 'SceneKit.SCNNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5EC22 /* #453 'SCNReferenceNode' => 'SceneKit.SCNReferenceNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F122 /* #454 'SCNReplicatorConstraint' => 'SceneKit.SCNReplicatorConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F522 /* #455 'SCNSceneExportDelegate' => 'SceneKit.SCNSceneExportDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5FB22 /* #456 'SCNSceneRendererDelegate' => 'SceneKit.SCNSceneRendererDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60322 /* #457 'SCNShadable' => 'SceneKit.SCNShadable, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60622 /* #458 'SCNShape' => 'SceneKit.SCNShape, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60722 /* #459 'SCNSliderConstraint' => 'SceneKit.SCNSliderConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60822 /* #460 'SCNSphere' => 'SceneKit.SCNSphere, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60B22 /* #461 'SCNTechniqueSupport' => 'SceneKit.SCNTechniqueSupport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60D22 /* #462 'SCNTimingFunction' => 'SceneKit.SCNTimingFunction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60E22 /* #463 'SCNTorus' => 'SceneKit.SCNTorus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60F22 /* #464 'SCNTransaction' => 'SceneKit.SCNTransaction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61022 /* #465 'SCNTransformConstraint' => 'SceneKit.SCNTransformConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61222 /* #466 'SCNTube' => 'SceneKit.SCNTube, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62522 /* #467 'RPBroadcastConfiguration' => 'ReplayKit.RPBroadcastConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62A22 /* #468 'RPBroadcastActivityViewControllerDelegate' => 'ReplayKit.RPBroadcastActivityViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62F22 /* #469 'RPBroadcastControllerDelegate' => 'ReplayKit.RPBroadcastControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63022 /* #470 'RPBroadcastHandler' => 'ReplayKit.RPBroadcastHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63122 /* #471 'RPBroadcastMP4ClipHandler' => 'ReplayKit.RPBroadcastMP4ClipHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63222 /* #472 'RPBroadcastSampleHandler' => 'ReplayKit.RPBroadcastSampleHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63422 /* #473 'RPPreviewViewController' => 'ReplayKit.RPPreviewViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63822 /* #474 'RPPreviewViewControllerDelegate' => 'ReplayKit.RPPreviewViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64022 /* #475 'RPScreenRecorderDelegate' => 'ReplayKit.RPScreenRecorderDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64522 /* #476 'PHChangeRequest' => 'Photos.PHChangeRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64322 /* #477 'PHAssetChangeRequest' => 'Photos.PHAssetChangeRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64422 /* #478 'PHAssetCreationRequest' => 'Photos.PHAssetCreationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64622 /* #479 'PHContentEditingInputRequestOptions' => 'Photos.PHContentEditingInputRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64A22 /* #480 'PHLivePhoto' => 'Photos.PHLivePhoto, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64D22 /* #481 'PHAdjustmentData' => 'Photos.PHAdjustmentData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67D22 /* #482 'PHObject' => 'Photos.PHObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64E22 /* #483 'PHAsset' => 'Photos.PHAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66422 /* #484 'PHCollection' => 'Photos.PHCollection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65022 /* #485 'PHAssetCollection' => 'Photos.PHAssetCollection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65122 /* #486 'PHAssetCollectionChangeRequest' => 'Photos.PHAssetCollectionChangeRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65922 /* #487 'PHAssetResource' => 'Photos.PHAssetResource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65A22 /* #488 'PHAssetResourceCreationOptions' => 'Photos.PHAssetResourceCreationOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65C22 /* #489 'PHAssetResourceRequestOptions' => 'Photos.PHAssetResourceRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67022 /* #490 'PHImageManager' => 'Photos.PHImageManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66022 /* #491 'PHCachingImageManager' => 'Photos.PHCachingImageManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66122 /* #492 'PHChange' => 'Photos.PHChange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66222 /* #493 'PHCloudIdentifier' => 'Photos.PHCloudIdentifier, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66322 /* #494 'PHCloudIdentifierMapping' => 'Photos.PHCloudIdentifierMapping, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66622 /* #495 'PHCollectionList' => 'Photos.PHCollectionList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66722 /* #496 'PHCollectionListChangeRequest' => 'Photos.PHCollectionListChangeRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66A22 /* #497 'PHContentEditingInput' => 'Photos.PHContentEditingInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66B22 /* #498 'PHContentEditingOutput' => 'Photos.PHContentEditingOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66C22 /* #499 'PHFetchOptions' => 'Photos.PHFetchOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66D22 /* #500 'PHFetchResultChangeDetails' => 'Photos.PHFetchResultChangeDetails, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67122 /* #501 'PHImageRequestOptions' => 'Photos.PHImageRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67B22 /* #502 'PHLivePhotoRequestOptions' => 'Photos.PHLivePhotoRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67C22 /* #503 'PHLocalIdentifierMapping' => 'Photos.PHLocalIdentifierMapping, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67E22 /* #504 'PHObjectChangeDetails' => 'Photos.PHObjectChangeDetails, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67F22 /* #505 'PHObjectPlaceholder' => 'Photos.PHObjectPlaceholder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68122 /* #506 'PHPersistentChange' => 'Photos.PHPersistentChange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68222 /* #507 'PHPersistentChangeFetchResult' => 'Photos.PHPersistentChangeFetchResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68322 /* #508 'PHPersistentChangeToken' => 'Photos.PHPersistentChangeToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68422 /* #509 'PHPersistentObjectChangeDetails' => 'Photos.PHPersistentObjectChangeDetails, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68A22 /* #510 'PHPhotoLibraryChangeObserver' => 'Photos.PHPhotoLibraryChangeObserver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68D22 /* #511 'PHVideoRequestOptions' => 'Photos.PHVideoRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A022 /* #512 'PDFBorder' => 'PdfKit.PdfBorder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A422 /* #513 'PDFAction' => 'PdfKit.PdfAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A522 /* #514 'PDFActionGoTo' => 'PdfKit.PdfActionGoTo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A622 /* #515 'PDFActionNamed' => 'PdfKit.PdfActionNamed, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A822 /* #516 'PDFActionRemoteGoTo' => 'PdfKit.PdfActionRemoteGoTo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A922 /* #517 'PDFActionResetForm' => 'PdfKit.PdfActionResetForm, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6AA22 /* #518 'PDFActionURL' => 'PdfKit.PdfActionUrl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B722 /* #519 'PDFAppearanceCharacteristics' => 'PdfKit.PdfAppearanceCharacteristics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6BC22 /* #520 'PDFDestination' => 'PdfKit.PdfDestination, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C622 /* #521 'PDFDocumentDelegate' => 'PdfKit.PdfDocumentDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CD22 /* #522 'PDFOutline' => 'PdfKit.PdfOutline, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CE22 /* #523 'PDFPage' => 'PdfKit.PdfPage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D522 /* #524 'PDFSelection' => 'PdfKit.PdfSelection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6DE22 /* #525 'PDFViewDelegate' => 'PdfKit.PdfViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E422 /* #526 'PKPaymentRequest' => 'PassKit.PKPaymentRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F722 /* #527 'PKAddSecureElementPassConfiguration' => 'PassKit.PKAddSecureElementPassConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E622 /* #528 'PKAddCarKeyPassConfiguration' => 'PassKit.PKAddCarKeyPassConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6ED22 /* #529 'PKAddPassesViewControllerDelegate' => 'PassKit.PKAddPassesViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6EF22 /* #530 'PKAddPaymentPassRequest' => 'PassKit.PKAddPaymentPassRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F022 /* #531 'PKAddPaymentPassRequestConfiguration' => 'PassKit.PKAddPaymentPassRequestConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F222 /* #532 'PKAddPaymentPassViewController' => 'PassKit.PKAddPaymentPassViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F522 /* #533 'PKAddPaymentPassViewControllerDelegate' => 'PassKit.PKAddPaymentPassViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FA22 /* #534 'PKAddSecureElementPassViewController' => 'PassKit.PKAddSecureElementPassViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FD22 /* #535 'Xamarin_iOS__PassKit_PKAddSecureElementPassViewControllerDelegate' => 'PassKit.PKAddSecureElementPassViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70122 /* #536 'PKAutomaticReloadPaymentRequest' => 'PassKit.PKAutomaticReloadPaymentRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76322 /* #537 'PKPaymentSummaryItem' => 'PassKit.PKPaymentSummaryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70222 /* #538 'PKAutomaticReloadPaymentSummaryItem' => 'PassKit.PKAutomaticReloadPaymentSummaryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70422 /* #539 'PKBarcodeEventConfigurationRequest' => 'PassKit.PKBarcodeEventConfigurationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70522 /* #540 'PKBarcodeEventMetadataRequest' => 'PassKit.PKBarcodeEventMetadataRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70622 /* #541 'PKBarcodeEventMetadataResponse' => 'PassKit.PKBarcodeEventMetadataResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70722 /* #542 'PKBarcodeEventSignatureRequest' => 'PassKit.PKBarcodeEventSignatureRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70822 /* #543 'PKBarcodeEventSignatureResponse' => 'PassKit.PKBarcodeEventSignatureResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70922 /* #544 'PKContact' => 'PassKit.PKContact, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70B22 /* #545 'PKDateComponentsRange' => 'PassKit.PKDateComponentsRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70C22 /* #546 'PKDeferredPaymentSummaryItem' => 'PassKit.PKDeferredPaymentSummaryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71022 /* #547 'PKDisbursementAuthorizationControllerDelegate' => 'PassKit.PKDisbursementAuthorizationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71122 /* #548 'PKDisbursementRequest' => 'PassKit.PKDisbursementRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71322 /* #549 'PKDisbursementVoucher' => 'PassKit.PKDisbursementVoucher, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71A22 /* #550 'PKIdentityDocument' => 'PassKit.PKIdentityDocument, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71D22 /* #551 'PKIdentityDriversLicenseDescriptor' => 'PassKit.PKIdentityDriversLicenseDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71E22 /* #552 'PKIdentityElement' => 'PassKit.PKIdentityElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72122 /* #553 'PKIdentityIntentToStore' => 'PassKit.PKIdentityIntentToStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72222 /* #554 'PKIdentityRequest' => 'PassKit.PKIdentityRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72722 /* #555 'PKIssuerProvisioningExtensionPassEntry' => 'PassKit.PKIssuerProvisioningExtensionPassEntry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72822 /* #556 'PKIssuerProvisioningExtensionPaymentPassEntry' => 'PassKit.PKIssuerProvisioningExtensionPaymentPassEntry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72922 /* #557 'PKIssuerProvisioningExtensionStatus' => 'PassKit.PKIssuerProvisioningExtensionStatus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72A22 /* #558 'PKLabeledValue' => 'PassKit.PKLabeledValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72C22 /* #559 'PKObject' => 'PassKit.PKObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72D22 /* #560 'PKPass' => 'PassKit.PKPass, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73622 /* #561 'PKPayment' => 'PassKit.PKPayment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73B22 /* #562 'PKPaymentAuthorizationControllerDelegate' => 'PassKit.PKPaymentAuthorizationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73C22 /* #563 'PKPaymentAuthorizationResult' => 'PassKit.PKPaymentAuthorizationResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74C22 /* #564 'PKPaymentAuthorizationViewControllerDelegate' => 'PassKit.PKPaymentAuthorizationViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75322 /* #565 'PKPaymentInformationEventExtension' => 'PassKit.PKPaymentInformationEventExtension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75622 /* #566 'PKPaymentMerchantSession' => 'PassKit.PKPaymentMerchantSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75722 /* #567 'PKPaymentMethod' => 'PassKit.PKPaymentMethod, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75A22 /* #568 'PKPaymentOrderDetails' => 'PassKit.PKPaymentOrderDetails, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76A22 /* #569 'PKSecureElementPass' => 'PassKit.PKSecureElementPass, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75B22 /* #570 'PKPaymentPass' => 'PassKit.PKPaymentPass, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76222 /* #571 'PKPaymentRequestUpdate' => 'PassKit.PKPaymentRequestUpdate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75D22 /* #572 'PKPaymentRequestCouponCodeUpdate' => 'PassKit.PKPaymentRequestCouponCodeUpdate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75E22 /* #573 'PKPaymentRequestMerchantSessionUpdate' => 'PassKit.PKPaymentRequestMerchantSessionUpdate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75F22 /* #574 'PKPaymentRequestPaymentMethodUpdate' => 'PassKit.PKPaymentRequestPaymentMethodUpdate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76022 /* #575 'PKPaymentRequestShippingContactUpdate' => 'PassKit.PKPaymentRequestShippingContactUpdate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76122 /* #576 'PKPaymentRequestShippingMethodUpdate' => 'PassKit.PKPaymentRequestShippingMethodUpdate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76522 /* #577 'PKPaymentToken' => 'PassKit.PKPaymentToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76622 /* #578 'PKPaymentTokenContext' => 'PassKit.PKPaymentTokenContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76822 /* #579 'PKRecurringPaymentRequest' => 'PassKit.PKRecurringPaymentRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76922 /* #580 'PKRecurringPaymentSummaryItem' => 'PassKit.PKRecurringPaymentSummaryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76C22 /* #581 'PKShareablePassMetadataPreview' => 'PassKit.PKShareablePassMetadataPreview, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77022 /* #582 'PKShareSecureElementPassViewController' => 'PassKit.PKShareSecureElementPassViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77422 /* #583 'Xamarin_iOS__PassKit_PKShareSecureElementPassViewControllerDelegate' => 'PassKit.PKShareSecureElementPassViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77622 /* #584 'PKShippingMethod' => 'PassKit.PKShippingMethod, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77822 /* #585 'PKStoredValuePassBalance' => 'PassKit.PKStoredValuePassBalance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77B22 /* #586 'PKStoredValuePassProperties' => 'PassKit.PKStoredValuePassProperties, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77D22 /* #587 'PKTransitPassProperties' => 'PassKit.PKTransitPassProperties, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77C22 /* #588 'PKSuicaPassProperties' => 'PassKit.PKSuicaPassProperties, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78022 /* #589 'Xamarin_iOS__PassKit_PKVehicleConnectionDelegate' => 'PassKit.PKVehicleConnectionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78F22 /* #590 'EAGLSharegroup' => 'OpenGLES.EAGLSharegroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F322 /* #591 'NETunnelNetworkSettings' => 'NetworkExtension.NETunnelNetworkSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79522 /* #592 'NEPacketTunnelNetworkSettings' => 'NetworkExtension.NEPacketTunnelNetworkSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79722 /* #593 'NWPath' => 'NetworkExtension.NWPath, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81022 /* #594 'NWEndpoint' => 'NetworkExtension.NWEndpoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79822 /* #595 'NWHostEndpoint' => 'NetworkExtension.NWHostEndpoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79922 /* #596 'NWTCPConnectionAuthenticationDelegate' => 'NetworkExtension.NWTcpConnectionAuthenticationDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79A22 /* #597 'NEFilterFlow' => 'NetworkExtension.NEFilterFlow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79C22 /* #598 'NEHotspotConfiguration' => 'NetworkExtension.NEHotspotConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79D22 /* #599 'NEHotspotEAPSettings' => 'NetworkExtension.NEHotspotEapSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7AB22 /* #600 'Xamarin_iOS__NetworkExtension_NEAppPushDelegate' => 'NetworkExtension.NEAppPushDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B022 /* #601 'NEAppRule' => 'NetworkExtension.NEAppRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B922 /* #602 'NEDNSSettings' => 'NetworkExtension.NEDnsSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B122 /* #603 'NEDNSOverHTTPSSettings' => 'NetworkExtension.NEDnsOverHttpsSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B222 /* #604 'NEDNSOverTLSSettings' => 'NetworkExtension.NEDnsOverTlsSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80A22 /* #605 'NEVPNProtocol' => 'NetworkExtension.NEVpnProtocol, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B822 /* #606 'NEDNSProxyProviderProtocol' => 'NetworkExtension.NEDnsProxyProviderProtocol, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7BD22 /* #607 'NEEvaluateConnectionRule' => 'NetworkExtension.NEEvaluateConnectionRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C022 /* #608 'NEFilterBrowserFlow' => 'NetworkExtension.NEFilterBrowserFlow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7CE22 /* #609 'NEFilterVerdict' => 'NetworkExtension.NEFilterVerdict, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C822 /* #610 'NEFilterNewFlowVerdict' => 'NetworkExtension.NEFilterNewFlowVerdict, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C222 /* #611 'NEFilterControlVerdict' => 'NetworkExtension.NEFilterControlVerdict, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7EE22 /* #612 'NEProvider' => 'NetworkExtension.NEProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79B22 /* #613 'NEFilterProvider' => 'NetworkExtension.NEFilterProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C322 /* #614 'NEFilterDataProvider' => 'NetworkExtension.NEFilterDataProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C422 /* #615 'NEFilterDataVerdict' => 'NetworkExtension.NEFilterDataVerdict, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C922 /* #616 'NEFilterProviderConfiguration' => 'NetworkExtension.NEFilterProviderConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7CA22 /* #617 'NEFilterRemediationVerdict' => 'NetworkExtension.NEFilterRemediationVerdict, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7CB22 /* #618 'NEFilterReport' => 'NetworkExtension.NEFilterReport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7CD22 /* #619 'NEFilterSocketFlow' => 'NetworkExtension.NEFilterSocketFlow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7CF22 /* #620 'NEFlowMetaData' => 'NetworkExtension.NEFlowMetaData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7D622 /* #621 'NEHotspotHelper' => 'NetworkExtension.NEHotspotHelper, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7D722 /* #622 'NEHotspotHelperCommand' => 'NetworkExtension.NEHotspotHelperCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7DB22 /* #623 'NEHotspotHelperResponse' => 'NetworkExtension.NEHotspotHelperResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7DD22 /* #624 'NEHotspotHS20Settings' => 'NetworkExtension.NEHotspotHS20Settings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E022 /* #625 'NEIPv4Route' => 'NetworkExtension.NEIPv4Route, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E122 /* #626 'NEIPv4Settings' => 'NetworkExtension.NEIPv4Settings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E222 /* #627 'NEIPv6Route' => 'NetworkExtension.NEIPv6Route, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E322 /* #628 'NEIPv6Settings' => 'NetworkExtension.NEIPv6Settings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E422 /* #629 'NEOnDemandRule' => 'NetworkExtension.NEOnDemandRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E622 /* #630 'NEOnDemandRuleConnect' => 'NetworkExtension.NEOnDemandRuleConnect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E722 /* #631 'NEOnDemandRuleDisconnect' => 'NetworkExtension.NEOnDemandRuleDisconnect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E822 /* #632 'NEOnDemandRuleEvaluateConnection' => 'NetworkExtension.NEOnDemandRuleEvaluateConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E922 /* #633 'NEOnDemandRuleIgnore' => 'NetworkExtension.NEOnDemandRuleIgnore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7EB22 /* #634 'NEPacket' => 'NetworkExtension.NEPacket, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7ED22 /* #635 'NEPrivateLTENetwork' => 'NetworkExtension.NEPrivateLteNetwork, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F022 /* #636 'NEProxyServer' => 'NetworkExtension.NEProxyServer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F122 /* #637 'NEProxySettings' => 'NetworkExtension.NEProxySettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F822 /* #638 'NETunnelProviderProtocol' => 'NetworkExtension.NETunnelProviderProtocol, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7FB22 /* #639 'NEVPNConnection' => 'NetworkExtension.NEVpnConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7FA22 /* #640 'NETunnelProviderSession' => 'NetworkExtension.NETunnelProviderSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80622 /* #641 'NEVPNIKEv2SecurityAssociationParameters' => 'NetworkExtension.NEVpnIke2SecurityAssociationParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80C22 /* #642 'NEVPNProtocolIPSec' => 'NetworkExtension.NEVpnProtocolIpSec, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80B22 /* #643 'NEVPNProtocolIKEv2' => 'NetworkExtension.NEVpnProtocolIke2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80F22 /* #644 'NWBonjourServiceEndpoint' => 'NetworkExtension.NWBonjourServiceEndpoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81722 /* #645 'NWTLSParameters' => 'NetworkExtension.NWTlsParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87522 /* #646 'NINearbyObject' => 'NearbyInteraction.NINearbyObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87622 /* #647 'NIAlgorithmConvergence' => 'NearbyInteraction.NIAlgorithmConvergence, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87A22 /* #648 'NIConfiguration' => 'NearbyInteraction.NIConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87D22 /* #649 'NIDiscoveryToken' => 'NearbyInteraction.NIDiscoveryToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88022 /* #650 'NINearbyAccessoryConfiguration' => 'NearbyInteraction.NINearbyAccessoryConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88322 /* #651 'NINearbyPeerConfiguration' => 'NearbyInteraction.NINearbyPeerConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88422 /* #652 'NISession' => 'NearbyInteraction.NISession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88822 /* #653 'Xamarin_iOS__NearbyInteraction_NISessionDelegate' => 'NearbyInteraction.NISessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88C22 /* #654 'NLModel' => 'NaturalLanguage.NLModel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89122 /* #655 'NLGazetteer' => 'NaturalLanguage.NLGazetteer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89322 /* #656 'NLModelConfiguration' => 'NaturalLanguage.NLModelConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89A22 /* #657 'NLTokenizer' => 'NaturalLanguage.NLTokenizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8AB22 /* #658 'MCPeerID' => 'MultipeerConnectivity.MCPeerID, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8AC22 /* #659 'MCAdvertiserAssistant' => 'MultipeerConnectivity.MCAdvertiserAssistant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8B122 /* #660 'MCAdvertiserAssistantDelegate' => 'MultipeerConnectivity.MCAdvertiserAssistantDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8B222 /* #661 'MCBrowserViewController' => 'MultipeerConnectivity.MCBrowserViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8B622 /* #662 'MCBrowserViewControllerDelegate' => 'MultipeerConnectivity.MCBrowserViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8BA22 /* #663 'MCNearbyServiceAdvertiser' => 'MultipeerConnectivity.MCNearbyServiceAdvertiser, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8BE22 /* #664 'MCNearbyServiceAdvertiserDelegate' => 'MultipeerConnectivity.MCNearbyServiceAdvertiserDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8BF22 /* #665 'MCNearbyServiceBrowser' => 'MultipeerConnectivity.MCNearbyServiceBrowser, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C322 /* #666 'MCNearbyServiceBrowserDelegate' => 'MultipeerConnectivity.MCNearbyServiceBrowserDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C722 /* #667 'MCSessionDelegate' => 'MultipeerConnectivity.MCSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CD22 /* #668 'MDLAnimatedValue' => 'ModelIO.MDLAnimatedValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CC22 /* #669 'MDLAnimatedQuaternion' => 'ModelIO.MDLAnimatedQuaternion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CE22 /* #670 'MDLAnimatedScalarArray' => 'ModelIO.MDLAnimatedScalarArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CF22 /* #671 'MDLAnimatedVector3Array' => 'ModelIO.MDLAnimatedVector3Array, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D022 /* #672 'MDLAnimatedQuaternionArray' => 'ModelIO.MDLAnimatedQuaternionArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D122 /* #673 'MDLAnimatedScalar' => 'ModelIO.MDLAnimatedScalar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D222 /* #674 'MDLAnimatedVector2' => 'ModelIO.MDLAnimatedVector2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D322 /* #675 'MDLAnimatedVector3' => 'ModelIO.MDLAnimatedVector3, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D422 /* #676 'MDLAnimatedVector4' => 'ModelIO.MDLAnimatedVector4, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D522 /* #677 'MDLAnimatedMatrix4x4' => 'ModelIO.MDLAnimatedMatrix4x4, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D622 /* #678 'MDLMatrix4x4Array' => 'ModelIO.MDLMatrix4x4Array, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D822 /* #679 'MDLAsset' => 'ModelIO.MDLAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92822 /* #680 'MDLTexture' => 'ModelIO.MDLTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8DA22 /* #681 'MDLNoiseTexture' => 'ModelIO.MDLNoiseTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8DF22 /* #682 'MDLTransform' => 'ModelIO.MDLTransform, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E122 /* #683 'MDLVertexDescriptor' => 'ModelIO.MDLVertexDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E322 /* #684 'MDLAnimationBindComponent' => 'ModelIO.MDLAnimationBindComponent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91622 /* #685 'MDLObject' => 'ModelIO.MDLObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8F322 /* #686 'MDLLight' => 'ModelIO.MDLLight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91E22 /* #687 'MDLPhysicallyPlausibleLight' => 'ModelIO.MDLPhysicallyPlausibleLight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E422 /* #688 'MDLAreaLight' => 'ModelIO.MDLAreaLight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E722 /* #689 'MDLBundleAssetResolver' => 'ModelIO.MDLBundleAssetResolver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E822 /* #690 'MDLCamera' => 'ModelIO.MDLCamera, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8EA22 /* #691 'MDLCheckerboardTexture' => 'ModelIO.MDLCheckerboardTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8EB22 /* #692 'MDLColorSwatchTexture' => 'ModelIO.MDLColorSwatchTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8F422 /* #693 'MDLLightProbe' => 'ModelIO.MDLLightProbe, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8F822 /* #694 'MDLLightProbeIrradianceDataSource' => 'ModelIO.MDLLightProbeIrradianceDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8FA22 /* #695 'MDLMaterial' => 'ModelIO.MDLMaterial, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8FD22 /* #696 'MDLMaterialProperty' => 'ModelIO.MDLMaterialProperty, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8FE22 /* #697 'MDLMaterialPropertyConnection' => 'ModelIO.MDLMaterialPropertyConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x90022 /* #698 'MDLMaterialPropertyNode' => 'ModelIO.MDLMaterialPropertyNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8FF22 /* #699 'MDLMaterialPropertyGraph' => 'ModelIO.MDLMaterialPropertyGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x90A22 /* #700 'MDLMeshBufferData' => 'ModelIO.MDLMeshBufferData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x90B22 /* #701 'MDLMeshBufferDataAllocator' => 'ModelIO.MDLMeshBufferDataAllocator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x90C22 /* #702 'MDLMeshBufferMap' => 'ModelIO.MDLMeshBufferMap, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91122 /* #703 'MDLMeshBufferZoneDefault' => 'ModelIO.MDLMeshBufferZoneDefault, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91522 /* #704 'MDLNormalMapTexture' => 'ModelIO.MDLNormalMapTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91722 /* #705 'MDLObjectContainer' => 'ModelIO.MDLObjectContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91B22 /* #706 'MDLPackedJointAnimation' => 'ModelIO.MDLPackedJointAnimation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91C22 /* #707 'MDLPathAssetResolver' => 'ModelIO.MDLPathAssetResolver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91D22 /* #708 'MDLPhotometricLight' => 'ModelIO.MDLPhotometricLight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92222 /* #709 'MDLScatteringFunction' => 'ModelIO.MDLScatteringFunction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91F22 /* #710 'MDLPhysicallyPlausibleScatteringFunction' => 'ModelIO.MDLPhysicallyPlausibleScatteringFunction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92122 /* #711 'MDLRelativeAssetResolver' => 'ModelIO.MDLRelativeAssetResolver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92322 /* #712 'MDLSkeleton' => 'ModelIO.MDLSkeleton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92422 /* #713 'MDLSkyCubeTexture' => 'ModelIO.MDLSkyCubeTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92522 /* #714 'MDLStereoscopicCamera' => 'ModelIO.MDLStereoscopicCamera, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92622 /* #715 'MDLSubmesh' => 'ModelIO.MDLSubmesh, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92722 /* #716 'MDLSubmeshTopology' => 'ModelIO.MDLSubmeshTopology, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92A22 /* #717 'MDLTextureFilter' => 'ModelIO.MDLTextureFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92B22 /* #718 'MDLTextureSampler' => 'ModelIO.MDLTextureSampler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92E22 /* #719 'MDLTransformMatrixOp' => 'ModelIO.MDLTransformMatrixOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93222 /* #720 'MDLTransformOrientOp' => 'ModelIO.MDLTransformOrientOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93322 /* #721 'MDLTransformRotateOp' => 'ModelIO.MDLTransformRotateOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93422 /* #722 'MDLTransformRotateXOp' => 'ModelIO.MDLTransformRotateXOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93522 /* #723 'MDLTransformRotateYOp' => 'ModelIO.MDLTransformRotateYOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93622 /* #724 'MDLTransformRotateZOp' => 'ModelIO.MDLTransformRotateZOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93722 /* #725 'MDLTransformScaleOp' => 'ModelIO.MDLTransformScaleOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93822 /* #726 'MDLTransformStack' => 'ModelIO.MDLTransformStack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93922 /* #727 'MDLTransformTranslateOp' => 'ModelIO.MDLTransformTranslateOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93A22 /* #728 'MDLURLTexture' => 'ModelIO.MDLUrlTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93B22 /* #729 'MDLVertexAttribute' => 'ModelIO.MDLVertexAttribute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93C22 /* #730 'MDLVertexAttributeData' => 'ModelIO.MDLVertexAttributeData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93E22 /* #731 'MDLVertexBufferLayout' => 'ModelIO.MDLVertexBufferLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94022 /* #732 'MDLVoxelArray' => 'ModelIO.MDLVoxelArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94322 /* #733 'MXMetaData' => 'MetricKit.MXMetaData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94422 /* #734 'MXMetric' => 'MetricKit.MXMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94522 /* #735 'MXMetricManager' => 'MetricKit.MXMetricManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94622 /* #736 'MXMetricPayload' => 'MetricKit.MXMetricPayload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94722 /* #737 'MXAnimationMetric' => 'MetricKit.MXAnimationMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94822 /* #738 'MXAppExitMetric' => 'MetricKit.MXAppExitMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95422 /* #739 'MXDiagnostic' => 'MetricKit.MXDiagnostic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94922 /* #740 'MXAppLaunchDiagnostic' => 'MetricKit.MXAppLaunchDiagnostic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94A22 /* #741 'MXAppLaunchMetric' => 'MetricKit.MXAppLaunchMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94B22 /* #742 'MXAppResponsivenessMetric' => 'MetricKit.MXAppResponsivenessMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94C22 /* #743 'MXAppRunTimeMetric' => 'MetricKit.MXAppRunTimeMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94D22 /* #744 'MXAverage' => 'MetricKit.MXAverage`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94E22 /* #745 'MXBackgroundExitData' => 'MetricKit.MXBackgroundExitData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94F22 /* #746 'MXCallStackTree' => 'MetricKit.MXCallStackTree, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95022 /* #747 'MXCellularConditionMetric' => 'MetricKit.MXCellularConditionMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95122 /* #748 'MXCPUExceptionDiagnostic' => 'MetricKit.MXCpuExceptionDiagnostic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95222 /* #749 'MXCPUMetric' => 'MetricKit.MXCpuMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95322 /* #750 'MXCrashDiagnostic' => 'MetricKit.MXCrashDiagnostic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95522 /* #751 'MXDiagnosticPayload' => 'MetricKit.MXDiagnosticPayload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95622 /* #752 'MXDiskIOMetric' => 'MetricKit.MXDiskIOMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95722 /* #753 'MXDiskWriteExceptionDiagnostic' => 'MetricKit.MXDiskWriteExceptionDiagnostic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95822 /* #754 'MXDisplayMetric' => 'MetricKit.MXDisplayMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95B22 /* #755 'MXForegroundExitData' => 'MetricKit.MXForegroundExitData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95C22 /* #756 'MXGPUMetric' => 'MetricKit.MXGpuMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95D22 /* #757 'MXHangDiagnostic' => 'MetricKit.MXHangDiagnostic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95E22 /* #758 'MXHistogram' => 'MetricKit.MXHistogram`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95F22 /* #759 'MXHistogramBucket' => 'MetricKit.MXHistogramBucket`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96022 /* #760 'MXLocationActivityMetric' => 'MetricKit.MXLocationActivityMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96122 /* #761 'MXMemoryMetric' => 'MetricKit.MXMemoryMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96522 /* #762 'MXNetworkTransferMetric' => 'MetricKit.MXNetworkTransferMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96622 /* #763 'MXSignpostIntervalData' => 'MetricKit.MXSignpostIntervalData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96722 /* #764 'MXSignpostMetric' => 'MetricKit.MXSignpostMetric, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14FE22 /* #765 'NSUnit' => 'Foundation.NSUnit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B822 /* #766 'NSDimension' => 'Foundation.NSDimension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96822 /* #767 'MXUnitAveragePixelLuminance' => 'MetricKit.MXUnitAveragePixelLuminance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96922 /* #768 'MXUnitSignalBars' => 'MetricKit.MXUnitSignalBars, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96C22 /* #769 'MPSGraph' => 'MetalPerformanceShadersGraph.MPSGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98722 /* #770 'MPSGraphCompilationDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphCompilationDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98822 /* #771 'MPSGraphConvolution2DOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphConvolution2DOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98922 /* #772 'MPSGraphCreateSparseOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphCreateSparseOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98A22 /* #773 'MPSGraphDepthwiseConvolution2DOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphDepthwiseConvolution2DOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98C22 /* #774 'MPSGraphDevice' => 'MetalPerformanceShadersGraph.MPSGraphDevice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98E22 /* #775 'MPSGraphExecutable' => 'MetalPerformanceShadersGraph.MPSGraphExecutable, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98F22 /* #776 'MPSGraphExecutableExecutionDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphExecutableExecutionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99022 /* #777 'MPSGraphExecutionDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphExecutionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99222 /* #778 'MPSGraphOperation' => 'MetalPerformanceShadersGraph.MPSGraphOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99622 /* #779 'MPSGraphPooling2DOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphPooling2DOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99A22 /* #780 'MPSGraphRandomOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphRandomOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A322 /* #781 'MPSGraphType' => 'MetalPerformanceShadersGraph.MPSGraphType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9AE22 /* #782 'MPSCNNConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnConvolutionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CB22 /* #783 'MPSKernel' => 'MetalPerformanceShaders.MPSKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2622 /* #784 'MPSCNNKernel' => 'MetalPerformanceShaders.MPSCnnKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9AF22 /* #785 'MPSCNNBinaryConvolution' => 'MetalPerformanceShaders.MPSCnnBinaryConvolution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B022 /* #786 'MPSCNNBinaryFullyConnected' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnected, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3722 /* #787 'MPSCNNNeuron' => 'MetalPerformanceShaders.MPSCnnNeuron, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B122 /* #788 'MPSCNNNeuronPReLU' => 'MetalPerformanceShaders.MPSCnnNeuronPReLU, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFA22 /* #789 'MPSNNFilterNode' => 'MetalPerformanceShaders.MPSNNFilterNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B322 /* #790 'MPSCNNConvolutionNode' => 'MetalPerformanceShaders.MPSCnnConvolutionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B222 /* #791 'MPSCNNConvolutionTransposeNode' => 'MetalPerformanceShaders.MPSCnnConvolutionTransposeNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B422 /* #792 'MPSCNNConvolutionTranspose' => 'MetalPerformanceShaders.MPSCnnConvolutionTranspose, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B522 /* #793 'MPSCNNConvolution' => 'MetalPerformanceShaders.MPSCnnConvolution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5722 /* #794 'MPSState' => 'MetalPerformanceShaders.MPSState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B622 /* #795 'MetalPerformanceShaders_MPSCnnConvolutionState' => 'MetalPerformanceShaders.MPSCnnConvolutionState, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x9C922 /* #796 'MPSImageHistogram' => 'MetalPerformanceShaders.MPSImageHistogram, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6022 /* #797 'MPSUnaryImageKernel' => 'MetalPerformanceShaders.MPSUnaryImageKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CA22 /* #798 'MPSImageScale' => 'MetalPerformanceShaders.MPSImageScale, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CC22 /* #799 'MPSImage' => 'MetalPerformanceShaders.MPSImage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CD22 /* #800 'MPSImageDilate' => 'MetalPerformanceShaders.MPSImageDilate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CE22 /* #801 'MPSImageErode' => 'MetalPerformanceShaders.MPSImageErode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CF22 /* #802 'MPSImageThresholdBinary' => 'MetalPerformanceShaders.MPSImageThresholdBinary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D022 /* #803 'MPSImageThresholdBinaryInverse' => 'MetalPerformanceShaders.MPSImageThresholdBinaryInverse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D122 /* #804 'MPSImageThresholdTruncate' => 'MetalPerformanceShaders.MPSImageThresholdTruncate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D222 /* #805 'MPSImageThresholdToZero' => 'MetalPerformanceShaders.MPSImageThresholdToZero, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D322 /* #806 'MPSImageThresholdToZeroInverse' => 'MetalPerformanceShaders.MPSImageThresholdToZeroInverse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D422 /* #807 'MPSImageSobel' => 'MetalPerformanceShaders.MPSImageSobel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D522 /* #808 'MPSCNNFullyConnected' => 'MetalPerformanceShaders.MPSCnnFullyConnected, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D622 /* #809 'MPSImageConversion' => 'MetalPerformanceShaders.MPSImageConversion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D722 /* #810 'MPSImagePyramid' => 'MetalPerformanceShaders.MPSImagePyramid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D822 /* #811 'MPSImageGaussianPyramid' => 'MetalPerformanceShaders.MPSImageGaussianPyramid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D922 /* #812 'MPSImageLaplacianPyramid' => 'MetalPerformanceShaders.MPSImageLaplacianPyramid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DA22 /* #813 'MPSImageLaplacianPyramidSubtract' => 'MetalPerformanceShaders.MPSImageLaplacianPyramidSubtract, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DB22 /* #814 'MPSImageLaplacianPyramidAdd' => 'MetalPerformanceShaders.MPSImageLaplacianPyramidAdd, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DC22 /* #815 'MPSCNNBinaryConvolutionNode' => 'MetalPerformanceShaders.MPSCnnBinaryConvolutionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DD22 /* #816 'MPSCNNBinaryFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnectedNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DE22 /* #817 'MPSMatrixDescriptor' => 'MetalPerformanceShaders.MPSMatrixDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DF22 /* #818 'MPSNDArray' => 'MetalPerformanceShaders.MPSNDArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E222 /* #819 'MPSStateResourceList' => 'MetalPerformanceShaders.MPSStateResourceList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E422 /* #820 'MPSAccelerationStructureGroup' => 'MetalPerformanceShaders.MPSAccelerationStructureGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E922 /* #821 'MPSBinaryImageKernel' => 'MetalPerformanceShaders.MPSBinaryImageKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9FE22 /* #822 'MPSCNNBinaryKernel' => 'MetalPerformanceShaders.MPSCnnBinaryKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9ED22 /* #823 'MPSCNNArithmetic' => 'MetalPerformanceShaders.MPSCnnArithmetic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EB22 /* #824 'MPSCNNAdd' => 'MetalPerformanceShaders.MPSCnnAdd, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1C22 /* #825 'MPSCNNGradientKernel' => 'MetalPerformanceShaders.MPSCnnGradientKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EE22 /* #826 'MPSCNNArithmeticGradient' => 'MetalPerformanceShaders.MPSCnnArithmeticGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EC22 /* #827 'MPSCNNAddGradient' => 'MetalPerformanceShaders.MPSCnnAddGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEF22 /* #828 'MPSNNBinaryGradientState' => 'MetalPerformanceShaders.MPSNNBinaryGradientState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EF22 /* #829 'MPSCNNArithmeticGradientState' => 'MetalPerformanceShaders.MPSCnnArithmeticGradientState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F022 /* #830 'MPSCNNBatchNormalization' => 'MetalPerformanceShaders.MPSCnnBatchNormalization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F422 /* #831 'Xamarin_iOS__MetalPerformanceShaders_MPSCnnBatchNormalizationDataSource' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F622 /* #832 'MPSCNNBatchNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFC22 /* #833 'MPSNNGradientFilterNode' => 'MetalPerformanceShaders.MPSNNGradientFilterNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F722 /* #834 'MPSCNNBatchNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F822 /* #835 'MPSCNNBatchNormalizationNode' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFD22 /* #836 'MPSNNGradientState' => 'MetalPerformanceShaders.MPSNNGradientState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F922 /* #837 'MPSCNNBatchNormalizationState' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9FA22 /* #838 'MPSCNNBatchNormalizationStatistics' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationStatistics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9FB22 /* #839 'MPSCNNBatchNormalizationStatisticsGradient' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationStatisticsGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0222 /* #840 'MPSCNNConvolutionDataSource' => 'MetalPerformanceShaders.MPSCnnConvolutionDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0422 /* #841 'MPSCNNConvolutionGradient' => 'MetalPerformanceShaders.MPSCnnConvolutionGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0522 /* #842 'MPSCNNConvolutionGradientNode' => 'MetalPerformanceShaders.MPSCnnConvolutionGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0722 /* #843 'MPSCNNConvolutionGradientState' => 'MetalPerformanceShaders.MPSCnnConvolutionGradientState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4022 /* #844 'MPSNNStateNode' => 'MetalPerformanceShaders.MPSNNStateNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFE22 /* #845 'MPSNNGradientStateNode' => 'MetalPerformanceShaders.MPSNNGradientStateNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0822 /* #846 'MPSCNNConvolutionGradientStateNode' => 'MetalPerformanceShaders.MPSCnnConvolutionGradientStateNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0922 /* #847 'MPSCNNConvolutionStateNode' => 'MetalPerformanceShaders.MPSCnnConvolutionStateNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0A22 /* #848 'MPSCNNConvolutionWeightsAndBiasesState' => 'MetalPerformanceShaders.MPSCnnConvolutionWeightsAndBiasesState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0B22 /* #849 'MPSCNNCrossChannelNormalization' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0C22 /* #850 'MPSCNNCrossChannelNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0D22 /* #851 'MPSCNNCrossChannelNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5922 /* #852 'MPSCNNNormalizationNode' => 'MetalPerformanceShaders.MPSCnnNormalizationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0E22 /* #853 'MPSCNNCrossChannelNormalizationNode' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0F22 /* #854 'MPSCNNDepthWiseConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnDepthWiseConvolutionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5A22 /* #855 'MPSCNNPooling' => 'MetalPerformanceShaders.MPSCnnPooling, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1022 /* #856 'MPSCNNDilatedPoolingMax' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5F22 /* #857 'MPSCNNPoolingGradient' => 'MetalPerformanceShaders.MPSCnnPoolingGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1122 /* #858 'MPSCNNDilatedPoolingMaxGradient' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6022 /* #859 'MPSCNNPoolingGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1222 /* #860 'MPSCNNDilatedPoolingMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1322 /* #861 'MPSCNNDilatedPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1422 /* #862 'MPSCNNDivide' => 'MetalPerformanceShaders.MPSCnnDivide, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1522 /* #863 'MPSCNNDropout' => 'MetalPerformanceShaders.MPSCnnDropout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1622 /* #864 'MPSCNNDropoutGradient' => 'MetalPerformanceShaders.MPSCnnDropoutGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1722 /* #865 'MPSCNNDropoutGradientNode' => 'MetalPerformanceShaders.MPSCnnDropoutGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1822 /* #866 'MPSCNNDropoutGradientState' => 'MetalPerformanceShaders.MPSCnnDropoutGradientState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1922 /* #867 'MPSCNNDropoutNode' => 'MetalPerformanceShaders.MPSCnnDropoutNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1A22 /* #868 'MPSCNNFullyConnectedGradient' => 'MetalPerformanceShaders.MPSCnnFullyConnectedGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1B22 /* #869 'MPSCNNFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnFullyConnectedNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1D22 /* #870 'MPSCNNInstanceNormalization' => 'MetalPerformanceShaders.MPSCnnInstanceNormalization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2122 /* #871 'Xamarin_iOS__MetalPerformanceShaders_MPSCnnInstanceNormalizationDataSource' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2222 /* #872 'MPSCNNInstanceNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2322 /* #873 'MPSCNNInstanceNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2422 /* #874 'MPSCNNInstanceNormalizationGradientState' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationGradientState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2522 /* #875 'MPSCNNInstanceNormalizationNode' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2722 /* #876 'MPSCNNLocalContrastNormalization' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2822 /* #877 'MPSCNNLocalContrastNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2922 /* #878 'MPSCNNLocalContrastNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2A22 /* #879 'MPSCNNLocalContrastNormalizationNode' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2B22 /* #880 'MPSCNNLogSoftMax' => 'MetalPerformanceShaders.MPSCnnLogSoftMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2C22 /* #881 'MPSCNNLogSoftMaxGradient' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2D22 /* #882 'MPSCNNLogSoftMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2E22 /* #883 'MPSCNNLogSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2F22 /* #884 'MPSCNNLoss' => 'MetalPerformanceShaders.MPSCnnLoss, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3022 /* #885 'MPSCNNLossDataDescriptor' => 'MetalPerformanceShaders.MPSCnnLossDataDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3122 /* #886 'MPSCNNLossDescriptor' => 'MetalPerformanceShaders.MPSCnnLossDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3222 /* #887 'MPSCNNLossLabels' => 'MetalPerformanceShaders.MPSCnnLossLabels, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3322 /* #888 'MPSCNNLossNode' => 'MetalPerformanceShaders.MPSCnnLossNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3522 /* #889 'MPSCNNMultiply' => 'MetalPerformanceShaders.MPSCnnMultiply, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3622 /* #890 'MPSCNNMultiplyGradient' => 'MetalPerformanceShaders.MPSCnnMultiplyGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3822 /* #891 'MPSCNNNeuronAbsolute' => 'MetalPerformanceShaders.MPSCnnNeuronAbsolute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4622 /* #892 'MPSCNNNeuronNode' => 'MetalPerformanceShaders.MPSCnnNeuronNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3922 /* #893 'MPSCNNNeuronAbsoluteNode' => 'MetalPerformanceShaders.MPSCnnNeuronAbsoluteNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3A22 /* #894 'MPSCNNNeuronELU' => 'MetalPerformanceShaders.MPSCnnNeuronElu, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3B22 /* #895 'MPSCNNNeuronELUNode' => 'MetalPerformanceShaders.MPSCnnNeuronEluNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3C22 /* #896 'MPSCNNNeuronExponential' => 'MetalPerformanceShaders.MPSCnnNeuronExponential, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3D22 /* #897 'MPSCNNNeuronExponentialNode' => 'MetalPerformanceShaders.MPSCnnNeuronExponentialNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3E22 /* #898 'MPSCNNNeuronGradient' => 'MetalPerformanceShaders.MPSCnnNeuronGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3F22 /* #899 'MPSCNNNeuronGradientNode' => 'MetalPerformanceShaders.MPSCnnNeuronGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4022 /* #900 'MPSCNNNeuronHardSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4122 /* #901 'MPSCNNNeuronHardSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoidNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4222 /* #902 'MPSCNNNeuronLinear' => 'MetalPerformanceShaders.MPSCnnNeuronLinear, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4322 /* #903 'MPSCNNNeuronLinearNode' => 'MetalPerformanceShaders.MPSCnnNeuronLinearNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4422 /* #904 'MPSCNNNeuronLogarithm' => 'MetalPerformanceShaders.MPSCnnNeuronLogarithm, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4522 /* #905 'MPSCNNNeuronLogarithmNode' => 'MetalPerformanceShaders.MPSCnnNeuronLogarithmNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4722 /* #906 'MPSCNNNeuronPower' => 'MetalPerformanceShaders.MPSCnnNeuronPower, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4822 /* #907 'MPSCNNNeuronPowerNode' => 'MetalPerformanceShaders.MPSCnnNeuronPowerNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4922 /* #908 'MPSCNNNeuronPReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronPReLUNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4A22 /* #909 'MPSCNNNeuronReLU' => 'MetalPerformanceShaders.MPSCnnNeuronReLU, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4B22 /* #910 'MPSCNNNeuronReLUN' => 'MetalPerformanceShaders.MPSCnnNeuronReLun, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4C22 /* #911 'MPSCNNNeuronReLUNNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLunNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4D22 /* #912 'MPSCNNNeuronReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLUNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4E22 /* #913 'MPSCNNNeuronSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4F22 /* #914 'MPSCNNNeuronSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoidNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5022 /* #915 'MPSCNNNeuronSoftPlus' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5122 /* #916 'MPSCNNNeuronSoftPlusNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlusNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5222 /* #917 'MPSCNNNeuronSoftSign' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSign, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5322 /* #918 'MPSCNNNeuronSoftSignNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSignNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5422 /* #919 'MPSCNNNeuronTanH' => 'MetalPerformanceShaders.MPSCnnNeuronTanH, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5522 /* #920 'MPSCNNNeuronTanHNode' => 'MetalPerformanceShaders.MPSCnnNeuronTanHNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5722 /* #921 'MPSCNNNormalizationGammaAndBetaState' => 'MetalPerformanceShaders.MPSCnnNormalizationGammaAndBetaState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5822 /* #922 'MPSCNNNormalizationMeanAndVarianceState' => 'MetalPerformanceShaders.MPSCnnNormalizationMeanAndVarianceState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5B22 /* #923 'MPSCNNPoolingAverage' => 'MetalPerformanceShaders.MPSCnnPoolingAverage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5C22 /* #924 'MPSCNNPoolingAverageGradient' => 'MetalPerformanceShaders.MPSCnnPoolingAverageGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5D22 /* #925 'MPSCNNPoolingAverageGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingAverageGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6922 /* #926 'MPSCNNPoolingNode' => 'MetalPerformanceShaders.MPSCnnPoolingNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA5E22 /* #927 'MPSCNNPoolingAverageNode' => 'MetalPerformanceShaders.MPSCnnPoolingAverageNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6122 /* #928 'MPSCNNPoolingL2Norm' => 'MetalPerformanceShaders.MPSCnnPoolingL2Norm, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6222 /* #929 'MPSCNNPoolingL2NormGradient' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6322 /* #930 'MPSCNNPoolingL2NormGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6422 /* #931 'MPSCNNPoolingL2NormNode' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6522 /* #932 'MPSCNNPoolingMax' => 'MetalPerformanceShaders.MPSCnnPoolingMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6622 /* #933 'MPSCNNPoolingMaxGradient' => 'MetalPerformanceShaders.MPSCnnPoolingMaxGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6722 /* #934 'MPSCNNPoolingMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingMaxGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6822 /* #935 'MPSCNNPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnPoolingMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6B22 /* #936 'MPSCNNSoftMax' => 'MetalPerformanceShaders.MPSCnnSoftMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6C22 /* #937 'MPSCNNSoftMaxGradient' => 'MetalPerformanceShaders.MPSCnnSoftMaxGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6D22 /* #938 'MPSCNNSoftMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnSoftMaxGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6E22 /* #939 'MPSCNNSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnSoftMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA6F22 /* #940 'MPSCNNSpatialNormalization' => 'MetalPerformanceShaders.MPSCnnSpatialNormalization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7022 /* #941 'MPSCNNSpatialNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7122 /* #942 'MPSCNNSpatialNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7222 /* #943 'MPSCNNSpatialNormalizationNode' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7322 /* #944 'MPSCNNSubPixelConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnSubPixelConvolutionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7422 /* #945 'MPSCNNSubtract' => 'MetalPerformanceShaders.MPSCnnSubtract, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7522 /* #946 'MPSCNNSubtractGradient' => 'MetalPerformanceShaders.MPSCnnSubtractGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7622 /* #947 'MPSCNNUpsampling' => 'MetalPerformanceShaders.MPSCnnUpsampling, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7722 /* #948 'MPSCNNUpsamplingBilinear' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinear, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7B22 /* #949 'MPSCNNUpsamplingGradient' => 'MetalPerformanceShaders.MPSCnnUpsamplingGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7822 /* #950 'MPSCNNUpsamplingBilinearGradient' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7922 /* #951 'MPSCNNUpsamplingBilinearGradientNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7A22 /* #952 'MPSCNNUpsamplingBilinearNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7C22 /* #953 'MPSCNNUpsamplingNearest' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7D22 /* #954 'MPSCNNUpsamplingNearestGradient' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7E22 /* #955 'MPSCNNUpsamplingNearestGradientNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA7F22 /* #956 'MPSCNNUpsamplingNearestNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA8122 /* #957 'MPSCNNYOLOLoss' => 'MetalPerformanceShaders.MPSCnnYoloLoss, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA8222 /* #958 'MPSCNNYOLOLossDescriptor' => 'MetalPerformanceShaders.MPSCnnYoloLossDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA8322 /* #959 'MPSCNNYOLOLossNode' => 'MetalPerformanceShaders.MPSCnnYoloLossNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA8422 /* #960 'MPSCommandBuffer' => 'MetalPerformanceShaders.MPSCommandBuffer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4D22 /* #961 'MPSRNNDescriptor' => 'MetalPerformanceShaders.MPSRnnDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA8B22 /* #962 'MPSGRUDescriptor' => 'MetalPerformanceShaders.MPSGRUDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9722 /* #963 'MPSImageArithmetic' => 'MetalPerformanceShaders.MPSImageArithmetic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9122 /* #964 'MPSImageAdd' => 'MetalPerformanceShaders.MPSImageAdd, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9522 /* #965 'MPSImageAreaMax' => 'MetalPerformanceShaders.MPSImageAreaMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9622 /* #966 'MPSImageAreaMin' => 'MetalPerformanceShaders.MPSImageAreaMin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9822 /* #967 'MPSImageBilinearScale' => 'MetalPerformanceShaders.MPSImageBilinearScale, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9922 /* #968 'MPSImageBox' => 'MetalPerformanceShaders.MPSImageBox, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9A22 /* #969 'MPSImageConvolution' => 'MetalPerformanceShaders.MPSImageConvolution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9B22 /* #970 'MPSImageCopyToMatrix' => 'MetalPerformanceShaders.MPSImageCopyToMatrix, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9C22 /* #971 'MPSImageDescriptor' => 'MetalPerformanceShaders.MPSImageDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9D22 /* #972 'MPSImageDivide' => 'MetalPerformanceShaders.MPSImageDivide, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA9F22 /* #973 'MPSImageEuclideanDistanceTransform' => 'MetalPerformanceShaders.MPSImageEuclideanDistanceTransform, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA122 /* #974 'MPSImageFindKeypoints' => 'MetalPerformanceShaders.MPSImageFindKeypoints, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA222 /* #975 'MPSImageGaussianBlur' => 'MetalPerformanceShaders.MPSImageGaussianBlur, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA322 /* #976 'MPSImageGuidedFilter' => 'MetalPerformanceShaders.MPSImageGuidedFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA422 /* #977 'MPSImageHistogramEqualization' => 'MetalPerformanceShaders.MPSImageHistogramEqualization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA522 /* #978 'MPSImageHistogramSpecification' => 'MetalPerformanceShaders.MPSImageHistogramSpecification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA622 /* #979 'MPSImageIntegral' => 'MetalPerformanceShaders.MPSImageIntegral, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA722 /* #980 'MPSImageIntegralOfSquares' => 'MetalPerformanceShaders.MPSImageIntegralOfSquares, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA822 /* #981 'MPSImageLanczosScale' => 'MetalPerformanceShaders.MPSImageLanczosScale, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAA922 /* #982 'MPSImageLaplacian' => 'MetalPerformanceShaders.MPSImageLaplacian, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAAA22 /* #983 'MPSImageMedian' => 'MetalPerformanceShaders.MPSImageMedian, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAAB22 /* #984 'MPSImageMultiply' => 'MetalPerformanceShaders.MPSImageMultiply, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAAC22 /* #985 'MPSImageNormalizedHistogram' => 'MetalPerformanceShaders.MPSImageNormalizedHistogram, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB522 /* #986 'MPSImageReduceUnary' => 'MetalPerformanceShaders.MPSImageReduceUnary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAAD22 /* #987 'MPSImageReduceColumnMax' => 'MetalPerformanceShaders.MPSImageReduceColumnMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAAE22 /* #988 'MPSImageReduceColumnMean' => 'MetalPerformanceShaders.MPSImageReduceColumnMean, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAAF22 /* #989 'MPSImageReduceColumnMin' => 'MetalPerformanceShaders.MPSImageReduceColumnMin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB022 /* #990 'MPSImageReduceColumnSum' => 'MetalPerformanceShaders.MPSImageReduceColumnSum, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB122 /* #991 'MPSImageReduceRowMax' => 'MetalPerformanceShaders.MPSImageReduceRowMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB222 /* #992 'MPSImageReduceRowMean' => 'MetalPerformanceShaders.MPSImageReduceRowMean, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB322 /* #993 'MPSImageReduceRowMin' => 'MetalPerformanceShaders.MPSImageReduceRowMin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB422 /* #994 'MPSImageReduceRowSum' => 'MetalPerformanceShaders.MPSImageReduceRowSum, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB822 /* #995 'MPSImageStatisticsMean' => 'MetalPerformanceShaders.MPSImageStatisticsMean, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAB922 /* #996 'MPSImageStatisticsMeanAndVariance' => 'MetalPerformanceShaders.MPSImageStatisticsMeanAndVariance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xABA22 /* #997 'MPSImageStatisticsMinAndMax' => 'MetalPerformanceShaders.MPSImageStatisticsMinAndMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xABB22 /* #998 'MPSImageSubtract' => 'MetalPerformanceShaders.MPSImageSubtract, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xABC22 /* #999 'MPSImageTent' => 'MetalPerformanceShaders.MPSImageTent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xABF22 /* #1000 'MPSImageTranspose' => 'MetalPerformanceShaders.MPSImageTranspose, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E322 /* #1001 'MPSAccelerationStructure' => 'MetalPerformanceShaders.MPSAccelerationStructure, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAC122 /* #1002 'MPSInstanceAccelerationStructure' => 'MetalPerformanceShaders.MPSInstanceAccelerationStructure, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B122 /* #1003 'NSCoder' => 'Foundation.NSCoder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CF22 /* #1004 'NSKeyedUnarchiver' => 'Foundation.NSKeyedUnarchiver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAC522 /* #1005 'MPSKeyedUnarchiver' => 'MetalPerformanceShaders.MPSKeyedUnarchiver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAC622 /* #1006 'MPSLSTMDescriptor' => 'MetalPerformanceShaders.MPSLSTMDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAC722 /* #1007 'MPSMatrix' => 'MetalPerformanceShaders.MPSMatrix, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE422 /* #1008 'MPSMatrixUnaryKernel' => 'MetalPerformanceShaders.MPSMatrixUnaryKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAC822 /* #1009 'MPSMatrixBatchNormalization' => 'MetalPerformanceShaders.MPSMatrixBatchNormalization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACA22 /* #1010 'MPSMatrixBinaryKernel' => 'MetalPerformanceShaders.MPSMatrixBinaryKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAC922 /* #1011 'MPSMatrixBatchNormalizationGradient' => 'MetalPerformanceShaders.MPSMatrixBatchNormalizationGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACB22 /* #1012 'MPSMatrixCopy' => 'MetalPerformanceShaders.MPSMatrixCopy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACC22 /* #1013 'MPSMatrixCopyDescriptor' => 'MetalPerformanceShaders.MPSMatrixCopyDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACD22 /* #1014 'MPSMatrixCopyToImage' => 'MetalPerformanceShaders.MPSMatrixCopyToImage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACE22 /* #1015 'MPSMatrixDecompositionCholesky' => 'MetalPerformanceShaders.MPSMatrixDecompositionCholesky, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACF22 /* #1016 'MPSMatrixDecompositionLU' => 'MetalPerformanceShaders.MPSMatrixDecompositionLU, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD122 /* #1017 'MPSMatrixFindTopK' => 'MetalPerformanceShaders.MPSMatrixFindTopK, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD222 /* #1018 'MPSMatrixFullyConnected' => 'MetalPerformanceShaders.MPSMatrixFullyConnected, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD322 /* #1019 'MPSMatrixFullyConnectedGradient' => 'MetalPerformanceShaders.MPSMatrixFullyConnectedGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xADE22 /* #1020 'MPSMatrixSoftMax' => 'MetalPerformanceShaders.MPSMatrixSoftMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD422 /* #1021 'MPSMatrixLogSoftMax' => 'MetalPerformanceShaders.MPSMatrixLogSoftMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xADF22 /* #1022 'MPSMatrixSoftMaxGradient' => 'MetalPerformanceShaders.MPSMatrixSoftMaxGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD522 /* #1023 'MPSMatrixLogSoftMaxGradient' => 'MetalPerformanceShaders.MPSMatrixLogSoftMaxGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD622 /* #1024 'MPSMatrixMultiplication' => 'MetalPerformanceShaders.MPSMatrixMultiplication, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD722 /* #1025 'MPSMatrixNeuron' => 'MetalPerformanceShaders.MPSMatrixNeuron, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD822 /* #1026 'MPSMatrixNeuronGradient' => 'MetalPerformanceShaders.MPSMatrixNeuronGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD922 /* #1027 'MPSMatrixRandom' => 'MetalPerformanceShaders.MPSMatrixRandom, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xADB22 /* #1028 'MPSMatrixRandomDistributionDescriptor' => 'MetalPerformanceShaders.MPSMatrixRandomDistributionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xADC22 /* #1029 'MPSMatrixRandomMTGP32' => 'MetalPerformanceShaders.MPSMatrixRandomMtgp32, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xADD22 /* #1030 'MPSMatrixRandomPhilox' => 'MetalPerformanceShaders.MPSMatrixRandomPhilox, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE022 /* #1031 'MPSMatrixSolveCholesky' => 'MetalPerformanceShaders.MPSMatrixSolveCholesky, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE122 /* #1032 'MPSMatrixSolveLU' => 'MetalPerformanceShaders.MPSMatrixSolveLU, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE222 /* #1033 'MPSMatrixSolveTriangular' => 'MetalPerformanceShaders.MPSMatrixSolveTriangular, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE322 /* #1034 'MPSMatrixSum' => 'MetalPerformanceShaders.MPSMatrixSum, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE522 /* #1035 'MPSMatrixVectorMultiplication' => 'MetalPerformanceShaders.MPSMatrixVectorMultiplication, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEB22 /* #1036 'MPSNNArithmeticGradientNode' => 'MetalPerformanceShaders.MPSNNArithmeticGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE922 /* #1037 'MPSNNAdditionGradientNode' => 'MetalPerformanceShaders.MPSNNAdditionGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEE22 /* #1038 'MPSNNBinaryArithmeticNode' => 'MetalPerformanceShaders.MPSNNBinaryArithmeticNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEA22 /* #1039 'MPSNNAdditionNode' => 'MetalPerformanceShaders.MPSNNAdditionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF022 /* #1040 'MPSNNBinaryGradientStateNode' => 'MetalPerformanceShaders.MPSNNBinaryGradientStateNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEC22 /* #1041 'MPSNNArithmeticGradientStateNode' => 'MetalPerformanceShaders.MPSNNArithmeticGradientStateNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3E22 /* #1042 'MPSNNScaleNode' => 'MetalPerformanceShaders.MPSNNScaleNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAED22 /* #1043 'MPSNNBilinearScaleNode' => 'MetalPerformanceShaders.MPSNNBilinearScaleNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF122 /* #1044 'MPSNNCompare' => 'MetalPerformanceShaders.MPSNNCompare, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF222 /* #1045 'MPSNNComparisonNode' => 'MetalPerformanceShaders.MPSNNComparisonNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF422 /* #1046 'MPSNNConcatenationGradientNode' => 'MetalPerformanceShaders.MPSNNConcatenationGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF522 /* #1047 'MPSNNConcatenationNode' => 'MetalPerformanceShaders.MPSNNConcatenationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF722 /* #1048 'MPSNNCropAndResizeBilinear' => 'MetalPerformanceShaders.MPSNNCropAndResizeBilinear, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF822 /* #1049 'MPSNNDefaultPadding' => 'MetalPerformanceShaders.MPSNNDefaultPadding, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF922 /* #1050 'MPSNNDivisionNode' => 'MetalPerformanceShaders.MPSNNDivisionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFB22 /* #1051 'MPSNNForwardLossNode' => 'MetalPerformanceShaders.MPSNNForwardLossNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFF22 /* #1052 'MPSNNImageNode' => 'MetalPerformanceShaders.MPSNNImageNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0022 /* #1053 'MPSNNInitialGradientNode' => 'MetalPerformanceShaders.MPSNNInitialGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0122 /* #1054 'MPSNNLabelsNode' => 'MetalPerformanceShaders.MPSNNLabelsNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0222 /* #1055 'MPSNNLanczosScaleNode' => 'MetalPerformanceShaders.MPSNNLanczosScaleNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0522 /* #1056 'MPSNNLossGradientNode' => 'MetalPerformanceShaders.MPSNNLossGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0622 /* #1057 'MPSNNMultiplicationGradientNode' => 'MetalPerformanceShaders.MPSNNMultiplicationGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0722 /* #1058 'MPSNNMultiplicationNode' => 'MetalPerformanceShaders.MPSNNMultiplicationNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0822 /* #1059 'MPSNNNeuronDescriptor' => 'MetalPerformanceShaders.MPSNNNeuronDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0922 /* #1060 'MPSNNOptimizer' => 'MetalPerformanceShaders.MPSNNOptimizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0A22 /* #1061 'MPSNNOptimizerAdam' => 'MetalPerformanceShaders.MPSNNOptimizerAdam, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0B22 /* #1062 'MPSNNOptimizerDescriptor' => 'MetalPerformanceShaders.MPSNNOptimizerDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0C22 /* #1063 'MPSNNOptimizerRMSProp' => 'MetalPerformanceShaders.MPSNNOptimizerRmsProp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0D22 /* #1064 'MPSNNOptimizerStochasticGradientDescent' => 'MetalPerformanceShaders.MPSNNOptimizerStochasticGradientDescent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0E22 /* #1065 'MPSNNPad' => 'MetalPerformanceShaders.MPSNNPad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1322 /* #1066 'MPSNNPadGradient' => 'MetalPerformanceShaders.MPSNNPadGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1422 /* #1067 'MPSNNPadGradientNode' => 'MetalPerformanceShaders.MPSNNPadGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1522 /* #1068 'MPSNNPadNode' => 'MetalPerformanceShaders.MPSNNPadNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1622 /* #1069 'MPSNNReduceBinary' => 'MetalPerformanceShaders.MPSNNReduceBinary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2722 /* #1070 'MPSNNReduceUnary' => 'MetalPerformanceShaders.MPSNNReduceUnary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1722 /* #1071 'MPSNNReduceColumnMax' => 'MetalPerformanceShaders.MPSNNReduceColumnMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1822 /* #1072 'MPSNNReduceColumnMean' => 'MetalPerformanceShaders.MPSNNReduceColumnMean, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1922 /* #1073 'MPSNNReduceColumnMin' => 'MetalPerformanceShaders.MPSNNReduceColumnMin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1A22 /* #1074 'MPSNNReduceColumnSum' => 'MetalPerformanceShaders.MPSNNReduceColumnSum, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1B22 /* #1075 'MPSNNReduceFeatureChannelsAndWeightsMean' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsAndWeightsMean, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1C22 /* #1076 'MPSNNReduceFeatureChannelsAndWeightsSum' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsAndWeightsSum, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1D22 /* #1077 'MPSNNReduceFeatureChannelsArgumentMax' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsArgumentMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1E22 /* #1078 'MPSNNReduceFeatureChannelsArgumentMin' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsArgumentMin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1F22 /* #1079 'MPSNNReduceFeatureChannelsMax' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2022 /* #1080 'MPSNNReduceFeatureChannelsMean' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsMean, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2122 /* #1081 'MPSNNReduceFeatureChannelsMin' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsMin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2222 /* #1082 'MPSNNReduceFeatureChannelsSum' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsSum, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2322 /* #1083 'MPSNNReduceRowMax' => 'MetalPerformanceShaders.MPSNNReduceRowMax, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2422 /* #1084 'MPSNNReduceRowMean' => 'MetalPerformanceShaders.MPSNNReduceRowMean, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2522 /* #1085 'MPSNNReduceRowMin' => 'MetalPerformanceShaders.MPSNNReduceRowMin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2622 /* #1086 'MPSNNReduceRowSum' => 'MetalPerformanceShaders.MPSNNReduceRowSum, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4622 /* #1087 'MPSNNUnaryReductionNode' => 'MetalPerformanceShaders.MPSNNUnaryReductionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2822 /* #1088 'MPSNNReductionColumnMaxNode' => 'MetalPerformanceShaders.MPSNNReductionColumnMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2922 /* #1089 'MPSNNReductionColumnMeanNode' => 'MetalPerformanceShaders.MPSNNReductionColumnMeanNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2A22 /* #1090 'MPSNNReductionColumnMinNode' => 'MetalPerformanceShaders.MPSNNReductionColumnMinNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2B22 /* #1091 'MPSNNReductionColumnSumNode' => 'MetalPerformanceShaders.MPSNNReductionColumnSumNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2C22 /* #1092 'MPSNNReductionFeatureChannelsArgumentMaxNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsArgumentMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2D22 /* #1093 'MPSNNReductionFeatureChannelsArgumentMinNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsArgumentMinNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2E22 /* #1094 'MPSNNReductionFeatureChannelsMaxNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2F22 /* #1095 'MPSNNReductionFeatureChannelsMeanNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsMeanNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3022 /* #1096 'MPSNNReductionFeatureChannelsMinNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsMinNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3122 /* #1097 'MPSNNReductionFeatureChannelsSumNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsSumNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3222 /* #1098 'MPSNNReductionRowMaxNode' => 'MetalPerformanceShaders.MPSNNReductionRowMaxNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3322 /* #1099 'MPSNNReductionRowMeanNode' => 'MetalPerformanceShaders.MPSNNReductionRowMeanNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3422 /* #1100 'MPSNNReductionRowMinNode' => 'MetalPerformanceShaders.MPSNNReductionRowMinNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3522 /* #1101 'MPSNNReductionRowSumNode' => 'MetalPerformanceShaders.MPSNNReductionRowSumNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3622 /* #1102 'MPSNNReductionSpatialMeanGradientNode' => 'MetalPerformanceShaders.MPSNNReductionSpatialMeanGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3722 /* #1103 'MPSNNReductionSpatialMeanNode' => 'MetalPerformanceShaders.MPSNNReductionSpatialMeanNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3922 /* #1104 'MPSNNReshape' => 'MetalPerformanceShaders.MPSNNReshape, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3A22 /* #1105 'MPSNNReshapeGradient' => 'MetalPerformanceShaders.MPSNNReshapeGradient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3B22 /* #1106 'MPSNNReshapeGradientNode' => 'MetalPerformanceShaders.MPSNNReshapeGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3C22 /* #1107 'MPSNNReshapeNode' => 'MetalPerformanceShaders.MPSNNReshapeNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3D22 /* #1108 'MPSNNResizeBilinear' => 'MetalPerformanceShaders.MPSNNResizeBilinear, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3F22 /* #1109 'MPSNNSlice' => 'MetalPerformanceShaders.MPSNNSlice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4122 /* #1110 'MPSNNSubtractionGradientNode' => 'MetalPerformanceShaders.MPSNNSubtractionGradientNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4222 /* #1111 'MPSNNSubtractionNode' => 'MetalPerformanceShaders.MPSNNSubtractionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4722 /* #1112 'MPSPredicate' => 'MetalPerformanceShaders.MPSPredicate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4A22 /* #1113 'MPSRayIntersector' => 'MetalPerformanceShaders.MPSRayIntersector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4E22 /* #1114 'MPSRNNImageInferenceLayer' => 'MetalPerformanceShaders.MPSRnnImageInferenceLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5022 /* #1115 'MPSRNNMatrixInferenceLayer' => 'MetalPerformanceShaders.MPSRnnMatrixInferenceLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5122 /* #1116 'MPSRNNMatrixTrainingLayer' => 'MetalPerformanceShaders.MPSRnnMatrixTrainingLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5222 /* #1117 'MPSRNNMatrixTrainingState' => 'MetalPerformanceShaders.MPSRnnMatrixTrainingState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5322 /* #1118 'MPSRNNRecurrentImageState' => 'MetalPerformanceShaders.MPSRnnRecurrentImageState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5422 /* #1119 'MPSRNNRecurrentMatrixState' => 'MetalPerformanceShaders.MPSRnnRecurrentMatrixState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5622 /* #1120 'MPSRNNSingleGateDescriptor' => 'MetalPerformanceShaders.MPSRnnSingleGateDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5922 /* #1121 'MPSTemporaryImage' => 'MetalPerformanceShaders.MPSTemporaryImage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5A22 /* #1122 'MPSTemporaryMatrix' => 'MetalPerformanceShaders.MPSTemporaryMatrix, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5B22 /* #1123 'MPSTemporaryNDArray' => 'MetalPerformanceShaders.MPSTemporaryNDArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6122 /* #1124 'MPSVector' => 'MetalPerformanceShaders.MPSVector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5C22 /* #1125 'MPSTemporaryVector' => 'MetalPerformanceShaders.MPSTemporaryVector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB5E22 /* #1126 'MPSTriangleAccelerationStructure' => 'MetalPerformanceShaders.MPSTriangleAccelerationStructure, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6222 /* #1127 'MPSVectorDescriptor' => 'MetalPerformanceShaders.MPSVectorDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6522 /* #1128 'MTKMesh' => 'MetalKit.MTKMesh, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6622 /* #1129 'MTKMeshBufferAllocator' => 'MetalKit.MTKMeshBufferAllocator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6822 /* #1130 'MTKMeshBuffer' => 'MetalKit.MTKMeshBuffer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6A22 /* #1131 'MTKSubmesh' => 'MetalKit.MTKSubmesh, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB7522 /* #1132 'MTKViewDelegate' => 'MetalKit.MTKViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB8E22 /* #1133 'MTLRenderPipelineColorAttachmentDescriptorArray' => 'Metal.MTLRenderPipelineColorAttachmentDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB8F22 /* #1134 'MTLRenderPassColorAttachmentDescriptorArray' => 'Metal.MTLRenderPassColorAttachmentDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9022 /* #1135 'MTLVertexAttributeDescriptorArray' => 'Metal.MTLVertexAttributeDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9122 /* #1136 'MTLVertexBufferLayoutDescriptorArray' => 'Metal.MTLVertexBufferLayoutDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9222 /* #1137 'MTLBufferLayoutDescriptorArray' => 'Metal.MTLBufferLayoutDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9322 /* #1138 'MTLAttributeDescriptorArray' => 'Metal.MTLAttributeDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9422 /* #1139 'MTLPipelineBufferDescriptorArray' => 'Metal.MTLPipelineBufferDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9522 /* #1140 'MTLTileRenderPipelineColorAttachmentDescriptorArray' => 'Metal.MTLTileRenderPipelineColorAttachmentDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9622 /* #1141 'MTLBlitPassSampleBufferAttachmentDescriptorArray' => 'Metal.MTLBlitPassSampleBufferAttachmentDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9722 /* #1142 'MTLSharedTextureHandle' => 'Metal.MTLSharedTextureHandle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9822 /* #1143 'MTLComputePassSampleBufferAttachmentDescriptorArray' => 'Metal.MTLComputePassSampleBufferAttachmentDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9C22 /* #1144 'MTLRasterizationRateLayerDescriptor' => 'Metal.MTLRasterizationRateLayerDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9E22 /* #1145 'MTLRenderPassDescriptor' => 'Metal.MTLRenderPassDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB9F22 /* #1146 'MTLRenderPassSampleBufferAttachmentDescriptorArray' => 'Metal.MTLRenderPassSampleBufferAttachmentDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBA122 /* #1147 'MTLResourceStatePassSampleBufferAttachmentDescriptorArray' => 'Metal.MTLResourceStatePassSampleBufferAttachmentDescriptorArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBA222 /* #1148 'MTLVertexDescriptor' => 'Metal.MTLVertexDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBAA22 /* #1149 'MTLAccelerationStructureGeometryDescriptor' => 'Metal.MTLAccelerationStructureGeometryDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBA522 /* #1150 'MTLAccelerationStructureBoundingBoxGeometryDescriptor' => 'Metal.MTLAccelerationStructureBoundingBoxGeometryDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBA922 /* #1151 'MTLAccelerationStructureDescriptor' => 'Metal.MTLAccelerationStructureDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBAD22 /* #1152 'MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor' => 'Metal.MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBAE22 /* #1153 'MTLAccelerationStructureMotionTriangleGeometryDescriptor' => 'Metal.MTLAccelerationStructureMotionTriangleGeometryDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBAF22 /* #1154 'MTLAccelerationStructureTriangleGeometryDescriptor' => 'Metal.MTLAccelerationStructureTriangleGeometryDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBB122 /* #1155 'MTLArgument' => 'Metal.MTLArgument, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBB422 /* #1156 'MTLArgumentDescriptor' => 'Metal.MTLArgumentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCAD22 /* #1157 'MTLType' => 'Metal.MTLType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBB822 /* #1158 'MTLArrayType' => 'Metal.MTLArrayType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBB922 /* #1159 'MTLAttribute' => 'Metal.MTLAttribute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBBA22 /* #1160 'MTLAttributeDescriptor' => 'Metal.MTLAttributeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBC022 /* #1161 'MTLBinaryArchiveDescriptor' => 'Metal.MTLBinaryArchiveDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBC922 /* #1162 'MTLBlitPassDescriptor' => 'Metal.MTLBlitPassDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBCA22 /* #1163 'MTLBlitPassSampleBufferAttachmentDescriptor' => 'Metal.MTLBlitPassSampleBufferAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBCE22 /* #1164 'MTLBufferLayoutDescriptor' => 'Metal.MTLBufferLayoutDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBCF22 /* #1165 'MTLCaptureDescriptor' => 'Metal.MTLCaptureDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBD322 /* #1166 'MTLCaptureManager' => 'Metal.MTLCaptureManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBD622 /* #1167 'Xamarin_iOS__Metal_MTLCaptureScope' => 'Metal.MTLCaptureScope, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBDB22 /* #1168 'MTLCommandBufferDescriptor' => 'Metal.MTLCommandBufferDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBEB22 /* #1169 'MTLCompileOptions' => 'Metal.MTLCompileOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBEF22 /* #1170 'MTLComputePassDescriptor' => 'Metal.MTLComputePassDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBF022 /* #1171 'MTLComputePassSampleBufferAttachmentDescriptor' => 'Metal.MTLComputePassSampleBufferAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBF122 /* #1172 'MTLComputePipelineDescriptor' => 'Metal.MTLComputePipelineDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBF222 /* #1173 'MTLComputePipelineReflection' => 'Metal.MTLComputePipelineReflection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBFC22 /* #1174 'MTLCounterSampleBufferDescriptor' => 'Metal.MTLCounterSampleBufferDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC0722 /* #1175 'MTLDepthStencilDescriptor' => 'Metal.MTLDepthStencilDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC1022 /* #1176 'MTLDrawable' => 'Metal.MTLDrawable, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC1D22 /* #1177 'MTLFunctionConstant' => 'Metal.MTLFunctionConstant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC1E22 /* #1178 'MTLFunctionConstantValues' => 'Metal.MTLFunctionConstantValues, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC1F22 /* #1179 'MTLFunctionDescriptor' => 'Metal.MTLFunctionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC2A22 /* #1180 'MTLFunctionStitchingFunctionNode' => 'Metal.MTLFunctionStitchingFunctionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC2B22 /* #1181 'MTLFunctionStitchingGraph' => 'Metal.MTLFunctionStitchingGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC2C22 /* #1182 'MTLFunctionStitchingInputNode' => 'Metal.MTLFunctionStitchingInputNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC3522 /* #1183 'MTLHeapDescriptor' => 'Metal.MTLHeapDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC3B22 /* #1184 'MTLIndirectCommandBufferDescriptor' => 'Metal.MTLIndirectCommandBufferDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC4322 /* #1185 'MTLInstanceAccelerationStructureDescriptor' => 'Metal.MTLInstanceAccelerationStructureDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC4422 /* #1186 'MTLIntersectionFunctionDescriptor' => 'Metal.MTLIntersectionFunctionDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC4822 /* #1187 'MTLIntersectionFunctionTableDescriptor' => 'Metal.MTLIntersectionFunctionTableDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC5022 /* #1188 'MTLLinkedFunctions' => 'Metal.MTLLinkedFunctions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC5522 /* #1189 'MTLMotionKeyframeData' => 'Metal.MTLMotionKeyframeData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC5D22 /* #1190 'MTLPipelineBufferDescriptor' => 'Metal.MTLPipelineBufferDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC6022 /* #1191 'MTLPointerType' => 'Metal.MTLPointerType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC6122 /* #1192 'MTLPrimitiveAccelerationStructureDescriptor' => 'Metal.MTLPrimitiveAccelerationStructureDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC6522 /* #1193 'MTLRasterizationRateLayerArray' => 'Metal.MTLRasterizationRateLayerArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC6822 /* #1194 'MTLRasterizationRateMapDescriptor' => 'Metal.MTLRasterizationRateMapDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC6922 /* #1195 'MTLRasterizationRateSampleArray' => 'Metal.MTLRasterizationRateSampleArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC6E22 /* #1196 'MTLRenderPassAttachmentDescriptor' => 'Metal.MTLRenderPassAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC6F22 /* #1197 'MTLRenderPassColorAttachmentDescriptor' => 'Metal.MTLRenderPassColorAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC7022 /* #1198 'MTLRenderPassDepthAttachmentDescriptor' => 'Metal.MTLRenderPassDepthAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC7122 /* #1199 'MTLRenderPassSampleBufferAttachmentDescriptor' => 'Metal.MTLRenderPassSampleBufferAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC7222 /* #1200 'MTLRenderPassStencilAttachmentDescriptor' => 'Metal.MTLRenderPassStencilAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC7322 /* #1201 'MTLRenderPipelineColorAttachmentDescriptor' => 'Metal.MTLRenderPipelineColorAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC7422 /* #1202 'MTLRenderPipelineDescriptor' => 'Metal.MTLRenderPipelineDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC7722 /* #1203 'MTLRenderPipelineFunctionsDescriptor' => 'Metal.MTLRenderPipelineFunctionsDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC7822 /* #1204 'MTLRenderPipelineReflection' => 'Metal.MTLRenderPipelineReflection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC8322 /* #1205 'MTLResourceStatePassDescriptor' => 'Metal.MTLResourceStatePassDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC8422 /* #1206 'MTLResourceStatePassSampleBufferAttachmentDescriptor' => 'Metal.MTLResourceStatePassSampleBufferAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC8822 /* #1207 'MTLSamplerDescriptor' => 'Metal.MTLSamplerDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC8F22 /* #1208 'MTLSharedEventHandle' => 'Metal.MTLSharedEventHandle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC9022 /* #1209 'MTLSharedEventListener' => 'Metal.MTLSharedEventListener, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC9322 /* #1210 'MTLStageInputOutputDescriptor' => 'Metal.MTLStageInputOutputDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC9422 /* #1211 'MTLStencilDescriptor' => 'Metal.MTLStencilDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC9722 /* #1212 'MTLStitchedLibraryDescriptor' => 'Metal.MTLStitchedLibraryDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC9B22 /* #1213 'MTLStructMember' => 'Metal.MTLStructMember, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC9C22 /* #1214 'MTLStructType' => 'Metal.MTLStructType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCA522 /* #1215 'MTLTextureDescriptor' => 'Metal.MTLTextureDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCA622 /* #1216 'MTLTextureReferenceType' => 'Metal.MTLTextureReferenceType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCAA22 /* #1217 'MTLTileRenderPipelineColorAttachmentDescriptor' => 'Metal.MTLTileRenderPipelineColorAttachmentDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCAB22 /* #1218 'MTLTileRenderPipelineDescriptor' => 'Metal.MTLTileRenderPipelineDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCAE22 /* #1219 'MTLVertexAttribute' => 'Metal.MTLVertexAttribute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCAF22 /* #1220 'MTLVertexAttributeDescriptor' => 'Metal.MTLVertexAttributeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCB022 /* #1221 'MTLVertexBufferLayoutDescriptor' => 'Metal.MTLVertexBufferLayoutDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCB622 /* #1222 'MTLVisibleFunctionTableDescriptor' => 'Metal.MTLVisibleFunctionTableDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24B822 /* #1223 'UINavigationControllerDelegate' => 'UIKit.UINavigationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCC922 /* #1224 'MFMailComposeViewControllerDelegate' => 'MessageUI.MFMailComposeViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCBE22 /* #1225 'MessageUI_Mono_MFMailComposeViewControllerDelegate' => 'MessageUI.Mono_MFMailComposeViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCCC22 /* #1226 'MFMessageComposeViewControllerDelegate' => 'MessageUI.MFMessageComposeViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCC122 /* #1227 'MessageUI_Mono_MFMessageComposeViewControllerDelegate' => 'MessageUI.Mono_MFMessageComposeViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCF622 /* #1228 'MPMediaEntity' => 'MediaPlayer.MPMediaEntity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCD722 /* #1229 'MPMediaItem' => 'MediaPlayer.MPMediaItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCD822 /* #1230 'MPMediaItemArtwork' => 'MediaPlayer.MPMediaItemArtwork, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCD922 /* #1231 'MPMediaQuery' => 'MediaPlayer.MPMediaQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCDC22 /* #1232 'MPNowPlayingInfoCenter' => 'MediaPlayer.MPNowPlayingInfoCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCDD22 /* #1233 'MPPlayableContentDelegate' => 'MediaPlayer.MPPlayableContentDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCDF22 /* #1234 'MPPlayableContentDataSource' => 'MediaPlayer.MPPlayableContentDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCE022 /* #1235 'MPRemoteCommandCenter' => 'MediaPlayer.MPRemoteCommandCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCE522 /* #1236 'MPAdTimeRange' => 'MediaPlayer.MPAdTimeRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3B22 /* #1237 'MPRemoteCommandEvent' => 'MediaPlayer.MPRemoteCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCE622 /* #1238 'MPChangeLanguageOptionCommandEvent' => 'MediaPlayer.MPChangeLanguageOptionCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3A22 /* #1239 'MPRemoteCommand' => 'MediaPlayer.MPRemoteCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCE822 /* #1240 'MPChangePlaybackPositionCommand' => 'MediaPlayer.MPChangePlaybackPositionCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCE922 /* #1241 'MPChangePlaybackPositionCommandEvent' => 'MediaPlayer.MPChangePlaybackPositionCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEA22 /* #1242 'MPChangePlaybackRateCommand' => 'MediaPlayer.MPChangePlaybackRateCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEB22 /* #1243 'MPChangePlaybackRateCommandEvent' => 'MediaPlayer.MPChangePlaybackRateCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEC22 /* #1244 'MPChangeRepeatModeCommand' => 'MediaPlayer.MPChangeRepeatModeCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCED22 /* #1245 'MPChangeRepeatModeCommandEvent' => 'MediaPlayer.MPChangeRepeatModeCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEE22 /* #1246 'MPChangeShuffleModeCommand' => 'MediaPlayer.MPChangeShuffleModeCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEF22 /* #1247 'MPChangeShuffleModeCommandEvent' => 'MediaPlayer.MPChangeShuffleModeCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCF022 /* #1248 'MPContentItem' => 'MediaPlayer.MPContentItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCF322 /* #1249 'MPFeedbackCommand' => 'MediaPlayer.MPFeedbackCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCF422 /* #1250 'MPFeedbackCommandEvent' => 'MediaPlayer.MPFeedbackCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCF822 /* #1251 'MPMediaItemCollection' => 'MediaPlayer.MPMediaItemCollection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0022 /* #1252 'MPMediaPickerControllerDelegate' => 'MediaPlayer.MPMediaPickerControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0522 /* #1253 'MPMediaPlaylistCreationMetadata' => 'MediaPlayer.MPMediaPlaylistCreationMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0722 /* #1254 'MPMediaPredicate' => 'MediaPlayer.MPMediaPredicate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0922 /* #1255 'MPMediaPropertyPredicate' => 'MediaPlayer.MPMediaPropertyPredicate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0A22 /* #1256 'MPMediaQuerySection' => 'MediaPlayer.MPMediaQuerySection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0C22 /* #1257 'MPMovieAccessLog' => 'MediaPlayer.MPMovieAccessLog, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0D22 /* #1258 'MPMovieAccessLogEvent' => 'MediaPlayer.MPMovieAccessLogEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD1022 /* #1259 'MPMovieErrorLog' => 'MediaPlayer.MPMovieErrorLog, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD1122 /* #1260 'MPMovieErrorLogEvent' => 'MediaPlayer.MPMovieErrorLogEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD1622 /* #1261 'MPMoviePlayerViewController' => 'MediaPlayer.MPMoviePlayerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD1F22 /* #1262 'MPMusicPlayerControllerQueue' => 'MediaPlayer.MPMusicPlayerControllerQueue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD1E22 /* #1263 'MPMusicPlayerControllerMutableQueue' => 'MediaPlayer.MPMusicPlayerControllerMutableQueue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2322 /* #1264 'MPMusicPlayerQueueDescriptor' => 'MediaPlayer.MPMusicPlayerQueueDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2022 /* #1265 'MPMusicPlayerMediaItemQueueDescriptor' => 'MediaPlayer.MPMusicPlayerMediaItemQueueDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2122 /* #1266 'MPMusicPlayerPlayParameters' => 'MediaPlayer.MPMusicPlayerPlayParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2222 /* #1267 'MPMusicPlayerPlayParametersQueueDescriptor' => 'MediaPlayer.MPMusicPlayerPlayParametersQueueDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2422 /* #1268 'MPMusicPlayerStoreQueueDescriptor' => 'MediaPlayer.MPMusicPlayerStoreQueueDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2722 /* #1269 'MPNowPlayingInfoLanguageOption' => 'MediaPlayer.MPNowPlayingInfoLanguageOption, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2822 /* #1270 'MPNowPlayingInfoLanguageOptionGroup' => 'MediaPlayer.MPNowPlayingInfoLanguageOptionGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3022 /* #1271 'Xamarin_iOS__MediaPlayer_MPNowPlayingSessionDelegate' => 'MediaPlayer.MPNowPlayingSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3622 /* #1272 'MPPlayableContentManager' => 'MediaPlayer.MPPlayableContentManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3722 /* #1273 'MPPlayableContentManagerContext' => 'MediaPlayer.MPPlayableContentManagerContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3822 /* #1274 'MPRatingCommand' => 'MediaPlayer.MPRatingCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3922 /* #1275 'MPRatingCommandEvent' => 'MediaPlayer.MPRatingCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3E22 /* #1276 'MPSeekCommandEvent' => 'MediaPlayer.MPSeekCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD4122 /* #1277 'MPSkipIntervalCommandEvent' => 'MediaPlayer.MPSkipIntervalCommandEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD4422 /* #1278 'MPTimedMetadata' => 'MediaPlayer.MPTimedMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDDF22 /* #1279 'MKShape' => 'MapKit.MKShape, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5F22 /* #1280 'MKMultiPoint' => 'MapKit.MKMultiPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD6422 /* #1281 'MKPolyline' => 'MapKit.MKPolyline, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5822 /* #1282 'MKGeodesicPolyline' => 'MapKit.MKGeodesicPolyline, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5B22 /* #1283 'MKMapCameraZoomRange' => 'MapKit.MKMapCameraZoomRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD6322 /* #1284 'MKPolygon' => 'MapKit.MKPolygon, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD6F22 /* #1285 'MKAnnotation' => 'MapKit.MKAnnotation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD7322 /* #1286 'MKCircle' => 'MapKit.MKCircle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCA22 /* #1287 'MKOverlayRenderer' => 'MapKit.MKOverlayRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC822 /* #1288 'MKOverlayPathRenderer' => 'MapKit.MKOverlayPathRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD7422 /* #1289 'MKCircleRenderer' => 'MapKit.MKCircleRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD7622 /* #1290 'MKClusterAnnotation' => 'MapKit.MKClusterAnnotation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD7822 /* #1291 'MKDirectionsRequest' => 'MapKit.MKDirectionsRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD7922 /* #1292 'MKDirectionsResponse' => 'MapKit.MKDirectionsResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CA22 /* #1293 'NSFormatter' => 'Foundation.NSFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD7C22 /* #1294 'MKDistanceFormatter' => 'MapKit.MKDistanceFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8122 /* #1295 'MKETAResponse' => 'MapKit.MKETAResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8322 /* #1296 'MKGeoJSONDecoder' => 'MapKit.MKGeoJsonDecoder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8422 /* #1297 'MKGeoJSONFeature' => 'MapKit.MKGeoJsonFeature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDA322 /* #1298 'MKMapConfiguration' => 'MapKit.MKMapConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8822 /* #1299 'MKHybridMapConfiguration' => 'MapKit.MKHybridMapConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8922 /* #1300 'MKIconStyle' => 'MapKit.MKIconStyle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8A22 /* #1301 'MKImageryMapConfiguration' => 'MapKit.MKImageryMapConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8B22 /* #1302 'MKLocalPointsOfInterestRequest' => 'MapKit.MKLocalPointsOfInterestRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8C22 /* #1303 'MKLocalSearchCompleter' => 'MapKit.MKLocalSearchCompleter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9022 /* #1304 'MKLocalSearchCompleterDelegate' => 'MapKit.MKLocalSearchCompleterDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9222 /* #1305 'MKLocalSearchCompletion' => 'MapKit.MKLocalSearchCompletion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9322 /* #1306 'MKLocalSearchRequest' => 'MapKit.MKLocalSearchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9422 /* #1307 'MKLocalSearchResponse' => 'MapKit.MKLocalSearchResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9722 /* #1308 'MKLookAroundScene' => 'MapKit.MKLookAroundScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9922 /* #1309 'MKLookAroundSnapshot' => 'MapKit.MKLookAroundSnapshot, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9A22 /* #1310 'MKLookAroundSnapshotOptions' => 'MapKit.MKLookAroundSnapshotOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9C22 /* #1311 'MKLookAroundViewController' => 'MapKit.MKLookAroundViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDA022 /* #1312 'Xamarin_iOS__MapKit_MKLookAroundViewControllerDelegate' => 'MapKit.MKLookAroundViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDA122 /* #1313 'MKMapCamera' => 'MapKit.MKMapCamera, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDA222 /* #1314 'MKMapCameraBoundary' => 'MapKit.MKMapCameraBoundary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDA522 /* #1315 'MKMapFeatureAnnotation' => 'MapKit.MKMapFeatureAnnotation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDA922 /* #1316 'MKMapSnapshot' => 'MapKit.MKMapSnapshot, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDAA22 /* #1317 'MKMapSnapshotOptions' => 'MapKit.MKMapSnapshotOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDBD22 /* #1318 'MKMapViewDelegate' => 'MapKit.MKMapViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDBF22 /* #1319 'MKMultiPolygon' => 'MapKit.MKMultiPolygon, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC022 /* #1320 'MKMultiPolygonRenderer' => 'MapKit.MKMultiPolygonRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC122 /* #1321 'MKMultiPolyline' => 'MapKit.MKMultiPolyline, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC222 /* #1322 'MKMultiPolylineRenderer' => 'MapKit.MKMultiPolylineRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC622 /* #1323 'MKOverlay' => 'MapKit.MKOverlay, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193822 /* #1324 'CLPlacemark' => 'CoreLocation.CLPlacemark, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCD22 /* #1325 'MKPlacemark' => 'MapKit.MKPlacemark, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCF22 /* #1326 'MKPointAnnotation' => 'MapKit.MKPointAnnotation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDD222 /* #1327 'MKPolygonRenderer' => 'MapKit.MKPolygonRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDD422 /* #1328 'MKPolylineRenderer' => 'MapKit.MKPolylineRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDD622 /* #1329 'MKReverseGeocoder' => 'MapKit.MKReverseGeocoder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDD922 /* #1330 'MKReverseGeocoderDelegate' => 'MapKit.MKReverseGeocoderDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDDA22 /* #1331 'MKRoute' => 'MapKit.MKRoute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDDB22 /* #1332 'MKRouteStep' => 'MapKit.MKRouteStep, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE022 /* #1333 'MKStandardMapConfiguration' => 'MapKit.MKStandardMapConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE222 /* #1334 'MKTileOverlay' => 'MapKit.MKTileOverlay, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE322 /* #1335 'MKTileOverlayRenderer' => 'MapKit.MKTileOverlayRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE422 /* #1336 'MKUserLocation' => 'MapKit.MKUserLocation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4C22 /* #1337 'JSContext' => 'JavaScriptCore.JSContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4D22 /* #1338 'JSValue' => 'JavaScriptCore.JSValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5122 /* #1339 'Xamarin_iOS__JavaScriptCore_JSExport' => 'JavaScriptCore.JSExport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5222 /* #1340 'JSManagedValue' => 'JavaScriptCore.JSManagedValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5622 /* #1341 'JSVirtualMachine' => 'JavaScriptCore.JSVirtualMachine, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6722 /* #1342 'INIntentResolutionResult' => 'Intents.INIntentResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5922 /* #1343 'INBillTypeResolutionResult' => 'Intents.INBillTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5A22 /* #1344 'INCallRecord' => 'Intents.INCallRecord, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5B22 /* #1345 'INCallRecordTypeResolutionResult' => 'Intents.INCallRecordTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5C22 /* #1346 'INCarAirCirculationModeResolutionResult' => 'Intents.INCarAirCirculationModeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5D22 /* #1347 'INCarAudioSourceResolutionResult' => 'Intents.INCarAudioSourceResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5E22 /* #1348 'INCarDefrosterResolutionResult' => 'Intents.INCarDefrosterResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5F22 /* #1349 'INCarSeatResolutionResult' => 'Intents.INCarSeatResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6022 /* #1350 'INCarSignalOptionsResolutionResult' => 'Intents.INCarSignalOptionsResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6C22 /* #1351 'INPerson' => 'Intents.INPerson, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6122 /* #1352 'INRideDriver' => 'Intents.INRideDriver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6222 /* #1353 'INRideStatus' => 'Intents.INRideStatus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6322 /* #1354 'INRestaurantGuest' => 'Intents.INRestaurantGuest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF6022 /* #1355 'INIntentResponse' => 'Intents.INIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6422 /* #1356 'INGetCarLockStatusIntentResponse' => 'Intents.INGetCarLockStatusIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6522 /* #1357 'INGetCarPowerLevelStatusIntentResponse' => 'Intents.INGetCarPowerLevelStatusIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6922 /* #1358 'INMessageAttributeOptionsResolutionResult' => 'Intents.INMessageAttributeOptionsResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6A22 /* #1359 'INMessageAttributeResolutionResult' => 'Intents.INMessageAttributeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6B22 /* #1360 'INPaymentStatusResolutionResult' => 'Intents.INPaymentStatusResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6D22 /* #1361 'INPlayMediaIntentResponse' => 'Intents.INPlayMediaIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6F22 /* #1362 'INPriceRange' => 'Intents.INPriceRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7022 /* #1363 'INRadioTypeResolutionResult' => 'Intents.INRadioTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7122 /* #1364 'INRelativeReferenceResolutionResult' => 'Intents.INRelativeReferenceResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7222 /* #1365 'INRelativeSettingResolutionResult' => 'Intents.INRelativeSettingResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7322 /* #1366 'INRideOption' => 'Intents.INRideOption, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF5722 /* #1367 'INIntent' => 'Intents.INIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7422 /* #1368 'INSaveProfileInCarIntent' => 'Intents.INSaveProfileInCarIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7522 /* #1369 'INSearchCallHistoryIntent' => 'Intents.INSearchCallHistoryIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7622 /* #1370 'INSetCarLockStatusIntent' => 'Intents.INSetCarLockStatusIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7722 /* #1371 'INSetClimateSettingsInCarIntent' => 'Intents.INSetClimateSettingsInCarIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7822 /* #1372 'INSetDefrosterSettingsInCarIntent' => 'Intents.INSetDefrosterSettingsInCarIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7922 /* #1373 'INSetProfileInCarIntent' => 'Intents.INSetProfileInCarIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7A22 /* #1374 'INSetSeatSettingsInCarIntent' => 'Intents.INSetSeatSettingsInCarIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7B22 /* #1375 'INSpeakableString' => 'Intents.INSpeakableString, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7C22 /* #1376 'INStartWorkoutIntent' => 'Intents.INStartWorkoutIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7D22 /* #1377 'INWorkoutGoalUnitTypeResolutionResult' => 'Intents.INWorkoutGoalUnitTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7E22 /* #1378 'INWorkoutLocationTypeResolutionResult' => 'Intents.INWorkoutLocationTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8122 /* #1379 'INAccountTypeResolutionResult' => 'Intents.INAccountTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8222 /* #1380 'INActivateCarSignalIntent' => 'Intents.INActivateCarSignalIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8622 /* #1381 'INActivateCarSignalIntentResponse' => 'Intents.INActivateCarSignalIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8822 /* #1382 'INAddMediaIntent' => 'Intents.INAddMediaIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8C22 /* #1383 'INAddMediaIntentResponse' => 'Intents.INAddMediaIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7722 /* #1384 'INMediaDestinationResolutionResult' => 'Intents.INMediaDestinationResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8E22 /* #1385 'INAddMediaMediaDestinationResolutionResult' => 'Intents.INAddMediaMediaDestinationResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7A22 /* #1386 'INMediaItemResolutionResult' => 'Intents.INMediaItemResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9022 /* #1387 'INAddMediaMediaItemResolutionResult' => 'Intents.INAddMediaMediaItemResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9222 /* #1388 'INAddTasksIntent' => 'Intents.INAddTasksIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9622 /* #1389 'INAddTasksIntentResponse' => 'Intents.INAddTasksIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10BF22 /* #1390 'INTaskListResolutionResult' => 'Intents.INTaskListResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9922 /* #1391 'INAddTasksTargetTaskListResolutionResult' => 'Intents.INAddTasksTargetTaskListResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C822 /* #1392 'INTemporalEventTriggerResolutionResult' => 'Intents.INTemporalEventTriggerResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9A22 /* #1393 'INAddTasksTemporalEventTriggerResolutionResult' => 'Intents.INAddTasksTemporalEventTriggerResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9C22 /* #1394 'INAirline' => 'Intents.INAirline, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9D22 /* #1395 'INAirport' => 'Intents.INAirport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9E22 /* #1396 'INAirportGate' => 'Intents.INAirportGate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEA022 /* #1397 'INAnswerCallIntent' => 'Intents.INAnswerCallIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEA422 /* #1398 'INAnswerCallIntentResponse' => 'Intents.INAnswerCallIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEA622 /* #1399 'INAppendToNoteIntent' => 'Intents.INAppendToNoteIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEAA22 /* #1400 'INAppendToNoteIntentResponse' => 'Intents.INAppendToNoteIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEAC22 /* #1401 'INBalanceAmount' => 'Intents.INBalanceAmount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEAE22 /* #1402 'INBalanceTypeResolutionResult' => 'Intents.INBalanceTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEAF22 /* #1403 'INBillDetails' => 'Intents.INBillDetails, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEB022 /* #1404 'INBillPayee' => 'Intents.INBillPayee, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEB122 /* #1405 'INBillPayeeResolutionResult' => 'Intents.INBillPayeeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE622 /* #1406 'INReservation' => 'Intents.INReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEB322 /* #1407 'INBoatReservation' => 'Intents.INBoatReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEB422 /* #1408 'INBoatTrip' => 'Intents.INBoatTrip, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEB522 /* #1409 'INBookRestaurantReservationIntent' => 'Intents.INBookRestaurantReservationIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEBA22 /* #1410 'INBookRestaurantReservationIntentResponse' => 'Intents.INBookRestaurantReservationIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEBB22 /* #1411 'INBooleanResolutionResult' => 'Intents.INBooleanResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEBC22 /* #1412 'INBusReservation' => 'Intents.INBusReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEBD22 /* #1413 'INBusTrip' => 'Intents.INBusTrip, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEC122 /* #1414 'INCallCapabilityResolutionResult' => 'Intents.INCallCapabilityResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEC322 /* #1415 'INCallDestinationTypeResolutionResult' => 'Intents.INCallDestinationTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEC422 /* #1416 'INCallGroup' => 'Intents.INCallGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEC522 /* #1417 'INCallRecordFilter' => 'Intents.INCallRecordFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEC622 /* #1418 'INCallRecordResolutionResult' => 'Intents.INCallRecordResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEC922 /* #1419 'INCallRecordTypeOptionsResolutionResult' => 'Intents.INCallRecordTypeOptionsResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xECC22 /* #1420 'INCancelRideIntent' => 'Intents.INCancelRideIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xED022 /* #1421 'INCancelRideIntentResponse' => 'Intents.INCancelRideIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xED222 /* #1422 'INCancelWorkoutIntent' => 'Intents.INCancelWorkoutIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xED622 /* #1423 'INCancelWorkoutIntentResponse' => 'Intents.INCancelWorkoutIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEE022 /* #1424 'INCarHeadUnit' => 'Intents.INCarHeadUnit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEE622 /* #1425 'INCreateNoteIntent' => 'Intents.INCreateNoteIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEEA22 /* #1426 'INCreateNoteIntentResponse' => 'Intents.INCreateNoteIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEEC22 /* #1427 'INCreateTaskListIntent' => 'Intents.INCreateTaskListIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF022 /* #1428 'INCreateTaskListIntentResponse' => 'Intents.INCreateTaskListIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF222 /* #1429 'INCurrencyAmount' => 'Intents.INCurrencyAmount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF322 /* #1430 'INCurrencyAmountResolutionResult' => 'Intents.INCurrencyAmountResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD022 /* #1431 'INRelevanceProvider' => 'Intents.INRelevanceProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF422 /* #1432 'INDailyRoutineRelevanceProvider' => 'Intents.INDailyRoutineRelevanceProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF622 /* #1433 'INDateComponentsRange' => 'Intents.INDateComponentsRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF722 /* #1434 'INDateComponentsRangeResolutionResult' => 'Intents.INDateComponentsRangeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF822 /* #1435 'INDateComponentsResolutionResult' => 'Intents.INDateComponentsResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEF922 /* #1436 'INDateRelevanceProvider' => 'Intents.INDateRelevanceProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEFB22 /* #1437 'INDateSearchTypeResolutionResult' => 'Intents.INDateSearchTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEFD22 /* #1438 'INDefaultCardTemplate' => 'Intents.INDefaultCardTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEFE22 /* #1439 'INDeleteTasksIntent' => 'Intents.INDeleteTasksIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF0222 /* #1440 'INDeleteTasksIntentResponse' => 'Intents.INDeleteTasksIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF0422 /* #1441 'INDeleteTasksTaskListResolutionResult' => 'Intents.INDeleteTasksTaskListResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C222 /* #1442 'INTaskResolutionResult' => 'Intents.INTaskResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF0622 /* #1443 'INDeleteTasksTaskResolutionResult' => 'Intents.INDeleteTasksTaskResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF0822 /* #1444 'INDoubleResolutionResult' => 'Intents.INDoubleResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF0922 /* #1445 'INEndWorkoutIntent' => 'Intents.INEndWorkoutIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF0D22 /* #1446 'INEndWorkoutIntentResponse' => 'Intents.INEndWorkoutIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF0F22 /* #1447 'INEnergyResolutionResult' => 'Intents.INEnergyResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1022 /* #1448 'INEnumResolutionResult' => 'Intents.INEnumResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1122 /* #1449 'INExtension' => 'Intents.INExtension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1222 /* #1450 'INFile' => 'Intents.INFile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1322 /* #1451 'INFileResolutionResult' => 'Intents.INFileResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1422 /* #1452 'INFlight' => 'Intents.INFlight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1522 /* #1453 'INFlightReservation' => 'Intents.INFlightReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1622 /* #1454 'INFocusStatus' => 'Intents.INFocusStatus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1922 /* #1455 'INGetAvailableRestaurantReservationBookingDefaultsIntent' => 'Intents.INGetAvailableRestaurantReservationBookingDefaultsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1D22 /* #1456 'INGetAvailableRestaurantReservationBookingDefaultsIntentResponse' => 'Intents.INGetAvailableRestaurantReservationBookingDefaultsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1F22 /* #1457 'INGetAvailableRestaurantReservationBookingsIntent' => 'Intents.INGetAvailableRestaurantReservationBookingsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF2422 /* #1458 'INGetAvailableRestaurantReservationBookingsIntentResponse' => 'Intents.INGetAvailableRestaurantReservationBookingsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF2522 /* #1459 'INGetCarLockStatusIntent' => 'Intents.INGetCarLockStatusIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF2A22 /* #1460 'INGetCarPowerLevelStatusIntent' => 'Intents.INGetCarPowerLevelStatusIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF3122 /* #1461 'INGetReservationDetailsIntent' => 'Intents.INGetReservationDetailsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF3222 /* #1462 'INGetReservationDetailsIntentResponse' => 'Intents.INGetReservationDetailsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF3422 /* #1463 'INGetRestaurantGuestIntent' => 'Intents.INGetRestaurantGuestIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF3822 /* #1464 'INGetRestaurantGuestIntentResponse' => 'Intents.INGetRestaurantGuestIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF3A22 /* #1465 'INGetRideStatusIntent' => 'Intents.INGetRideStatusIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF3E22 /* #1466 'INGetRideStatusIntentResponse' => 'Intents.INGetRideStatusIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF4222 /* #1467 'INGetUserCurrentRestaurantReservationBookingsIntent' => 'Intents.INGetUserCurrentRestaurantReservationBookingsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF4622 /* #1468 'INGetUserCurrentRestaurantReservationBookingsIntentResponse' => 'Intents.INGetUserCurrentRestaurantReservationBookingsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF4822 /* #1469 'INGetVisualCodeIntent' => 'Intents.INGetVisualCodeIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF4C22 /* #1470 'INGetVisualCodeIntentResponse' => 'Intents.INGetVisualCodeIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF4E22 /* #1471 'INHangUpCallIntent' => 'Intents.INHangUpCallIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF5222 /* #1472 'INHangUpCallIntentResponse' => 'Intents.INHangUpCallIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF8C22 /* #1473 'INNoteContent' => 'Intents.INNoteContent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF5522 /* #1474 'INImageNoteContent' => 'Intents.INImageNoteContent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF5622 /* #1475 'INIntegerResolutionResult' => 'Intents.INIntegerResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF5822 /* #1476 'INIntentDonationMetadata' => 'Intents.INIntentDonationMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF6222 /* #1477 'INLengthResolutionResult' => 'Intents.INLengthResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF6322 /* #1478 'INListCarsIntent' => 'Intents.INListCarsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF6722 /* #1479 'INListCarsIntentResponse' => 'Intents.INListCarsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF6922 /* #1480 'INListRideOptionsIntent' => 'Intents.INListRideOptionsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF6D22 /* #1481 'INListRideOptionsIntentResponse' => 'Intents.INListRideOptionsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF6F22 /* #1482 'INLocationRelevanceProvider' => 'Intents.INLocationRelevanceProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7122 /* #1483 'INLocationSearchTypeResolutionResult' => 'Intents.INLocationSearchTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7222 /* #1484 'INLodgingReservation' => 'Intents.INLodgingReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7322 /* #1485 'INMassResolutionResult' => 'Intents.INMassResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7522 /* #1486 'INMediaAffinityTypeResolutionResult' => 'Intents.INMediaAffinityTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7622 /* #1487 'INMediaDestination' => 'Intents.INMediaDestination, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7922 /* #1488 'INMediaItem' => 'Intents.INMediaItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7D22 /* #1489 'INMediaSearch' => 'Intents.INMediaSearch, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10E422 /* #1490 'INUserContext' => 'Intents.INUserContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF7F22 /* #1491 'INMediaUserContext' => 'Intents.INMediaUserContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF8122 /* #1492 'INMessage' => 'Intents.INMessage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF8722 /* #1493 'INNote' => 'Intents.INNote, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF8B22 /* #1494 'INNotebookItemTypeResolutionResult' => 'Intents.INNotebookItemTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF8D22 /* #1495 'INNoteContentResolutionResult' => 'Intents.INNoteContentResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF8F22 /* #1496 'INNoteContentTypeResolutionResult' => 'Intents.INNoteContentTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9022 /* #1497 'INNoteResolutionResult' => 'Intents.INNoteResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9122 /* #1498 'INObject' => 'Intents.INObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9222 /* #1499 'INObjectCollection' => 'Intents.INObjectCollection`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9322 /* #1500 'INObjectResolutionResult' => 'Intents.INObjectResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9422 /* #1501 'INObjectSection' => 'Intents.INObjectSection`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9622 /* #1502 'INOutgoingMessageTypeResolutionResult' => 'Intents.INOutgoingMessageTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9722 /* #1503 'INParameter' => 'Intents.INParameter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9822 /* #1504 'INPauseWorkoutIntent' => 'Intents.INPauseWorkoutIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9C22 /* #1505 'INPauseWorkoutIntentResponse' => 'Intents.INPauseWorkoutIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF9E22 /* #1506 'INPayBillIntent' => 'Intents.INPayBillIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA222 /* #1507 'INPayBillIntentResponse' => 'Intents.INPayBillIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA422 /* #1508 'INPaymentAccount' => 'Intents.INPaymentAccount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA522 /* #1509 'INPaymentAccountResolutionResult' => 'Intents.INPaymentAccountResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA622 /* #1510 'INPaymentAmount' => 'Intents.INPaymentAmount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA722 /* #1511 'INPaymentAmountResolutionResult' => 'Intents.INPaymentAmountResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA822 /* #1512 'INPaymentMethod' => 'Intents.INPaymentMethod, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA922 /* #1513 'INPaymentMethodResolutionResult' => 'Intents.INPaymentMethodResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFAB22 /* #1514 'INPaymentRecord' => 'Intents.INPaymentRecord, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFAF22 /* #1515 'INPersonHandle' => 'Intents.INPersonHandle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFB522 /* #1516 'INPersonResolutionResult' => 'Intents.INPersonResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBA22 /* #1517 'INPlacemarkResolutionResult' => 'Intents.INPlacemarkResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBC22 /* #1518 'INPlaybackQueueLocationResolutionResult' => 'Intents.INPlaybackQueueLocationResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBE22 /* #1519 'INPlaybackRepeatModeResolutionResult' => 'Intents.INPlaybackRepeatModeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBF22 /* #1520 'INPlayMediaIntent' => 'Intents.INPlayMediaIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC422 /* #1521 'INPlayMediaMediaItemResolutionResult' => 'Intents.INPlayMediaMediaItemResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC622 /* #1522 'INPlayMediaPlaybackSpeedResolutionResult' => 'Intents.INPlayMediaPlaybackSpeedResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFCD22 /* #1523 'INRecurrenceRule' => 'Intents.INRecurrenceRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD122 /* #1524 'INRelevantShortcut' => 'Intents.INRelevantShortcut, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD422 /* #1525 'INRentalCar' => 'Intents.INRentalCar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD522 /* #1526 'INRentalCarReservation' => 'Intents.INRentalCarReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD622 /* #1527 'INRequestPaymentCurrencyAmountResolutionResult' => 'Intents.INRequestPaymentCurrencyAmountResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD822 /* #1528 'INRequestPaymentIntent' => 'Intents.INRequestPaymentIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFDC22 /* #1529 'INRequestPaymentIntentResponse' => 'Intents.INRequestPaymentIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFDE22 /* #1530 'INRequestPaymentPayerResolutionResult' => 'Intents.INRequestPaymentPayerResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE022 /* #1531 'INRequestRideIntent' => 'Intents.INRequestRideIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE422 /* #1532 'INRequestRideIntentResponse' => 'Intents.INRequestRideIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE722 /* #1533 'INReservationAction' => 'Intents.INReservationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFEA22 /* #1534 'INRestaurant' => 'Intents.INRestaurant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFEB22 /* #1535 'INRestaurantGuestDisplayPreferences' => 'Intents.INRestaurantGuestDisplayPreferences, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFEC22 /* #1536 'INRestaurantGuestResolutionResult' => 'Intents.INRestaurantGuestResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFED22 /* #1537 'INRestaurantOffer' => 'Intents.INRestaurantOffer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFEE22 /* #1538 'INRestaurantReservation' => 'Intents.INRestaurantReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFEF22 /* #1539 'INRestaurantReservationBooking' => 'Intents.INRestaurantReservationBooking, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF022 /* #1540 'INRestaurantReservationUserBooking' => 'Intents.INRestaurantReservationUserBooking, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF222 /* #1541 'INRestaurantResolutionResult' => 'Intents.INRestaurantResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF322 /* #1542 'INResumeWorkoutIntent' => 'Intents.INResumeWorkoutIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF722 /* #1543 'INResumeWorkoutIntentResponse' => 'Intents.INResumeWorkoutIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF922 /* #1544 'INRideCompletionStatus' => 'Intents.INRideCompletionStatus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFFA22 /* #1545 'INRideFareLineItem' => 'Intents.INRideFareLineItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFFC22 /* #1546 'INRidePartySizeOption' => 'Intents.INRidePartySizeOption, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100022 /* #1547 'INRideVehicle' => 'Intents.INRideVehicle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100422 /* #1548 'INSaveProfileInCarIntentResponse' => 'Intents.INSaveProfileInCarIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100922 /* #1549 'INSearchCallHistoryIntentResponse' => 'Intents.INSearchCallHistoryIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100B22 /* #1550 'INSearchForAccountsIntent' => 'Intents.INSearchForAccountsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100F22 /* #1551 'INSearchForAccountsIntentResponse' => 'Intents.INSearchForAccountsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101122 /* #1552 'INSearchForBillsIntent' => 'Intents.INSearchForBillsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101522 /* #1553 'INSearchForBillsIntentResponse' => 'Intents.INSearchForBillsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101722 /* #1554 'INSearchForMediaIntent' => 'Intents.INSearchForMediaIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101B22 /* #1555 'INSearchForMediaIntentResponse' => 'Intents.INSearchForMediaIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101D22 /* #1556 'INSearchForMediaMediaItemResolutionResult' => 'Intents.INSearchForMediaMediaItemResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101F22 /* #1557 'INSearchForMessagesIntent' => 'Intents.INSearchForMessagesIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102322 /* #1558 'INSearchForMessagesIntentResponse' => 'Intents.INSearchForMessagesIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102522 /* #1559 'INSearchForNotebookItemsIntent' => 'Intents.INSearchForNotebookItemsIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102922 /* #1560 'INSearchForNotebookItemsIntentResponse' => 'Intents.INSearchForNotebookItemsIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102B22 /* #1561 'INSearchForPhotosIntent' => 'Intents.INSearchForPhotosIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102F22 /* #1562 'INSearchForPhotosIntentResponse' => 'Intents.INSearchForPhotosIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103122 /* #1563 'INSeat' => 'Intents.INSeat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103222 /* #1564 'INSendMessageAttachment' => 'Intents.INSendMessageAttachment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103322 /* #1565 'INSendMessageIntent' => 'Intents.INSendMessageIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103422 /* #1566 'INSendMessageIntentDonationMetadata' => 'Intents.INSendMessageIntentDonationMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103822 /* #1567 'INSendMessageIntentResponse' => 'Intents.INSendMessageIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103A22 /* #1568 'INSendMessageRecipientResolutionResult' => 'Intents.INSendMessageRecipientResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103C22 /* #1569 'INSendPaymentCurrencyAmountResolutionResult' => 'Intents.INSendPaymentCurrencyAmountResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103E22 /* #1570 'INSendPaymentIntent' => 'Intents.INSendPaymentIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104222 /* #1571 'INSendPaymentIntentResponse' => 'Intents.INSendPaymentIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104422 /* #1572 'INSendPaymentPayeeResolutionResult' => 'Intents.INSendPaymentPayeeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104622 /* #1573 'INSendRideFeedbackIntent' => 'Intents.INSendRideFeedbackIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104A22 /* #1574 'INSendRideFeedbackIntentResponse' => 'Intents.INSendRideFeedbackIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104C22 /* #1575 'INSetAudioSourceInCarIntent' => 'Intents.INSetAudioSourceInCarIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105022 /* #1576 'INSetAudioSourceInCarIntentResponse' => 'Intents.INSetAudioSourceInCarIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105522 /* #1577 'INSetCarLockStatusIntentResponse' => 'Intents.INSetCarLockStatusIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105A22 /* #1578 'INSetClimateSettingsInCarIntentResponse' => 'Intents.INSetClimateSettingsInCarIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105F22 /* #1579 'INSetDefrosterSettingsInCarIntentResponse' => 'Intents.INSetDefrosterSettingsInCarIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106122 /* #1580 'INSetMessageAttributeIntent' => 'Intents.INSetMessageAttributeIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106522 /* #1581 'INSetMessageAttributeIntentResponse' => 'Intents.INSetMessageAttributeIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106A22 /* #1582 'INSetProfileInCarIntentResponse' => 'Intents.INSetProfileInCarIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106C22 /* #1583 'INSetRadioStationIntent' => 'Intents.INSetRadioStationIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107022 /* #1584 'INSetRadioStationIntentResponse' => 'Intents.INSetRadioStationIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107522 /* #1585 'INSetSeatSettingsInCarIntentResponse' => 'Intents.INSetSeatSettingsInCarIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107722 /* #1586 'INSetTaskAttributeIntent' => 'Intents.INSetTaskAttributeIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107B22 /* #1587 'INSetTaskAttributeIntentResponse' => 'Intents.INSetTaskAttributeIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107D22 /* #1588 'INSetTaskAttributeTemporalEventTriggerResolutionResult' => 'Intents.INSetTaskAttributeTemporalEventTriggerResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107F22 /* #1589 'INShareFocusStatusIntent' => 'Intents.INShareFocusStatusIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x108322 /* #1590 'INShareFocusStatusIntentResponse' => 'Intents.INShareFocusStatusIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x108522 /* #1591 'INShortcut' => 'Intents.INShortcut, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x108822 /* #1592 'INSnoozeTasksIntent' => 'Intents.INSnoozeTasksIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x108C22 /* #1593 'INSnoozeTasksIntentResponse' => 'Intents.INSnoozeTasksIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x108E22 /* #1594 'INSnoozeTasksTaskResolutionResult' => 'Intents.INSnoozeTasksTaskResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109222 /* #1595 'INSpatialEventTrigger' => 'Intents.INSpatialEventTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109322 /* #1596 'INSpatialEventTriggerResolutionResult' => 'Intents.INSpatialEventTriggerResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109722 /* #1597 'INSpeakableStringResolutionResult' => 'Intents.INSpeakableStringResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109822 /* #1598 'INSpeedResolutionResult' => 'Intents.INSpeedResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109922 /* #1599 'INStartAudioCallIntent' => 'Intents.INStartAudioCallIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109D22 /* #1600 'INStartAudioCallIntentResponse' => 'Intents.INStartAudioCallIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109F22 /* #1601 'INStartCallCallCapabilityResolutionResult' => 'Intents.INStartCallCallCapabilityResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A122 /* #1602 'INStartCallCallRecordToCallBackResolutionResult' => 'Intents.INStartCallCallRecordToCallBackResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A322 /* #1603 'INStartCallContactResolutionResult' => 'Intents.INStartCallContactResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A522 /* #1604 'INStartCallIntent' => 'Intents.INStartCallIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A922 /* #1605 'INStartCallIntentResponse' => 'Intents.INStartCallIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10AB22 /* #1606 'INStartPhotoPlaybackIntent' => 'Intents.INStartPhotoPlaybackIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10AF22 /* #1607 'INStartPhotoPlaybackIntentResponse' => 'Intents.INStartPhotoPlaybackIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10B122 /* #1608 'INStartVideoCallIntent' => 'Intents.INStartVideoCallIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10B522 /* #1609 'INStartVideoCallIntentResponse' => 'Intents.INStartVideoCallIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10BA22 /* #1610 'INStartWorkoutIntentResponse' => 'Intents.INStartWorkoutIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10BC22 /* #1611 'INStringResolutionResult' => 'Intents.INStringResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10BD22 /* #1612 'INTask' => 'Intents.INTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10BE22 /* #1613 'INTaskList' => 'Intents.INTaskList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C122 /* #1614 'INTaskPriorityResolutionResult' => 'Intents.INTaskPriorityResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C422 /* #1615 'INTaskStatusResolutionResult' => 'Intents.INTaskStatusResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C622 /* #1616 'INTemperatureResolutionResult' => 'Intents.INTemperatureResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C722 /* #1617 'INTemporalEventTrigger' => 'Intents.INTemporalEventTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CA22 /* #1618 'INTemporalEventTriggerTypeOptionsResolutionResult' => 'Intents.INTemporalEventTriggerTypeOptionsResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CB22 /* #1619 'INTermsAndConditions' => 'Intents.INTermsAndConditions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CC22 /* #1620 'INTextNoteContent' => 'Intents.INTextNoteContent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CD22 /* #1621 'INTicketedEvent' => 'Intents.INTicketedEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CF22 /* #1622 'INTicketedEventReservation' => 'Intents.INTicketedEventReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D022 /* #1623 'INTimeIntervalResolutionResult' => 'Intents.INTimeIntervalResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D122 /* #1624 'INTrainReservation' => 'Intents.INTrainReservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D222 /* #1625 'INTrainTrip' => 'Intents.INTrainTrip, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D322 /* #1626 'INTransferMoneyIntent' => 'Intents.INTransferMoneyIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D722 /* #1627 'INTransferMoneyIntentResponse' => 'Intents.INTransferMoneyIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D922 /* #1628 'INUpcomingMediaManager' => 'Intents.INUpcomingMediaManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10DB22 /* #1629 'INUpdateMediaAffinityIntent' => 'Intents.INUpdateMediaAffinityIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10DF22 /* #1630 'INUpdateMediaAffinityIntentResponse' => 'Intents.INUpdateMediaAffinityIntentResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10E122 /* #1631 'INUpdateMediaAffinityMediaItemResolutionResult' => 'Intents.INUpdateMediaAffinityMediaItemResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10E322 /* #1632 'INURLResolutionResult' => 'Intents.INUrlResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10E822 /* #1633 'INVisualCodeTypeResolutionResult' => 'Intents.INVisualCodeTypeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10E922 /* #1634 'INVocabulary' => 'Intents.INVocabulary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10EB22 /* #1635 'INVoiceShortcut' => 'Intents.INVoiceShortcut, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10ED22 /* #1636 'INVolumeResolutionResult' => 'Intents.INVolumeResolutionResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x112122 /* #1637 'HMCharacteristicMetadata' => 'HomeKit.HMCharacteristicMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113222 /* #1638 'HMAccessControl' => 'HomeKit.HMAccessControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113D22 /* #1639 'HMAccessoryBrowserDelegate' => 'HomeKit.HMAccessoryBrowserDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113E22 /* #1640 'HMAccessoryCategory' => 'HomeKit.HMAccessoryCategory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114422 /* #1641 'HMAccessoryDelegate' => 'HomeKit.HMAccessoryDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114522 /* #1642 'HMAccessoryOwnershipToken' => 'HomeKit.HMAccessoryOwnershipToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114622 /* #1643 'HMAccessoryProfile' => 'HomeKit.HMAccessoryProfile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114722 /* #1644 'HMAccessorySetupPayload' => 'HomeKit.HMAccessorySetupPayload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114822 /* #1645 'HMAccessorySetupRequest' => 'HomeKit.HMAccessorySetupRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114922 /* #1646 'HMAccessorySetupResult' => 'HomeKit.HMAccessorySetupResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114A22 /* #1647 'HMAction' => 'HomeKit.HMAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114D22 /* #1648 'HMAddAccessoryRequest' => 'HomeKit.HMAddAccessoryRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119E22 /* #1649 'HMEvent' => 'HomeKit.HMEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D322 /* #1650 'HMTimeEvent' => 'HomeKit.HMTimeEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114E22 /* #1651 'HMCalendarEvent' => 'HomeKit.HMCalendarEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115122 /* #1652 'HMCameraControl' => 'HomeKit.HMCameraControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114F22 /* #1653 'HMCameraAudioControl' => 'HomeKit.HMCameraAudioControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115222 /* #1654 'HMCameraProfile' => 'HomeKit.HMCameraProfile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115322 /* #1655 'HMCameraSettingsControl' => 'HomeKit.HMCameraSettingsControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115A22 /* #1656 'HMCameraSource' => 'HomeKit.HMCameraSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115422 /* #1657 'HMCameraSnapshot' => 'HomeKit.HMCameraSnapshot, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115522 /* #1658 'HMCameraSnapshotControl' => 'HomeKit.HMCameraSnapshotControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115922 /* #1659 'HMCameraSnapshotControlDelegate' => 'HomeKit.HMCameraSnapshotControlDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115C22 /* #1660 'HMCameraStreamControl' => 'HomeKit.HMCameraStreamControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x116022 /* #1661 'HMCameraStreamControlDelegate' => 'HomeKit.HMCameraStreamControlDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x116922 /* #1662 'HMCharacteristicThresholdRangeEvent' => 'HomeKit.HMCharacteristicThresholdRangeEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119B22 /* #1663 'HMDurationEvent' => 'HomeKit.HMDurationEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11AC22 /* #1664 'HMHomeAccessControl' => 'HomeKit.HMHomeAccessControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11B022 /* #1665 'HMHomeDelegate' => 'HomeKit.HMHomeDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11BA22 /* #1666 'HMHomeManagerDelegate' => 'HomeKit.HMHomeManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11BC22 /* #1667 'HMMutableCalendarEvent' => 'HomeKit.HMMutableCalendarEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x116322 /* #1668 'HMCharacteristicEvent' => 'HomeKit.HMCharacteristicEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11BD22 /* #1669 'HMMutableCharacteristicEvent' => 'HomeKit.HMMutableCharacteristicEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11BE22 /* #1670 'HMMutableCharacteristicThresholdRangeEvent' => 'HomeKit.HMMutableCharacteristicThresholdRangeEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11BF22 /* #1671 'HMMutableDurationEvent' => 'HomeKit.HMMutableDurationEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11BB22 /* #1672 'HMLocationEvent' => 'HomeKit.HMLocationEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11C022 /* #1673 'HMMutableLocationEvent' => 'HomeKit.HMMutableLocationEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11C922 /* #1674 'HMPresenceEvent' => 'HomeKit.HMPresenceEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11C122 /* #1675 'HMMutablePresenceEvent' => 'HomeKit.HMMutablePresenceEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D222 /* #1676 'HMSignificantTimeEvent' => 'HomeKit.HMSignificantTimeEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11C222 /* #1677 'HMMutableSignificantTimeEvent' => 'HomeKit.HMMutableSignificantTimeEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11C322 /* #1678 'HMNetworkConfigurationProfile' => 'HomeKit.HMNetworkConfigurationProfile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11C722 /* #1679 'Xamarin_iOS__HomeKit_HMNetworkConfigurationProfileDelegate' => 'HomeKit.HMNetworkConfigurationProfileDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11C822 /* #1680 'HMNumberRange' => 'HomeKit.HMNumberRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D622 /* #1681 'HMUser' => 'HomeKit.HMUser, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125822 /* #1682 'HKQuery' => 'HealthKit.HKQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11DC22 /* #1683 'HKAnchoredObjectQuery' => 'HealthKit.HKAnchoredObjectQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E522 /* #1684 'HKObjectType' => 'HealthKit.HKObjectType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125D22 /* #1685 'HKSampleType' => 'HealthKit.HKSampleType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11DF22 /* #1686 'HKQuantityType' => 'HealthKit.HKQuantityType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E022 /* #1687 'HKCategoryType' => 'HealthKit.HKCategoryType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E122 /* #1688 'HKCharacteristicType' => 'HealthKit.HKCharacteristicType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E222 /* #1689 'HKCorrelationType' => 'HealthKit.HKCorrelationType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E322 /* #1690 'HKDocumentType' => 'HealthKit.HKDocumentType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E422 /* #1691 'HKStatisticsCollectionQuery' => 'HealthKit.HKStatisticsCollectionQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E622 /* #1692 'HKSampleQuery' => 'HealthKit.HKSampleQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E722 /* #1693 'HKUnit' => 'HealthKit.HKUnit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E922 /* #1694 'HKActivityMoveModeObject' => 'HealthKit.HKActivityMoveModeObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11EA22 /* #1695 'HKActivitySummary' => 'HealthKit.HKActivitySummary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11EB22 /* #1696 'HKActivitySummaryQuery' => 'HealthKit.HKActivitySummaryQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11EC22 /* #1697 'HKActivitySummaryType' => 'HealthKit.HKActivitySummaryType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11EF22 /* #1698 'HKAttachment' => 'HealthKit.HKAttachment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124C22 /* #1699 'HKObject' => 'HealthKit.HKObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125C22 /* #1700 'HKSample' => 'HealthKit.HKSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F122 /* #1701 'HKAudiogramSample' => 'HealthKit.HKAudiogramSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F222 /* #1702 'HKAudiogramSampleType' => 'HealthKit.HKAudiogramSampleType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F322 /* #1703 'HKAudiogramSensitivityPoint' => 'HealthKit.HKAudiogramSensitivityPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F722 /* #1704 'HKBiologicalSexObject' => 'HealthKit.HKBiologicalSexObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FA22 /* #1705 'HKBloodTypeObject' => 'HealthKit.HKBloodTypeObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FC22 /* #1706 'HKCategorySample' => 'HealthKit.HKCategorySample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121022 /* #1707 'HKCDADocument' => 'HealthKit.HKCdaDocument, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122A22 /* #1708 'HKDocumentSample' => 'HealthKit.HKDocumentSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121122 /* #1709 'HKCDADocumentSample' => 'HealthKit.HKCdaDocumentSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121422 /* #1710 'HKClinicalRecord' => 'HealthKit.HKClinicalRecord, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121522 /* #1711 'HKClinicalType' => 'HealthKit.HKClinicalType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124822 /* #1712 'HKLensSpecification' => 'HealthKit.HKLensSpecification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121822 /* #1713 'HKContactsLensSpecification' => 'HealthKit.HKContactsLensSpecification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127422 /* #1714 'HKVisionPrescription' => 'HealthKit.HKVisionPrescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121922 /* #1715 'HKContactsPrescription' => 'HealthKit.HKContactsPrescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121A22 /* #1716 'HKCorrelation' => 'HealthKit.HKCorrelation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121B22 /* #1717 'HKCorrelationQuery' => 'HealthKit.HKCorrelationQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125322 /* #1718 'HKQuantitySample' => 'HealthKit.HKQuantitySample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121E22 /* #1719 'HKCumulativeQuantitySample' => 'HealthKit.HKCumulativeQuantitySample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121F22 /* #1720 'HKCumulativeQuantitySeriesSample' => 'HealthKit.HKCumulativeQuantitySeriesSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122222 /* #1721 'HKDeletedObject' => 'HealthKit.HKDeletedObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122522 /* #1722 'HKDevice' => 'HealthKit.HKDevice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122822 /* #1723 'HKDiscreteQuantitySample' => 'HealthKit.HKDiscreteQuantitySample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122922 /* #1724 'HKDocumentQuery' => 'HealthKit.HKDocumentQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122D22 /* #1725 'HKElectrocardiogram' => 'HealthKit.HKElectrocardiogram, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123022 /* #1726 'HKElectrocardiogramQuery' => 'HealthKit.HKElectrocardiogramQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123222 /* #1727 'HKElectrocardiogramType' => 'HealthKit.HKElectrocardiogramType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123322 /* #1728 'HKElectrocardiogramVoltageMeasurement' => 'HealthKit.HKElectrocardiogramVoltageMeasurement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123822 /* #1729 'HKFHIRResource' => 'HealthKit.HKFhirResource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123B22 /* #1730 'HKFHIRVersion' => 'HealthKit.HKFhirVersion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123D22 /* #1731 'HKFitzpatrickSkinTypeObject' => 'HealthKit.HKFitzpatrickSkinTypeObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123E22 /* #1732 'HKGlassesLensSpecification' => 'HealthKit.HKGlassesLensSpecification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123F22 /* #1733 'HKGlassesPrescription' => 'HealthKit.HKGlassesPrescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124222 /* #1734 'HKHeartbeatSeriesQuery' => 'HealthKit.HKHeartbeatSeriesQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125F22 /* #1735 'HKSeriesSample' => 'HealthKit.HKSeriesSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124322 /* #1736 'HKHeartbeatSeriesSample' => 'HealthKit.HKHeartbeatSeriesSample, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124D22 /* #1737 'HKObserverQuery' => 'HealthKit.HKObserverQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124F22 /* #1738 'HKPrescriptionType' => 'HealthKit.HKPrescriptionType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125122 /* #1739 'HKQuantity' => 'HealthKit.HKQuantity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125522 /* #1740 'HKQuantitySeriesSampleQuery' => 'HealthKit.HKQuantitySeriesSampleQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125922 /* #1741 'HKQueryAnchor' => 'HealthKit.HKQueryAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125A22 /* #1742 'HKQueryDescriptor' => 'HealthKit.HKQueryDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125E22 /* #1743 'HKSeriesBuilder' => 'HealthKit.HKSeriesBuilder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126022 /* #1744 'HKSeriesType' => 'HealthKit.HKSeriesType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126122 /* #1745 'HKSource' => 'HealthKit.HKSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126222 /* #1746 'HKSourceQuery' => 'HealthKit.HKSourceQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126322 /* #1747 'HKSourceRevision' => 'HealthKit.HKSourceRevision, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126522 /* #1748 'HKStatistics' => 'HealthKit.HKStatistics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126622 /* #1749 'HKStatisticsCollection' => 'HealthKit.HKStatisticsCollection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126822 /* #1750 'HKStatisticsQuery' => 'HealthKit.HKStatisticsQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126C22 /* #1751 'HKVerifiableClinicalRecord' => 'HealthKit.HKVerifiableClinicalRecord, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127222 /* #1752 'HKVerifiableClinicalRecordSubject' => 'HealthKit.HKVerifiableClinicalRecordSubject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127622 /* #1753 'HKVisionPrism' => 'HealthKit.HKVisionPrism, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127A22 /* #1754 'HKWheelchairUseObject' => 'HealthKit.HKWheelchairUseObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127B22 /* #1755 'HKWorkout' => 'HealthKit.HKWorkout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127C22 /* #1756 'HKWorkoutActivity' => 'HealthKit.HKWorkoutActivity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127F22 /* #1757 'HKWorkoutConfiguration' => 'HealthKit.HKWorkoutConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128022 /* #1758 'HKWorkoutEvent' => 'HealthKit.HKWorkoutEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128222 /* #1759 'HKWorkoutRoute' => 'HealthKit.HKWorkoutRoute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128422 /* #1760 'HKWorkoutRouteQuery' => 'HealthKit.HKWorkoutRouteQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128722 /* #1761 'HKWorkoutType' => 'HealthKit.HKWorkoutType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12A522 /* #1762 'GKBehavior' => 'GameplayKit.GKBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12A622 /* #1763 'GKQuadtree' => 'GameplayKit.GKQuadTree, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12A722 /* #1764 'GKQuadtreeNode' => 'GameplayKit.GKQuadTreeNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12A822 /* #1765 'GKComponentSystem' => 'GameplayKit.GKComponentSystem`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12A922 /* #1766 'GKCompositeBehavior' => 'GameplayKit.GKCompositeBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12AA22 /* #1767 'GKEntity' => 'GameplayKit.GKEntity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D222 /* #1768 'GKGraph' => 'GameplayKit.GKGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12AC22 /* #1769 'GKGridGraph' => 'GameplayKit.GKGridGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12AD22 /* #1770 'GKObstacleGraph' => 'GameplayKit.GKObstacleGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12AF22 /* #1771 'GKPath' => 'GameplayKit.GKPath, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E222 /* #1772 'GKObstacle' => 'GameplayKit.GKObstacle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B022 /* #1773 'GKPolygonObstacle' => 'GameplayKit.GKPolygonObstacle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B422 /* #1774 'GKState' => 'GameplayKit.GKState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B522 /* #1775 'GKStateMachine' => 'GameplayKit.GKStateMachine, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C322 /* #1776 'GKComponent' => 'GameplayKit.GKComponent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B722 /* #1777 'GKAgent' => 'GameplayKit.GKAgent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B822 /* #1778 'GKAgent2D' => 'GameplayKit.GKAgent2D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B922 /* #1779 'GKAgent3D' => 'GameplayKit.GKAgent3D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12BD22 /* #1780 'GKAgentDelegate' => 'GameplayKit.GKAgentDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E922 /* #1781 'GKRandomSource' => 'GameplayKit.GKRandomSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12BE22 /* #1782 'GKARC4RandomSource' => 'GameplayKit.GKARC4RandomSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E022 /* #1783 'GKNoiseSource' => 'GameplayKit.GKNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C222 /* #1784 'GKCoherentNoiseSource' => 'GameplayKit.GKCoherentNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12BF22 /* #1785 'GKBillowNoiseSource' => 'GameplayKit.GKBillowNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C022 /* #1786 'GKCheckerboardNoiseSource' => 'GameplayKit.GKCheckerboardNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C122 /* #1787 'GKCircleObstacle' => 'GameplayKit.GKCircleObstacle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C422 /* #1788 'GKConstantNoiseSource' => 'GameplayKit.GKConstantNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C522 /* #1789 'GKCylindersNoiseSource' => 'GameplayKit.GKCylindersNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C622 /* #1790 'GKDecisionNode' => 'GameplayKit.GKDecisionNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C722 /* #1791 'GKDecisionTree' => 'GameplayKit.GKDecisionTree, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E822 /* #1792 'GKRandomDistribution' => 'GameplayKit.GKRandomDistribution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D022 /* #1793 'GKGaussianDistribution' => 'GameplayKit.GKGaussianDistribution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D122 /* #1794 'GKGoal' => 'GameplayKit.GKGoal, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D322 /* #1795 'GKGraphNode' => 'GameplayKit.GKGraphNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D422 /* #1796 'GKGraphNode2D' => 'GameplayKit.GKGraphNode2D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D522 /* #1797 'GKGraphNode3D' => 'GameplayKit.GKGraphNode3D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D622 /* #1798 'GKGridGraphNode' => 'GameplayKit.GKGridGraphNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D722 /* #1799 'GKHybridStrategist' => 'GameplayKit.GKHybridStrategist, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D822 /* #1800 'GKLinearCongruentialRandomSource' => 'GameplayKit.GKLinearCongruentialRandomSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D922 /* #1801 'GKMersenneTwisterRandomSource' => 'GameplayKit.GKMersenneTwisterRandomSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DA22 /* #1802 'GKMeshGraph' => 'GameplayKit.GKMeshGraph`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DC22 /* #1803 'GKMinmaxStrategist' => 'GameplayKit.GKMinMaxStrategist, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DD22 /* #1804 'GKMonteCarloStrategist' => 'GameplayKit.GKMonteCarloStrategist, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DE22 /* #1805 'GKNoise' => 'GameplayKit.GKNoise, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DF22 /* #1806 'GKNoiseMap' => 'GameplayKit.GKNoiseMap, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12ED22 /* #1807 'GKRule' => 'GameplayKit.GKRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E122 /* #1808 'GKNSPredicateRule' => 'GameplayKit.GKNSPredicateRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E322 /* #1809 'GKOctree' => 'GameplayKit.GKOctree`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E422 /* #1810 'GKOctreeNode' => 'GameplayKit.GKOctreeNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E522 /* #1811 'GKPerlinNoiseSource' => 'GameplayKit.GKPerlinNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12EA22 /* #1812 'GKRidgedNoiseSource' => 'GameplayKit.GKRidgedNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12EB22 /* #1813 'GKRTree' => 'GameplayKit.GKRTree`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12EE22 /* #1814 'GKRuleSystem' => 'GameplayKit.GKRuleSystem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12EF22 /* #1815 'GKScene' => 'GameplayKit.GKScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F222 /* #1816 'GKSCNNodeComponent' => 'GameplayKit.GKSCNNodeComponent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F322 /* #1817 'GKShuffledDistribution' => 'GameplayKit.GKShuffledDistribution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F422 /* #1818 'GKSKNodeComponent' => 'GameplayKit.GKSKNodeComponent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F522 /* #1819 'GKSphereObstacle' => 'GameplayKit.GKSphereObstacle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F622 /* #1820 'GKSpheresNoiseSource' => 'GameplayKit.GKSpheresNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F922 /* #1821 'GKVoronoiNoiseSource' => 'GameplayKit.GKVoronoiNoiseSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FC22 /* #1822 'GKMatchRequest' => 'GameKit.GKMatchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130122 /* #1823 'GameKit_GKPeerPickerControllerDelegate' => 'GameKit.GKPeerPickerControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x130222 /* #1824 'GameKit_GKPeerPickerController' => 'GameKit.GKPeerPickerController, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x130322 /* #1825 'GKLocalPlayerListener' => 'GameKit.GKLocalPlayerListener, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x137922 /* #1826 'GKSessionDelegate' => 'GameKit.GKSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130722 /* #1827 'GameKit_Mono_GKSessionDelegate' => 'GameKit.Mono_GKSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x130A22 /* #1828 'GKVoiceChat' => 'GameKit.GKVoiceChat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130C22 /* #1829 'GKTurnBasedExchangeReply' => 'GameKit.GKTurnBasedExchangeReply, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130F22 /* #1830 'GKAccessPoint' => 'GameKit.GKAccessPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130D22 /* #1831 'GKChallenge' => 'GameKit.GKChallenge, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131322 /* #1832 'GKAchievementChallenge' => 'GameKit.GKAchievementChallenge, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131822 /* #1833 'GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131A22 /* #1834 'GKBasePlayer' => 'GameKit.GKBasePlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131F22 /* #1835 'GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandlerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132322 /* #1836 'GKChallengeListener' => 'GameKit.GKChallengeListener, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132522 /* #1837 'GKCloudPlayer' => 'GameKit.GKCloudPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132C22 /* #1838 'GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133022 /* #1839 'GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133822 /* #1840 'GKInvite' => 'GameKit.GKInvite, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133D22 /* #1841 'GKInviteEventListener' => 'GameKit.GKInviteEventListener, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x134522 /* #1842 'GKLeaderboardScore' => 'GameKit.GKLeaderboardScore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x134C22 /* #1843 'GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x135B22 /* #1844 'GKMatchDelegate' => 'GameKit.GKMatchDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x136522 /* #1845 'GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x137322 /* #1846 'GKSavedGameListener' => 'GameKit.GKSavedGameListener, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x137422 /* #1847 'GKScoreChallenge' => 'GameKit.GKScoreChallenge, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x137C22 /* #1848 'GKTurnBasedEventHandler' => 'GameKit.GKTurnBasedEventHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x138022 /* #1849 'GKTurnBasedEventHandlerDelegate' => 'GameKit.GKTurnBasedEventHandlerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x138422 /* #1850 'GKTurnBasedEventListener' => 'GameKit.GKTurnBasedEventListener, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x138A22 /* #1851 'GKTurnBasedMatchmakerViewControllerDelegate' => 'GameKit.GKTurnBasedMatchmakerViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x138D22 /* #1852 'GKTurnBasedParticipant' => 'GameKit.GKTurnBasedParticipant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x139222 /* #1853 'GKVoiceChatClient' => 'GameKit.GKVoiceChatClient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x139422 /* #1854 'GKVoiceChatService' => 'GameKit.GKVoiceChatService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13FA22 /* #1855 'GCPhysicalInputProfile' => 'GameController.GCPhysicalInputProfile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13E322 /* #1856 'GCExtendedGamepad' => 'GameController.GCExtendedGamepad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13B322 /* #1857 'GCExtendedGamepadSnapshot' => 'GameController.GCExtendedGamepadSnapshot, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13E522 /* #1858 'GCGamepad' => 'GameController.GCGamepad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13B522 /* #1859 'GCGamepadSnapshot' => 'GameController.GCGamepadSnapshot, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13F322 /* #1860 'GCMicroGamepad' => 'GameController.GCMicroGamepad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13B822 /* #1861 'GCMicroGamepadSnapshot' => 'GameController.GCMicroGamepadSnapshot, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13C422 /* #1862 'GCColor' => 'GameController.GCColor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13C822 /* #1863 'GCControllerElement' => 'GameController.GCControllerElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13C522 /* #1864 'GCControllerAxisInput' => 'GameController.GCControllerAxisInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13C622 /* #1865 'GCControllerButtonInput' => 'GameController.GCControllerButtonInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13C722 /* #1866 'GCControllerDirectionPad' => 'GameController.GCControllerDirectionPad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13CA22 /* #1867 'GCControllerTouchpad' => 'GameController.GCControllerTouchpad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13CE22 /* #1868 'GCDeviceBattery' => 'GameController.GCDeviceBattery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13D022 /* #1869 'GCDeviceCursor' => 'GameController.GCDeviceCursor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13D122 /* #1870 'GCDeviceHaptics' => 'GameController.GCDeviceHaptics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13D222 /* #1871 'GCDeviceLight' => 'GameController.GCDeviceLight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13DA22 /* #1872 'GCDirectionalGamepad' => 'GameController.GCDirectionalGamepad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13DD22 /* #1873 'GCDualSenseAdaptiveTrigger' => 'GameController.GCDualSenseAdaptiveTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13E022 /* #1874 'GCDualSenseGamepad' => 'GameController.GCDualSenseGamepad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13E122 /* #1875 'GCDualShockGamepad' => 'GameController.GCDualShockGamepad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13E222 /* #1876 'GCEventViewController' => 'GameController.GCEventViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13EF22 /* #1877 'GCKeyboardInput' => 'GameController.GCKeyboardInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13F522 /* #1878 'GCMotion' => 'GameController.GCMotion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13F722 /* #1879 'GCMouseInput' => 'GameController.GCMouseInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x140922 /* #1880 'GCVirtualControllerConfiguration' => 'GameController.GCVirtualControllerConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x140A22 /* #1881 'GCVirtualControllerElementConfiguration' => 'GameController.GCVirtualControllerElementConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x140B22 /* #1882 'GCXboxGamepad' => 'GameController.GCXboxGamepad, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142622 /* #1883 'GLKMesh' => 'GLKit.GLKMesh, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142922 /* #1884 'GLKBaseEffect' => 'GLKit.GLKBaseEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142A22 /* #1885 'GLKEffectProperty' => 'GLKit.GLKEffectProperty, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142B22 /* #1886 'GLKEffectPropertyFog' => 'GLKit.GLKEffectPropertyFog, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142C22 /* #1887 'GLKEffectPropertyLight' => 'GLKit.GLKEffectPropertyLight, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142D22 /* #1888 'GLKEffectPropertyMaterial' => 'GLKit.GLKEffectPropertyMaterial, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142E22 /* #1889 'GLKEffectPropertyTexture' => 'GLKit.GLKEffectPropertyTexture, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142F22 /* #1890 'GLKEffectPropertyTransform' => 'GLKit.GLKEffectPropertyTransform, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143022 /* #1891 'GLKMeshBuffer' => 'GLKit.GLKMeshBuffer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143122 /* #1892 'GLKMeshBufferAllocator' => 'GLKit.GLKMeshBufferAllocator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143522 /* #1893 'GLKNamedEffect' => 'GLKit.GLKNamedEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143622 /* #1894 'GLKReflectionMapEffect' => 'GLKit.GLKReflectionMapEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143722 /* #1895 'GLKSkyboxEffect' => 'GLKit.GLKSkyboxEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143822 /* #1896 'GLKSubmesh' => 'GLKit.GLKSubmesh, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143922 /* #1897 'GLKTextureInfo' => 'GLKit.GLKTextureInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x143C22 /* #1898 'GLKViewController' => 'GLKit.GLKViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144022 /* #1899 'GLKViewControllerDelegate' => 'GLKit.GLKViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144322 /* #1900 'GLKViewDelegate' => 'GLKit.GLKViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144722 /* #1901 'WKPreferences' => 'WebKit.WKPreferences, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144822 /* #1902 'WKWindowFeatures' => 'WebKit.WKWindowFeatures, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144B22 /* #1903 'WKBackForwardList' => 'WebKit.WKBackForwardList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144C22 /* #1904 'WKBackForwardListItem' => 'WebKit.WKBackForwardListItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144E22 /* #1905 'WKContentRuleList' => 'WebKit.WKContentRuleList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x145022 /* #1906 'WKContentWorld' => 'WebKit.WKContentWorld, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x145122 /* #1907 'WKContextMenuElementInfo' => 'WebKit.WKContextMenuElementInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x145822 /* #1908 'Xamarin_iOS__WebKit_WKDownloadDelegate' => 'WebKit.WKDownloadDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x145C22 /* #1909 'WKFindConfiguration' => 'WebKit.WKFindConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x145D22 /* #1910 'WKFindResult' => 'WebKit.WKFindResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x145E22 /* #1911 'WKFrameInfo' => 'WebKit.WKFrameInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x146722 /* #1912 'WKNavigation' => 'WebKit.WKNavigation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x146822 /* #1913 'WKNavigationAction' => 'WebKit.WKNavigationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x146D22 /* #1914 'WKNavigationDelegate' => 'WebKit.WKNavigationDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x146E22 /* #1915 'WKNavigationResponse' => 'WebKit.WKNavigationResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147122 /* #1916 'WKPDFConfiguration' => 'WebKit.WKPdfConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147622 /* #1917 'WKPreviewElementInfo' => 'WebKit.WKPreviewElementInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147722 /* #1918 'WKProcessPool' => 'WebKit.WKProcessPool, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147822 /* #1919 'WKScriptMessage' => 'WebKit.WKScriptMessage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147B22 /* #1920 'WKScriptMessageHandler' => 'WebKit.WKScriptMessageHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147E22 /* #1921 'WKSecurityOrigin' => 'WebKit.WKSecurityOrigin, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x148022 /* #1922 'WKSnapshotConfiguration' => 'WebKit.WKSnapshotConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x148422 /* #1923 'WKUIDelegate' => 'WebKit.WKUIDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x148922 /* #1924 'WKUserContentController' => 'WebKit.WKUserContentController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x148A22 /* #1925 'WKUserScript' => 'WebKit.WKUserScript, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x148C22 /* #1926 'WKWebpagePreferences' => 'WebKit.WKWebpagePreferences, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x148D22 /* #1927 'WKWebsiteDataRecord' => 'WebKit.WKWebsiteDataRecord, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x148F22 /* #1928 'WKWebViewConfiguration' => 'WebKit.WKWebViewConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x149222 /* #1929 'NSOperation' => 'Foundation.NSOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14A122 /* #1930 'Foundation_NSDispatcher' => 'Foundation.NSDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14A222 /* #1931 '__MonoMac_NSActionDispatcher' => 'Foundation.NSActionDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14A322 /* #1932 '__MonoMac_NSSynchronizationContextDispatcher' => 'Foundation.NSSynchronizationContextDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14A422 /* #1933 '__Xamarin_NSTimerActionDispatcher' => 'Foundation.NSTimerActionDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14A522 /* #1934 'Foundation_NSAsyncDispatcher' => 'Foundation.NSAsyncDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14A622 /* #1935 '__MonoMac_NSAsyncActionDispatcher' => 'Foundation.NSAsyncActionDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14A722 /* #1936 '__MonoMac_NSAsyncSynchronizationContextDispatcher' => 'Foundation.NSAsyncSynchronizationContextDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14A822 /* #1937 'NSArray' => 'Foundation.NSArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14AC22 /* #1938 'NSAutoreleasePool' => 'Foundation.NSAutoreleasePool, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14AD22 /* #1939 'NSBundle' => 'Foundation.NSBundle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B322 /* #1940 'NSDate' => 'Foundation.NSDate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B422 /* #1941 'NSDateComponents' => 'Foundation.NSDateComponents, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B922 /* #1942 'NSDirectoryEnumerator' => 'Foundation.NSDirectoryEnumerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14BD22 /* #1943 'NSError' => 'Foundation.NSError, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14BF22 /* #1944 'NSExpression' => 'Foundation.NSExpression, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14C822 /* #1945 'NSFileManagerDelegate' => 'Foundation.NSFileManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CB22 /* #1946 'NSHTTPCookie' => 'Foundation.NSHttpCookie, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14F722 /* #1947 'NSStream' => 'Foundation.NSStream, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CC22 /* #1948 'NSInputStream' => 'Foundation.NSInputStream, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D122 /* #1949 'NSMetadataItem' => 'Foundation.NSMetadataItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E122 /* #1950 'NSMutableArray' => 'Foundation.NSMutableArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14AA22 /* #1951 'NSAttributedString' => 'Foundation.NSAttributedString, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D322 /* #1952 'NSMutableAttributedString' => 'Foundation.NSMutableAttributedString, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E622 /* #1953 'NSOrderedSet' => 'Foundation.NSOrderedSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E722 /* #1954 'NSMutableOrderedSet' => 'Foundation.NSMutableOrderedSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14F222 /* #1955 'NSSet' => 'Foundation.NSSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D822 /* #1956 'NSMutableSet' => 'Foundation.NSMutableSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14F822 /* #1957 'NSString' => 'Foundation.NSString, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14DA22 /* #1958 'NSMutableString' => 'Foundation.NSMutableString, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14DB22 /* #1959 'NSURLRequest' => 'Foundation.NSUrlRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14DC22 /* #1960 'NSMutableURLRequest' => 'Foundation.NSMutableUrlRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14DD22 /* #1961 'Foundation_InternalNSNotificationHandler' => 'Foundation.InternalNSNotificationHandler, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x14E022 /* #1962 'NSNull' => 'Foundation.NSNull, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151F22 /* #1963 'NSValue' => 'Foundation.NSValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E122 /* #1964 'NSNumber' => 'Foundation.NSNumber, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E922 /* #1965 'NSOutputStream' => 'Foundation.NSOutputStream, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14EA22 /* #1966 'NSPredicate' => 'Foundation.NSPredicate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14EC22 /* #1967 'NSProxy' => 'Foundation.NSProxy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14EE22 /* #1968 'NSRunLoop' => 'Foundation.NSRunLoop, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14F922 /* #1969 'NSThread' => 'Foundation.NSThread, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14FA22 /* #1970 'NSTimeZone' => 'Foundation.NSTimeZone, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14FB22 /* #1971 'NSTimer' => 'Foundation.NSTimer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14FF22 /* #1972 'NSUnitAcceleration' => 'Foundation.NSUnitAcceleration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150022 /* #1973 'NSUnitAngle' => 'Foundation.NSUnitAngle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150122 /* #1974 'NSUnitArea' => 'Foundation.NSUnitArea, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150222 /* #1975 'NSUnitConcentrationMass' => 'Foundation.NSUnitConcentrationMass, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150322 /* #1976 'NSUnitDispersion' => 'Foundation.NSUnitDispersion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150422 /* #1977 'NSUnitDuration' => 'Foundation.NSUnitDuration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150522 /* #1978 'NSUnitElectricCharge' => 'Foundation.NSUnitElectricCharge, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150622 /* #1979 'NSUnitElectricCurrent' => 'Foundation.NSUnitElectricCurrent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150722 /* #1980 'NSUnitElectricPotentialDifference' => 'Foundation.NSUnitElectricPotentialDifference, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150822 /* #1981 'NSUnitElectricResistance' => 'Foundation.NSUnitElectricResistance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150922 /* #1982 'NSUnitEnergy' => 'Foundation.NSUnitEnergy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150A22 /* #1983 'NSUnitFrequency' => 'Foundation.NSUnitFrequency, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150B22 /* #1984 'NSUnitFuelEfficiency' => 'Foundation.NSUnitFuelEfficiency, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150C22 /* #1985 'NSUnitLength' => 'Foundation.NSUnitLength, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150D22 /* #1986 'NSUnitIlluminance' => 'Foundation.NSUnitIlluminance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150E22 /* #1987 'NSUnitMass' => 'Foundation.NSUnitMass, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150F22 /* #1988 'NSUnitPower' => 'Foundation.NSUnitPower, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151022 /* #1989 'NSUnitPressure' => 'Foundation.NSUnitPressure, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151122 /* #1990 'NSUnitSpeed' => 'Foundation.NSUnitSpeed, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151222 /* #1991 'NSUnitVolume' => 'Foundation.NSUnitVolume, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151522 /* #1992 'NSURLComponents' => 'Foundation.NSUrlComponents, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151722 /* #1993 'NSURLCredential' => 'Foundation.NSUrlCredential, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151822 /* #1994 'NSURLProtectionSpace' => 'Foundation.NSUrlProtectionSpace, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151922 /* #1995 'NSURLProtocol' => 'Foundation.NSUrlProtocol, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151E22 /* #1996 'NSUUID' => 'Foundation.NSUuid, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152022 /* #1997 'NSXPCConnection' => 'Foundation.NSXpcConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152122 /* #1998 'NSXPCInterface' => 'Foundation.NSXpcInterface, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153222 /* #1999 'NSAttributedStringMarkdownParsingOptions' => 'Foundation.NSAttributedStringMarkdownParsingOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153322 /* #2000 'NSAttributedStringMarkdownSourcePosition' => 'Foundation.NSAttributedStringMarkdownSourcePosition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153622 /* #2001 'NSBlockOperation' => 'Foundation.NSBlockOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153822 /* #2002 'NSByteCountFormatter' => 'Foundation.NSByteCountFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154022 /* #2003 'NSCacheDelegate' => 'Foundation.NSCacheDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154122 /* #2004 'NSCachedURLResponse' => 'Foundation.NSCachedUrlResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154522 /* #2005 'NSCharacterSet' => 'Foundation.NSCharacterSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154922 /* #2006 'NSCoding' => 'Foundation.NSCoding, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154B22 /* #2007 'NSComparisonPredicate' => 'Foundation.NSComparisonPredicate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154F22 /* #2008 'NSCompoundPredicate' => 'Foundation.NSCompoundPredicate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155122 /* #2009 'NSCondition' => 'Foundation.NSCondition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155222 /* #2010 'NSConditionLock' => 'Foundation.NSConditionLock, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155522 /* #2011 'NSCopying' => 'Foundation.NSCopying, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162A22 /* #2012 'NSRegularExpression' => 'Foundation.NSRegularExpression, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155922 /* #2013 'NSDataDetector' => 'Foundation.NSDataDetector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155D22 /* #2014 'NSDateComponentsFormatter' => 'Foundation.NSDateComponentsFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156122 /* #2015 'NSDateFormatter' => 'Foundation.NSDateFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156422 /* #2016 'NSDateInterval' => 'Foundation.NSDateInterval, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156522 /* #2017 'NSDateIntervalFormatter' => 'Foundation.NSDateIntervalFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156722 /* #2018 'NSDecimalNumber' => 'Foundation.NSDecimalNumber, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156E22 /* #2019 'NSEnergyFormatter' => 'Foundation.NSEnergyFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157222 /* #2020 'NSException' => 'Foundation.NSException, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157522 /* #2021 'NSExtensionItem' => 'Foundation.NSExtensionItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157822 /* #2022 'NSExtensionRequestHandling' => 'Foundation.NSExtensionRequestHandling, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157922 /* #2023 'NSFileAccessIntent' => 'Foundation.NSFileAccessIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157A22 /* #2024 'NSFileCoordinator' => 'Foundation.NSFileCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158522 /* #2025 'NSFilePresenter' => 'Foundation.NSFilePresenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158622 /* #2026 'NSFileProviderService' => 'Foundation.NSFileProviderService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158A22 /* #2027 'NSFileWrapper' => 'Foundation.NSFileWrapper, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167722 /* #2028 'NSURLResponse' => 'Foundation.NSUrlResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159422 /* #2029 'NSHTTPURLResponse' => 'Foundation.NSHttpUrlResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159522 /* #2030 'NSIndexSet' => 'Foundation.NSIndexSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159622 /* #2031 'NSInflectionRule' => 'Foundation.NSInflectionRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159722 /* #2032 'NSInflectionRuleExplicit' => 'Foundation.NSInflectionRuleExplicit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159922 /* #2033 'NSInvocation' => 'Foundation.NSInvocation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159B22 /* #2034 'NSISO8601DateFormatter' => 'Foundation.NSIso8601DateFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15A922 /* #2035 'NSJSONSerialization' => 'Foundation.NSJsonSerialization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15AF22 /* #2036 'NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiverDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15B322 /* #2037 'NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiverDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15B922 /* #2038 'NSLengthFormatter' => 'Foundation.NSLengthFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15BE22 /* #2039 'NSLinguisticTagger' => 'Foundation.NSLinguisticTagger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15C522 /* #2040 'NSListFormatter' => 'Foundation.NSListFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15C722 /* #2041 'NSLock' => 'Foundation.NSLock, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160C22 /* #2042 'NSPort' => 'Foundation.NSPort, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15CA22 /* #2043 'NSMachPort' => 'Foundation.NSMachPort, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161022 /* #2044 'NSPortDelegate' => 'Foundation.NSPortDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15CE22 /* #2045 'NSMachPortDelegate' => 'Foundation.NSMachPortDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15D022 /* #2046 'NSMassFormatter' => 'Foundation.NSMassFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15D422 /* #2047 'NSMeasurement' => 'Foundation.NSMeasurement`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15D522 /* #2048 'NSMeasurementFormatter' => 'Foundation.NSMeasurementFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15D822 /* #2049 'NSMetadataQueryAttributeValueTuple' => 'Foundation.NSMetadataQueryAttributeValueTuple, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15DC22 /* #2050 'NSMetadataQueryDelegate' => 'Foundation.NSMetadataQueryDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15DD22 /* #2051 'NSMetadataQueryResultGroup' => 'Foundation.NSMetadataQueryResultGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15DE22 /* #2052 'NSMethodSignature' => 'Foundation.NSMethodSignature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15DF22 /* #2053 'NSMorphology' => 'Foundation.NSMorphology, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E022 /* #2054 'NSMorphologyCustomPronoun' => 'Foundation.NSMorphologyCustomPronoun, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E222 /* #2055 'NSMutableCharacterSet' => 'Foundation.NSMutableCharacterSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E522 /* #2056 'NSMutableCopying' => 'Foundation.NSMutableCopying, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E622 /* #2057 'NSMutableIndexSet' => 'Foundation.NSMutableIndexSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F022 /* #2058 'NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowserDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F422 /* #2059 'NSNetServiceDelegate' => 'Foundation.NSNetServiceDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F722 /* #2060 'NSNotification' => 'Foundation.NSNotification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F922 /* #2061 'NSNotificationQueue' => 'Foundation.NSNotificationQueue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15FA22 /* #2062 'NSNumberFormatter' => 'Foundation.NSNumberFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160222 /* #2063 'NSOperationQueue' => 'Foundation.NSOperationQueue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160522 /* #2064 'NSOrthography' => 'Foundation.NSOrthography, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160722 /* #2065 'NSPersonNameComponents' => 'Foundation.NSPersonNameComponents, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160822 /* #2066 'NSPersonNameComponentsFormatter' => 'Foundation.NSPersonNameComponentsFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160B22 /* #2067 'NSPipe' => 'Foundation.NSPipe, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161122 /* #2068 'NSPortMessage' => 'Foundation.NSPortMessage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161A22 /* #2069 'NSPresentationIntent' => 'Foundation.NSPresentationIntent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162522 /* #2070 'NSPropertyListSerialization' => 'Foundation.NSPropertyListSerialization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B222 /* #2071 'NSData' => 'Foundation.NSData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D422 /* #2072 'NSMutableData' => 'Foundation.NSMutableData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162722 /* #2073 'NSPurgeableData' => 'Foundation.NSPurgeableData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162922 /* #2074 'NSRecursiveLock' => 'Foundation.NSRecursiveLock, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162C22 /* #2075 'NSRelativeDateTimeFormatter' => 'Foundation.NSRelativeDateTimeFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x163622 /* #2076 'NSSortDescriptor' => 'Foundation.NSSortDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x163D22 /* #2077 'NSStreamDelegate' => 'Foundation.NSStreamDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164122 /* #2078 'NSStringDrawingContext' => 'Foundation.NSStringDrawingContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164922 /* #2079 'NSTextCheckingResult' => 'Foundation.NSTextCheckingResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165122 /* #2080 'NSUnitConverter' => 'Foundation.NSUnitConverter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165222 /* #2081 'NSUnitConverterLinear' => 'Foundation.NSUnitConverterLinear, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165322 /* #2082 'NSUnitInformationStorage' => 'Foundation.NSUnitInformationStorage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165422 /* #2083 'NSUnitTemperature' => 'Foundation.NSUnitTemperature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165522 /* #2084 'NSURLAuthenticationChallenge' => 'Foundation.NSUrlAuthenticationChallenge, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165922 /* #2085 'NSURLAuthenticationChallengeSender' => 'Foundation.NSURLAuthenticationChallengeSender, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166622 /* #2086 'NSURLConnectionDelegate' => 'Foundation.NSUrlConnectionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166222 /* #2087 'NSURLConnectionDataDelegate' => 'Foundation.NSUrlConnectionDataDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166A22 /* #2088 'NSURLConnectionDownloadDelegate' => 'Foundation.NSUrlConnectionDownloadDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167222 /* #2089 'NSURLQueryItem' => 'Foundation.NSUrlQueryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168722 /* #2090 'NSURLSessionDelegate' => 'Foundation.NSUrlSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169922 /* #2091 'NSURLSessionTaskDelegate' => 'Foundation.NSUrlSessionTaskDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168122 /* #2092 'NSURLSessionDataDelegate' => 'Foundation.NSUrlSessionDataDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169522 /* #2093 'NSURLSessionTask' => 'Foundation.NSUrlSessionTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168222 /* #2094 'NSURLSessionDataTask' => 'Foundation.NSUrlSessionDataTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168B22 /* #2095 'NSURLSessionDownloadDelegate' => 'Foundation.NSUrlSessionDownloadDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168C22 /* #2096 'NSURLSessionDownloadTask' => 'Foundation.NSUrlSessionDownloadTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169222 /* #2097 'NSURLSessionStreamDelegate' => 'Foundation.NSUrlSessionStreamDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169A22 /* #2098 'NSURLSessionTaskMetrics' => 'Foundation.NSUrlSessionTaskMetrics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169F22 /* #2099 'NSURLSessionTaskTransactionMetrics' => 'Foundation.NSUrlSessionTaskTransactionMetrics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16A022 /* #2100 'NSURLSessionUploadTask' => 'Foundation.NSUrlSessionUploadTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16A522 /* #2101 'Xamarin_iOS__Foundation_NSUrlSessionWebSocketDelegate' => 'Foundation.NSUrlSessionWebSocketDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16A622 /* #2102 'NSURLSessionWebSocketMessage' => 'Foundation.NSUrlSessionWebSocketMessage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16AF22 /* #2103 'NSUserActivityDelegate' => 'Foundation.NSUserActivityDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16B522 /* #2104 'NSXPCListener' => 'Foundation.NSXpcListener, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16B922 /* #2105 'Xamarin_iOS__Foundation_NSXpcListenerDelegate' => 'Foundation.NSXpcListenerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16BA22 /* #2106 'NSXPCListenerEndpoint' => 'Foundation.NSXpcListenerEndpoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16FE22 /* #2107 'NSFileProviderDomainVersion' => 'FileProvider.NSFileProviderDomainVersion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x171422 /* #2108 'NSFileProviderItemVersion' => 'FileProvider.NSFileProviderItemVersion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x172022 /* #2109 'NSFileProviderRequest' => 'FileProvider.NSFileProviderRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x174922 /* #2110 'EKCalendarChooserDelegate' => 'EventKitUI.EKCalendarChooserDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x174F22 /* #2111 'EKEventEditViewDelegate' => 'EventKitUI.EKEventEditViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x175422 /* #2112 'EKEventViewDelegate' => 'EventKitUI.EKEventViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x176922 /* #2113 'EKObject' => 'EventKit.EKObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x175622 /* #2114 'EKRecurrenceRule' => 'EventKit.EKRecurrenceRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x175722 /* #2115 'EKRecurrenceDayOfWeek' => 'EventKit.EKRecurrenceDayOfWeek, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x175822 /* #2116 'EKAlarm' => 'EventKit.EKAlarm, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x175E22 /* #2117 'EKCalendarItem' => 'EventKit.EKCalendarItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x175922 /* #2118 'EKReminder' => 'EventKit.EKReminder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x175C22 /* #2119 'EKCalendar' => 'EventKit.EKCalendar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x176522 /* #2120 'EKEvent' => 'EventKit.EKEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x176A22 /* #2121 'EKParticipant' => 'EventKit.EKParticipant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x176F22 /* #2122 'EKRecurrenceEnd' => 'EventKit.EKRecurrenceEnd, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x177222 /* #2123 'EKSource' => 'EventKit.EKSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x177522 /* #2124 'EKStructuredLocation' => 'EventKit.EKStructuredLocation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x177622 /* #2125 'EKVirtualConferenceDescriptor' => 'EventKit.EKVirtualConferenceDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x177822 /* #2126 'EKVirtualConferenceRoomTypeDescriptor' => 'EventKit.EKVirtualConferenceRoomTypeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x177922 /* #2127 'EKVirtualConferenceURLDescriptor' => 'EventKit.EKVirtualConferenceUrlDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x182622 /* #2128 'CTCall' => 'CoreTelephony.CTCall, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x182722 /* #2129 'CTCallCenter' => 'CoreTelephony.CTCallCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x182822 /* #2130 'CTCarrier' => 'CoreTelephony.CTCarrier, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x182922 /* #2131 'CTCellularData' => 'CoreTelephony.CTCellularData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x182D22 /* #2132 'CTCellularPlanProvisioningRequest' => 'CoreTelephony.CTCellularPlanProvisioningRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183022 /* #2133 'CTSubscriber' => 'CoreTelephony.CTSubscriber, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183322 /* #2134 'CTSubscriberInfo' => 'CoreTelephony.CTSubscriberInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183822 /* #2135 'Xamarin_iOS__CoreTelephony_CTTelephonyNetworkInfoDelegate' => 'CoreTelephony.CTTelephonyNetworkInfoDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183922 /* #2136 'CSCustomAttributeKey' => 'CoreSpotlight.CSCustomAttributeKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183A22 /* #2137 'CSSearchQueryContext' => 'CoreSpotlight.CSSearchQueryContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183C22 /* #2138 'CSSearchableItemAttributeSet' => 'CoreSpotlight.CSSearchableItemAttributeSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183E22 /* #2139 'CSImportExtension' => 'CoreSpotlight.CSImportExtension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x184122 /* #2140 'CSIndexExtensionRequestHandler' => 'CoreSpotlight.CSIndexExtensionRequestHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x184222 /* #2141 'CSLocalizedString' => 'CoreSpotlight.CSLocalizedString, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x184422 /* #2142 'CSPerson' => 'CoreSpotlight.CSPerson, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x184A22 /* #2143 'CSSearchableIndexDelegate' => 'CoreSpotlight.CSSearchableIndexDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x184B22 /* #2144 'CSSearchableItem' => 'CoreSpotlight.CSSearchableItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x184C22 /* #2145 'CSSearchQuery' => 'CoreSpotlight.CSSearchQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x185022 /* #2146 'CSSuggestion' => 'CoreSpotlight.CSSuggestion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x185222 /* #2147 'CSUserQuery' => 'CoreSpotlight.CSUserQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x185322 /* #2148 'CSUserQueryContext' => 'CoreSpotlight.CSUserQueryContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x185522 /* #2149 'CMSensorRecorder' => 'CoreMotion.CMSensorRecorder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x185822 /* #2150 'CMSensorDataList' => 'CoreMotion.CMSensorDataList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187122 /* #2151 'CMLogItem' => 'CoreMotion.CMLogItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x185E22 /* #2152 'CMAccelerometerData' => 'CoreMotion.CMAccelerometerData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x185F22 /* #2153 'CMAbsoluteAltitudeData' => 'CoreMotion.CMAbsoluteAltitudeData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186122 /* #2154 'CMAltitudeData' => 'CoreMotion.CMAltitudeData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186222 /* #2155 'CMAmbientPressureData' => 'CoreMotion.CMAmbientPressureData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186322 /* #2156 'CMAttitude' => 'CoreMotion.CMAttitude, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186622 /* #2157 'CMDeviceMotion' => 'CoreMotion.CMDeviceMotion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186822 /* #2158 'CMDyskineticSymptomResult' => 'CoreMotion.CMDyskineticSymptomResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186B22 /* #2159 'CMGyroData' => 'CoreMotion.CMGyroData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186C22 /* #2160 'CMHeadphoneMotionManager' => 'CoreMotion.CMHeadphoneMotionManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187022 /* #2161 'Xamarin_iOS__CoreMotion_CMHeadphoneMotionManagerDelegate' => 'CoreMotion.CMHeadphoneMotionManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187222 /* #2162 'CMMagnetometerData' => 'CoreMotion.CMMagnetometerData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187322 /* #2163 'CMMotionActivity' => 'CoreMotion.CMMotionActivity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187622 /* #2164 'CMMotionManager' => 'CoreMotion.CMMotionManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187822 /* #2165 'CMPedometerData' => 'CoreMotion.CMPedometerData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187922 /* #2166 'CMPedometerEvent' => 'CoreMotion.CMPedometerEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187B22 /* #2167 'CMRecordedAccelerometerData' => 'CoreMotion.CMRecordedAccelerometerData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187C22 /* #2168 'CMRecordedPressureData' => 'CoreMotion.CMRecordedPressureData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187E22 /* #2169 'CMRotationRateData' => 'CoreMotion.CMRotationRateData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187D22 /* #2170 'CMRecordedRotationRateData' => 'CoreMotion.CMRecordedRotationRateData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188022 /* #2171 'CMTremorResult' => 'CoreMotion.CMTremorResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188E22 /* #2172 'MIDICISession' => 'CoreMidi.MidiCISession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188F22 /* #2173 'MIDINetworkConnection' => 'CoreMidi.MidiNetworkConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189022 /* #2174 'MIDINetworkHost' => 'CoreMidi.MidiNetworkHost, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18AD22 /* #2175 'MIDICIDeviceInfo' => 'CoreMidi.MidiCIDeviceInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18AE22 /* #2176 'MIDICIDiscoveredNode' => 'CoreMidi.MidiCIDiscoveredNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18AF22 /* #2177 'MIDICIDiscoveryManager' => 'CoreMidi.MidiCIDiscoveryManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B022 /* #2178 'MIDICIProfile' => 'CoreMidi.MidiCIProfile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B422 /* #2179 'Xamarin_iOS__CoreMidi_MidiCIProfileResponderDelegate' => 'CoreMidi.MidiCIProfileResponderDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B522 /* #2180 'MIDICIProfileState' => 'CoreMidi.MidiCIProfileState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18BA22 /* #2181 'MIDINetworkSession' => 'CoreMidi.MidiNetworkSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18F922 /* #2182 'MLDictionaryFeatureProvider' => 'CoreML.MLDictionaryFeatureProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18FB22 /* #2183 'MLMultiArrayConstraint' => 'CoreML.MLMultiArrayConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18FC22 /* #2184 'MLArrayBatchProvider' => 'CoreML.MLArrayBatchProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x190622 /* #2185 'Xamarin_iOS__CoreML_MLCustomModel' => 'CoreML.MLCustomModel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x190722 /* #2186 'MLDictionaryConstraint' => 'CoreML.MLDictionaryConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x190822 /* #2187 'MLFeatureDescription' => 'CoreML.MLFeatureDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x190C22 /* #2188 'MLFeatureValue' => 'CoreML.MLFeatureValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x190F22 /* #2189 'MLImageConstraint' => 'CoreML.MLImageConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191022 /* #2190 'MLImageSize' => 'CoreML.MLImageSize, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191122 /* #2191 'MLImageSizeConstraint' => 'CoreML.MLImageSizeConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191322 /* #2192 'MLKey' => 'CoreML.MLKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191422 /* #2193 'MLMetricKey' => 'CoreML.MLMetricKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191822 /* #2194 'MLModelAsset' => 'CoreML.MLModelAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191A22 /* #2195 'MLModelCollectionEntry' => 'CoreML.MLModelCollectionEntry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191B22 /* #2196 'MLModelConfiguration' => 'CoreML.MLModelConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191C22 /* #2197 'MLModelDescription' => 'CoreML.MLModelDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192422 /* #2198 'MLMultiArrayShapeConstraint' => 'CoreML.MLMultiArrayShapeConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192622 /* #2199 'MLNumericConstraint' => 'CoreML.MLNumericConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192722 /* #2200 'MLParameterDescription' => 'CoreML.MLParameterDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192822 /* #2201 'MLParameterKey' => 'CoreML.MLParameterKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192922 /* #2202 'MLPredictionOptions' => 'CoreML.MLPredictionOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192A22 /* #2203 'MLSequence' => 'CoreML.MLSequence, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192B22 /* #2204 'MLSequenceConstraint' => 'CoreML.MLSequenceConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192C22 /* #2205 'MLTask' => 'CoreML.MLTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192E22 /* #2206 'MLUpdateContext' => 'CoreML.MLUpdateContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193022 /* #2207 'MLUpdateProgressHandlers' => 'CoreML.MLUpdateProgressHandlers, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193122 /* #2208 'MLUpdateTask' => 'CoreML.MLUpdateTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193422 /* #2209 'CLHeading' => 'CoreLocation.CLHeading, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193522 /* #2210 'CLLocation' => 'CoreLocation.CLLocation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193C22 /* #2211 'CLBeacon' => 'CoreLocation.CLBeacon, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193D22 /* #2212 'CLBeaconIdentityConstraint' => 'CoreLocation.CLBeaconIdentityConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195C22 /* #2213 'CLRegion' => 'CoreLocation.CLRegion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193E22 /* #2214 'CLBeaconRegion' => 'CoreLocation.CLBeaconRegion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193F22 /* #2215 'CLCircularRegion' => 'CoreLocation.CLCircularRegion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194222 /* #2216 'CLFloor' => 'CoreLocation.CLFloor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195422 /* #2217 'CLLocationManagerDelegate' => 'CoreLocation.CLLocationManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195A22 /* #2218 'CLLocationSourceInformation' => 'CoreLocation.CLLocationSourceInformation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195E22 /* #2219 'CLVisit' => 'CoreLocation.CLVisit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x196122 /* #2220 'CIColor' => 'CoreImage.CIColor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x196322 /* #2221 'CIContext' => 'CoreImage.CIContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x196522 /* #2222 'CIDetector' => 'CoreImage.CIDetector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x196722 /* #2223 'CIFilter' => 'CoreImage.CIFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x196922 /* #2224 'CIImage' => 'CoreImage.CIImage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x196F22 /* #2225 'CISampler' => 'CoreImage.CISampler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x197022 /* #2226 'CIVector' => 'CoreImage.CIVector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x197122 /* #2227 'CoreImage_CIAccordionFoldTransition' => 'CoreImage.CIAccordionFoldTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A1722 /* #2228 'CoreImage_CICompositingFilter' => 'CoreImage.CICompositingFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x197422 /* #2229 'CoreImage_CIAdditionCompositing' => 'CoreImage.CIAdditionCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x197822 /* #2230 'CoreImage_CIAffineFilter' => 'CoreImage.CIAffineFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x197522 /* #2231 'CoreImage_CIAffineClamp' => 'CoreImage.CIAffineClamp, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x197922 /* #2232 'CoreImage_CIAffineTile' => 'CoreImage.CIAffineTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x197C22 /* #2233 'CoreImage_CIAffineTransform' => 'CoreImage.CIAffineTransform, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B8822 /* #2234 'CoreImage_CIReductionFilter' => 'CoreImage.CIReductionFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x197D22 /* #2235 'CoreImage_CIAreaAverage' => 'CoreImage.CIAreaAverage, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x198022 /* #2236 'CoreImage_CIAreaHistogram' => 'CoreImage.CIAreaHistogram, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x198322 /* #2237 'CoreImage_CIAreaLogarithmicHistogram' => 'CoreImage.CIAreaLogarithmicHistogram, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x198622 /* #2238 'CoreImage_CIAreaMaximum' => 'CoreImage.CIAreaMaximum, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x198722 /* #2239 'CoreImage_CIAreaMaximumAlpha' => 'CoreImage.CIAreaMaximumAlpha, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x198C22 /* #2240 'CoreImage_CIAreaMinimum' => 'CoreImage.CIAreaMinimum, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x198D22 /* #2241 'CoreImage_CIAreaMinimumAlpha' => 'CoreImage.CIAreaMinimumAlpha, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x199222 /* #2242 'CoreImage_CIAreaMinMax' => 'CoreImage.CIAreaMinMax, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x199522 /* #2243 'CoreImage_CIAreaMinMaxRed' => 'CoreImage.CIAreaMinMaxRed, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AC022 /* #2244 'CoreImage_CIImageGenerator' => 'CoreImage.CIImageGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x199A22 /* #2245 'CoreImage_CIAttributedTextImageGenerator' => 'CoreImage.CIAttributedTextImageGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19A222 /* #2246 'CIBarcodeDescriptor' => 'CoreImage.CIBarcodeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199E22 /* #2247 'CIAztecCodeDescriptor' => 'CoreImage.CIAztecCodeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19D722 /* #2248 'CoreImage_CICodeGenerator' => 'CoreImage.CICodeGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x199F22 /* #2249 'CoreImage_CIAztecCodeGenerator' => 'CoreImage.CIAztecCodeGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19A322 /* #2250 'CoreImage_CIBarcodeGenerator' => 'CoreImage.CIBarcodeGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BE222 /* #2251 'CoreImage_CITransitionFilter' => 'CoreImage.CITransitionFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19A622 /* #2252 'CoreImage_CIBarsSwipeTransition' => 'CoreImage.CIBarsSwipeTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19A922 /* #2253 'CoreImage_CIBicubicScaleTransform' => 'CoreImage.CIBicubicScaleTransform, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19AC22 /* #2254 'CoreImage_CIBlendFilter' => 'CoreImage.CIBlendFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AD322 /* #2255 'CIKernel' => 'CoreImage.CIKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F922 /* #2256 'CIColorKernel' => 'CoreImage.CIColorKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19AD22 /* #2257 'CIBlendKernel' => 'CoreImage.CIBlendKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19B022 /* #2258 'CoreImage_CIBlendWithMask' => 'CoreImage.CIBlendWithMask, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19AE22 /* #2259 'CoreImage_CIBlendWithAlphaMask' => 'CoreImage.CIBlendWithAlphaMask, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19AF22 /* #2260 'CoreImage_CIBlendWithBlueMask' => 'CoreImage.CIBlendWithBlueMask, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19B322 /* #2261 'CoreImage_CIBlendWithRedMask' => 'CoreImage.CIBlendWithRedMask, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19B422 /* #2262 'CoreImage_CIBloom' => 'CoreImage.CIBloom, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AEE22 /* #2263 'CoreImage_CILinearBlur' => 'CoreImage.CILinearBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19B722 /* #2264 'CoreImage_CIBokehBlur' => 'CoreImage.CIBokehBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19BA22 /* #2265 'CoreImage_CIBoxBlur' => 'CoreImage.CIBoxBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A5022 /* #2266 'CoreImage_CIDistortionFilter' => 'CoreImage.CIDistortionFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19BD22 /* #2267 'CoreImage_CIBumpDistortion' => 'CoreImage.CIBumpDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19BE22 /* #2268 'CoreImage_CIBumpDistortionLinear' => 'CoreImage.CIBumpDistortionLinear, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19C322 /* #2269 'CoreImage_CICameraCalibrationLensCorrection' => 'CoreImage.CICameraCalibrationLensCorrection, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19C422 /* #2270 'CoreImage_CICheckerboardGenerator' => 'CoreImage.CICheckerboardGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19C722 /* #2271 'CoreImage_CICircleSplashDistortion' => 'CoreImage.CICircleSplashDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9C22 /* #2272 'CoreImage_CIScreenFilter' => 'CoreImage.CIScreenFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19CA22 /* #2273 'CoreImage_CICircularScreen' => 'CoreImage.CICircularScreen, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19CD22 /* #2274 'CoreImage_CICircularWrap' => 'CoreImage.CICircularWrap, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19D022 /* #2275 'CoreImage_CIClamp' => 'CoreImage.CIClamp, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19D122 /* #2276 'CoreImage_CICmykHalftone' => 'CoreImage.CICmykHalftone, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19D422 /* #2277 'CoreImage_CICode128BarcodeGenerator' => 'CoreImage.CICode128BarcodeGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19D822 /* #2278 'CoreImage_CIColorAbsoluteDifference' => 'CoreImage.CIColorAbsoluteDifference, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19DB22 /* #2279 'CoreImage_CIColorBlendMode' => 'CoreImage.CIColorBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19DC22 /* #2280 'CoreImage_CIColorBurnBlendMode' => 'CoreImage.CIColorBurnBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19DD22 /* #2281 'CoreImage_CIColorClamp' => 'CoreImage.CIColorClamp, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19E022 /* #2282 'CoreImage_CIColorControls' => 'CoreImage.CIColorControls, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19E322 /* #2283 'CoreImage_CIColorCrossPolynomial' => 'CoreImage.CIColorCrossPolynomial, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19E622 /* #2284 'CoreImage_CIColorCube' => 'CoreImage.CIColorCube, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19EA22 /* #2285 'CoreImage_CIColorCubesMixedWithMask' => 'CoreImage.CIColorCubesMixedWithMask, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19EE22 /* #2286 'CoreImage_CIColorCubeWithColorSpace' => 'CoreImage.CIColorCubeWithColorSpace, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19F222 /* #2287 'CoreImage_CIColorCurves' => 'CoreImage.CIColorCurves, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19F522 /* #2288 'CoreImage_CIColorDodgeBlendMode' => 'CoreImage.CIColorDodgeBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19F622 /* #2289 'CoreImage_CIColorInvert' => 'CoreImage.CIColorInvert, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19FA22 /* #2290 'CoreImage_CIColorMap' => 'CoreImage.CIColorMap, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19FD22 /* #2291 'CoreImage_CIColorMatrix' => 'CoreImage.CIColorMatrix, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A0022 /* #2292 'CoreImage_CIColorMonochrome' => 'CoreImage.CIColorMonochrome, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A0322 /* #2293 'CoreImage_CIColorPolynomial' => 'CoreImage.CIColorPolynomial, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A0622 /* #2294 'CoreImage_CIColorPosterize' => 'CoreImage.CIColorPosterize, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A0922 /* #2295 'CoreImage_CIColorThreshold' => 'CoreImage.CIColorThreshold, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A0A22 /* #2296 'CoreImage_CIColorThresholdOtsu' => 'CoreImage.CIColorThresholdOtsu, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A0F22 /* #2297 'CoreImage_CIColumnAverage' => 'CoreImage.CIColumnAverage, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A1222 /* #2298 'CoreImage_CIComicEffect' => 'CoreImage.CIComicEffect, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A1822 /* #2299 'CoreImage_CIConstantColorGenerator' => 'CoreImage.CIConstantColorGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2322 /* #2300 'CoreImage_CIConvolutionCore' => 'CoreImage.CIConvolutionCore, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A1E22 /* #2301 'CoreImage_CIConvolution3X3' => 'CoreImage.CIConvolution3X3, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A1F22 /* #2302 'CoreImage_CIConvolution5X5' => 'CoreImage.CIConvolution5X5, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2022 /* #2303 'CoreImage_CIConvolution7X7' => 'CoreImage.CIConvolution7X7, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2122 /* #2304 'CoreImage_CIConvolution9Horizontal' => 'CoreImage.CIConvolution9Horizontal, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2222 /* #2305 'CoreImage_CIConvolution9Vertical' => 'CoreImage.CIConvolution9Vertical, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2622 /* #2306 'CoreImage_CIConvolutionRGB3X3' => 'CoreImage.CIConvolutionRGB3X3, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2722 /* #2307 'CoreImage_CIConvolutionRGB5X5' => 'CoreImage.CIConvolutionRGB5X5, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2822 /* #2308 'CoreImage_CIConvolutionRGB7X7' => 'CoreImage.CIConvolutionRGB7X7, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2922 /* #2309 'CoreImage_CIConvolutionRGB9Horizontal' => 'CoreImage.CIConvolutionRGB9Horizontal, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2A22 /* #2310 'CoreImage_CIConvolutionRGB9Vertical' => 'CoreImage.CIConvolutionRGB9Vertical, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2B22 /* #2311 'CoreImage_CICopyMachineTransition' => 'CoreImage.CICopyMachineTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A2E22 /* #2312 'CoreImage_CICoreMLModelFilter' => 'CoreImage.CICoreMLModelFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A3122 /* #2313 'CoreImage_CICrop' => 'CoreImage.CICrop, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A3222 /* #2314 'CoreImage_CICrystallize' => 'CoreImage.CICrystallize, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A3522 /* #2315 'CoreImage_CIDarkenBlendMode' => 'CoreImage.CIDarkenBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A3622 /* #2316 'CIDataMatrixCodeDescriptor' => 'CoreImage.CIDataMatrixCodeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A3822 /* #2317 'CoreImage_CIDepthBlurEffect' => 'CoreImage.CIDepthBlurEffect, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A3922 /* #2318 'CoreImage_CIDepthDisparityConverter' => 'CoreImage.CIDepthDisparityConverter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A3A22 /* #2319 'CoreImage_CIDepthOfField' => 'CoreImage.CIDepthOfField, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A3D22 /* #2320 'CoreImage_CIDepthToDisparity' => 'CoreImage.CIDepthToDisparity, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A4022 /* #2321 'CoreImage_CIDifferenceBlendMode' => 'CoreImage.CIDifferenceBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A4122 /* #2322 'CoreImage_CIDiscBlur' => 'CoreImage.CIDiscBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A4422 /* #2323 'CoreImage_CIDisintegrateWithMaskTransition' => 'CoreImage.CIDisintegrateWithMaskTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A4722 /* #2324 'CoreImage_CIDisparityToDepth' => 'CoreImage.CIDisparityToDepth, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A4A22 /* #2325 'CoreImage_CIDisplacementDistortion' => 'CoreImage.CIDisplacementDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A4D22 /* #2326 'CoreImage_CIDissolveTransition' => 'CoreImage.CIDissolveTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A5122 /* #2327 'CoreImage_CIDither' => 'CoreImage.CIDither, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A5422 /* #2328 'CoreImage_CIDivideBlendMode' => 'CoreImage.CIDivideBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A5522 /* #2329 'CoreImage_CIDocumentEnhancer' => 'CoreImage.CIDocumentEnhancer, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A5822 /* #2330 'CoreImage_CIDotScreen' => 'CoreImage.CIDotScreen, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A5B22 /* #2331 'CoreImage_CIDroste' => 'CoreImage.CIDroste, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A5E22 /* #2332 'CoreImage_CIEdgePreserveUpsampleFilter' => 'CoreImage.CIEdgePreserveUpsampleFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A6122 /* #2333 'CoreImage_CIEdges' => 'CoreImage.CIEdges, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A6422 /* #2334 'CoreImage_CIEdgeWork' => 'CoreImage.CIEdgeWork, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BDB22 /* #2335 'CoreImage_CITileFilter' => 'CoreImage.CITileFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A6722 /* #2336 'CoreImage_CIEightfoldReflectedTile' => 'CoreImage.CIEightfoldReflectedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A6A22 /* #2337 'CoreImage_CIExclusionBlendMode' => 'CoreImage.CIExclusionBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A6B22 /* #2338 'CoreImage_CIExposureAdjust' => 'CoreImage.CIExposureAdjust, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A6E22 /* #2339 'CoreImage_CIFaceBalance' => 'CoreImage.CIFaceBalance, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A7322 /* #2340 'CIFeature' => 'CoreImage.CIFeature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6F22 /* #2341 'CIFaceFeature' => 'CoreImage.CIFaceFeature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7022 /* #2342 'CoreImage_CIFalseColor' => 'CoreImage.CIFalseColor, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A7C22 /* #2343 'CIFilterShape' => 'CoreImage.CIFilterShape, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7D22 /* #2344 'CoreImage_CIFlashTransition' => 'CoreImage.CIFlashTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A8322 /* #2345 'CoreImage_CIFourfoldReflectedTile' => 'CoreImage.CIFourfoldReflectedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A8622 /* #2346 'CoreImage_CIFourfoldRotatedTile' => 'CoreImage.CIFourfoldRotatedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A8922 /* #2347 'CoreImage_CIFourfoldTranslatedTile' => 'CoreImage.CIFourfoldTranslatedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A8C22 /* #2348 'CoreImage_CIGaborGradients' => 'CoreImage.CIGaborGradients, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A8F22 /* #2349 'CoreImage_CIGammaAdjust' => 'CoreImage.CIGammaAdjust, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A9222 /* #2350 'CoreImage_CIGaussianBlur' => 'CoreImage.CIGaussianBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A9522 /* #2351 'CoreImage_CIGaussianGradient' => 'CoreImage.CIGaussianGradient, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A9822 /* #2352 'CoreImage_CIGlassDistortion' => 'CoreImage.CIGlassDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A9B22 /* #2353 'CoreImage_CIGlassLozenge' => 'CoreImage.CIGlassLozenge, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1A9E22 /* #2354 'CoreImage_CIGlideReflectedTile' => 'CoreImage.CIGlideReflectedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AA122 /* #2355 'CoreImage_CIGloom' => 'CoreImage.CIGloom, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AA422 /* #2356 'CoreImage_CIGuidedFilter' => 'CoreImage.CIGuidedFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AA522 /* #2357 'CoreImage_CIHardLightBlendMode' => 'CoreImage.CIHardLightBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AA622 /* #2358 'CoreImage_CIHatchedScreen' => 'CoreImage.CIHatchedScreen, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AA922 /* #2359 'CoreImage_CIHeightFieldFromMask' => 'CoreImage.CIHeightFieldFromMask, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AAC22 /* #2360 'CoreImage_CIHexagonalPixellate' => 'CoreImage.CIHexagonalPixellate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AAF22 /* #2361 'CoreImage_CIHighlightShadowAdjust' => 'CoreImage.CIHighlightShadowAdjust, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AB222 /* #2362 'CoreImage_CIHistogramDisplayFilter' => 'CoreImage.CIHistogramDisplayFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AB522 /* #2363 'CoreImage_CIHoleDistortion' => 'CoreImage.CIHoleDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AB822 /* #2364 'CoreImage_CIHueAdjust' => 'CoreImage.CIHueAdjust, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1ABB22 /* #2365 'CoreImage_CIHueBlendMode' => 'CoreImage.CIHueBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1ABC22 /* #2366 'CoreImage_CIHueSaturationValueGradient' => 'CoreImage.CIHueSaturationValueGradient, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1ABF22 /* #2367 'CIImageAccumulator' => 'CoreImage.CIImageAccumulator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AC622 /* #2368 'CIImageProcessorKernel' => 'CoreImage.CIImageProcessorKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AD022 /* #2369 'CoreImage_CIKaleidoscope' => 'CoreImage.CIKaleidoscope, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AD422 /* #2370 'CoreImage_CIKeystoneCorrection' => 'CoreImage.CIKeystoneCorrection, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AD522 /* #2371 'CoreImage_CIKeystoneCorrectionCombined' => 'CoreImage.CIKeystoneCorrectionCombined, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AD822 /* #2372 'CoreImage_CIKeystoneCorrectionHorizontal' => 'CoreImage.CIKeystoneCorrectionHorizontal, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1ADB22 /* #2373 'CoreImage_CIKeystoneCorrectionVertical' => 'CoreImage.CIKeystoneCorrectionVertical, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1ADE22 /* #2374 'CoreImage_CIKMeans' => 'CoreImage.CIKMeans, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AE122 /* #2375 'CoreImage_CILabDeltaE' => 'CoreImage.CILabDeltaE, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AE422 /* #2376 'CoreImage_CILanczosScaleTransform' => 'CoreImage.CILanczosScaleTransform, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AE722 /* #2377 'CoreImage_CILenticularHaloGenerator' => 'CoreImage.CILenticularHaloGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AEA22 /* #2378 'CoreImage_CILightenBlendMode' => 'CoreImage.CILightenBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AEB22 /* #2379 'CoreImage_CILightTunnel' => 'CoreImage.CILightTunnel, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AEF22 /* #2380 'CoreImage_CILinearBurnBlendMode' => 'CoreImage.CILinearBurnBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AF022 /* #2381 'CoreImage_CILinearDodgeBlendMode' => 'CoreImage.CILinearDodgeBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AF122 /* #2382 'CoreImage_CILinearGradient' => 'CoreImage.CILinearGradient, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AF422 /* #2383 'CoreImage_CILinearLightBlendMode' => 'CoreImage.CILinearLightBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AF522 /* #2384 'CoreImage_CILinearToSRGBToneCurve' => 'CoreImage.CILinearToSRGBToneCurve, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AF822 /* #2385 'CoreImage_CILineOverlay' => 'CoreImage.CILineOverlay, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AFB22 /* #2386 'CoreImage_CILineScreen' => 'CoreImage.CILineScreen, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AFE22 /* #2387 'CoreImage_CILuminosityBlendMode' => 'CoreImage.CILuminosityBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1AFF22 /* #2388 'CoreImage_CIMaskedVariableBlur' => 'CoreImage.CIMaskedVariableBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B0222 /* #2389 'CoreImage_CIMaskToAlpha' => 'CoreImage.CIMaskToAlpha, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B0522 /* #2390 'CoreImage_CIMaximumComponent' => 'CoreImage.CIMaximumComponent, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B0822 /* #2391 'CoreImage_CIMaximumCompositing' => 'CoreImage.CIMaximumCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B0922 /* #2392 'CoreImage_CIMedianFilter' => 'CoreImage.CIMedianFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B0C22 /* #2393 'CoreImage_CIMeshGenerator' => 'CoreImage.CIMeshGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B0F22 /* #2394 'CoreImage_CIMinimumComponent' => 'CoreImage.CIMinimumComponent, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B1222 /* #2395 'CoreImage_CIMinimumCompositing' => 'CoreImage.CIMinimumCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B1322 /* #2396 'CoreImage_CIMix' => 'CoreImage.CIMix, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B1622 /* #2397 'CoreImage_CIModTransition' => 'CoreImage.CIModTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B1922 /* #2398 'CoreImage_CIMorphology' => 'CoreImage.CIMorphology, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B1A22 /* #2399 'CoreImage_CIMorphologyGradient' => 'CoreImage.CIMorphologyGradient, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B1D22 /* #2400 'CoreImage_CIMorphologyMaximum' => 'CoreImage.CIMorphologyMaximum, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2022 /* #2401 'CoreImage_CIMorphologyMinimum' => 'CoreImage.CIMorphologyMinimum, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2322 /* #2402 'CoreImage_CIMorphologyRectangle' => 'CoreImage.CIMorphologyRectangle, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2422 /* #2403 'CoreImage_CIMorphologyRectangleMaximum' => 'CoreImage.CIMorphologyRectangleMaximum, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2722 /* #2404 'CoreImage_CIMorphologyRectangleMinimum' => 'CoreImage.CIMorphologyRectangleMinimum, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2A22 /* #2405 'CoreImage_CIMotionBlur' => 'CoreImage.CIMotionBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2D22 /* #2406 'CoreImage_CIMultiplyBlendMode' => 'CoreImage.CIMultiplyBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2E22 /* #2407 'CoreImage_CIMultiplyCompositing' => 'CoreImage.CIMultiplyCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B2F22 /* #2408 'CoreImage_CINinePartStretched' => 'CoreImage.CINinePartStretched, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B3222 /* #2409 'CoreImage_CINinePartTiled' => 'CoreImage.CINinePartTiled, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B3522 /* #2410 'CoreImage_CINoiseReduction' => 'CoreImage.CINoiseReduction, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B3822 /* #2411 'CoreImage_CIOpTile' => 'CoreImage.CIOpTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B3B22 /* #2412 'CoreImage_CIOverlayBlendMode' => 'CoreImage.CIOverlayBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B3C22 /* #2413 'CoreImage_CIPageCurlTransition' => 'CoreImage.CIPageCurlTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B3F22 /* #2414 'CoreImage_CIPageCurlWithShadowTransition' => 'CoreImage.CIPageCurlWithShadowTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B4222 /* #2415 'CoreImage_CIPaletteCentroid' => 'CoreImage.CIPaletteCentroid, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B4522 /* #2416 'CoreImage_CIPalettize' => 'CoreImage.CIPalettize, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B4822 /* #2417 'CoreImage_CIParallelogramTile' => 'CoreImage.CIParallelogramTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B4B22 /* #2418 'CoreImage_CIPdf417BarcodeGenerator' => 'CoreImage.CIPdf417BarcodeGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B4E22 /* #2419 'CIPDF417CodeDescriptor' => 'CoreImage.CIPdf417CodeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B4F22 /* #2420 'CoreImage_CIPersonSegmentation' => 'CoreImage.CIPersonSegmentation, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B5B22 /* #2421 'CoreImage_CIPerspectiveTransform' => 'CoreImage.CIPerspectiveTransform, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B5222 /* #2422 'CoreImage_CIPerspectiveCorrection' => 'CoreImage.CIPerspectiveCorrection, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B5522 /* #2423 'CoreImage_CIPerspectiveRotate' => 'CoreImage.CIPerspectiveRotate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B5822 /* #2424 'CoreImage_CIPerspectiveTile' => 'CoreImage.CIPerspectiveTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B5E22 /* #2425 'CoreImage_CIPerspectiveTransformWithExtent' => 'CoreImage.CIPerspectiveTransformWithExtent, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6122 /* #2426 'CoreImage_CIPhotoEffect' => 'CoreImage.CIPhotoEffect, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6222 /* #2427 'CoreImage_CIPhotoEffectChrome' => 'CoreImage.CIPhotoEffectChrome, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6322 /* #2428 'CoreImage_CIPhotoEffectFade' => 'CoreImage.CIPhotoEffectFade, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6422 /* #2429 'CoreImage_CIPhotoEffectInstant' => 'CoreImage.CIPhotoEffectInstant, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6522 /* #2430 'CoreImage_CIPhotoEffectMono' => 'CoreImage.CIPhotoEffectMono, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6622 /* #2431 'CoreImage_CIPhotoEffectNoir' => 'CoreImage.CIPhotoEffectNoir, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6722 /* #2432 'CoreImage_CIPhotoEffectProcess' => 'CoreImage.CIPhotoEffectProcess, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6A22 /* #2433 'CoreImage_CIPhotoEffectTonal' => 'CoreImage.CIPhotoEffectTonal, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6B22 /* #2434 'CoreImage_CIPhotoEffectTransfer' => 'CoreImage.CIPhotoEffectTransfer, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6C22 /* #2435 'CoreImage_CIPinchDistortion' => 'CoreImage.CIPinchDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B6F22 /* #2436 'CoreImage_CIPinLightBlendMode' => 'CoreImage.CIPinLightBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B7022 /* #2437 'CoreImage_CIPixellate' => 'CoreImage.CIPixellate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B7322 /* #2438 'CoreImage_CIPointillize' => 'CoreImage.CIPointillize, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B7622 /* #2439 'CIQRCodeDescriptor' => 'CoreImage.CIQRCodeDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7822 /* #2440 'CIQRCodeFeature' => 'CoreImage.CIQRCodeFeature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7922 /* #2441 'CoreImage_CIQRCodeGenerator' => 'CoreImage.CIQRCodeGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B7C22 /* #2442 'CoreImage_CIRadialGradient' => 'CoreImage.CIRadialGradient, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B7F22 /* #2443 'CoreImage_CIRandomGenerator' => 'CoreImage.CIRandomGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B8422 /* #2444 'CIRAWFilter' => 'CoreImage.CIRawFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8722 /* #2445 'CIRectangleFeature' => 'CoreImage.CIRectangleFeature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8922 /* #2446 'CIRenderDestination' => 'CoreImage.CIRenderDestination, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8B22 /* #2447 'CIRenderInfo' => 'CoreImage.CIRenderInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8C22 /* #2448 'CIRenderTask' => 'CoreImage.CIRenderTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8D22 /* #2449 'CoreImage_CIRippleTransition' => 'CoreImage.CIRippleTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9022 /* #2450 'CoreImage_CIRoundedRectangleGenerator' => 'CoreImage.CIRoundedRectangleGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9322 /* #2451 'CoreImage_CIRowAverage' => 'CoreImage.CIRowAverage, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9622 /* #2452 'CoreImage_CISaliencyMapFilter' => 'CoreImage.CISaliencyMapFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9922 /* #2453 'CoreImage_CISampleNearest' => 'CoreImage.CISampleNearest, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9A22 /* #2454 'CoreImage_CISaturationBlendMode' => 'CoreImage.CISaturationBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9B22 /* #2455 'CoreImage_CIScreenBlendMode' => 'CoreImage.CIScreenBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9D22 /* #2456 'CoreImage_CISepiaTone' => 'CoreImage.CISepiaTone, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BA022 /* #2457 'CoreImage_CIShadedMaterial' => 'CoreImage.CIShadedMaterial, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BA322 /* #2458 'CoreImage_CISharpenLuminance' => 'CoreImage.CISharpenLuminance, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BA622 /* #2459 'CoreImage_CISixfoldReflectedTile' => 'CoreImage.CISixfoldReflectedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BA922 /* #2460 'CoreImage_CISixfoldRotatedTile' => 'CoreImage.CISixfoldRotatedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BAC22 /* #2461 'CoreImage_CISmoothLinearGradient' => 'CoreImage.CISmoothLinearGradient, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BAF22 /* #2462 'CoreImage_CISoftLightBlendMode' => 'CoreImage.CISoftLightBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BB022 /* #2463 'CoreImage_CISourceAtopCompositing' => 'CoreImage.CISourceAtopCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BB122 /* #2464 'CoreImage_CISourceInCompositing' => 'CoreImage.CISourceInCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BB222 /* #2465 'CoreImage_CISourceOutCompositing' => 'CoreImage.CISourceOutCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BB322 /* #2466 'CoreImage_CISourceOverCompositing' => 'CoreImage.CISourceOverCompositing, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BB422 /* #2467 'CoreImage_CISpotColor' => 'CoreImage.CISpotColor, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BB722 /* #2468 'CoreImage_CISpotLight' => 'CoreImage.CISpotLight, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BBA22 /* #2469 'CoreImage_CISRGBToneCurveToLinear' => 'CoreImage.CISRGBToneCurveToLinear, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BBD22 /* #2470 'CoreImage_CIStarShineGenerator' => 'CoreImage.CIStarShineGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BC022 /* #2471 'CoreImage_CIStraightenFilter' => 'CoreImage.CIStraightenFilter, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BC322 /* #2472 'CoreImage_CIStretchCrop' => 'CoreImage.CIStretchCrop, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BC622 /* #2473 'CoreImage_CIStripesGenerator' => 'CoreImage.CIStripesGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BC922 /* #2474 'CoreImage_CISubtractBlendMode' => 'CoreImage.CISubtractBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BCA22 /* #2475 'CoreImage_CISunbeamsGenerator' => 'CoreImage.CISunbeamsGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BCD22 /* #2476 'CoreImage_CISwipeTransition' => 'CoreImage.CISwipeTransition, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BD022 /* #2477 'CoreImage_CITemperatureAndTint' => 'CoreImage.CITemperatureAndTint, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BD322 /* #2478 'CITextFeature' => 'CoreImage.CITextFeature, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BD422 /* #2479 'CoreImage_CITextImageGenerator' => 'CoreImage.CITextImageGenerator, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BD822 /* #2480 'CoreImage_CIThermal' => 'CoreImage.CIThermal, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BDC22 /* #2481 'CoreImage_CIToneCurve' => 'CoreImage.CIToneCurve, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BDF22 /* #2482 'CoreImage_CITorusLensDistortion' => 'CoreImage.CITorusLensDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BE522 /* #2483 'CoreImage_CITriangleKaleidoscope' => 'CoreImage.CITriangleKaleidoscope, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BE822 /* #2484 'CoreImage_CITriangleTile' => 'CoreImage.CITriangleTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BEB22 /* #2485 'CoreImage_CITwelvefoldReflectedTile' => 'CoreImage.CITwelvefoldReflectedTile, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BEE22 /* #2486 'CoreImage_CITwirlDistortion' => 'CoreImage.CITwirlDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BF222 /* #2487 'CoreImage_CIUnsharpMask' => 'CoreImage.CIUnsharpMask, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BF522 /* #2488 'CoreImage_CIVibrance' => 'CoreImage.CIVibrance, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BF822 /* #2489 'CoreImage_CIVignette' => 'CoreImage.CIVignette, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BF922 /* #2490 'CoreImage_CIVignetteEffect' => 'CoreImage.CIVignetteEffect, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BFE22 /* #2491 'CoreImage_CIVividLightBlendMode' => 'CoreImage.CIVividLightBlendMode, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BFF22 /* #2492 'CoreImage_CIVortexDistortion' => 'CoreImage.CIVortexDistortion, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C0222 /* #2493 'CIWarpKernel' => 'CoreImage.CIWarpKernel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C0322 /* #2494 'CoreImage_CIWhitePointAdjust' => 'CoreImage.CIWhitePointAdjust, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C0622 /* #2495 'CoreImage_CIXRay' => 'CoreImage.CIXRay, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C0922 /* #2496 'CoreImage_CIZoomBlur' => 'CoreImage.CIZoomBlur, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1CAD22 /* #2497 'NSEntityDescription' => 'CoreData.NSEntityDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CAE22 /* #2498 'NSMergeConflict' => 'CoreData.NSMergeConflict, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CAF22 /* #2499 'NSMergePolicy' => 'CoreData.NSMergePolicy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CFD22 /* #2500 'NSPersistentStoreRequest' => 'CoreData.NSPersistentStoreRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB322 /* #2501 'NSAsynchronousFetchRequest' => 'CoreData.NSAsynchronousFetchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CFF22 /* #2502 'NSPersistentStoreResult' => 'CoreData.NSPersistentStoreResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CFA22 /* #2503 'NSPersistentStoreAsynchronousResult' => 'CoreData.NSPersistentStoreAsynchronousResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB422 /* #2504 'NSAsynchronousFetchResult' => 'CoreData.NSAsynchronousFetchResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB022 /* #2505 'NSPersistentStore' => 'CoreData.NSPersistentStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB522 /* #2506 'NSAtomicStore' => 'CoreData.NSAtomicStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB622 /* #2507 'NSAtomicStoreCacheNode' => 'CoreData.NSAtomicStoreCacheNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0122 /* #2508 'NSPropertyDescription' => 'CoreData.NSPropertyDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB722 /* #2509 'NSAttributeDescription' => 'CoreData.NSAttributeDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB922 /* #2510 'NSBatchDeleteRequest' => 'CoreData.NSBatchDeleteRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBB22 /* #2511 'NSBatchDeleteResult' => 'CoreData.NSBatchDeleteResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBC22 /* #2512 'NSBatchInsertRequest' => 'CoreData.NSBatchInsertRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBE22 /* #2513 'NSBatchInsertResult' => 'CoreData.NSBatchInsertResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBF22 /* #2514 'NSBatchUpdateRequest' => 'CoreData.NSBatchUpdateRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CC122 /* #2515 'NSBatchUpdateResult' => 'CoreData.NSBatchUpdateResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CC222 /* #2516 'NSConstraintConflict' => 'CoreData.NSConstraintConflict, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CC422 /* #2517 'NSDerivedAttributeDescription' => 'CoreData.NSDerivedAttributeDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CC522 /* #2518 'NSEntityMapping' => 'CoreData.NSEntityMapping, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CC722 /* #2519 'NSEntityMigrationPolicy' => 'CoreData.NSEntityMigrationPolicy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CC822 /* #2520 'NSExpressionDescription' => 'CoreData.NSExpressionDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CC922 /* #2521 'NSFetchedPropertyDescription' => 'CoreData.NSFetchedPropertyDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CCB22 /* #2522 'NSFetchedResultsController' => 'CoreData.NSFetchedResultsController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CCF22 /* #2523 'NSFetchedResultsControllerDelegate' => 'CoreData.NSFetchedResultsControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD222 /* #2524 'NSFetchedResultsSectionInfo' => 'CoreData.NSFetchedResultsSectionInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD322 /* #2525 'NSFetchIndexDescription' => 'CoreData.NSFetchIndexDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD422 /* #2526 'NSFetchIndexElementDescription' => 'CoreData.NSFetchIndexElementDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD622 /* #2527 'NSFetchRequest' => 'CoreData.NSFetchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD722 /* #2528 'NSFetchRequestExpression' => 'CoreData.NSFetchRequestExpression, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CDB22 /* #2529 'NSIncrementalStore' => 'CoreData.NSIncrementalStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CDC22 /* #2530 'NSIncrementalStoreNode' => 'CoreData.NSIncrementalStoreNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CDD22 /* #2531 'NSManagedObject' => 'CoreData.NSManagedObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE022 /* #2532 'NSManagedObjectID' => 'CoreData.NSManagedObjectID, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE122 /* #2533 'NSManagedObjectModel' => 'CoreData.NSManagedObjectModel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE222 /* #2534 'NSMappingModel' => 'CoreData.NSMappingModel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE422 /* #2535 'NSMigrationManager' => 'CoreData.NSMigrationManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CEC22 /* #2536 'NSPersistentCloudKitContainerEventRequest' => 'CoreData.NSPersistentCloudKitContainerEventRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CED22 /* #2537 'NSPersistentCloudKitContainerEventResult' => 'CoreData.NSPersistentCloudKitContainerEventResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF022 /* #2538 'NSPersistentCloudKitContainerOptions' => 'CoreData.NSPersistentCloudKitContainerOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF322 /* #2539 'NSPersistentHistoryChange' => 'CoreData.NSPersistentHistoryChange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF422 /* #2540 'NSPersistentHistoryChangeRequest' => 'CoreData.NSPersistentHistoryChangeRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF622 /* #2541 'NSPersistentHistoryResult' => 'CoreData.NSPersistentHistoryResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF822 /* #2542 'NSPersistentHistoryToken' => 'CoreData.NSPersistentHistoryToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF922 /* #2543 'NSPersistentHistoryTransaction' => 'CoreData.NSPersistentHistoryTransaction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CFC22 /* #2544 'NSPersistentStoreDescription' => 'CoreData.NSPersistentStoreDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0222 /* #2545 'NSPropertyMapping' => 'CoreData.NSPropertyMapping, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0322 /* #2546 'NSQueryGenerationToken' => 'CoreData.NSQueryGenerationToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0422 /* #2547 'NSRelationshipDescription' => 'CoreData.NSRelationshipDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0522 /* #2548 'NSSaveChangesRequest' => 'CoreData.NSSaveChangesRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2922 /* #2549 'CBAttribute' => 'CoreBluetooth.CBAttribute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3A22 /* #2550 'CBCharacteristic' => 'CoreBluetooth.CBCharacteristic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1822 /* #2551 'CBMutableCharacteristic' => 'CoreBluetooth.CBMutableCharacteristic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6122 /* #2552 'CBService' => 'CoreBluetooth.CBService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1922 /* #2553 'CBMutableService' => 'CoreBluetooth.CBMutableService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1B22 /* #2554 'CBManager' => 'CoreBluetooth.CBManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1C22 /* #2555 'CBPeer' => 'CoreBluetooth.CBPeer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1D22 /* #2556 'CBUUID' => 'CoreBluetooth.CBUUID, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2822 /* #2557 'CBATTRequest' => 'CoreBluetooth.CBATTRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2B22 /* #2558 'CBCentral' => 'CoreBluetooth.CBCentral, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3722 /* #2559 'CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D4222 /* #2560 'CBDescriptor' => 'CoreBluetooth.CBDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D4522 /* #2561 'CBL2CAPChannel' => 'CoreBluetooth.CBL2CapChannel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D4822 /* #2562 'CBMutableDescriptor' => 'CoreBluetooth.CBMutableDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5222 /* #2563 'CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheralDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5E22 /* #2564 'CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6622 /* #2565 'CAAnimation' => 'CoreAnimation.CAAnimation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8F22 /* #2566 'CAPropertyAnimation' => 'CoreAnimation.CAPropertyAnimation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6422 /* #2567 'CABasicAnimation' => 'CoreAnimation.CABasicAnimation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6D22 /* #2568 'CALayer' => 'CoreAnimation.CALayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6522 /* #2569 'CAScrollLayer' => 'CoreAnimation.CAScrollLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6822 /* #2570 'CAEmitterBehavior' => 'CoreAnimation.CAEmitterBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6922 /* #2571 'CAMetalLayer' => 'CoreAnimation.CAMetalLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6A22 /* #2572 'CAGradientLayer' => 'CoreAnimation.CAGradientLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6B22 /* #2573 'CAKeyframeAnimation' => 'CoreAnimation.CAKeyFrameAnimation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6E22 /* #2574 'CADisplayLink' => 'CoreAnimation.CADisplayLink, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6F22 /* #2575 'CALayerDelegate' => 'CoreAnimation.CALayerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7022 /* #2576 'CAMediaTimingFunction' => 'CoreAnimation.CAMediaTimingFunction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7122 /* #2577 'CATextLayer' => 'CoreAnimation.CATextLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7522 /* #2578 'CAAction' => 'CoreAnimation.CAAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7922 /* #2579 'CAAnimationDelegate' => 'CoreAnimation.CAAnimationDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7A22 /* #2580 'CAAnimationGroup' => 'CoreAnimation.CAAnimationGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8022 /* #2581 'CAEAGLLayer' => 'CoreAnimation.CAEAGLLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8222 /* #2582 'CAEmitterCell' => 'CoreAnimation.CAEmitterCell, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8322 /* #2583 'CAEmitterLayer' => 'CoreAnimation.CAEmitterLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8C22 /* #2584 'CAMediaTiming' => 'CoreAnimation.CAMediaTiming, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9022 /* #2585 'CAReplicatorLayer' => 'CoreAnimation.CAReplicatorLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9322 /* #2586 'CAShapeLayer' => 'CoreAnimation.CAShapeLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9422 /* #2587 'CASpringAnimation' => 'CoreAnimation.CASpringAnimation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9922 /* #2588 'CATiledLayer' => 'CoreAnimation.CATiledLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9A22 /* #2589 'CATransaction' => 'CoreAnimation.CATransaction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9B22 /* #2590 'CATransformLayer' => 'CoreAnimation.CATransformLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9C22 /* #2591 'CATransition' => 'CoreAnimation.CATransition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9D22 /* #2592 'CAValueFunction' => 'CoreAnimation.CAValueFunction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DCC22 /* #2593 'CNFetchRequest' => 'Contacts.CNFetchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9F22 /* #2594 'CNContactFetchRequest' => 'Contacts.CNContactFetchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DA322 /* #2595 'CNInstantMessageAddress' => 'Contacts.CNInstantMessageAddress, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DA722 /* #2596 'CNSocialProfile' => 'Contacts.CNSocialProfile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DB022 /* #2597 'CNChangeHistoryEvent' => 'Contacts.CNChangeHistoryEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DA922 /* #2598 'CNChangeHistoryAddContactEvent' => 'Contacts.CNChangeHistoryAddContactEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DAA22 /* #2599 'CNChangeHistoryAddGroupEvent' => 'Contacts.CNChangeHistoryAddGroupEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DAB22 /* #2600 'CNChangeHistoryAddMemberToGroupEvent' => 'Contacts.CNChangeHistoryAddMemberToGroupEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DAC22 /* #2601 'CNChangeHistoryAddSubgroupToGroupEvent' => 'Contacts.CNChangeHistoryAddSubgroupToGroupEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DAD22 /* #2602 'CNChangeHistoryDeleteContactEvent' => 'Contacts.CNChangeHistoryDeleteContactEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DAE22 /* #2603 'CNChangeHistoryDeleteGroupEvent' => 'Contacts.CNChangeHistoryDeleteGroupEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DAF22 /* #2604 'CNChangeHistoryDropEverythingEvent' => 'Contacts.CNChangeHistoryDropEverythingEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DB422 /* #2605 'CNChangeHistoryFetchRequest' => 'Contacts.CNChangeHistoryFetchRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DB522 /* #2606 'CNChangeHistoryRemoveMemberFromGroupEvent' => 'Contacts.CNChangeHistoryRemoveMemberFromGroupEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DB622 /* #2607 'CNChangeHistoryRemoveSubgroupFromGroupEvent' => 'Contacts.CNChangeHistoryRemoveSubgroupFromGroupEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DB722 /* #2608 'CNChangeHistoryUpdateContactEvent' => 'Contacts.CNChangeHistoryUpdateContactEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DB822 /* #2609 'CNChangeHistoryUpdateGroupEvent' => 'Contacts.CNChangeHistoryUpdateGroupEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DBA22 /* #2610 'CNContactFormatter' => 'Contacts.CNContactFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DBE22 /* #2611 'CNContactProperty' => 'Contacts.CNContactProperty, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DBF22 /* #2612 'CNContactRelation' => 'Contacts.CNContactRelation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DC122 /* #2613 'CNContactsUserDefaults' => 'Contacts.CNContactsUserDefaults, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DC322 /* #2614 'CNContactVCardSerialization' => 'Contacts.CNContactVCardSerialization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DC422 /* #2615 'CNContainer' => 'Contacts.CNContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DCD22 /* #2616 'CNFetchResult' => 'Contacts.CNFetchResult`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DCE22 /* #2617 'CNGroup' => 'Contacts.CNGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DD522 /* #2618 'CNLabeledValue' => 'Contacts.CNLabeledValue`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9E22 /* #2619 'CNContact' => 'Contacts.CNContact, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DD822 /* #2620 'CNMutableContact' => 'Contacts.CNMutableContact, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DD922 /* #2621 'CNMutableGroup' => 'Contacts.CNMutableGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DDC22 /* #2622 'CNPostalAddress' => 'Contacts.CNPostalAddress, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DDA22 /* #2623 'CNMutablePostalAddress' => 'Contacts.CNMutablePostalAddress, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DDB22 /* #2624 'CNPhoneNumber' => 'Contacts.CNPhoneNumber, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DDD22 /* #2625 'CNPostalAddressFormatter' => 'Contacts.CNPostalAddressFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DE222 /* #2626 'CNSaveRequest' => 'Contacts.CNSaveRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1F22 /* #2627 'CKNotification' => 'CloudKit.CKNotification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF022 /* #2628 'CKQueryNotification' => 'CloudKit.CKQueryNotification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF122 /* #2629 'CKOperation' => 'CloudKit.CKOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF222 /* #2630 'CKNotificationID' => 'CloudKit.CKNotificationID, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF422 /* #2631 'CKDiscoverAllContactsOperation' => 'CloudKit.CKDiscoverAllContactsOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF622 /* #2632 'CloudKit_CKDiscoverUserInfosOperation' => 'CloudKit.CKDiscoverUserInfosOperation, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1DF722 /* #2633 'CKSubscription' => 'CloudKit.CKSubscription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF822 /* #2634 'CKDiscoveredUserInfo' => 'CloudKit.CKDiscoveredUserInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF922 /* #2635 'CKRecord' => 'CloudKit.CKRecord, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DFA22 /* #2636 'CKRecordID' => 'CloudKit.CKRecordID, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DFB22 /* #2637 'CKRecordZoneID' => 'CloudKit.CKRecordZoneID, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DFC22 /* #2638 'CKUserIdentityLookupInfo' => 'CloudKit.CKUserIdentityLookupInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DFD22 /* #2639 'CKAcceptSharesOperation' => 'CloudKit.CKAcceptSharesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DFF22 /* #2640 'CKAllowedSharingOptions' => 'CloudKit.CKAllowedSharingOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0222 /* #2641 'CKAsset' => 'CloudKit.CKAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0422 /* #2642 'CKDatabaseNotification' => 'CloudKit.CKDatabaseNotification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0522 /* #2643 'CKDatabaseOperation' => 'CloudKit.CKDatabaseOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0722 /* #2644 'CKDatabaseSubscription' => 'CloudKit.CKDatabaseSubscription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0822 /* #2645 'CKDiscoverAllUserIdentitiesOperation' => 'CloudKit.CKDiscoverAllUserIdentitiesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0922 /* #2646 'CKDiscoverUserIdentitiesOperation' => 'CloudKit.CKDiscoverUserIdentitiesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0D22 /* #2647 'CKFetchDatabaseChangesOperation' => 'CloudKit.CKFetchDatabaseChangesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0E22 /* #2648 'CKFetchNotificationChangesOperation' => 'CloudKit.CKFetchNotificationChangesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0F22 /* #2649 'CKFetchRecordChangesOperation' => 'CloudKit.CKFetchRecordChangesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1022 /* #2650 'CKFetchRecordsOperation' => 'CloudKit.CKFetchRecordsOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1122 /* #2651 'CKFetchRecordZoneChangesConfiguration' => 'CloudKit.CKFetchRecordZoneChangesConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1222 /* #2652 'CKFetchRecordZoneChangesOperation' => 'CloudKit.CKFetchRecordZoneChangesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1322 /* #2653 'CKFetchRecordZoneChangesOptions' => 'CloudKit.CKFetchRecordZoneChangesOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1422 /* #2654 'CKFetchRecordZonesOperation' => 'CloudKit.CKFetchRecordZonesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1522 /* #2655 'CKFetchShareMetadataOperation' => 'CloudKit.CKFetchShareMetadataOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1622 /* #2656 'CKFetchShareParticipantsOperation' => 'CloudKit.CKFetchShareParticipantsOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1722 /* #2657 'CKFetchSubscriptionsOperation' => 'CloudKit.CKFetchSubscriptionsOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1822 /* #2658 'CKFetchWebAuthTokenOperation' => 'CloudKit.CKFetchWebAuthTokenOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1922 /* #2659 'CKLocationSortDescriptor' => 'CloudKit.CKLocationSortDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1A22 /* #2660 'CKMarkNotificationsReadOperation' => 'CloudKit.CKMarkNotificationsReadOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1B22 /* #2661 'CKModifyBadgeOperation' => 'CloudKit.CKModifyBadgeOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1C22 /* #2662 'CKModifyRecordsOperation' => 'CloudKit.CKModifyRecordsOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1D22 /* #2663 'CKModifyRecordZonesOperation' => 'CloudKit.CKModifyRecordZonesOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E1E22 /* #2664 'CKModifySubscriptionsOperation' => 'CloudKit.CKModifySubscriptionsOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2022 /* #2665 'CKNotificationInfo' => 'CloudKit.CKNotificationInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2222 /* #2666 'CKOperationConfiguration' => 'CloudKit.CKOperationConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2322 /* #2667 'CKOperationGroup' => 'CloudKit.CKOperationGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2522 /* #2668 'CKQuery' => 'CloudKit.CKQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2622 /* #2669 'CKQueryCursor' => 'CloudKit.CKQueryCursor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2822 /* #2670 'CKQueryOperation' => 'CloudKit.CKQueryOperation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2922 /* #2671 'CKQuerySubscription' => 'CloudKit.CKQuerySubscription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2E22 /* #2672 'CKRecordValue' => 'CloudKit.CKRecordValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E2F22 /* #2673 'CKRecordZone' => 'CloudKit.CKRecordZone, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E3122 /* #2674 'CKRecordZoneNotification' => 'CloudKit.CKRecordZoneNotification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E3222 /* #2675 'CKRecordZoneSubscription' => 'CloudKit.CKRecordZoneSubscription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E3322 /* #2676 'CKReference' => 'CloudKit.CKReference, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E3522 /* #2677 'CKServerChangeToken' => 'CloudKit.CKServerChangeToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E3622 /* #2678 'CKShare' => 'CloudKit.CKShare, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E3822 /* #2679 'CKShareMetadata' => 'CloudKit.CKShareMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E3922 /* #2680 'CKShareParticipant' => 'CloudKit.CKShareParticipant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E4222 /* #2681 'CKSystemSharingUIObserver' => 'CloudKit.CKSystemSharingUIObserver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E4322 /* #2682 'CKUserIdentity' => 'CloudKit.CKUserIdentity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E7022 /* #2683 'CLSObject' => 'ClassKit.CLSObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E6022 /* #2684 'CLSActivity' => 'ClassKit.CLSActivity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E6122 /* #2685 'CLSActivityItem' => 'ClassKit.CLSActivityItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E6222 /* #2686 'CLSBinaryItem' => 'ClassKit.CLSBinaryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E6C22 /* #2687 'CLSDataStoreDelegate' => 'ClassKit.CLSDataStoreDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E7222 /* #2688 'CLSProgressReportingCapability' => 'ClassKit.CLSProgressReportingCapability, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E7422 /* #2689 'CLSQuantityItem' => 'ClassKit.CLSQuantityItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E7522 /* #2690 'CLSScoreItem' => 'ClassKit.CLSScoreItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ECA22 /* #2691 'CPMessageListItem' => 'CarPlay.CPMessageListItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ECB22 /* #2692 'CPNavigationAlert' => 'CarPlay.CPNavigationAlert, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3922 /* #2693 'CPTemplate' => 'CarPlay.CPTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ECC22 /* #2694 'CPActionSheetTemplate' => 'CarPlay.CPActionSheetTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ECD22 /* #2695 'CPAlertAction' => 'CarPlay.CPAlertAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ECF22 /* #2696 'CPAlertTemplate' => 'CarPlay.CPAlertTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ED322 /* #2697 'Xamarin_iOS__CarPlay_CPApplicationDelegate' => 'CarPlay.CPApplicationDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ED522 /* #2698 'CPAssistantCellConfiguration' => 'CarPlay.CPAssistantCellConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ED822 /* #2699 'CPBarButton' => 'CarPlay.CPBarButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EDE22 /* #2700 'CPButton' => 'CarPlay.CPButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EDF22 /* #2701 'CPContact' => 'CarPlay.CPContact, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE022 /* #2702 'CPContactCallButton' => 'CarPlay.CPContactCallButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE122 /* #2703 'CPContactDirectionsButton' => 'CarPlay.CPContactDirectionsButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE222 /* #2704 'CPContactMessageButton' => 'CarPlay.CPContactMessageButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE322 /* #2705 'CPContactTemplate' => 'CarPlay.CPContactTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE522 /* #2706 'CPDashboardButton' => 'CarPlay.CPDashboardButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE622 /* #2707 'CPDashboardController' => 'CarPlay.CPDashboardController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE722 /* #2708 'CPGridButton' => 'CarPlay.CPGridButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE822 /* #2709 'CPGridTemplate' => 'CarPlay.CPGridTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EE922 /* #2710 'CPImageSet' => 'CarPlay.CPImageSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EEA22 /* #2711 'CPInformationItem' => 'CarPlay.CPInformationItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EEB22 /* #2712 'CPInformationRatingItem' => 'CarPlay.CPInformationRatingItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EEC22 /* #2713 'CPInformationTemplate' => 'CarPlay.CPInformationTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EEE22 /* #2714 'CPInstrumentClusterController' => 'CarPlay.CPInstrumentClusterController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EF222 /* #2715 'Xamarin_iOS__CarPlay_CPInstrumentClusterControllerDelegate' => 'CarPlay.CPInstrumentClusterControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EF822 /* #2716 'Xamarin_iOS__CarPlay_CPInterfaceControllerDelegate' => 'CarPlay.CPInterfaceControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EFA22 /* #2717 'CPListImageRowItem' => 'CarPlay.CPListImageRowItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EFB22 /* #2718 'CPListItem' => 'CarPlay.CPListItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EFE22 /* #2719 'CPListSection' => 'CarPlay.CPListSection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EFF22 /* #2720 'CPListTemplate' => 'CarPlay.CPListTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F0222 /* #2721 'Xamarin_iOS__CarPlay_CPListTemplateDelegate' => 'CarPlay.CPListTemplateDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F0622 /* #2722 'CPManeuver' => 'CarPlay.CPManeuver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F0822 /* #2723 'CPMapButton' => 'CarPlay.CPMapButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F0D22 /* #2724 'Xamarin_iOS__CarPlay_CPMapTemplateDelegate' => 'CarPlay.CPMapTemplateDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F0E22 /* #2725 'CPMessageComposeBarButton' => 'CarPlay.CPMessageComposeBarButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1022 /* #2726 'CPMessageListItemLeadingConfiguration' => 'CarPlay.CPMessageListItemLeadingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1122 /* #2727 'CPMessageListItemTrailingConfiguration' => 'CarPlay.CPMessageListItemTrailingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1522 /* #2728 'CPNavigationSession' => 'CarPlay.CPNavigationSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1722 /* #2729 'CPNowPlayingButton' => 'CarPlay.CPNowPlayingButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1622 /* #2730 'CPNowPlayingAddToLibraryButton' => 'CarPlay.CPNowPlayingAddToLibraryButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1822 /* #2731 'CPNowPlayingImageButton' => 'CarPlay.CPNowPlayingImageButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1922 /* #2732 'CPNowPlayingMoreButton' => 'CarPlay.CPNowPlayingMoreButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1A22 /* #2733 'CPNowPlayingPlaybackRateButton' => 'CarPlay.CPNowPlayingPlaybackRateButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1B22 /* #2734 'CPNowPlayingRepeatButton' => 'CarPlay.CPNowPlayingRepeatButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1C22 /* #2735 'CPNowPlayingShuffleButton' => 'CarPlay.CPNowPlayingShuffleButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F1D22 /* #2736 'CPNowPlayingTemplate' => 'CarPlay.CPNowPlayingTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F2222 /* #2737 'CPPointOfInterest' => 'CarPlay.CPPointOfInterest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F2322 /* #2738 'CPPointOfInterestTemplate' => 'CarPlay.CPPointOfInterestTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F2722 /* #2739 'Xamarin_iOS__CarPlay_CPPointOfInterestTemplateDelegate' => 'CarPlay.CPPointOfInterestTemplateDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F2822 /* #2740 'CPRouteChoice' => 'CarPlay.CPRouteChoice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F2922 /* #2741 'CPSearchTemplate' => 'CarPlay.CPSearchTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F2D22 /* #2742 'Xamarin_iOS__CarPlay_CPSearchTemplateDelegate' => 'CarPlay.CPSearchTemplateDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3022 /* #2743 'CPSessionConfiguration' => 'CarPlay.CPSessionConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3422 /* #2744 'Xamarin_iOS__CarPlay_CPSessionConfigurationDelegate' => 'CarPlay.CPSessionConfigurationDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3522 /* #2745 'CPTabBarTemplate' => 'CarPlay.CPTabBarTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3822 /* #2746 'Xamarin_iOS__CarPlay_CPTabBarTemplateDelegate' => 'CarPlay.CPTabBarTemplateDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255A22 /* #2747 'UIScene' => 'UIKit.UIScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3A22 /* #2748 'CPTemplateApplicationDashboardScene' => 'CarPlay.CPTemplateApplicationDashboardScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3E22 /* #2749 'Xamarin_iOS__CarPlay_CPTemplateApplicationDashboardSceneDelegate' => 'CarPlay.CPTemplateApplicationDashboardSceneDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F3F22 /* #2750 'CPTemplateApplicationInstrumentClusterScene' => 'CarPlay.CPTemplateApplicationInstrumentClusterScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F4322 /* #2751 'Xamarin_iOS__CarPlay_CPTemplateApplicationInstrumentClusterSceneDelegate' => 'CarPlay.CPTemplateApplicationInstrumentClusterSceneDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F4422 /* #2752 'CPTemplateApplicationScene' => 'CarPlay.CPTemplateApplicationScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F4822 /* #2753 'Xamarin_iOS__CarPlay_CPTemplateApplicationSceneDelegate' => 'CarPlay.CPTemplateApplicationSceneDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F4922 /* #2754 'CPTextButton' => 'CarPlay.CPTextButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F4C22 /* #2755 'CPTravelEstimates' => 'CarPlay.CPTravelEstimates, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F4D22 /* #2756 'CPTrip' => 'CarPlay.CPTrip, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5022 /* #2757 'CPTripPreviewTextConfiguration' => 'CarPlay.CPTripPreviewTextConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5122 /* #2758 'CPVoiceControlState' => 'CarPlay.CPVoiceControlState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5222 /* #2759 'CPVoiceControlTemplate' => 'CarPlay.CPVoiceControlTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5922 /* #2760 'CXAction' => 'CallKit.CXAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5C22 /* #2761 'CXCallAction' => 'CallKit.CXCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5A22 /* #2762 'CXAnswerCallAction' => 'CallKit.CXAnswerCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5B22 /* #2763 'CXCall' => 'CallKit.CXCall, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F6222 /* #2764 'CXCallDirectoryExtensionContextDelegate' => 'CallKit.CXCallDirectoryExtensionContextDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F6422 /* #2765 'CXCallDirectoryProvider' => 'CallKit.CXCallDirectoryProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F6622 /* #2766 'CXCallObserver' => 'CallKit.CXCallObserver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F6922 /* #2767 'CXCallObserverDelegate' => 'CallKit.CXCallObserverDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F6A22 /* #2768 'CXCallUpdate' => 'CallKit.CXCallUpdate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F6B22 /* #2769 'CXEndCallAction' => 'CallKit.CXEndCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F7622 /* #2770 'CXHandle' => 'CallKit.CXHandle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F7822 /* #2771 'CXPlayDTMFCallAction' => 'CallKit.CXPlayDtmfCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F7A22 /* #2772 'CXProviderConfiguration' => 'CallKit.CXProviderConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F7E22 /* #2773 'CXProviderDelegate' => 'CallKit.CXProviderDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F7F22 /* #2774 'CXSetGroupCallAction' => 'CallKit.CXSetGroupCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8022 /* #2775 'CXSetHeldCallAction' => 'CallKit.CXSetHeldCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8122 /* #2776 'CXSetMutedCallAction' => 'CallKit.CXSetMutedCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8222 /* #2777 'CXStartCallAction' => 'CallKit.CXStartCallAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8322 /* #2778 'CXTransaction' => 'CallKit.CXTransaction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8822 /* #2779 'BCChatAction' => 'BusinessChat.BCChatAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8D22 /* #2780 'BAAppExtensionInfo' => 'BackgroundAssets.BAAppExtensionInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8F22 /* #2781 'BADownload' => 'BackgroundAssets.BADownload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F9722 /* #2782 'Xamarin_iOS__BackgroundAssets_BADownloadManagerDelegate' => 'BackgroundAssets.BADownloadManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F9922 /* #2783 'BAURLDownload' => 'BackgroundAssets.BAUrlDownload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F9A22 /* #2784 'ASAuthorization' => 'AuthenticationServices.ASAuthorization, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F9B22 /* #2785 'ASAuthorizationRequest' => 'AuthenticationServices.ASAuthorizationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F9D22 /* #2786 'ASAccountAuthenticationModificationController' => 'AuthenticationServices.ASAccountAuthenticationModificationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FA122 /* #2787 'Xamarin_iOS__AuthenticationServices_ASAccountAuthenticationModificationControllerDelegate' => 'AuthenticationServices.ASAccountAuthenticationModificationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FA622 /* #2788 'ASAccountAuthenticationModificationRequest' => 'AuthenticationServices.ASAccountAuthenticationModificationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FA522 /* #2789 'ASAccountAuthenticationModificationReplacePasswordWithSignInWithAppleRequest' => 'AuthenticationServices.ASAccountAuthenticationModificationReplacePasswordWithSignInWithAppleRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FA722 /* #2790 'ASAccountAuthenticationModificationUpgradePasswordToStrongPasswordRequest' => 'AuthenticationServices.ASAccountAuthenticationModificationUpgradePasswordToStrongPasswordRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FA822 /* #2791 'ASAccountAuthenticationModificationViewController' => 'AuthenticationServices.ASAccountAuthenticationModificationViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FBC22 /* #2792 'ASAuthorizationOpenIDRequest' => 'AuthenticationServices.ASAuthorizationOpenIdRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FAF22 /* #2793 'ASAuthorizationAppleIDRequest' => 'AuthenticationServices.ASAuthorizationAppleIdRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FB022 /* #2794 'ASAuthorizationController' => 'AuthenticationServices.ASAuthorizationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FB422 /* #2795 'Xamarin_iOS__AuthenticationServices_ASAuthorizationControllerDelegate' => 'AuthenticationServices.ASAuthorizationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FBF22 /* #2796 'ASAuthorizationPasswordProvider' => 'AuthenticationServices.ASAuthorizationPasswordProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FC022 /* #2797 'ASAuthorizationPasswordRequest' => 'AuthenticationServices.ASAuthorizationPasswordRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FC122 /* #2798 'ASAuthorizationPlatformPublicKeyCredentialAssertion' => 'AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FC222 /* #2799 'ASAuthorizationPlatformPublicKeyCredentialAssertionRequest' => 'AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertionRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FC322 /* #2800 'ASAuthorizationPlatformPublicKeyCredentialDescriptor' => 'AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FC422 /* #2801 'ASAuthorizationPlatformPublicKeyCredentialProvider' => 'AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FC522 /* #2802 'ASAuthorizationPlatformPublicKeyCredentialRegistration' => 'AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FC622 /* #2803 'ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest' => 'AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FCF22 /* #2804 'ASAuthorizationProviderExtensionAuthorizationResult' => 'AuthenticationServices.ASAuthorizationProviderExtensionAuthorizationResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FD722 /* #2805 'ASAuthorizationPublicKeyCredentialParameters' => 'AuthenticationServices.ASAuthorizationPublicKeyCredentialParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE122 /* #2806 'ASAuthorizationSecurityKeyPublicKeyCredentialAssertion' => 'AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialAssertion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE222 /* #2807 'ASAuthorizationSecurityKeyPublicKeyCredentialAssertionRequest' => 'AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialAssertionRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE622 /* #2808 'ASAuthorizationSecurityKeyPublicKeyCredentialProvider' => 'AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE722 /* #2809 'ASAuthorizationSecurityKeyPublicKeyCredentialRegistration' => 'AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialRegistration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE822 /* #2810 'ASAuthorizationSecurityKeyPublicKeyCredentialRegistrationRequest' => 'AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialRegistrationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FEA22 /* #2811 'ASAuthorizationSingleSignOnProvider' => 'AuthenticationServices.ASAuthorizationSingleSignOnProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FEB22 /* #2812 'ASAuthorizationSingleSignOnRequest' => 'AuthenticationServices.ASAuthorizationSingleSignOnRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FF022 /* #2813 'ASCredentialIdentityStoreState' => 'AuthenticationServices.ASCredentialIdentityStoreState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FF122 /* #2814 'ASCredentialProviderExtensionContext' => 'AuthenticationServices.ASCredentialProviderExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FF222 /* #2815 'ASCredentialProviderViewController' => 'AuthenticationServices.ASCredentialProviderViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FF322 /* #2816 'ASCredentialServiceIdentifier' => 'AuthenticationServices.ASCredentialServiceIdentifier, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FF722 /* #2817 'ASPasswordCredential' => 'AuthenticationServices.ASPasswordCredential, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FF822 /* #2818 'ASPasswordCredentialIdentity' => 'AuthenticationServices.ASPasswordCredentialIdentity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FFE22 /* #2819 'ASWebAuthenticationSession' => 'AuthenticationServices.ASWebAuthenticationSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x205722 /* #2820 'AUParameterNode' => 'AudioUnit.AUParameterNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x200622 /* #2821 'AUParameter' => 'AudioUnit.AUParameter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x203922 /* #2822 'AUAudioUnitBus' => 'AudioUnit.AUAudioUnitBus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x203A22 /* #2823 'AUAudioUnitBusArray' => 'AudioUnit.AUAudioUnitBusArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x203E22 /* #2824 'AUAudioUnitPreset' => 'AudioUnit.AUAudioUnitPreset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x205622 /* #2825 'AUParameterGroup' => 'AudioUnit.AUParameterGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x205822 /* #2826 'AUParameterTree' => 'AudioUnit.AUParameterTree, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x210A22 /* #2827 'ALAssetsGroup' => 'AssetsLibrary.ALAssetsGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x210C22 /* #2828 'ALAssetRepresentation' => 'AssetsLibrary.ALAssetRepresentation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x210F22 /* #2829 'ALAssetsFilter' => 'AssetsLibrary.ALAssetsFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x211722 /* #2830 'NSLayoutManager' => 'UIKit.NSLayoutManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x211822 /* #2831 'NSLayoutConstraint' => 'UIKit.NSLayoutConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x211922 /* #2832 'UIAdaptivePresentationControllerDelegate' => 'UIKit.UIAdaptivePresentationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x211C22 /* #2833 'UIPresentationController' => 'UIKit.UIPresentationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x253C22 /* #2834 'UIPrintFormatter' => 'UIKit.UIPrintFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x211E22 /* #2835 'UIMarkupTextPrintFormatter' => 'UIKit.UIMarkupTextPrintFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x212022 /* #2836 'UIFocusUpdateContext' => 'UIKit.UIFocusUpdateContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x211F22 /* #2837 'UICollectionViewFocusUpdateContext' => 'UIKit.UICollectionViewFocusUpdateContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x212622 /* #2838 'UIActivityItemProvider' => 'UIKit.UIActivityItemProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x212722 /* #2839 'UIActivityViewController' => 'UIKit.UIActivityViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x212922 /* #2840 'UIAppearance' => 'UIKit.UIAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x212F22 /* #2841 'UIBezierPath' => 'UIKit.UIBezierPath, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x213122 /* #2842 'UICellAccessory' => 'UIKit.UICellAccessory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x213622 /* #2843 'UICollectionViewLayout' => 'UIKit.UICollectionViewLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x213722 /* #2844 'UICollectionViewLayoutAttributes' => 'UIKit.UICollectionViewLayoutAttributes, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x213822 /* #2845 'UICollectionViewTransitionLayout' => 'UIKit.UICollectionViewTransitionLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x213F22 /* #2846 'UIKit_UIControlEventProxy' => 'UIKit.UIControlEventProxy, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x214922 /* #2847 'UIEvent' => 'UIKit.UIEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x214B22 /* #2848 'UIFont' => 'UIKit.UIFont, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x214D22 /* #2849 'UIFontDescriptor' => 'UIKit.UIFontDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215122 /* #2850 'UIGestureRecognizer' => 'UIKit.UIGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215222 /* #2851 'UIRotationGestureRecognizer' => 'UIKit.UIRotationGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215322 /* #2852 'UILongPressGestureRecognizer' => 'UIKit.UILongPressGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215422 /* #2853 'UITapGestureRecognizer' => 'UIKit.UITapGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215522 /* #2854 'UIPanGestureRecognizer' => 'UIKit.UIPanGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215622 /* #2855 'UIPinchGestureRecognizer' => 'UIKit.UIPinchGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215722 /* #2856 'UISwipeGestureRecognizer' => 'UIKit.UISwipeGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215822 /* #2857 'UIScreenEdgePanGestureRecognizer' => 'UIKit.UIScreenEdgePanGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215922 /* #2858 'UIHoverGestureRecognizer' => 'UIKit.UIHoverGestureRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x215D22 /* #2859 '__MonoTouch_UIImageStatusDispatcher' => 'UIKit.UIImageStatusDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x216222 /* #2860 'UIListSeparatorConfiguration' => 'UIKit.UIListSeparatorConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x216B22 /* #2861 'UIPopoverPresentationControllerDelegate' => 'UIKit.UIPopoverPresentationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23E622 /* #2862 'UIDynamicBehavior' => 'UIKit.UIDynamicBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x216F22 /* #2863 'UIPushBehavior' => 'UIKit.UIPushBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x217422 /* #2864 'UISearchDisplayController' => 'UIKit.UISearchDisplayController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x217622 /* #2865 'UISimpleTextPrintFormatter' => 'UIKit.UISimpleTextPrintFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x217822 /* #2866 'UIStoryboardSegue' => 'UIKit.UIStoryboardSegue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x217722 /* #2867 'UIStoryboardPopoverSegue' => 'UIKit.UIStoryboardPopoverSegue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x218422 /* #2868 'UITraitCollection' => 'UIKit.UITraitCollection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26FC22 /* #2869 'UIVisualEffect' => 'UIKit.UIVisualEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x218822 /* #2870 'UIVibrancyEffect' => 'UIKit.UIVibrancyEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x218922 /* #2871 '__MonoTouch_UIVideoStatusDispatcher' => 'UIKit.UIVideoStatusDispatcher, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x21F822 /* #2872 'NSCollectionLayoutAnchor' => 'UIKit.NSCollectionLayoutAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220322 /* #2873 'NSCollectionLayoutItem' => 'UIKit.NSCollectionLayoutItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220722 /* #2874 'NSCollectionLayoutSupplementaryItem' => 'UIKit.NSCollectionLayoutSupplementaryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21F922 /* #2875 'NSCollectionLayoutBoundarySupplementaryItem' => 'UIKit.NSCollectionLayoutBoundarySupplementaryItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21FC22 /* #2876 'NSCollectionLayoutDecorationItem' => 'UIKit.NSCollectionLayoutDecorationItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21FD22 /* #2877 'NSCollectionLayoutDimension' => 'UIKit.NSCollectionLayoutDimension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21FE22 /* #2878 'NSCollectionLayoutEdgeSpacing' => 'UIKit.NSCollectionLayoutEdgeSpacing, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220122 /* #2879 'NSCollectionLayoutGroup' => 'UIKit.NSCollectionLayoutGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220222 /* #2880 'NSCollectionLayoutGroupCustomItem' => 'UIKit.NSCollectionLayoutGroupCustomItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220422 /* #2881 'NSCollectionLayoutSection' => 'UIKit.NSCollectionLayoutSection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220522 /* #2882 'NSCollectionLayoutSize' => 'UIKit.NSCollectionLayoutSize, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220622 /* #2883 'NSCollectionLayoutSpacing' => 'UIKit.NSCollectionLayoutSpacing, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220B22 /* #2884 'NSDataAsset' => 'UIKit.NSDataAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220C22 /* #2885 'NSDiffableDataSourceSectionSnapshot' => 'UIKit.NSDiffableDataSourceSectionSnapshot`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220D22 /* #2886 'NSDiffableDataSourceSectionTransaction' => 'UIKit.NSDiffableDataSourceSectionTransaction`2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220E22 /* #2887 'NSDiffableDataSourceSnapshot' => 'UIKit.NSDiffableDataSourceSnapshot`2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x220F22 /* #2888 'NSDiffableDataSourceTransaction' => 'UIKit.NSDiffableDataSourceTransaction`2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x221422 /* #2889 'NSLayoutAnchor' => 'UIKit.NSLayoutAnchor`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x221622 /* #2890 'NSLayoutDimension' => 'UIKit.NSLayoutDimension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x221B22 /* #2891 'NSLayoutManagerDelegate' => 'UIKit.NSLayoutManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x221D22 /* #2892 'NSLayoutXAxisAnchor' => 'UIKit.NSLayoutXAxisAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x221E22 /* #2893 'NSLayoutYAxisAnchor' => 'UIKit.NSLayoutYAxisAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222322 /* #2894 'NSParagraphStyle' => 'UIKit.NSParagraphStyle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222122 /* #2895 'NSMutableParagraphStyle' => 'UIKit.NSMutableParagraphStyle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222522 /* #2896 'NSShadow' => 'UIKit.NSShadow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222722 /* #2897 'NSTextAttachment' => 'UIKit.NSTextAttachment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222A22 /* #2898 'NSTextAttachmentContainer' => 'UIKit.NSTextAttachmentContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222D22 /* #2899 'NSTextAttachmentViewProvider' => 'UIKit.NSTextAttachmentViewProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222E22 /* #2900 'NSTextContainer' => 'UIKit.NSTextContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x223322 /* #2901 'Xamarin_iOS__UIKit_NSTextContentManagerDelegate' => 'UIKit.NSTextContentManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x222F22 /* #2902 'NSTextContentManager' => 'UIKit.NSTextContentManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x223522 /* #2903 'NSTextContentStorage' => 'UIKit.NSTextContentStorage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x223922 /* #2904 'Xamarin_iOS__UIKit_NSTextContentStorageDelegate' => 'UIKit.NSTextContentStorageDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x223B22 /* #2905 'NSTextElement' => 'UIKit.NSTextElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x223F22 /* #2906 'NSTextLayoutFragment' => 'UIKit.NSTextLayoutFragment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x224222 /* #2907 'NSTextLayoutManager' => 'UIKit.NSTextLayoutManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x224622 /* #2908 'Xamarin_iOS__UIKit_NSTextLayoutManagerDelegate' => 'UIKit.NSTextLayoutManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x224C22 /* #2909 'NSTextLineFragment' => 'UIKit.NSTextLineFragment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x224D22 /* #2910 'NSTextList' => 'UIKit.NSTextList, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x225422 /* #2911 'NSTextParagraph' => 'UIKit.NSTextParagraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x224E22 /* #2912 'NSTextListElement' => 'UIKit.NSTextListElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x225522 /* #2913 'NSTextRange' => 'UIKit.NSTextRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x225722 /* #2914 'NSTextSelection' => 'UIKit.NSTextSelection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x225C22 /* #2915 'Xamarin_iOS__UIKit_NSTextSelectionDataSource' => 'UIKit.NSTextSelectionDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x225E22 /* #2916 'NSTextSelectionNavigation' => 'UIKit.NSTextSelectionNavigation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x226922 /* #2917 'NSTextStorageDelegate' => 'UIKit.NSTextStorageDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x226D22 /* #2918 'NSTextTab' => 'UIKit.NSTextTab, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x226E22 /* #2919 'NSTextViewportLayoutController' => 'UIKit.NSTextViewportLayoutController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x227222 /* #2920 'Xamarin_iOS__UIKit_NSTextViewportLayoutControllerDelegate' => 'UIKit.NSTextViewportLayoutControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x227522 /* #2921 'UIAcceleration' => 'UIKit.UIAcceleration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x227B22 /* #2922 'UIAccelerometerDelegate' => 'UIKit.UIAccelerometerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x228222 /* #2923 'UIAccessibilityContainerDataTable' => 'UIKit.UIAccessibilityContainerDataTable, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x228922 /* #2924 'UIAccessibilityCustomRotor' => 'UIKit.UIAccessibilityCustomRotor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x228B22 /* #2925 'UIAccessibilityCustomRotorItemResult' => 'UIKit.UIAccessibilityCustomRotorItemResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x228C22 /* #2926 'UIAccessibilityCustomRotorSearchPredicate' => 'UIKit.UIAccessibilityCustomRotorSearchPredicate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x228E22 /* #2927 'UIAccessibilityElement' => 'UIKit.UIAccessibilityElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x229222 /* #2928 'UIAccessibilityLocationDescriptor' => 'UIKit.UIAccessibilityLocationDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249D22 /* #2929 'UIMenuElement' => 'UIKit.UIMenuElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x229B22 /* #2930 'UIAction' => 'UIKit.UIAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22A222 /* #2931 'UIActionSheetDelegate' => 'UIKit.UIActionSheetDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22A422 /* #2932 'UIActivity' => 'UIKit.UIActivity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22A822 /* #2933 'UIActivityItemsConfiguration' => 'UIKit.UIActivityItemsConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22B622 /* #2934 'UIActivityItemSource' => 'UIKit.UIActivityItemSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22BA22 /* #2935 'UIAlertAction' => 'UIKit.UIAlertAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22BC22 /* #2936 'UIAlertController' => 'UIKit.UIAlertController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22C222 /* #2937 'UIAlertViewDelegate' => 'UIKit.UIAlertViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22C822 /* #2938 'UIAppearanceContainer' => 'UIKit.UIAppearanceContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22CF22 /* #2939 'UIApplicationShortcutIcon' => 'UIKit.UIApplicationShortcutIcon, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22D122 /* #2940 'UIApplicationShortcutItem' => 'UIKit.UIApplicationShortcutItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22D322 /* #2941 'UIAttachmentBehavior' => 'UIKit.UIAttachmentBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22D622 /* #2942 'UIBackgroundConfiguration' => 'UIKit.UIBackgroundConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22D922 /* #2943 'UIBandSelectionInteraction' => 'UIKit.UIBandSelectionInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22DB22 /* #2944 'UIBarAppearance' => 'UIKit.UIBarAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22DC22 /* #2945 'UIBarButtonItemAppearance' => 'UIKit.UIBarButtonItemAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22DD22 /* #2946 'UIBarButtonItemGroup' => 'UIKit.UIBarButtonItemGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22DE22 /* #2947 'UIBarButtonItemStateAppearance' => 'UIKit.UIBarButtonItemStateAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22E522 /* #2948 'UIBarPositioning' => 'UIKit.UIBarPositioning, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22E922 /* #2949 'UIBarPositioningDelegate' => 'UIKit.UIBarPositioningDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22ED22 /* #2950 'UIBlurEffect' => 'UIKit.UIBlurEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22EF22 /* #2951 'UIButtonConfiguration' => 'UIKit.UIButtonConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22F722 /* #2952 'UICalendarSelection' => 'UIKit.UICalendarSelection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22F822 /* #2953 'UICalendarSelectionMultiDate' => 'UIKit.UICalendarSelectionMultiDate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22FC22 /* #2954 'Xamarin_iOS__UIKit_UICalendarSelectionMultiDateDelegate' => 'UIKit.UICalendarSelectionMultiDateDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22FD22 /* #2955 'UICalendarSelectionSingleDate' => 'UIKit.UICalendarSelectionSingleDate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230122 /* #2956 'Xamarin_iOS__UIKit_UICalendarSelectionSingleDateDelegate' => 'UIKit.UICalendarSelectionSingleDateDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230322 /* #2957 'UICalendarViewDecoration' => 'UIKit.UICalendarViewDecoration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230822 /* #2958 'Xamarin_iOS__UIKit_UICalendarViewDelegate' => 'UIKit.UICalendarViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230922 /* #2959 'UICellAccessoryCheckmark' => 'UIKit.UICellAccessoryCheckmark, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230A22 /* #2960 'UICellAccessoryCustomView' => 'UIKit.UICellAccessoryCustomView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230B22 /* #2961 'UICellAccessoryDelete' => 'UIKit.UICellAccessoryDelete, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230C22 /* #2962 'UICellAccessoryDetail' => 'UIKit.UICellAccessoryDetail, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230D22 /* #2963 'UICellAccessoryDisclosureIndicator' => 'UIKit.UICellAccessoryDisclosureIndicator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x230F22 /* #2964 'UICellAccessoryInsert' => 'UIKit.UICellAccessoryInsert, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231022 /* #2965 'UICellAccessoryLabel' => 'UIKit.UICellAccessoryLabel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231122 /* #2966 'UICellAccessoryMultiselect' => 'UIKit.UICellAccessoryMultiselect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231222 /* #2967 'UICellAccessoryOutlineDisclosure' => 'UIKit.UICellAccessoryOutlineDisclosure, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231522 /* #2968 'UICellAccessoryPopUpMenu' => 'UIKit.UICellAccessoryPopUpMenu, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231622 /* #2969 'UICellAccessoryReorder' => 'UIKit.UICellAccessoryReorder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26D722 /* #2970 'UIViewConfigurationState' => 'UIKit.UIViewConfigurationState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231922 /* #2971 'UICellConfigurationState' => 'UIKit.UICellConfigurationState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231A22 /* #2972 'UICloudSharingController' => 'UIKit.UICloudSharingController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x231E22 /* #2973 'UICloudSharingControllerDelegate' => 'UIKit.UICloudSharingControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x232422 /* #2974 'UICollectionLayoutListConfiguration' => 'UIKit.UICollectionLayoutListConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x232D22 /* #2975 'UICollectionViewCellRegistration' => 'UIKit.UICollectionViewCellRegistration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x232E22 /* #2976 'UICollectionViewCompositionalLayout' => 'UIKit.UICollectionViewCompositionalLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x232F22 /* #2977 'UICollectionViewCompositionalLayoutConfiguration' => 'UIKit.UICollectionViewCompositionalLayoutConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x233022 /* #2978 'UICollectionViewController' => 'UIKit.UICollectionViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x233422 /* #2979 'UICollectionViewDataSource' => 'UIKit.UICollectionViewDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x233B22 /* #2980 'UICollectionViewDelegate' => 'UIKit.UICollectionViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x233F22 /* #2981 'UICollectionViewDelegateFlowLayout' => 'UIKit.UICollectionViewDelegateFlowLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x234122 /* #2982 'UICollectionViewDiffableDataSourceReorderingHandlers' => 'UIKit.UICollectionViewDiffableDataSourceReorderingHandlers`2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x234222 /* #2983 'UICollectionViewDiffableDataSourceSectionSnapshotHandlers' => 'UIKit.UICollectionViewDiffableDataSourceSectionSnapshotHandlers`1, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x234622 /* #2984 'UICollectionViewDragDelegate' => 'UIKit.UICollectionViewDragDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x234C22 /* #2985 'UICollectionViewDropDelegate' => 'UIKit.UICollectionViewDropDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x235922 /* #2986 'UICollectionViewPlaceholder' => 'UIKit.UICollectionViewPlaceholder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x235022 /* #2987 'UICollectionViewDropPlaceholder' => 'UIKit.UICollectionViewDropPlaceholder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23DF22 /* #2988 'UIDropProposal' => 'UIKit.UIDropProposal, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x235322 /* #2989 'UICollectionViewDropProposal' => 'UIKit.UICollectionViewDropProposal, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x235422 /* #2990 'UICollectionViewFlowLayout' => 'UIKit.UICollectionViewFlowLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x235722 /* #2991 'UICollectionViewLayoutInvalidationContext' => 'UIKit.UICollectionViewLayoutInvalidationContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x235522 /* #2992 'UICollectionViewFlowLayoutInvalidationContext' => 'UIKit.UICollectionViewFlowLayoutInvalidationContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x236022 /* #2993 'UICollectionViewSource' => 'UIKit.UICollectionViewSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x236122 /* #2994 'UICollectionViewSupplementaryRegistration' => 'UIKit.UICollectionViewSupplementaryRegistration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x236222 /* #2995 'UICollectionViewUpdateItem' => 'UIKit.UICollectionViewUpdateItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x236B22 /* #2996 'UICollisionBehaviorDelegate' => 'UIKit.UICollisionBehaviorDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x236D22 /* #2997 'UIColorPickerViewController' => 'UIKit.UIColorPickerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x237122 /* #2998 'Xamarin_iOS__UIKit_UIColorPickerViewControllerDelegate' => 'UIKit.UIColorPickerViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x237322 /* #2999 'UICommand' => 'UIKit.UICommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x237422 /* #3000 'UICommandAlternate' => 'UIKit.UICommandAlternate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x237B22 /* #3001 'UIContentContainer' => 'UIKit.UIContentContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x238322 /* #3002 'UIContextMenuConfiguration' => 'UIKit.UIContextMenuConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x238522 /* #3003 'UIContextMenuInteraction' => 'UIKit.UIContextMenuInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x238F22 /* #3004 'Xamarin_iOS__UIKit_UIContextMenuInteractionDelegate' => 'UIKit.UIContextMenuInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x239022 /* #3005 'UIContextualAction' => 'UIKit.UIContextualAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x239822 /* #3006 'UICoordinateSpace' => 'UIKit.UICoordinateSpace, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x239922 /* #3007 'UICubicTimingParameters' => 'UIKit.UICubicTimingParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23A222 /* #3008 'UIDeferredMenuElement' => 'UIKit.UIDeferredMenuElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23A522 /* #3009 'UIDictationPhrase' => 'UIKit.UIDictationPhrase, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23A822 /* #3010 'UIDocumentBrowserAction' => 'UIKit.UIDocumentBrowserAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23AD22 /* #3011 'UIDocumentBrowserTransitionController' => 'UIKit.UIDocumentBrowserTransitionController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23B222 /* #3012 'UIDocumentBrowserViewControllerDelegate' => 'UIKit.UIDocumentBrowserViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23B922 /* #3013 'UIDocumentInteractionControllerDelegate' => 'UIKit.UIDocumentInteractionControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23BC22 /* #3014 'UIDocumentMenuDelegate' => 'UIKit.UIDocumentMenuDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23C222 /* #3015 'UIDocumentPickerDelegate' => 'UIKit.UIDocumentPickerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23C322 /* #3016 'UIDocumentPickerExtensionViewController' => 'UIKit.UIDocumentPickerExtensionViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23C722 /* #3017 'UIDocumentProperties' => 'UIKit.UIDocumentProperties, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23CE22 /* #3018 'UIDragInteraction' => 'UIKit.UIDragInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D222 /* #3019 'UIDragInteractionDelegate' => 'UIKit.UIDragInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D322 /* #3020 'UIDragItem' => 'UIKit.UIDragItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D422 /* #3021 'UIDragPreview' => 'UIKit.UIDragPreview, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x252D22 /* #3022 'UIPreviewParameters' => 'UIKit.UIPreviewParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D522 /* #3023 'UIDragPreviewParameters' => 'UIKit.UIDragPreviewParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x252E22 /* #3024 'UIPreviewTarget' => 'UIKit.UIPreviewTarget, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D622 /* #3025 'UIDragPreviewTarget' => 'UIKit.UIDragPreviewTarget, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D922 /* #3026 'UIDropInteraction' => 'UIKit.UIDropInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23DD22 /* #3027 'UIDropInteractionDelegate' => 'UIKit.UIDropInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23E522 /* #3028 'UIDynamicAnimatorDelegate' => 'UIKit.UIDynamicAnimatorDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23EA22 /* #3029 'UIDynamicItem' => 'UIKit.UIDynamicItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23EB22 /* #3030 'UIDynamicItemBehavior' => 'UIKit.UIDynamicItemBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23ED22 /* #3031 'UIDynamicItemGroup' => 'UIKit.UIDynamicItemGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23F022 /* #3032 'UIEditMenuConfiguration' => 'UIKit.UIEditMenuConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23F122 /* #3033 'UIEditMenuInteraction' => 'UIKit.UIEditMenuInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23F722 /* #3034 'Xamarin_iOS__UIKit_UIEditMenuInteractionDelegate' => 'UIKit.UIEditMenuInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23F822 /* #3035 'UIEventAttribution' => 'UIKit.UIEventAttribution, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23FE22 /* #3036 'UIFeedbackGenerator' => 'UIKit.UIFeedbackGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23FF22 /* #3037 'UIFieldBehavior' => 'UIKit.UIFieldBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x240022 /* #3038 'UIFindInteraction' => 'UIKit.UIFindInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x240422 /* #3039 'Xamarin_iOS__UIKit_UIFindInteractionDelegate' => 'UIKit.UIFindInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x240522 /* #3040 'UIFindSession' => 'UIKit.UIFindSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x240A22 /* #3041 'UIFocusDebugger' => 'UIKit.UIFocusDebugger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x240D22 /* #3042 'UIFocusEffect' => 'UIKit.UIFocusEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x248122 /* #3043 'UILayoutGuide' => 'UIKit.UILayoutGuide, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x241222 /* #3044 'UIFocusGuide' => 'UIKit.UIFocusGuide, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x241322 /* #3045 'UIFocusHaloEffect' => 'UIKit.UIFocusHaloEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x241D22 /* #3046 'UIFocusMovementHint' => 'UIKit.UIFocusMovementHint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x241E22 /* #3047 'UIFocusSystem' => 'UIKit.UIFocusSystem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x242222 /* #3048 'UIFontMetrics' => 'UIKit.UIFontMetrics, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x242322 /* #3049 'UIFontPickerViewController' => 'UIKit.UIFontPickerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x242422 /* #3050 'UIFontPickerViewControllerConfiguration' => 'UIKit.UIFontPickerViewControllerConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x242822 /* #3051 'Xamarin_iOS__UIKit_UIFontPickerViewControllerDelegate' => 'UIKit.UIFontPickerViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243322 /* #3052 'UIGestureRecognizerDelegate' => 'UIKit.UIGestureRecognizerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243C22 /* #3053 'UIGraphicsRenderer' => 'UIKit.UIGraphicsRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243522 /* #3054 'UIGraphicsImageRenderer' => 'UIKit.UIGraphicsImageRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243D22 /* #3055 'UIGraphicsRendererContext' => 'UIKit.UIGraphicsRendererContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243622 /* #3056 'UIGraphicsImageRendererContext' => 'UIKit.UIGraphicsImageRendererContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243E22 /* #3057 'UIGraphicsRendererFormat' => 'UIKit.UIGraphicsRendererFormat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243722 /* #3058 'UIGraphicsImageRendererFormat' => 'UIKit.UIGraphicsImageRendererFormat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243922 /* #3059 'UIGraphicsPDFRenderer' => 'UIKit.UIGraphicsPdfRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243A22 /* #3060 'UIGraphicsPDFRendererContext' => 'UIKit.UIGraphicsPdfRendererContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243B22 /* #3061 'UIGraphicsPDFRendererFormat' => 'UIKit.UIGraphicsPdfRendererFormat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x243F22 /* #3062 'UIGravityBehavior' => 'UIKit.UIGravityBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x244722 /* #3063 'UIImageAsset' => 'UIKit.UIImageAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x244822 /* #3064 'UIImageConfiguration' => 'UIKit.UIImageConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x245122 /* #3065 'UIImagePickerControllerDelegate' => 'UIKit.UIImagePickerControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x245722 /* #3066 'UIImageSymbolConfiguration' => 'UIKit.UIImageSymbolConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x245B22 /* #3067 'UIImpactFeedbackGenerator' => 'UIKit.UIImpactFeedbackGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x245D22 /* #3068 'UIIndirectScribbleInteraction' => 'UIKit.UIIndirectScribbleInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x246122 /* #3069 'Xamarin_iOS__UIKit_UIIndirectScribbleInteractionDelegate' => 'UIKit.UIIndirectScribbleInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24AA22 /* #3070 'UIMotionEffect' => 'UIKit.UIMotionEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x246B22 /* #3071 'UIInterpolatingMotionEffect' => 'UIKit.UIInterpolatingMotionEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x246F22 /* #3072 'UIKey' => 'UIKit.UIKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26B122 /* #3073 'UITrackingLayoutGuide' => 'UIKit.UITrackingLayoutGuide, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x247222 /* #3074 'UIKeyboardLayoutGuide' => 'UIKit.UIKeyboardLayoutGuide, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x247422 /* #3075 'UIKeyCommand' => 'UIKit.UIKeyCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x247D22 /* #3076 'Xamarin_iOS__UIKit_UILargeContentViewerInteractionDelegate' => 'UIKit.UILargeContentViewerInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x248922 /* #3077 'UILayoutSupport' => 'UIKit.UILayoutSupport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x248B22 /* #3078 'UILexicon' => 'UIKit.UILexicon, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x248C22 /* #3079 'UILexiconEntry' => 'UIKit.UILexiconEntry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x248E22 /* #3080 'UIListContentConfiguration' => 'UIKit.UIListContentConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x248F22 /* #3081 'UIListContentImageProperties' => 'UIKit.UIListContentImageProperties, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249122 /* #3082 'UIListContentTextProperties' => 'UIKit.UIListContentTextProperties, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249522 /* #3083 'UILocalizedIndexedCollation' => 'UIKit.UILocalizedIndexedCollation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249622 /* #3084 'UILocalNotification' => 'UIKit.UILocalNotification, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23A722 /* #3085 'UIDocument' => 'UIKit.UIDocument, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249722 /* #3086 'UIManagedDocument' => 'UIKit.UIManagedDocument, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249822 /* #3087 'UIMenu' => 'UIKit.UIMenu, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24A322 /* #3088 'UIMenuItem' => 'UIKit.UIMenuItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24A722 /* #3089 'UIMenuSystem' => 'UIKit.UIMenuSystem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24AB22 /* #3090 'UIMotionEffectGroup' => 'UIKit.UIMotionEffectGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24AC22 /* #3091 'UIMutableApplicationShortcutItem' => 'UIKit.UIMutableApplicationShortcutItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26C022 /* #3092 'UIUserNotificationAction' => 'UIKit.UIUserNotificationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24AD22 /* #3093 'UIMutableUserNotificationAction' => 'UIKit.UIMutableUserNotificationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26C422 /* #3094 'UIUserNotificationCategory' => 'UIKit.UIUserNotificationCategory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24AE22 /* #3095 'UIMutableUserNotificationCategory' => 'UIKit.UIMutableUserNotificationCategory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24AF22 /* #3096 'UINavigationBarAppearance' => 'UIKit.UINavigationBarAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24B322 /* #3097 'UINavigationBarDelegate' => 'UIKit.UINavigationBarDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24BA22 /* #3098 'UINavigationItem' => 'UIKit.UINavigationItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24C022 /* #3099 'Xamarin_iOS__UIKit_UINavigationItemRenameDelegate' => 'UIKit.UINavigationItemRenameDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24C322 /* #3100 'UINib' => 'UIKit.UINib, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24C422 /* #3101 'UINotificationFeedbackGenerator' => 'UIKit.UINotificationFeedbackGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24C922 /* #3102 'UIObjectRestoration' => 'UIKit.UIObjectRestoration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24CA22 /* #3103 'UIOpenURLContext' => 'UIKit.UIOpenUrlContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24D422 /* #3104 'UIPageViewControllerDataSource' => 'UIKit.UIPageViewControllerDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24D822 /* #3105 'UIPageViewControllerDelegate' => 'UIKit.UIPageViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24E222 /* #3106 'UIPasteConfiguration' => 'UIKit.UIPasteConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24E722 /* #3107 'UIPasteControlConfiguration' => 'UIKit.UIPasteControlConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24E922 /* #3108 'UIPencilInteraction' => 'UIKit.UIPencilInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24ED22 /* #3109 'UIPencilInteractionDelegate' => 'UIKit.UIPencilInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24EF22 /* #3110 'UIPercentDrivenInteractiveTransition' => 'UIKit.UIPercentDrivenInteractiveTransition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24FA22 /* #3111 'UIPickerViewDelegate' => 'UIKit.UIPickerViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24F322 /* #3112 'UIPickerViewAccessibilityDelegate' => 'UIKit.UIPickerViewAccessibilityDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24F622 /* #3113 'UIPickerViewDataSource' => 'UIKit.UIPickerViewDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24FD22 /* #3114 'UIPickerViewModel' => 'UIKit.UIPickerViewModel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24FE22 /* #3115 'UIPointerAccessory' => 'UIKit.UIPointerAccessory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24FF22 /* #3116 'UIPointerEffect' => 'UIKit.UIPointerEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250122 /* #3117 'UIPointerHighlightEffect' => 'UIKit.UIPointerHighlightEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250222 /* #3118 'UIPointerHoverEffect' => 'UIKit.UIPointerHoverEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250322 /* #3119 'UIPointerInteraction' => 'UIKit.UIPointerInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250922 /* #3120 'Xamarin_iOS__UIKit_UIPointerInteractionDelegate' => 'UIKit.UIPointerInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250A22 /* #3121 'UIPointerLiftEffect' => 'UIKit.UIPointerLiftEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250C22 /* #3122 'UIPointerRegion' => 'UIKit.UIPointerRegion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250D22 /* #3123 'UIPointerRegionRequest' => 'UIKit.UIPointerRegionRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250E22 /* #3124 'UIPointerShape' => 'UIKit.UIPointerShape, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250F22 /* #3125 'UIPointerStyle' => 'UIKit.UIPointerStyle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x251822 /* #3126 'UIPopoverControllerDelegate' => 'UIKit.UIPopoverControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x251F22 /* #3127 'UIPress' => 'UIKit.UIPress, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x252022 /* #3128 'UIPressesEvent' => 'UIKit.UIPressesEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x252322 /* #3129 'UIPreviewAction' => 'UIKit.UIPreviewAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x252422 /* #3130 'UIPreviewActionGroup' => 'UIKit.UIPreviewActionGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x252C22 /* #3131 'UIPreviewInteractionDelegate' => 'UIKit.UIPreviewInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x253122 /* #3132 'UIPrinterDestination' => 'UIKit.UIPrinterDestination, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x253822 /* #3133 'UIPrinterPickerControllerDelegate' => 'UIKit.UIPrinterPickerControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x253D22 /* #3134 'UIPrintInfo' => 'UIKit.UIPrintInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x254622 /* #3135 'UIPrintInteractionControllerDelegate' => 'UIKit.UIPrintInteractionControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x254722 /* #3136 'UIPrintPageRenderer' => 'UIKit.UIPrintPageRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x254822 /* #3137 'UIPrintPaper' => 'UIKit.UIPrintPaper, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x254A22 /* #3138 'UIPrintServiceExtension' => 'UIKit.UIPrintServiceExtension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255022 /* #3139 'UIReferenceLibraryViewController' => 'UIKit.UIReferenceLibraryViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255222 /* #3140 'UIRegion' => 'UIKit.UIRegion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255B22 /* #3141 'UISceneActivationConditions' => 'UIKit.UISceneActivationConditions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255C22 /* #3142 'UISceneActivationRequestOptions' => 'UIKit.UISceneActivationRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255E22 /* #3143 'UISceneConfiguration' => 'UIKit.UISceneConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x255F22 /* #3144 'UISceneConnectionOptions' => 'UIKit.UISceneConnectionOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256322 /* #3145 'Xamarin_iOS__UIKit_UISceneDelegate' => 'UIKit.UISceneDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256422 /* #3146 'UISceneDestructionRequestOptions' => 'UIKit.UISceneDestructionRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256722 /* #3147 'UISceneOpenExternalURLOptions' => 'UIKit.UISceneOpenExternalUrlOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256822 /* #3148 'UISceneOpenURLOptions' => 'UIKit.UISceneOpenUrlOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256922 /* #3149 'UISceneSession' => 'UIKit.UISceneSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256A22 /* #3150 'UISceneSizeRestrictions' => 'UIKit.UISceneSizeRestrictions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256B22 /* #3151 'UISceneWindowingBehaviors' => 'UIKit.UISceneWindowingBehaviors, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256C22 /* #3152 'UIScreenMode' => 'UIKit.UIScreenMode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256F22 /* #3153 'UIScreenshotService' => 'UIKit.UIScreenshotService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x257322 /* #3154 'Xamarin_iOS__UIKit_UIScreenshotServiceDelegate' => 'UIKit.UIScreenshotServiceDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x257422 /* #3155 'UIScribbleInteraction' => 'UIKit.UIScribbleInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x257822 /* #3156 'Xamarin_iOS__UIKit_UIScribbleInteractionDelegate' => 'UIKit.UIScribbleInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x258722 /* #3157 'UIScrollViewDelegate' => 'UIKit.UIScrollViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x258222 /* #3158 'UIScrollViewAccessibilityDelegate' => 'UIKit.UIScrollViewAccessibilityDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x259022 /* #3159 'UISearchBarDelegate' => 'UIKit.UISearchBarDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x259322 /* #3160 'UISearchContainerViewController' => 'UIKit.UISearchContainerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x259722 /* #3161 'UISearchControllerDelegate' => 'UIKit.UISearchControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x259C22 /* #3162 'UISearchDisplayDelegate' => 'UIKit.UISearchDisplayDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25A022 /* #3163 'UISearchResultsUpdating' => 'UIKit.UISearchResultsUpdating, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25A422 /* #3164 'UISearchSuggestionItem' => 'UIKit.UISearchSuggestionItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25A922 /* #3165 'Xamarin_iOS__UIKit_UISearchTextFieldDelegate' => 'UIKit.UISearchTextFieldDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25AC22 /* #3166 'UISearchToken' => 'UIKit.UISearchToken, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25AF22 /* #3167 'UISelectionFeedbackGenerator' => 'UIKit.UISelectionFeedbackGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25B122 /* #3168 'UISheetPresentationController' => 'UIKit.UISheetPresentationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25B522 /* #3169 'Xamarin_iOS__UIKit_UISheetPresentationControllerDelegate' => 'UIKit.UISheetPresentationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25B622 /* #3170 'UISheetPresentationControllerDetent' => 'UIKit.UISheetPresentationControllerDetent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25BC22 /* #3171 'UISnapBehavior' => 'UIKit.UISnapBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25C922 /* #3172 'UISplitViewControllerDelegate' => 'UIKit.UISplitViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25CF22 /* #3173 'UISpringLoadedInteraction' => 'UIKit.UISpringLoadedInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25DA22 /* #3174 'UISpringTimingParameters' => 'UIKit.UISpringTimingParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25E222 /* #3175 'UIStateRestoring' => 'UIKit.UIStateRestoring, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25E422 /* #3176 'UIStatusBarManager' => 'UIKit.UIStatusBarManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25E722 /* #3177 'UIStoryboard' => 'UIKit.UIStoryboard, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25E822 /* #3178 'UIStoryboardUnwindSegueSource' => 'UIKit.UIStoryboardUnwindSegueSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25EA22 /* #3179 'UISwipeActionsConfiguration' => 'UIKit.UISwipeActionsConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25F322 /* #3180 'UITabBarAppearance' => 'UIKit.UITabBarAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25FB22 /* #3181 'UITabBarControllerDelegate' => 'UIKit.UITabBarControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25FF22 /* #3182 'UITabBarDelegate' => 'UIKit.UITabBarDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x260122 /* #3183 'UITabBarItemAppearance' => 'UIKit.UITabBarItemAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x260422 /* #3184 'UITabBarItemStateAppearance' => 'UIKit.UITabBarItemStateAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x261222 /* #3185 'Xamarin_iOS__UIKit_UITableViewDataSource' => 'UIKit.UITableViewDataSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x261922 /* #3186 'UITableViewDelegate' => 'UIKit.UITableViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x261E22 /* #3187 'UITableViewDragDelegate' => 'UIKit.UITableViewDragDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x262422 /* #3188 'UITableViewDropDelegate' => 'UIKit.UITableViewDropDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x262E22 /* #3189 'UITableViewPlaceholder' => 'UIKit.UITableViewPlaceholder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x262822 /* #3190 'UITableViewDropPlaceholder' => 'UIKit.UITableViewDropPlaceholder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x262B22 /* #3191 'UITableViewDropProposal' => 'UIKit.UITableViewDropProposal, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x262C22 /* #3192 'UITableViewFocusUpdateContext' => 'UIKit.UITableViewFocusUpdateContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x262F22 /* #3193 'UITableViewRowAction' => 'UIKit.UITableViewRowAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x263522 /* #3194 'UITableViewSource' => 'UIKit.UITableViewSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x263822 /* #3195 'UITargetedPreview' => 'UIKit.UITargetedPreview, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x263722 /* #3196 'UITargetedDragPreview' => 'UIKit.UITargetedDragPreview, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x263F22 /* #3197 'UITextChecker' => 'UIKit.UITextChecker, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x264522 /* #3198 'UITextDocumentProxy' => 'UIKit.UITextDocumentProxy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x264922 /* #3199 'UITextDragDelegate' => 'UIKit.UITextDragDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x264D22 /* #3200 'UITextDragPreviewRenderer' => 'UIKit.UITextDragPreviewRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x265422 /* #3201 'UITextDropDelegate' => 'UIKit.UITextDropDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x265A22 /* #3202 'UITextDropProposal' => 'UIKit.UITextDropProposal, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266022 /* #3203 'UITextFieldDelegate' => 'UIKit.UITextFieldDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266322 /* #3204 'UITextFormattingCoordinator' => 'UIKit.UITextFormattingCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266622 /* #3205 'Xamarin_iOS__UIKit_UITextFormattingCoordinatorDelegate' => 'UIKit.UITextFormattingCoordinatorDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266B22 /* #3206 'UITextInputAssistantItem' => 'UIKit.UITextInputAssistantItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266E22 /* #3207 'UITextInputDelegate' => 'UIKit.UITextInputDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x267022 /* #3208 'UITextInputPasswordRules' => 'UIKit.UITextInputPasswordRules, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x267122 /* #3209 'UITextInputStringTokenizer' => 'UIKit.UITextInputStringTokenizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x267422 /* #3210 'UITextInputTokenizer' => 'UIKit.UITextInputTokenizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x267822 /* #3211 'UITextInteraction' => 'UIKit.UITextInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x267C22 /* #3212 'Xamarin_iOS__UIKit_UITextInteractionDelegate' => 'UIKit.UITextInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x268522 /* #3213 'UITextPasteDelegate' => 'UIKit.UITextPasteDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x268822 /* #3214 'UITextPlaceholder' => 'UIKit.UITextPlaceholder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x268922 /* #3215 'UITextPosition' => 'UIKit.UITextPosition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x268A22 /* #3216 'UITextRange' => 'UIKit.UITextRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x269122 /* #3217 'UITextSearchingFindSession' => 'UIKit.UITextSearchingFindSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x269322 /* #3218 'UITextSearchOptions' => 'UIKit.UITextSearchOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x269422 /* #3219 'UITextSelectionRect' => 'UIKit.UITextSelectionRect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x269D22 /* #3220 'UITextViewDelegate' => 'UIKit.UITextViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26A222 /* #3221 'UIToolbarAppearance' => 'UIKit.UIToolbarAppearance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26A522 /* #3222 'UIToolbarDelegate' => 'UIKit.UIToolbarDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26A722 /* #3223 'UIToolTipConfiguration' => 'UIKit.UIToolTipConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26A822 /* #3224 'UIToolTipInteraction' => 'UIKit.UIToolTipInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26AC22 /* #3225 'Xamarin_iOS__UIKit_UIToolTipInteractionDelegate' => 'UIKit.UIToolTipInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26AD22 /* #3226 'UITouch' => 'UIKit.UITouch, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26B422 /* #3227 'UITraitEnvironment' => 'UIKit.UITraitEnvironment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26C522 /* #3228 'UIUserNotificationSettings' => 'UIKit.UIUserNotificationSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26CD22 /* #3229 'UIVideoEditorControllerDelegate' => 'UIKit.UIVideoEditorControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26DC22 /* #3230 'UIViewControllerAnimatedTransitioning' => 'UIKit.UIViewControllerAnimatedTransitioning, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26E022 /* #3231 'UIViewControllerContextTransitioning' => 'UIKit.UIViewControllerContextTransitioning, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26E422 /* #3232 'UIViewControllerInteractiveTransitioning' => 'UIKit.UIViewControllerInteractiveTransitioning, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26E922 /* #3233 'UIViewControllerPreviewingDelegate' => 'UIKit.UIViewControllerPreviewingDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26F422 /* #3234 'UIViewControllerTransitioningDelegate' => 'UIKit.UIViewControllerTransitioningDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26F922 /* #3235 'UIViewPrintFormatter' => 'UIKit.UIViewPrintFormatter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26FA22 /* #3236 'UIViewPropertyAnimator' => 'UIKit.UIViewPropertyAnimator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x270522 /* #3237 'UIWebViewDelegate' => 'UIKit.UIWebViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x270822 /* #3238 'UIWindowScene' => 'UIKit.UIWindowScene, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x270922 /* #3239 'UIWindowSceneActivationAction' => 'UIKit.UIWindowSceneActivationAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x270B22 /* #3240 'UIWindowSceneActivationInteraction' => 'UIKit.UIWindowSceneActivationInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x270C22 /* #3241 'UIWindowSceneActivationRequestOptions' => 'UIKit.UIWindowSceneActivationRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271022 /* #3242 'Xamarin_iOS__UIKit_UIWindowSceneDelegate' => 'UIKit.UIWindowSceneDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271122 /* #3243 'UIWindowSceneDestructionRequestOptions' => 'UIKit.UIWindowSceneDestructionRequestOptions, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271322 /* #3244 'UIWindowSceneGeometry' => 'UIKit.UIWindowSceneGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271422 /* #3245 'UIWindowSceneGeometryPreferences' => 'UIKit.UIWindowSceneGeometryPreferences, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271522 /* #3246 'UIWindowSceneGeometryPreferencesIOS' => 'UIKit.UIWindowSceneGeometryPreferencesIOS, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271622 /* #3247 'UIWindowSceneGeometryPreferencesMac' => 'UIKit.UIWindowSceneGeometryPreferencesMac, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x272E22 /* #3248 'ABNewPersonViewControllerDelegate' => 'AddressBookUI.ABNewPersonViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271C22 /* #3249 'AddressBookUI_InternalABNewPersonViewControllerDelegate' => 'AddressBookUI.InternalABNewPersonViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x273222 /* #3250 'ABPeoplePickerNavigationControllerDelegate' => 'AddressBookUI.ABPeoplePickerNavigationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x272222 /* #3251 'AddressBookUI_InternalABPeoplePickerNavigationControllerDelegate' => 'AddressBookUI.InternalABPeoplePickerNavigationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x273622 /* #3252 'ABPersonViewControllerDelegate' => 'AddressBookUI.ABPersonViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x272522 /* #3253 'AddressBookUI_InternalABPersonViewControllerDelegate' => 'AddressBookUI.InternalABPersonViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x273A22 /* #3254 'ABUnknownPersonViewControllerDelegate' => 'AddressBookUI.ABUnknownPersonViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x272822 /* #3255 'AddressBookUI_InternalABUnknownPersonViewControllerDelegate' => 'AddressBookUI.InternalABUnknownPersonViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x276622 /* #3256 'ASIdentifierManager' => 'AdSupport.ASIdentifierManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x276922 /* #3257 'ACAccount' => 'Accounts.ACAccount, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x276A22 /* #3258 'ACAccountCredential' => 'Accounts.ACAccountCredential, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x276D22 /* #3259 'ACAccountType' => 'Accounts.ACAccountType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x277722 /* #3260 'AXBrailleMap' => 'Accessibility.AXBrailleMap, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x277A22 /* #3261 'AXCategoricalDataAxisDescriptor' => 'Accessibility.AXCategoricalDataAxisDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x277D22 /* #3262 'AXChartDescriptor' => 'Accessibility.AXChartDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x277F22 /* #3263 'AXCustomContent' => 'Accessibility.AXCustomContent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x278522 /* #3264 'AXDataPoint' => 'Accessibility.AXDataPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x278622 /* #3265 'AXDataPointValue' => 'Accessibility.AXDataPointValue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x278722 /* #3266 'AXDataSeriesDescriptor' => 'Accessibility.AXDataSeriesDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x278922 /* #3267 'AXLiveAudioGraph' => 'Accessibility.AXLiveAudioGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x278A22 /* #3268 'AXNumericDataAxisDescriptor' => 'Accessibility.AXNumericDataAxisDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x279A22 /* #3269 'AVCustomDeviceRoute' => 'AVRouting.AVCustomDeviceRoute, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x279B22 /* #3270 'AVCustomRoutingActionItem' => 'AVRouting.AVCustomRoutingActionItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x279D22 /* #3271 'AVCustomRoutingEvent' => 'AVRouting.AVCustomRoutingEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x279F22 /* #3272 'AVPlayerViewController' => 'AVKit.AVPlayerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27A622 /* #3273 'Xamarin_iOS__AVKit_AVCustomRoutingControllerDelegate' => 'AVKit.AVCustomRoutingControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27A722 /* #3274 'AVInterstitialTimeRange' => 'AVKit.AVInterstitialTimeRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27AA22 /* #3275 'AVPictureInPictureController' => 'AVKit.AVPictureInPictureController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27AB22 /* #3276 'AVPictureInPictureControllerContentSource' => 'AVKit.AVPictureInPictureControllerContentSource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27AF22 /* #3277 'AVPictureInPictureControllerDelegate' => 'AVKit.AVPictureInPictureControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27B322 /* #3278 'Xamarin_iOS__AVKit_AVPictureInPictureSampleBufferPlaybackDelegate' => 'AVKit.AVPictureInPictureSampleBufferPlaybackDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27B422 /* #3279 'AVPictureInPictureVideoCallViewController' => 'AVKit.AVPictureInPictureVideoCallViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27B522 /* #3280 'AVPlaybackSpeed' => 'AVKit.AVPlaybackSpeed, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27B922 /* #3281 'AVPlayerViewControllerDelegate' => 'AVKit.AVPlayerViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27BF22 /* #3282 'AVRoutePickerViewDelegate' => 'AVKit.AVRoutePickerViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C122 /* #3283 'AVAssetDownloadStorageManagementPolicy' => 'AVFoundation.AVAssetDownloadStorageManagementPolicy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C222 /* #3284 'AVMutableAssetDownloadStorageManagementPolicy' => 'AVFoundation.AVMutableAssetDownloadStorageManagementPolicy, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C322 /* #3285 'AVAssetDownloadTask' => 'AVFoundation.AVAssetDownloadTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167822 /* #3286 'NSURLSession' => 'Foundation.NSUrlSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C422 /* #3287 'AVAssetDownloadURLSession' => 'AVFoundation.AVAssetDownloadUrlSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C522 /* #3288 'AVAssetResourceLoadingDataRequest' => 'AVFoundation.AVAssetResourceLoadingDataRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C622 /* #3289 'AVAudioBuffer' => 'AVFoundation.AVAudioBuffer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C722 /* #3290 'AVAudioChannelLayout' => 'AVFoundation.AVAudioChannelLayout, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27C922 /* #3291 'AVAudioFormat' => 'AVFoundation.AVAudioFormat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27CA22 /* #3292 'AVAudioPlayer' => 'AVFoundation.AVAudioPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27CB22 /* #3293 'AVAudioRecorder' => 'AVFoundation.AVAudioRecorder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27D122 /* #3294 'AVAudioSessionDataSourceDescription' => 'AVFoundation.AVAudioSessionDataSourceDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27D222 /* #3295 'AVAudioSessionPortDescription' => 'AVFoundation.AVAudioSessionPortDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27D522 /* #3296 'AVCaptureConnection' => 'AVFoundation.AVCaptureConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27D622 /* #3297 'AVCaptureDeviceDiscoverySession' => 'AVFoundation.AVCaptureDeviceDiscoverySession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28E322 /* #3298 'AVCaptureInput' => 'AVFoundation.AVCaptureInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27D722 /* #3299 'AVCaptureDeviceInput' => 'AVFoundation.AVCaptureDeviceInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28ED22 /* #3300 'AVCaptureOutput' => 'AVFoundation.AVCaptureOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27D922 /* #3301 'AVCaptureMetadataOutput' => 'AVFoundation.AVCaptureMetadataOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27DA22 /* #3302 'AVCaptureSynchronizedDataCollection' => 'AVFoundation.AVCaptureSynchronizedDataCollection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x290322 /* #3303 'AVCaptureSynchronizedData' => 'AVFoundation.AVCaptureSynchronizedData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27DB22 /* #3304 'AVCaptureSynchronizedDepthData' => 'AVFoundation.AVCaptureSynchronizedDepthData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27DE22 /* #3305 'AVAudioNode' => 'AVFoundation.AVAudioNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27DF22 /* #3306 'AVAudioSourceNode' => 'AVFoundation.AVAudioSourceNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E122 /* #3307 'AVAssetTrack' => 'AVFoundation.AVAssetTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x291A22 /* #3308 'AVCompositionTrack' => 'AVFoundation.AVCompositionTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E222 /* #3309 'AVMutableCompositionTrack' => 'AVFoundation.AVMutableCompositionTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E322 /* #3310 'AVCaptureAudioDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E522 /* #3311 'AVCaptureInputPort' => 'AVFoundation.AVCaptureInputPort, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E622 /* #3312 'AVAudioConnectionPoint' => 'AVFoundation.AVAudioConnectionPoint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28CA22 /* #3313 'AVCaptureBracketedStillImageSettings' => 'AVFoundation.AVCaptureBracketedStillImageSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E922 /* #3314 'AVCaptureManualExposureBracketedStillImageSettings' => 'AVFoundation.AVCaptureManualExposureBracketedStillImageSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27EA22 /* #3315 'AVCaptureAutoExposureBracketedStillImageSettings' => 'AVFoundation.AVCaptureAutoExposureBracketedStillImageSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299722 /* #3316 'AVPlayerInterstitialEventMonitor' => 'AVFoundation.AVPlayerInterstitialEventMonitor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27EB22 /* #3317 'AVPlayerInterstitialEventController' => 'AVFoundation.AVPlayerInterstitialEventController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27EC22 /* #3318 'AVPlayerInterstitialEvent' => 'AVFoundation.AVPlayerInterstitialEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27EE22 /* #3319 'AVContentKeyResponse' => 'AVFoundation.AVContentKeyResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27EF22 /* #3320 'AVDepthData' => 'AVFoundation.AVDepthData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27F222 /* #3321 'AVPlayerLayer' => 'AVFoundation.AVPlayerLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27F522 /* #3322 'AVMetadataObject' => 'AVFoundation.AVMetadataObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27F422 /* #3323 'AVMetadataMachineReadableCodeObject' => 'AVFoundation.AVMetadataMachineReadableCodeObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27F622 /* #3324 'AVOutputSettingsAssistant' => 'AVFoundation.AVOutputSettingsAssistant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27FA22 /* #3325 'AVPlayerLooper' => 'AVFoundation.AVPlayerLooper, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27FB22 /* #3326 'AVTextStyleRule' => 'AVFoundation.AVTextStyleRule, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x288422 /* #3327 'AVAudioPlayerDelegate' => 'AVFoundation.AVAudioPlayerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x281422 /* #3328 'AVFoundation_InternalAVAudioPlayerDelegate' => 'AVFoundation.InternalAVAudioPlayerDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x288C22 /* #3329 'AVAudioRecorderDelegate' => 'AVFoundation.AVAudioRecorderDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x281522 /* #3330 'AVFoundation_InternalAVAudioRecorderDelegate' => 'AVFoundation.InternalAVAudioRecorderDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x289522 /* #3331 'AVAudioSessionDelegate' => 'AVFoundation.AVAudioSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x281922 /* #3332 'AVFoundation_InternalAVAudioSessionDelegate' => 'AVFoundation.InternalAVAudioSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x281A22 /* #3333 'AVAggregateAssetDownloadTask' => 'AVFoundation.AVAggregateAssetDownloadTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x281B22 /* #3334 'AVAssetCache' => 'AVFoundation.AVAssetCache, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x281C22 /* #3335 'AVAssetDownloadConfiguration' => 'AVFoundation.AVAssetDownloadConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x281D22 /* #3336 'AVAssetDownloadContentConfiguration' => 'AVFoundation.AVAssetDownloadContentConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x282122 /* #3337 'AVAssetDownloadDelegate' => 'AVFoundation.AVAssetDownloadDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x282522 /* #3338 'AVAssetDownloadStorageManager' => 'AVFoundation.AVAssetDownloadStorageManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x282C22 /* #3339 'AVAssetImageGenerator' => 'AVFoundation.AVAssetImageGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x282E22 /* #3340 'AVAssetReader' => 'AVFoundation.AVAssetReader, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283022 /* #3341 'AVAssetReaderOutput' => 'AVFoundation.AVAssetReaderOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x282F22 /* #3342 'AVAssetReaderAudioMixOutput' => 'AVFoundation.AVAssetReaderAudioMixOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283122 /* #3343 'AVAssetReaderOutputMetadataAdaptor' => 'AVFoundation.AVAssetReaderOutputMetadataAdaptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283222 /* #3344 'AVAssetReaderSampleReferenceOutput' => 'AVFoundation.AVAssetReaderSampleReferenceOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283422 /* #3345 'AVAssetReaderTrackOutput' => 'AVFoundation.AVAssetReaderTrackOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283522 /* #3346 'AVAssetReaderVideoCompositionOutput' => 'AVFoundation.AVAssetReaderVideoCompositionOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283722 /* #3347 'AVAssetResourceLoader' => 'AVFoundation.AVAssetResourceLoader, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283B22 /* #3348 'AVAssetResourceLoaderDelegate' => 'AVFoundation.AVAssetResourceLoaderDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283C22 /* #3349 'AVAssetResourceLoadingContentInformationRequest' => 'AVFoundation.AVAssetResourceLoadingContentInformationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283D22 /* #3350 'AVAssetResourceLoadingRequest' => 'AVFoundation.AVAssetResourceLoadingRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283E22 /* #3351 'AVAssetResourceLoadingRequestor' => 'AVFoundation.AVAssetResourceLoadingRequestor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x283F22 /* #3352 'AVAssetResourceRenewalRequest' => 'AVFoundation.AVAssetResourceRenewalRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284022 /* #3353 'AVAssetSegmentReport' => 'AVFoundation.AVAssetSegmentReport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284122 /* #3354 'AVAssetSegmentReportSampleInformation' => 'AVFoundation.AVAssetSegmentReportSampleInformation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284222 /* #3355 'AVAssetSegmentTrackReport' => 'AVFoundation.AVAssetSegmentTrackReport, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284422 /* #3356 'AVAssetTrackGroup' => 'AVFoundation.AVAssetTrackGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284522 /* #3357 'AVAssetTrackSegment' => 'AVFoundation.AVAssetTrackSegment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284722 /* #3358 'AVAssetVariant' => 'AVFoundation.AVAssetVariant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284822 /* #3359 'AVAssetVariantAudioAttributes' => 'AVFoundation.AVAssetVariantAudioAttributes, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284922 /* #3360 'AVAssetVariantAudioRenditionSpecificAttributes' => 'AVFoundation.AVAssetVariantAudioRenditionSpecificAttributes, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284A22 /* #3361 'AVAssetVariantQualifier' => 'AVFoundation.AVAssetVariantQualifier, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284B22 /* #3362 'AVAssetVariantVideoAttributes' => 'AVFoundation.AVAssetVariantVideoAttributes, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285022 /* #3363 'Xamarin_iOS__AVFoundation_AVAssetWriterDelegate' => 'AVFoundation.AVAssetWriterDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285122 /* #3364 'AVAssetWriterInput' => 'AVFoundation.AVAssetWriterInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x295B22 /* #3365 'AVMediaSelectionGroup' => 'AVFoundation.AVMediaSelectionGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285222 /* #3366 'AVAssetWriterInputGroup' => 'AVFoundation.AVAssetWriterInputGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285522 /* #3367 'AVAssetWriterInputMetadataAdaptor' => 'AVFoundation.AVAssetWriterInputMetadataAdaptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285622 /* #3368 'AVAssetWriterInputPassDescription' => 'AVFoundation.AVAssetWriterInputPassDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285722 /* #3369 'AVAssetWriterInputPixelBufferAdaptor' => 'AVFoundation.AVAssetWriterInputPixelBufferAdaptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285922 /* #3370 'AVAsynchronousCIImageFilteringRequest' => 'AVFoundation.AVAsynchronousCIImageFilteringRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285C22 /* #3371 'AVAsynchronousKeyValueLoading' => 'AVFoundation.AVAsynchronousKeyValueLoading, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x286122 /* #3372 'AVAudio3DMixing' => 'AVFoundation.AVAudio3DMixing, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x286722 /* #3373 'AVAudioCompressedBuffer' => 'AVFoundation.AVAudioCompressedBuffer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x286822 /* #3374 'AVAudioConverter' => 'AVFoundation.AVAudioConverter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287122 /* #3375 'AVAudioEnvironmentDistanceAttenuationParameters' => 'AVFoundation.AVAudioEnvironmentDistanceAttenuationParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287222 /* #3376 'AVAudioEnvironmentNode' => 'AVFoundation.AVAudioEnvironmentNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287422 /* #3377 'AVAudioEnvironmentReverbParameters' => 'AVFoundation.AVAudioEnvironmentReverbParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287522 /* #3378 'AVAudioFile' => 'AVFoundation.AVAudioFile, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287722 /* #3379 'AVAudioIONode' => 'AVFoundation.AVAudioIONode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287622 /* #3380 'AVAudioInputNode' => 'AVFoundation.AVAudioInputNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287822 /* #3381 'AVAudioMix' => 'AVFoundation.AVAudioMix, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287922 /* #3382 'AVAudioMixerNode' => 'AVFoundation.AVAudioMixerNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287D22 /* #3383 'AVAudioMixingDestination' => 'AVFoundation.AVAudioMixingDestination, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287E22 /* #3384 'AVAudioMixInputParameters' => 'AVFoundation.AVAudioMixInputParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x287F22 /* #3385 'AVAudioOutputNode' => 'AVFoundation.AVAudioOutputNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x288022 /* #3386 'AVAudioPCMBuffer' => 'AVFoundation.AVAudioPcmBuffer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x288E22 /* #3387 'AVAudioSequencer' => 'AVFoundation.AVAudioSequencer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x289122 /* #3388 'AVAudioSessionChannelDescription' => 'AVFoundation.AVAudioSessionChannelDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28A122 /* #3389 'AVAudioSessionRouteDescription' => 'AVFoundation.AVAudioSessionRouteDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28A622 /* #3390 'AVAudioSinkNode' => 'AVFoundation.AVAudioSinkNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28AA22 /* #3391 'AVAudioStereoMixing' => 'AVFoundation.AVAudioStereoMixing, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28AC22 /* #3392 'AVAudioTime' => 'AVFoundation.AVAudioTime, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28AE22 /* #3393 'AVAudioUnit' => 'AVFoundation.AVAudioUnit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28B322 /* #3394 'AVAudioUnitEffect' => 'AVFoundation.AVAudioUnitEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28B022 /* #3395 'AVAudioUnitDelay' => 'AVFoundation.AVAudioUnitDelay, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28B122 /* #3396 'AVAudioUnitDistortion' => 'AVFoundation.AVAudioUnitDistortion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28B422 /* #3397 'AVAudioUnitEQ' => 'AVFoundation.AVAudioUnitEQ, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28B522 /* #3398 'AVAudioUnitEQFilterParameters' => 'AVFoundation.AVAudioUnitEQFilterParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28B722 /* #3399 'AVAudioUnitGenerator' => 'AVFoundation.AVAudioUnitGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28B922 /* #3400 'AVAudioUnitMIDIInstrument' => 'AVFoundation.AVAudioUnitMidiInstrument, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28BA22 /* #3401 'AVAudioUnitReverb' => 'AVFoundation.AVAudioUnitReverb, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28BC22 /* #3402 'AVAudioUnitSampler' => 'AVFoundation.AVAudioUnitSampler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28BD22 /* #3403 'AVAudioUnitTimeEffect' => 'AVFoundation.AVAudioUnitTimeEffect, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28BE22 /* #3404 'AVAudioUnitTimePitch' => 'AVFoundation.AVAudioUnitTimePitch, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28C022 /* #3405 'AVAudioUnitVarispeed' => 'AVFoundation.AVAudioUnitVarispeed, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28C322 /* #3406 'AVCameraCalibrationData' => 'AVFoundation.AVCameraCalibrationData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28C422 /* #3407 'AVCaptureAudioChannel' => 'AVFoundation.AVCaptureAudioChannel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28C522 /* #3408 'AVCaptureAudioDataOutput' => 'AVFoundation.AVCaptureAudioDataOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28CD22 /* #3409 'AVCaptureDataOutputSynchronizer' => 'AVFoundation.AVCaptureDataOutputSynchronizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28D022 /* #3410 'AVCaptureDataOutputSynchronizerDelegate' => 'AVFoundation.AVCaptureDataOutputSynchronizerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28D122 /* #3411 'AVCaptureDepthDataOutput' => 'AVFoundation.AVCaptureDepthDataOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28D522 /* #3412 'AVCaptureDepthDataOutputDelegate' => 'AVFoundation.AVCaptureDepthDataOutputDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28D722 /* #3413 'AVCaptureDeviceFormat' => 'AVFoundation.AVCaptureDeviceFormat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28E022 /* #3414 'AVCaptureFileOutputRecordingDelegate' => 'AVFoundation.AVCaptureFileOutputRecordingDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28E522 /* #3415 'AVCaptureMetadataInput' => 'AVFoundation.AVCaptureMetadataInput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28E922 /* #3416 'AVCaptureMetadataOutputObjectsDelegate' => 'AVFoundation.AVCaptureMetadataOutputObjectsDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27D822 /* #3417 'AVCaptureFileOutput' => 'AVFoundation.AVCaptureFileOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28EB22 /* #3418 'AVCaptureMovieFileOutput' => 'AVFoundation.AVCaptureMovieFileOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x290022 /* #3419 'AVCaptureSession' => 'AVFoundation.AVCaptureSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28EC22 /* #3420 'AVCaptureMultiCamSession' => 'AVFoundation.AVCaptureMultiCamSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28EF22 /* #3421 'AVCapturePhoto' => 'AVFoundation.AVCapturePhoto, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28FA22 /* #3422 'AVCapturePhotoSettings' => 'AVFoundation.AVCapturePhotoSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28F022 /* #3423 'AVCapturePhotoBracketSettings' => 'AVFoundation.AVCapturePhotoBracketSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28F422 /* #3424 'AVCapturePhotoCaptureDelegate' => 'AVFoundation.AVCapturePhotoCaptureDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28FF22 /* #3425 'AVCaptureResolvedPhotoSettings' => 'AVFoundation.AVCaptureResolvedPhotoSettings, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x290422 /* #3426 'AVCaptureSynchronizedMetadataObjectData' => 'AVFoundation.AVCaptureSynchronizedMetadataObjectData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x290522 /* #3427 'AVCaptureSynchronizedSampleBufferData' => 'AVFoundation.AVCaptureSynchronizedSampleBufferData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x290922 /* #3428 'AVCaptureSystemPressureState' => 'AVFoundation.AVCaptureSystemPressureState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x290C22 /* #3429 'AVCaptureVideoDataOutput' => 'AVFoundation.AVCaptureVideoDataOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x291022 /* #3430 'AVCaptureVideoDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E022 /* #3431 'AVAsset' => 'AVFoundation.AVAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x291822 /* #3432 'AVComposition' => 'AVFoundation.AVComposition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x291B22 /* #3433 'AVCompositionTrackFormatDescriptionReplacement' => 'AVFoundation.AVCompositionTrackFormatDescriptionReplacement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x291C22 /* #3434 'AVCompositionTrackSegment' => 'AVFoundation.AVCompositionTrackSegment, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x291F22 /* #3435 'AVContentKey' => 'AVFoundation.AVContentKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x292E22 /* #3436 'AVContentKeySessionDelegate' => 'AVFoundation.AVContentKeySessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293122 /* #3437 'AVContentKeySpecifier' => 'AVFoundation.AVContentKeySpecifier, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293422 /* #3438 'AVCoordinatedPlaybackParticipant' => 'AVFoundation.AVCoordinatedPlaybackParticipant, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293522 /* #3439 'AVCoordinatedPlaybackSuspension' => 'AVFoundation.AVCoordinatedPlaybackSuspension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296822 /* #3440 'AVMetadataGroup' => 'AVFoundation.AVMetadataGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293822 /* #3441 'AVDateRangeMetadataGroup' => 'AVFoundation.AVDateRangeMetadataGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299022 /* #3442 'AVPlaybackCoordinator' => 'AVFoundation.AVPlaybackCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293922 /* #3443 'AVDelegatingPlaybackCoordinator' => 'AVFoundation.AVDelegatingPlaybackCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293C22 /* #3444 'AVDelegatingPlaybackCoordinatorPlaybackControlCommand' => 'AVFoundation.AVDelegatingPlaybackCoordinatorPlaybackControlCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293A22 /* #3445 'AVDelegatingPlaybackCoordinatorBufferingCommand' => 'AVFoundation.AVDelegatingPlaybackCoordinatorBufferingCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293B22 /* #3446 'AVDelegatingPlaybackCoordinatorPauseCommand' => 'AVFoundation.AVDelegatingPlaybackCoordinatorPauseCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293D22 /* #3447 'AVDelegatingPlaybackCoordinatorPlayCommand' => 'AVFoundation.AVDelegatingPlaybackCoordinatorPlayCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x293F22 /* #3448 'AVDelegatingPlaybackCoordinatorSeekCommand' => 'AVFoundation.AVDelegatingPlaybackCoordinatorSeekCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29E622 /* #3449 'AVURLAsset' => 'AVFoundation.AVUrlAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x294A22 /* #3450 'AVFragmentedAsset' => 'AVFoundation.AVFragmentedAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x294C22 /* #3451 'AVFragmentedAssetMinder' => 'AVFoundation.AVFragmentedAssetMinder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x294D22 /* #3452 'AVFragmentedAssetTrack' => 'AVFoundation.AVFragmentedAssetTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x295022 /* #3453 'AVFragmentedMovieMinder' => 'AVFoundation.AVFragmentedMovieMinder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x295422 /* #3454 'AVFrameRateRange' => 'AVFoundation.AVFrameRateRange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x295922 /* #3455 'AVMediaDataStorage' => 'AVFoundation.AVMediaDataStorage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x295A22 /* #3456 'AVMediaSelection' => 'AVFoundation.AVMediaSelection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x295C22 /* #3457 'AVMediaSelectionOption' => 'AVFoundation.AVMediaSelectionOption, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296122 /* #3458 'AVMetadataBodyObject' => 'AVFoundation.AVMetadataBodyObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296222 /* #3459 'AVMetadataCatBodyObject' => 'AVFoundation.AVMetadataCatBodyObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296322 /* #3460 'AVMetadataDogBodyObject' => 'AVFoundation.AVMetadataDogBodyObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296522 /* #3461 'AVMetadataFaceObject' => 'AVFoundation.AVMetadataFaceObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296922 /* #3462 'AVMetadataHumanBodyObject' => 'AVFoundation.AVMetadataHumanBodyObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296B22 /* #3463 'AVMetadataItemFilter' => 'AVFoundation.AVMetadataItemFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296C22 /* #3464 'AVMetadataItemValueRequest' => 'AVFoundation.AVMetadataItemValueRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296F22 /* #3465 'AVMetadataSalientObject' => 'AVFoundation.AVMetadataSalientObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297122 /* #3466 'AVMovie' => 'AVFoundation.AVMovie, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297422 /* #3467 'AVMovieTrack' => 'AVFoundation.AVMovieTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297722 /* #3468 'AVMusicTrack' => 'AVFoundation.AVMusicTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297922 /* #3469 'AVMutableAudioMix' => 'AVFoundation.AVMutableAudioMix, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297A22 /* #3470 'AVMutableAudioMixInputParameters' => 'AVFoundation.AVMutableAudioMixInputParameters, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297B22 /* #3471 'AVMutableComposition' => 'AVFoundation.AVMutableComposition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297D22 /* #3472 'AVMutableDateRangeMetadataGroup' => 'AVFoundation.AVMutableDateRangeMetadataGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297E22 /* #3473 'AVMutableMediaSelection' => 'AVFoundation.AVMutableMediaSelection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x296A22 /* #3474 'AVMetadataItem' => 'AVFoundation.AVMetadataItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297F22 /* #3475 'AVMutableMetadataItem' => 'AVFoundation.AVMutableMetadataItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x298422 /* #3476 'AVMutableMovieTrack' => 'AVFoundation.AVMutableMovieTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29E522 /* #3477 'AVTimedMetadataGroup' => 'AVFoundation.AVTimedMetadataGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x298722 /* #3478 'AVMutableTimedMetadataGroup' => 'AVFoundation.AVMutableTimedMetadataGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29F522 /* #3479 'AVVideoCompositionLayerInstruction' => 'AVFoundation.AVVideoCompositionLayerInstruction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x298A22 /* #3480 'AVMutableVideoCompositionLayerInstruction' => 'AVFoundation.AVMutableVideoCompositionLayerInstruction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x292322 /* #3481 'AVContentKeyRequest' => 'AVFoundation.AVContentKeyRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x298D22 /* #3482 'AVPersistableContentKeyRequest' => 'AVFoundation.AVPersistableContentKeyRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299322 /* #3483 'Xamarin_iOS__AVFoundation_AVPlaybackCoordinatorPlaybackControlDelegate' => 'AVFoundation.AVPlaybackCoordinatorPlaybackControlDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299A22 /* #3484 'AVPlayerItemAccessLog' => 'AVFoundation.AVPlayerItemAccessLog, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299B22 /* #3485 'AVPlayerItemAccessLogEvent' => 'AVFoundation.AVPlayerItemAccessLogEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299C22 /* #3486 'AVPlayerItemErrorLog' => 'AVFoundation.AVPlayerItemErrorLog, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299D22 /* #3487 'AVPlayerItemErrorLogEvent' => 'AVFoundation.AVPlayerItemErrorLogEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29AD22 /* #3488 'AVPlayerItemOutput' => 'AVFoundation.AVPlayerItemOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x299E22 /* #3489 'AVPlayerItemLegibleOutput' => 'AVFoundation.AVPlayerItemLegibleOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29B522 /* #3490 'AVPlayerItemOutputPushDelegate' => 'AVFoundation.AVPlayerItemOutputPushDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29A222 /* #3491 'AVPlayerItemLegibleOutputPushDelegate' => 'AVFoundation.AVPlayerItemLegibleOutputPushDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29A322 /* #3492 'AVPlayerItemMediaDataCollector' => 'AVFoundation.AVPlayerItemMediaDataCollector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29A422 /* #3493 'AVPlayerItemMetadataCollector' => 'AVFoundation.AVPlayerItemMetadataCollector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29A722 /* #3494 'AVPlayerItemMetadataCollectorPushDelegate' => 'AVFoundation.AVPlayerItemMetadataCollectorPushDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29A822 /* #3495 'AVPlayerItemMetadataOutput' => 'AVFoundation.AVPlayerItemMetadataOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29AC22 /* #3496 'AVPlayerItemMetadataOutputPushDelegate' => 'AVFoundation.AVPlayerItemMetadataOutputPushDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29B122 /* #3497 'AVPlayerItemOutputPullDelegate' => 'AVFoundation.AVPlayerItemOutputPullDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29B722 /* #3498 'AVPlayerItemTrack' => 'AVFoundation.AVPlayerItemTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29BC22 /* #3499 'AVPlayerPlaybackCoordinator' => 'AVFoundation.AVPlayerPlaybackCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29C022 /* #3500 'Xamarin_iOS__AVFoundation_AVPlayerPlaybackCoordinatorDelegate' => 'AVFoundation.AVPlayerPlaybackCoordinatorDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29C722 /* #3501 'AVPortraitEffectsMatte' => 'AVFoundation.AVPortraitEffectsMatte, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27F322 /* #3502 'AVPlayer' => 'AVFoundation.AVPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29CC22 /* #3503 'AVQueuePlayer' => 'AVFoundation.AVQueuePlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29D422 /* #3504 'AVSemanticSegmentationMatte' => 'AVFoundation.AVSemanticSegmentationMatte, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29D822 /* #3505 'AVSpeechSynthesisVoice' => 'AVFoundation.AVSpeechSynthesisVoice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29E122 /* #3506 'AVSpeechSynthesizerDelegate' => 'AVFoundation.AVSpeechSynthesizerDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29E222 /* #3507 'AVSpeechUtterance' => 'AVFoundation.AVSpeechUtterance, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29E422 /* #3508 'AVSynchronizedLayer' => 'AVFoundation.AVSynchronizedLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29F122 /* #3509 'AVVideoCompositing' => 'AVFoundation.AVVideoCompositing, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29F322 /* #3510 'AVVideoCompositionCoreAnimationTool' => 'AVFoundation.AVVideoCompositionCoreAnimationTool, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29F622 /* #3511 'AVVideoCompositionRenderContext' => 'AVFoundation.AVVideoCompositionRenderContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29F722 /* #3512 'AVVideoCompositionRenderHint' => 'AVFoundation.AVVideoCompositionRenderHint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29FB22 /* #3513 'AVVideoCompositionValidationHandling' => 'AVFoundation.AVVideoCompositionValidationHandling, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A1622 /* #3514 'ARFaceGeometry' => 'ARKit.ARFaceGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A1722 /* #3515 'ARPlaneGeometry' => 'ARKit.ARPlaneGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A1822 /* #3516 'ARPointCloud' => 'ARKit.ARPointCloud, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A1922 /* #3517 'ARSkeleton' => 'ARKit.ARSkeleton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A1A22 /* #3518 'ARSkeleton2D' => 'ARKit.ARSkeleton2D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A1B22 /* #3519 'ARSkeleton3D' => 'ARKit.ARSkeleton3D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A1D22 /* #3520 'ARAnchor' => 'ARKit.ARAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A2022 /* #3521 'ARAppClipCodeAnchor' => 'ARKit.ARAppClipCodeAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A2422 /* #3522 'ARBody2D' => 'ARKit.ARBody2D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A2522 /* #3523 'ARBodyAnchor' => 'ARKit.ARBodyAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3122 /* #3524 'ARConfiguration' => 'ARKit.ARConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A2622 /* #3525 'ARBodyTrackingConfiguration' => 'ARKit.ARBodyTrackingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A2722 /* #3526 'ARCamera' => 'ARKit.ARCamera, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A2D22 /* #3527 'Xamarin_iOS__ARKit_ARCoachingOverlayViewDelegate' => 'ARKit.ARCoachingOverlayViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A2E22 /* #3528 'ARCollaborationData' => 'ARKit.ARCollaborationData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3222 /* #3529 'ARDepthData' => 'ARKit.ARDepthData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4922 /* #3530 'ARLightEstimate' => 'ARKit.ARLightEstimate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3322 /* #3531 'ARDirectionalLightEstimate' => 'ARKit.ARDirectionalLightEstimate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3422 /* #3532 'AREnvironmentProbeAnchor' => 'ARKit.AREnvironmentProbeAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3822 /* #3533 'ARFaceAnchor' => 'ARKit.ARFaceAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3922 /* #3534 'ARFaceTrackingConfiguration' => 'ARKit.ARFaceTrackingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3A22 /* #3535 'ARFrame' => 'ARKit.ARFrame, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3C22 /* #3536 'ARGeoAnchor' => 'ARKit.ARGeoAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3D22 /* #3537 'ARGeometryElement' => 'ARKit.ARGeometryElement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A3F22 /* #3538 'ARGeometrySource' => 'ARKit.ARGeometrySource, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4422 /* #3539 'ARGeoTrackingStatus' => 'ARKit.ARGeoTrackingStatus, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4522 /* #3540 'ARHitTestResult' => 'ARKit.ARHitTestResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4722 /* #3541 'ARImageAnchor' => 'ARKit.ARImageAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4822 /* #3542 'ARImageTrackingConfiguration' => 'ARKit.ARImageTrackingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4A22 /* #3543 'ARMatteGenerator' => 'ARKit.ARMatteGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4C22 /* #3544 'ARMeshAnchor' => 'ARKit.ARMeshAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4E22 /* #3545 'ARMeshGeometry' => 'ARKit.ARMeshGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4F22 /* #3546 'ARObjectAnchor' => 'ARKit.ARObjectAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5022 /* #3547 'ARObjectScanningConfiguration' => 'ARKit.ARObjectScanningConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5122 /* #3548 'AROrientationTrackingConfiguration' => 'ARKit.AROrientationTrackingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5222 /* #3549 'ARParticipantAnchor' => 'ARKit.ARParticipantAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5322 /* #3550 'ARPlaneAnchor' => 'ARKit.ARPlaneAnchor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5822 /* #3551 'ARPlaneExtent' => 'ARKit.ARPlaneExtent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5922 /* #3552 'ARPositionalTrackingConfiguration' => 'ARKit.ARPositionalTrackingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5A22 /* #3553 'ARQuickLookPreviewItem' => 'ARKit.ARQuickLookPreviewItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5B22 /* #3554 'ARRaycastQuery' => 'ARKit.ARRaycastQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5C22 /* #3555 'ARRaycastResult' => 'ARKit.ARRaycastResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A6022 /* #3556 'ARReferenceObject' => 'ARKit.ARReferenceObject, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A6322 /* #3557 'ARSCNFaceGeometry' => 'ARKit.ARSCNFaceGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A6422 /* #3558 'ARSCNPlaneGeometry' => 'ARKit.ARSCNPlaneGeometry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A6922 /* #3559 'ARSCNViewDelegate' => 'ARKit.ARSCNViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A7022 /* #3560 'ARSessionDelegate' => 'ARKit.ARSessionDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A7722 /* #3561 'ARSkeletonDefinition' => 'ARKit.ARSkeletonDefinition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A7E22 /* #3562 'ARSKViewDelegate' => 'ARKit.ARSKViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A8122 /* #3563 'ARTrackedRaycast' => 'ARKit.ARTrackedRaycast, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A8422 /* #3564 'ARVideoFormat' => 'ARKit.ARVideoFormat, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A8622 /* #3565 'ARWorldMap' => 'ARKit.ARWorldMap, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A8822 /* #3566 'ARWorldTrackingConfiguration' => 'ARKit.ARWorldTrackingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3E22 /* #3567 'SNAudioFileAnalyzer' => 'SoundAnalysis.SNAudioFileAnalyzer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E22 /* #3568 'SNTimeDurationConstraint' => 'SoundAnalysis.SNTimeDurationConstraint, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x329A22 /* #3569 'UIKit_UIView_UIViewAppearance' => 'UIKit.UIView+UIViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2AE722 /* #3570 'SharedWithYou_SWAttributionView_SWAttributionViewAppearance' => 'SharedWithYou.SWAttributionView+SWAttributionViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6322 /* #3571 'SWAttributionView' => 'SharedWithYou.SWAttributionView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2AE822 /* #3572 'SharedWithYou_SWCollaborationView_SWCollaborationViewAppearance' => 'SharedWithYou.SWCollaborationView+SWCollaborationViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6822 /* #3573 'SWCollaborationView' => 'SharedWithYou.SWCollaborationView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E22 /* #3574 'SWHighlightCenter' => 'SharedWithYou.SWHighlightCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8622 /* #3575 'SFContentBlockerManager' => 'SafariServices.SFContentBlockerManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E22 /* #3576 'SFSafariViewControllerDataStore' => 'SafariServices.SFSafariViewControllerDataStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D22 /* #3577 'QLThumbnailGenerator' => 'QuickLookThumbnailing.QLThumbnailGenerator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2AF222 /* #3578 'QuickLook_QLPreviewController__QLPreviewControllerDelegate' => 'QuickLook.QLPreviewController+_QLPreviewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xA322 /* #3579 'QLPreviewController' => 'QuickLook.QLPreviewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2AF822 /* #3580 'PhotosUI_PHLivePhotoView_PHLivePhotoViewAppearance' => 'PhotosUI.PHLivePhotoView+PHLivePhotoViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xE422 /* #3581 'PHLivePhotoView' => 'PhotosUI.PHLivePhotoView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F022 /* #3582 'UIKit_UIScrollView_UIScrollViewAppearance' => 'UIKit.UIScrollView+UIScrollViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2B0222 /* #3583 'PencilKit_PKCanvasView_PKCanvasViewAppearance' => 'PencilKit.PKCanvasView+PKCanvasViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x257B22 /* #3584 'UIScrollView' => 'UIKit.UIScrollView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14722 /* #3585 'PKCanvasView' => 'PencilKit.PKCanvasView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17D22 /* #3586 'NKIssue' => 'NewsstandKit.NKIssue, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18022 /* #3587 'MSConversation' => 'Messages.MSConversation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B0C22 /* #3588 'Messages_MSStickerBrowserView_MSStickerBrowserViewAppearance' => 'Messages.MSStickerBrowserView+MSStickerBrowserViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18E22 /* #3589 'MSStickerBrowserView' => 'Messages.MSStickerBrowserView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B0D22 /* #3590 'Messages_MSStickerView_MSStickerViewAppearance' => 'Messages.MSStickerView+MSStickerViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x19422 /* #3591 'MSStickerView' => 'Messages.MSStickerView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19D22 /* #3592 'LAContext' => 'LocalAuthentication.LAContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A122 /* #3593 'LAPrivateKey' => 'LocalAuthentication.LAPrivateKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A222 /* #3594 'LAPublicKey' => 'LocalAuthentication.LAPublicKey, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A522 /* #3595 'LARightStore' => 'LocalAuthentication.LARightStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A622 /* #3596 'LASecret' => 'LocalAuthentication.LASecret, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B1F22 /* #3597 'LinkPresentation_LPLinkView_LPLinkViewAppearance' => 'LinkPresentation.LPLinkView+LPLinkViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B422 /* #3598 'LPLinkView' => 'LinkPresentation.LPLinkView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B522 /* #3599 'LPMetadataProvider' => 'LinkPresentation.LPMetadataProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x325622 /* #3600 'UIKit_UIControl_UIControlAppearance' => 'UIKit.UIControl+UIControlAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x324E22 /* #3601 'UIKit_UIButton_UIButtonAppearance' => 'UIKit.UIButton+UIButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2B2222 /* #3602 'IntentsUI_INUIAddVoiceShortcutButton_INUIAddVoiceShortcutButtonAppearance' => 'IntentsUI.INUIAddVoiceShortcutButton+INUIAddVoiceShortcutButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x214022 /* #3603 'UIControl' => 'UIKit.UIControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x213022 /* #3604 'UIButton' => 'UIKit.UIButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B622 /* #3605 'INUIAddVoiceShortcutButton' => 'IntentsUI.INUIAddVoiceShortcutButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DB22 /* #3606 'ILMessageFilterCapabilitiesQueryResponse' => 'IdentityLookup.ILMessageFilterCapabilitiesQueryResponse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF22 /* #3607 'ILMessageFilterExtensionContext' => 'IdentityLookup.ILMessageFilterExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B2522 /* #3608 'HealthKitUI_HKActivityRingView_HKActivityRingViewAppearance' => 'HealthKitUI.HKActivityRingView+HKActivityRingViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1E622 /* #3609 'HKActivityRingView' => 'HealthKitUI.HKActivityRingView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B2622 /* #3610 'ExternalAccessory_EAAccessory__EAAccessoryDelegate' => 'ExternalAccessory.EAAccessory+_EAAccessoryDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1EB22 /* #3611 'EAAccessory' => 'ExternalAccessory.EAAccessory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F022 /* #3612 'EAAccessoryManager' => 'ExternalAccessory.EAAccessoryManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B2922 /* #3613 'ExternalAccessory_EAWiFiUnconfiguredAccessoryBrowser__EAWiFiUnconfiguredAccessoryBrowserDelegate' => 'ExternalAccessory.EAWiFiUnconfiguredAccessoryBrowser+_EAWiFiUnconfiguredAccessoryBrowserDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1F522 /* #3614 'EAWiFiUnconfiguredAccessoryBrowser' => 'ExternalAccessory.EAWiFiUnconfiguredAccessoryBrowser, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20022 /* #3615 'DCAppAttestService' => 'DeviceCheck.DCAppAttestService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20122 /* #3616 'DCDevice' => 'DeviceCheck.DCDevice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B3022 /* #3617 'CoreLocationUI_CLLocationButton_CLLocationButtonAppearance' => 'CoreLocationUI.CLLocationButton+CLLocationButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x24E22 /* #3618 'CLLocationButton' => 'CoreLocationUI.CLLocationButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25A22 /* #3619 'CHHapticEngine' => 'CoreHaptics.CHHapticEngine, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B3422 /* #3620 'CoreAudioKit_CAInterAppAudioSwitcherView_CAInterAppAudioSwitcherViewAppearance' => 'CoreAudioKit.CAInterAppAudioSwitcherView+CAInterAppAudioSwitcherViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x27322 /* #3621 'CAInterAppAudioSwitcherView' => 'CoreAudioKit.CAInterAppAudioSwitcherView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B3522 /* #3622 'CoreAudioKit_CAInterAppAudioTransportView_CAInterAppAudioTransportViewAppearance' => 'CoreAudioKit.CAInterAppAudioTransportView+CAInterAppAudioTransportViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x27422 /* #3623 'CAInterAppAudioTransportView' => 'CoreAudioKit.CAInterAppAudioTransportView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28522 /* #3624 'BGTaskScheduler' => 'BackgroundTasks.BGTaskScheduler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29322 /* #3625 'ATTrackingManager' => 'AppTrackingTransparency.ATTrackingManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29522 /* #3626 'APActivationPayload' => 'AppClip.APActivationPayload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B3922 /* #3627 'iAd_ADBannerView_ADBannerViewAppearance' => 'iAd.ADBannerView+ADBannerViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x29C22 /* #3628 'iAd_ADBannerView' => 'iAd.ADBannerView, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x2A122 /* #3629 'ADClient' => 'iAd.ADClient, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D322 /* #3630 'VNFaceLandmarkRegion2D' => 'Vision.VNFaceLandmarkRegion2D, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D522 /* #3631 'VNRecognizedPointsObservation' => 'Vision.VNRecognizedPointsObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2FA22 /* #3632 'VNDetectHumanBodyPoseRequest' => 'Vision.VNDetectHumanBodyPoseRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2FC22 /* #3633 'VNDetectHumanHandPoseRequest' => 'Vision.VNDetectHumanHandPoseRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x31F22 /* #3634 'VNHumanBodyPoseObservation' => 'Vision.VNHumanBodyPoseObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32422 /* #3635 'VNHumanHandPoseObservation' => 'Vision.VNHumanHandPoseObservation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x33722 /* #3636 'VNRecognizeAnimalsRequest' => 'Vision.VNRecognizeAnimalsRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x39B22 /* #3637 'VSAccountManager' => 'VideoSubscriberAccount.VSAccountManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3B322 /* #3638 'VSUserAccountManager' => 'VideoSubscriberAccount.VSUserAccountManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3DA22 /* #3639 'UNUserNotificationCenter' => 'UserNotifications.UNUserNotificationCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3E322 /* #3640 'TWRequest' => 'Twitter.TWRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F722 /* #3641 'SKAdNetwork' => 'StoreKit.SKAdNetwork, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3FF22 /* #3642 'SKCloudServiceController' => 'StoreKit.SKCloudServiceController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40522 /* #3643 'SKCloudServiceSetupViewController' => 'StoreKit.SKCloudServiceSetupViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B6F22 /* #3644 'StoreKit_SKRequest__SKRequestDelegate' => 'StoreKit.SKRequest+_SKRequestDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2B6A22 /* #3645 'StoreKit_SKProductsRequest__SKProductsRequestDelegate' => 'StoreKit.SKProductsRequest+_SKProductsRequestDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x42622 /* #3646 'SKProductsRequest' => 'StoreKit.SKProductsRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42C22 /* #3647 'SKProductStorePromotionController' => 'StoreKit.SKProductStorePromotionController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B7022 /* #3648 'StoreKit_SKStoreProductViewController__SKStoreProductViewControllerDelegate' => 'StoreKit.SKStoreProductViewController+_SKStoreProductViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x43722 /* #3649 'SKStoreProductViewController' => 'StoreKit.SKStoreProductViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B7722 /* #3650 'SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsWorld+_SKPhysicsContactDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x46922 /* #3651 'SKPhysicsWorld' => 'SpriteKit.SKPhysicsWorld, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47922 /* #3652 'SKTextureAtlas' => 'SpriteKit.SKTextureAtlas, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B7D22 /* #3653 'SpriteKit_SKView_SKViewAppearance' => 'SpriteKit.SKView+SKViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x48822 /* #3654 'SKView' => 'SpriteKit.SKView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49A22 /* #3655 'SLRequest' => 'Social.SLRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C222 /* #3656 'SWCollaborationMetadata' => 'SharedWithYouCore.SWCollaborationMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4ED22 /* #3657 'SRSensorReader' => 'SensorKit.SRSensorReader, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55022 /* #3658 'SCNAction' => 'SceneKit.SCNAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55322 /* #3659 'SCNAnimationEvent' => 'SceneKit.SCNAnimationEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B9422 /* #3660 'SceneKit_SCNView_SCNViewAppearance' => 'SceneKit.SCNView+SCNViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x55622 /* #3661 'SCNView' => 'SceneKit.SCNView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B9B22 /* #3662 'SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsWorld+_SCNPhysicsContactDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5E122 /* #3663 'SCNPhysicsWorld' => 'SceneKit.SCNPhysicsWorld, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5ED22 /* #3664 'SCNRenderer' => 'SceneKit.SCNRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62722 /* #3665 'RPBroadcastActivityViewController' => 'ReplayKit.RPBroadcastActivityViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62B22 /* #3666 'RPBroadcastController' => 'ReplayKit.RPBroadcastController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63C22 /* #3667 'RPScreenRecorder' => 'ReplayKit.RPScreenRecorder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BAC22 /* #3668 'ReplayKit_RPSystemBroadcastPickerView_RPSystemBroadcastPickerViewAppearance' => 'ReplayKit.RPSystemBroadcastPickerView+RPSystemBroadcastPickerViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x64122 /* #3669 'RPSystemBroadcastPickerView' => 'ReplayKit.RPSystemBroadcastPickerView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64822 /* #3670 'PHLivePhotoEditingContext' => 'Photos.PHLivePhotoEditingContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64922 /* #3671 'PHFetchResult' => 'Photos.PHFetchResult, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BB522 /* #3672 'Photos_PHPhotoLibrary___phlib_observer' => 'Photos.PHPhotoLibrary+__phlib_observer, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x64B22 /* #3673 'PHPhotoLibrary' => 'Photos.PHPhotoLibrary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65B22 /* #3674 'PHAssetResourceManager' => 'Photos.PHAssetResourceManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69F22 /* #3675 'PDFAnnotation' => 'PdfKit.PdfAnnotation, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BBA22 /* #3676 'PdfKit_PdfView__PdfViewDelegate' => 'PdfKit.PdfView+_PdfViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2BBB22 /* #3677 'PdfKit_PdfView_PdfViewAppearance' => 'PdfKit.PdfView+PdfViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6A122 /* #3678 'PDFView' => 'PdfKit.PdfView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BBD22 /* #3679 'PdfKit_PdfDocument__PdfDocumentDelegate' => 'PdfKit.PdfDocument+_PdfDocumentDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6C022 /* #3680 'PDFDocument' => 'PdfKit.PdfDocument, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BC022 /* #3681 'PdfKit_PdfThumbnailView_PdfThumbnailViewAppearance' => 'PdfKit.PdfThumbnailView+PdfThumbnailViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6D822 /* #3682 'PDFThumbnailView' => 'PdfKit.PdfThumbnailView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BC222 /* #3683 'PassKit_PKPaymentAuthorizationViewController__PKPaymentAuthorizationViewControllerDelegate' => 'PassKit.PKPaymentAuthorizationViewController+_PKPaymentAuthorizationViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6E222 /* #3684 'PKPaymentAuthorizationViewController' => 'PassKit.PKPaymentAuthorizationViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E522 /* #3685 'PKShareablePassMetadata' => 'PassKit.PKShareablePassMetadata, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BC422 /* #3686 'PassKit_PKAddPassButton_PKAddPassButtonAppearance' => 'PassKit.PKAddPassButton+PKAddPassButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6E722 /* #3687 'PKAddPassButton' => 'PassKit.PKAddPassButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BC522 /* #3688 'PassKit_PKAddPassesViewController__PKAddPassesViewControllerDelegate' => 'PassKit.PKAddPassesViewController+_PKAddPassesViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6E922 /* #3689 'PKAddPassesViewController' => 'PassKit.PKAddPassesViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FE22 /* #3690 'PKAddShareablePassConfiguration' => 'PassKit.PKAddShareablePassConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70D22 /* #3691 'PKDisbursementAuthorizationController' => 'PassKit.PKDisbursementAuthorizationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71622 /* #3692 'PKIdentityAuthorizationController' => 'PassKit.PKIdentityAuthorizationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BCB22 /* #3693 'PassKit_PKIdentityButton_PKIdentityButtonAppearance' => 'PassKit.PKIdentityButton+PKIdentityButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x71722 /* #3694 'PKIdentityButton' => 'PassKit.PKIdentityButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72622 /* #3695 'PKIssuerProvisioningExtensionHandler' => 'PassKit.PKIssuerProvisioningExtensionHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73022 /* #3696 'PKPassLibrary' => 'PassKit.PKPassLibrary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73722 /* #3697 'PKPaymentAuthorizationController' => 'PassKit.PKPaymentAuthorizationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BDA22 /* #3698 'PassKit_PKPaymentButton_PKPaymentButtonAppearance' => 'PassKit.PKPaymentButton+PKPaymentButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x74D22 /* #3699 'PKPaymentButton' => 'PassKit.PKPaymentButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78222 /* #3700 'PKVehicleConnectionSession' => 'PassKit.PKVehicleConnectionSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78B22 /* #3701 'EAGLContext' => 'OpenGLES.EAGLContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F422 /* #3702 'NETunnelProvider' => 'NetworkExtension.NETunnelProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79622 /* #3703 'NEPacketTunnelProvider' => 'NetworkExtension.NEPacketTunnelProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7A122 /* #3704 'NEAppProxyFlow' => 'NetworkExtension.NEAppProxyFlow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7A422 /* #3705 'NEAppProxyProvider' => 'NetworkExtension.NEAppProxyProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80922 /* #3706 'NEVPNManager' => 'NetworkExtension.NEVpnManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F722 /* #3707 'NETunnelProviderManager' => 'NetworkExtension.NETunnelProviderManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7A522 /* #3708 'NEAppProxyProviderManager' => 'NetworkExtension.NEAppProxyProviderManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7A622 /* #3709 'NEAppProxyTCPFlow' => 'NetworkExtension.NEAppProxyTcpFlow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7A722 /* #3710 'NEAppProxyUDPFlow' => 'NetworkExtension.NEAppProxyUdpFlow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7AC22 /* #3711 'NEAppPushManager' => 'NetworkExtension.NEAppPushManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7AF22 /* #3712 'NEAppPushProvider' => 'NetworkExtension.NEAppPushProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B422 /* #3713 'NEDNSProxyManager' => 'NetworkExtension.NEDnsProxyManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B722 /* #3714 'NEDNSProxyProvider' => 'NetworkExtension.NEDnsProxyProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7BA22 /* #3715 'NEDNSSettingsManager' => 'NetworkExtension.NEDnsSettingsManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C122 /* #3716 'NEFilterControlProvider' => 'NetworkExtension.NEFilterControlProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C522 /* #3717 'NEFilterManager' => 'NetworkExtension.NEFilterManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7D422 /* #3718 'NEHotspotConfigurationManager' => 'NetworkExtension.NEHotspotConfigurationManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7DE22 /* #3719 'NEHotspotNetwork' => 'NetworkExtension.NEHotspotNetwork, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7EC22 /* #3720 'NEPacketTunnelFlow' => 'NetworkExtension.NEPacketTunnelFlow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81222 /* #3721 'NWTCPConnection' => 'NetworkExtension.NWTcpConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81822 /* #3722 'NWUDPSession' => 'NetworkExtension.NWUdpSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88922 /* #3723 'NLEmbedding' => 'NaturalLanguage.NLEmbedding, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88B22 /* #3724 'NLLanguageRecognizer' => 'NaturalLanguage.NLLanguageRecognizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88E22 /* #3725 'NLTagger' => 'NaturalLanguage.NLTagger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C6422 /* #3726 'System_Net_Http_NSUrlSessionHandler_WrappedNSInputStream' => 'System.Net.Http.NSUrlSessionHandler+WrappedNSInputStream, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8AD22 /* #3727 'MCSession' => 'MultipeerConnectivity.MCSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D922 /* #3728 'MDLMesh' => 'ModelIO.MDLMesh, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96B22 /* #3729 'MPSGraphTensorData' => 'MetalPerformanceShadersGraph.MPSGraphTensorData, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98B22 /* #3730 'MPSGraphDepthwiseConvolution3DOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphDepthwiseConvolution3DOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99722 /* #3731 'MPSGraphPooling4DOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphPooling4DOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99E22 /* #3732 'MPSGraphShapedType' => 'MetalPerformanceShadersGraph.MPSGraphShapedType, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A022 /* #3733 'MPSGraphStencilOpDescriptor' => 'MetalPerformanceShadersGraph.MPSGraphStencilOpDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A122 /* #3734 'MPSGraphTensor' => 'MetalPerformanceShadersGraph.MPSGraphTensor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A422 /* #3735 'MPSGraphVariableOp' => 'MetalPerformanceShadersGraph.MPSGraphVariableOp, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E022 /* #3736 'MPSNNGraph' => 'MetalPerformanceShaders.MPSNNGraph, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE822 /* #3737 'MPSNDArrayDescriptor' => 'MetalPerformanceShaders.MPSNDArrayDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6B22 /* #3738 'MTKTextureLoader' => 'MetalKit.MTKTextureLoader, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C9422 /* #3739 'MetalKit_MTKView_MTKViewAppearance' => 'MetalKit.MTKView+MTKViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xB7222 /* #3740 'MTKView' => 'MetalKit.MTKView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C9922 /* #3741 'MessageUI_MFMailComposeViewController_MFMailComposeViewControllerAppearance' => 'MessageUI.MFMailComposeViewController+MFMailComposeViewControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCBD22 /* #3742 'MFMailComposeViewController' => 'MessageUI.MFMailComposeViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C9A22 /* #3743 'MessageUI_MFMessageComposeViewController_MFMessageComposeViewControllerAppearance' => 'MessageUI.MFMessageComposeViewController+MFMessageComposeViewControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCC022 /* #3744 'MFMessageComposeViewController' => 'MessageUI.MFMessageComposeViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCDA22 /* #3745 'MPMoviePlayerController' => 'MediaPlayer.MPMoviePlayerController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCE122 /* #3746 'MPSkipIntervalCommand' => 'MediaPlayer.MPSkipIntervalCommand, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCF922 /* #3747 'MPMediaLibrary' => 'MediaPlayer.MPMediaLibrary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CA722 /* #3748 'MediaPlayer_MPMediaPickerController__MPMediaPickerControllerDelegate' => 'MediaPlayer.MPMediaPickerController+_MPMediaPickerControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCFB22 /* #3749 'MPMediaPickerController' => 'MediaPlayer.MPMediaPickerController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD0322 /* #3750 'MPMediaPlaylist' => 'MediaPlayer.MPMediaPlaylist, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD1D22 /* #3751 'MPMusicPlayerController' => 'MediaPlayer.MPMusicPlayerController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD1C22 /* #3752 'MPMusicPlayerApplicationController' => 'MediaPlayer.MPMusicPlayerApplicationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD2C22 /* #3753 'MPNowPlayingSession' => 'MediaPlayer.MPNowPlayingSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CB022 /* #3754 'MediaPlayer_MPVolumeView_MPVolumeViewAppearance' => 'MediaPlayer.MPVolumeView+MPVolumeViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD4522 /* #3755 'MPVolumeView' => 'MediaPlayer.MPVolumeView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x324C22 /* #3756 'UIKit_UIBarItem_UIBarItemAppearance' => 'UIKit.UIBarItem+UIBarItemAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x324B22 /* #3757 'UIKit_UIBarButtonItem_UIBarButtonItemAppearance' => 'UIKit.UIBarButtonItem+UIBarButtonItemAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2CB322 /* #3758 'MapKit_MKUserTrackingBarButtonItem_MKUserTrackingBarButtonItemAppearance' => 'MapKit.MKUserTrackingBarButtonItem+MKUserTrackingBarButtonItemAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x212E22 /* #3759 'UIBarItem' => 'UIKit.UIBarItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x212D22 /* #3760 'UIBarButtonItem' => 'UIKit.UIBarButtonItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5522 /* #3761 'MKUserTrackingBarButtonItem' => 'MapKit.MKUserTrackingBarButtonItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5622 /* #3762 'MKDirections' => 'MapKit.MKDirections, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5922 /* #3763 'MKLocalSearch' => 'MapKit.MKLocalSearch, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5E22 /* #3764 'MKMapItem' => 'MapKit.MKMapItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CBE22 /* #3765 'MapKit_MKOverlayView_MKOverlayViewAppearance' => 'MapKit.MKOverlayView+MKOverlayViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD6022 /* #3766 'MKOverlayView' => 'MapKit.MKOverlayView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD6222 /* #3767 'MKPointOfInterestFilter' => 'MapKit.MKPointOfInterestFilter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CC022 /* #3768 'MapKit_MKAnnotationView_MKAnnotationViewAppearance' => 'MapKit.MKAnnotationView+MKAnnotationViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD7022 /* #3769 'MKAnnotationView' => 'MapKit.MKAnnotationView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CCC22 /* #3770 'MapKit_MKOverlayPathView_MKOverlayPathViewAppearance' => 'MapKit.MKOverlayPathView+MKOverlayPathViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2CC122 /* #3771 'MapKit_MKCircleView_MKCircleViewAppearance' => 'MapKit.MKCircleView+MKCircleViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDC922 /* #3772 'MKOverlayPathView' => 'MapKit.MKOverlayPathView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD7522 /* #3773 'MKCircleView' => 'MapKit.MKCircleView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CC222 /* #3774 'MapKit_MKCompassButton_MKCompassButtonAppearance' => 'MapKit.MKCompassButton+MKCompassButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD7722 /* #3775 'MKCompassButton' => 'MapKit.MKCompassButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD8722 /* #3776 'MKGradientPolylineRenderer' => 'MapKit.MKGradientPolylineRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9822 /* #3777 'MKLookAroundSceneRequest' => 'MapKit.MKLookAroundSceneRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD9B22 /* #3778 'MKLookAroundSnapshotter' => 'MapKit.MKLookAroundSnapshotter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDA822 /* #3779 'MKMapItemRequest' => 'MapKit.MKMapItemRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDAB22 /* #3780 'MKMapSnapshotter' => 'MapKit.MKMapSnapshotter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CC922 /* #3781 'MapKit_MKMapView__MKMapViewDelegate' => 'MapKit.MKMapView+_MKMapViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2CCA22 /* #3782 'MapKit_MKMapView_MKMapViewAppearance' => 'MapKit.MKMapView+MKMapViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDAD22 /* #3783 'MKMapView' => 'MapKit.MKMapView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CCB22 /* #3784 'MapKit_MKMarkerAnnotationView_MKMarkerAnnotationViewAppearance' => 'MapKit.MKMarkerAnnotationView+MKMarkerAnnotationViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDBE22 /* #3785 'MKMarkerAnnotationView' => 'MapKit.MKMarkerAnnotationView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CCD22 /* #3786 'MapKit_MKPinAnnotationView_MKPinAnnotationViewAppearance' => 'MapKit.MKPinAnnotationView+MKPinAnnotationViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDCC22 /* #3787 'MKPinAnnotationView' => 'MapKit.MKPinAnnotationView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CCE22 /* #3788 'MapKit_MKPolygonView_MKPolygonViewAppearance' => 'MapKit.MKPolygonView+MKPolygonViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDD322 /* #3789 'MKPolygonView' => 'MapKit.MKPolygonView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CCF22 /* #3790 'MapKit_MKPolylineView_MKPolylineViewAppearance' => 'MapKit.MKPolylineView+MKPolylineViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDD522 /* #3791 'MKPolylineView' => 'MapKit.MKPolylineView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CD022 /* #3792 'MapKit_MKScaleView_MKScaleViewAppearance' => 'MapKit.MKScaleView+MKScaleViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDDC22 /* #3793 'MKScaleView' => 'MapKit.MKScaleView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CD122 /* #3794 'MapKit_MKUserLocationView_MKUserLocationViewAppearance' => 'MapKit.MKUserLocationView+MKUserLocationViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDE522 /* #3795 'MKUserLocationView' => 'MapKit.MKUserLocationView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2CD222 /* #3796 'MapKit_MKUserTrackingButton_MKUserTrackingButtonAppearance' => 'MapKit.MKUserTrackingButton+MKUserTrackingButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDE622 /* #3797 'MKUserTrackingButton' => 'MapKit.MKUserTrackingButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6822 /* #3798 'INInteraction' => 'Intents.INInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xED822 /* #3799 'INCar' => 'Intents.INCar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1822 /* #3800 'INFocusStatusCenter' => 'Intents.INFocusStatusCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF5422 /* #3801 'INImage' => 'Intents.INImage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC822 /* #3802 'INPreferences' => 'Intents.INPreferences, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD322 /* #3803 'INRelevantShortcutStore' => 'Intents.INRelevantShortcutStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10EC22 /* #3804 'INVoiceShortcutCenter' => 'Intents.INVoiceShortcutCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x111F22 /* #3805 'HMActionSet' => 'HomeKit.HMActionSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x112022 /* #3806 'HMCharacteristic' => 'HomeKit.HMCharacteristic, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x112922 /* #3807 'HMAccessorySetupManager' => 'HomeKit.HMAccessorySetupManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D522 /* #3808 'HMTrigger' => 'HomeKit.HMTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x112F22 /* #3809 'HMEventTrigger' => 'HomeKit.HMEventTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D1722 /* #3810 'HomeKit_HMHome__HMHomeDelegate' => 'HomeKit.HMHome+_HMHomeDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x113022 /* #3811 'HMHome' => 'HomeKit.HMHome, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113122 /* #3812 'HMService' => 'HomeKit.HMService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D2E22 /* #3813 'HomeKit_HMAccessory__HMAccessoryDelegate' => 'HomeKit.HMAccessory+_HMAccessoryDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x113322 /* #3814 'HMAccessory' => 'HomeKit.HMAccessory, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D3122 /* #3815 'HomeKit_HMAccessoryBrowser__HMAccessoryBrowserDelegate' => 'HomeKit.HMAccessoryBrowser+_HMAccessoryBrowserDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x113822 /* #3816 'HMAccessoryBrowser' => 'HomeKit.HMAccessoryBrowser, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115B22 /* #3817 'HMCameraStream' => 'HomeKit.HMCameraStream, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D3322 /* #3818 'HomeKit_HMCameraView_HMCameraViewAppearance' => 'HomeKit.HMCameraView+HMCameraViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x116222 /* #3819 'HMCameraView' => 'HomeKit.HMCameraView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119A22 /* #3820 'HMCharacteristicWriteAction' => 'HomeKit.HMCharacteristicWriteAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D3722 /* #3821 'HomeKit_HMHomeManager__HMHomeManagerDelegate' => 'HomeKit.HMHomeManager+_HMHomeManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x11B222 /* #3822 'HMHomeManager' => 'HomeKit.HMHomeManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11CC22 /* #3823 'HMRoom' => 'HomeKit.HMRoom, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11CD22 /* #3824 'HMServiceGroup' => 'HomeKit.HMServiceGroup, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D422 /* #3825 'HMTimerTrigger' => 'HomeKit.HMTimerTrigger, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D722 /* #3826 'HMZone' => 'HomeKit.HMZone, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F022 /* #3827 'HKAttachmentStore' => 'HealthKit.HKAttachmentStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124022 /* #3828 'HKHealthStore' => 'HealthKit.HKHealthStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124122 /* #3829 'HKHeartbeatSeriesBuilder' => 'HealthKit.HKHeartbeatSeriesBuilder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125422 /* #3830 'HKQuantitySeriesSampleBuilder' => 'HealthKit.HKQuantitySeriesSampleBuilder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126F22 /* #3831 'HKVerifiableClinicalRecordQuery' => 'HealthKit.HKVerifiableClinicalRecordQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127E22 /* #3832 'HKWorkoutBuilder' => 'HealthKit.HKWorkoutBuilder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128322 /* #3833 'HKWorkoutRouteBuilder' => 'HealthKit.HKWorkoutRouteBuilder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FD22 /* #3834 'GKMatchmaker' => 'GameKit.GKMatchmaker, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FE22 /* #3835 'GKGameSession' => 'GameKit.GKGameSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130422 /* #3836 'GKScore' => 'GameKit.GKScore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D8D22 /* #3837 'MonoTouch_GKSession_ReceivedObject' => 'GameKit.GKSession+ReceiverObject, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130622 /* #3838 'GKSession' => 'GameKit.GKSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130B22 /* #3839 'GKTurnBasedExchange' => 'GameKit.GKTurnBasedExchange, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D9122 /* #3840 'GameKit_GKMatch__GKMatchDelegate' => 'GameKit.GKMatch+_GKMatchDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130E22 /* #3841 'GKMatch' => 'GameKit.GKMatch, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131122 /* #3842 'GKAchievement' => 'GameKit.GKAchievement, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131422 /* #3843 'GKAchievementDescription' => 'GameKit.GKAchievementDescription, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DA522 /* #3844 'GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterViewController+_GKGameCenterControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2DA022 /* #3845 'GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewController+_GKAchievementViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2DA122 /* #3846 'GameKit_GKAchievementViewController_GKAchievementViewControllerAppearance' => 'GameKit.GKAchievementViewController+GKAchievementViewControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x133122 /* #3847 'GKGameCenterViewController' => 'GameKit.GKGameCenterViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131522 /* #3848 'GKAchievementViewController' => 'GameKit.GKAchievementViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DA222 /* #3849 'GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandler+_GKChallengeEventHandlerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x131B22 /* #3850 'GKChallengeEventHandler' => 'GameKit.GKChallengeEventHandler, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DA322 /* #3851 'GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewController+_GKFriendRequestComposeViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2DA422 /* #3852 'GameKit_GKFriendRequestComposeViewController_GKFriendRequestComposeViewControllerAppearance' => 'GameKit.GKFriendRequestComposeViewController+GKFriendRequestComposeViewControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x132922 /* #3853 'GKFriendRequestComposeViewController' => 'GameKit.GKFriendRequestComposeViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133F22 /* #3854 'GKLeaderboard' => 'GameKit.GKLeaderboard, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x134322 /* #3855 'GKLeaderboardEntry' => 'GameKit.GKLeaderboardEntry, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x134622 /* #3856 'GKLeaderboardSet' => 'GameKit.GKLeaderboardSet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DB722 /* #3857 'GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewController+_GKLeaderboardViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2DB822 /* #3858 'GameKit_GKLeaderboardViewController_GKLeaderboardViewControllerAppearance' => 'GameKit.GKLeaderboardViewController+GKLeaderboardViewControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x134922 /* #3859 'GKLeaderboardViewController' => 'GameKit.GKLeaderboardViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x136D22 /* #3860 'GKPlayer' => 'GameKit.GKPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x134D22 /* #3861 'GKLocalPlayer' => 'GameKit.GKLocalPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DC822 /* #3862 'GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewController+_GKMatchmakerViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x135C22 /* #3863 'GKMatchmakerViewController' => 'GameKit.GKMatchmakerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x136922 /* #3864 'GKNotificationBanner' => 'GameKit.GKNotificationBanner, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x136F22 /* #3865 'GKSavedGame' => 'GameKit.GKSavedGame, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x138622 /* #3866 'GKTurnBasedMatch' => 'GameKit.GKTurnBasedMatch, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DE322 /* #3867 'GameKit_GKTurnBasedMatchmakerViewController_GKTurnBasedMatchmakerViewControllerAppearance' => 'GameKit.GKTurnBasedMatchmakerViewController+GKTurnBasedMatchmakerViewControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x138722 /* #3868 'GKTurnBasedMatchmakerViewController' => 'GameKit.GKTurnBasedMatchmakerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13B022 /* #3869 'GCController' => 'GameController.GCController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13EE22 /* #3870 'GCKeyboard' => 'GameController.GCKeyboard, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13F622 /* #3871 'GCMouse' => 'GameController.GCMouse, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x140822 /* #3872 'GCVirtualController' => 'GameController.GCVirtualController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x142722 /* #3873 'GLKTextureLoader' => 'GLKit.GLKTextureLoader, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DF222 /* #3874 'GLKit_GLKView__GLKViewDelegate' => 'GLKit.GLKView+_GLKViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2DF322 /* #3875 'GLKit_GLKView_GLKViewAppearance' => 'GLKit.GLKView+GLKViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x143A22 /* #3876 'GLKView' => 'GLKit.GLKView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DF422 /* #3877 'WebKit_WKWebView_WKWebViewAppearance' => 'WebKit.WKWebView+WKWebViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x144622 /* #3878 'WKWebsiteDataStore' => 'WebKit.WKWebsiteDataStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x144F22 /* #3879 'WKContentRuleListStore' => 'WebKit.WKContentRuleListStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x145422 /* #3880 'WKDownload' => 'WebKit.WKDownload, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x146022 /* #3881 'WKHTTPCookieStore' => 'WebKit.WKHttpCookieStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x149022 /* #3882 'NSIndexPath' => 'Foundation.NSIndexPath, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E1722 /* #3883 'Foundation_NSNetService__NSNetServiceDelegate' => 'Foundation.NSNetService+_NSNetServiceDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x149322 /* #3884 'NSNetService' => 'Foundation.NSNetService, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x149422 /* #3885 'NSUserActivity' => 'Foundation.NSUserActivity, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14AE22 /* #3886 'NSBundleResourceRequest' => 'Foundation.NSBundleResourceRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B022 /* #3887 'NSCalendar' => 'Foundation.NSCalendar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B622 /* #3888 'NSDictionary' => 'Foundation.NSDictionary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14C722 /* #3889 'NSFileManager' => 'Foundation.NSFileManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CD22 /* #3890 'NSItemProvider' => 'Foundation.NSItemProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E4022 /* #3891 'Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiver+_NSKeyedArchiverDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14CE22 /* #3892 'NSKeyedArchiver' => 'Foundation.NSKeyedArchiver, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E4122 /* #3893 'Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiver+_NSKeyedUnarchiverDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14D022 /* #3894 'NSLocale' => 'Foundation.NSLocale, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D522 /* #3895 'NSMutableDictionary' => 'Foundation.NSMutableDictionary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14DE22 /* #3896 'NSNotificationCenter' => 'Foundation.NSNotificationCenter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E4C22 /* #3897 '__NSObject_Disposer' => 'Foundation.NSObject+NSObject_Disposer, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2E4D22 /* #3898 '__XamarinObjectObserver' => 'Foundation.NSObject+Observer, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14EB22 /* #3899 'NSProgress' => 'Foundation.NSProgress, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E5322 /* #3900 'Foundation_NSStream__NSStreamDelegate' => 'Foundation.NSStream+_NSStreamDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14FC22 /* #3901 'NSUbiquitousKeyValueStore' => 'Foundation.NSUbiquitousKeyValueStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14FD22 /* #3902 'NSUndoManager' => 'Foundation.NSUndoManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151322 /* #3903 'NSURL' => 'Foundation.NSUrl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151622 /* #3904 'NSURLConnection' => 'Foundation.NSUrlConnection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151B22 /* #3905 'NSURLSessionConfiguration' => 'Foundation.NSUrlSessionConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151D22 /* #3906 'NSUserDefaults' => 'Foundation.NSUserDefaults, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E5E22 /* #3907 'Foundation_NSCache__NSCacheDelegate' => 'Foundation.NSCache+_NSCacheDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x153B22 /* #3908 'NSCache' => 'Foundation.NSCache, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157D22 /* #3909 'NSFileHandle' => 'Foundation.NSFileHandle, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158722 /* #3910 'NSFileVersion' => 'Foundation.NSFileVersion, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159322 /* #3911 'NSHTTPCookieStorage' => 'Foundation.NSHttpCookieStorage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E6922 /* #3912 'Foundation_NSMetadataQuery__NSMetadataQueryDelegate' => 'Foundation.NSMetadataQuery+_NSMetadataQueryDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x15D722 /* #3913 'NSMetadataQuery' => 'Foundation.NSMetadataQuery, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E6B22 /* #3914 'Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowser+_NSNetServiceBrowserDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x15EA22 /* #3915 'NSNetServiceBrowser' => 'Foundation.NSNetServiceBrowser, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161D22 /* #3916 'NSProcessInfo' => 'Foundation.NSProcessInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16B122 /* #3917 'NSValueTransformer' => 'Foundation.NSValueTransformer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x163522 /* #3918 'NSSecureUnarchiveFromDataTransformer' => 'Foundation.NSSecureUnarchiveFromDataTransformer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165C22 /* #3919 'NSURLCache' => 'Foundation.NSUrlCache, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166C22 /* #3920 'NSURLCredentialStorage' => 'Foundation.NSUrlCredentialStorage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169322 /* #3921 'NSURLSessionStreamTask' => 'Foundation.NSUrlSessionStreamTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16A822 /* #3922 'NSURLSessionWebSocketTask' => 'Foundation.NSUrlSessionWebSocketTask, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16F922 /* #3923 'NSFileProviderDomain' => 'FileProvider.NSFileProviderDomain, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x171522 /* #3924 'NSFileProviderManager' => 'FileProvider.NSFileProviderManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E9B22 /* #3925 'EventKitUI_EKCalendarChooser__EKCalendarChooserDelegate' => 'EventKitUI.EKCalendarChooser+_EKCalendarChooserDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x174522 /* #3926 'EKCalendarChooser' => 'EventKitUI.EKCalendarChooser, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E9C22 /* #3927 'EventKitUI_EKEventEditViewController__EKEventEditViewDelegate' => 'EventKitUI.EKEventEditViewController+_EKEventEditViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2E9D22 /* #3928 'EventKitUI_EKEventEditViewController_EKEventEditViewControllerAppearance' => 'EventKitUI.EKEventEditViewController+EKEventEditViewControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x174A22 /* #3929 'EKEventEditViewController' => 'EventKitUI.EKEventEditViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E9E22 /* #3930 'EventKitUI_EKEventViewController__EKEventViewDelegate' => 'EventKitUI.EKEventViewController+_EKEventViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x175022 /* #3931 'EKEventViewController' => 'EventKitUI.EKEventViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x176822 /* #3932 'EKEventStore' => 'EventKit.EKEventStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x177722 /* #3933 'EKVirtualConferenceProvider' => 'EventKit.EKVirtualConferenceProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x182B22 /* #3934 'CTCellularPlanProvisioning' => 'CoreTelephony.CTCellularPlanProvisioning, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183422 /* #3935 'CTTelephonyNetworkInfo' => 'CoreTelephony.CTTelephonyNetworkInfo, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x183B22 /* #3936 'CSSearchableIndex' => 'CoreSpotlight.CSSearchableIndex, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x186022 /* #3937 'CMAltimeter' => 'CoreMotion.CMAltimeter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187522 /* #3938 'CMMotionActivityManager' => 'CoreMotion.CMMotionActivityManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187722 /* #3939 'CMPedometer' => 'CoreMotion.CMPedometer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x187F22 /* #3940 'CMStepCounter' => 'CoreMotion.CMStepCounter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B622 /* #3941 'MIDICIResponder' => 'CoreMidi.MidiCIResponder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18FA22 /* #3942 'MLMultiArray' => 'CoreML.MLMultiArray, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191522 /* #3943 'MLModel' => 'CoreML.MLModel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191922 /* #3944 'MLModelCollection' => 'CoreML.MLModelCollection, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F0922 /* #3945 'CoreLocation_CLLocationManager__CLLocationManagerDelegate' => 'CoreLocation.CLLocationManager+_CLLocationManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x193622 /* #3946 'CLLocationManager' => 'CoreLocation.CLLocationManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194322 /* #3947 'CLGeocoder' => 'CoreLocation.CLGeocoder, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB122 /* #3948 'NSCoreDataCoreSpotlightDelegate' => 'CoreData.NSCoreDataCoreSpotlightDelegate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CDE22 /* #3949 'NSManagedObjectContext' => 'CoreData.NSManagedObjectContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF222 /* #3950 'NSPersistentContainer' => 'CoreData.NSPersistentContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE522 /* #3951 'NSPersistentCloudKitContainer' => 'CoreData.NSPersistentCloudKitContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CEB22 /* #3952 'NSPersistentCloudKitContainerEvent' => 'CoreData.NSPersistentCloudKitContainerEvent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CFB22 /* #3953 'NSPersistentStoreCoordinator' => 'CoreData.NSPersistentStoreCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F6F22 /* #3954 'CoreBluetooth_CBCentralManager__CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManager+_CBCentralManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1D1A22 /* #3955 'CBCentralManager' => 'CoreBluetooth.CBCentralManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F7022 /* #3956 'CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManager+_CBPeripheralManagerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1D1E22 /* #3957 'CBPeripheralManager' => 'CoreBluetooth.CBPeripheralManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F7122 /* #3958 'CoreBluetooth_CBPeripheral__CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheral+_CBPeripheralDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1D2022 /* #3959 'CBPeripheral' => 'CoreBluetooth.CBPeripheral, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F7222 /* #3960 'CoreAnimation_CAAnimation__CAAnimationDelegate' => 'CoreAnimation.CAAnimation+_CAAnimationDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1DA022 /* #3961 'CNContactStore' => 'Contacts.CNContactStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF322 /* #3962 'CKContainer' => 'CloudKit.CKContainer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E0322 /* #3963 'CKDatabase' => 'CloudKit.CKDatabase, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E5F22 /* #3964 'CLSContext' => 'ClassKit.CLSContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1E6922 /* #3965 'CLSDataStore' => 'ClassKit.CLSDataStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1EF422 /* #3966 'CPInterfaceController' => 'CarPlay.CPInterfaceController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F0922 /* #3967 'CPMapTemplate' => 'CarPlay.CPMapTemplate, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32AD22 /* #3968 'UIKit_UIWindow_UIWindowAppearance' => 'UIKit.UIWindow+UIWindowAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x31F422 /* #3969 'CarPlay_CPWindow_CPWindowAppearance' => 'CarPlay.CPWindow+CPWindowAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x218E22 /* #3970 'UIWindow' => 'UIKit.UIWindow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5322 /* #3971 'CPWindow' => 'CarPlay.CPWindow, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5822 /* #3972 'CXProvider' => 'CallKit.CXProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5D22 /* #3973 'CXCallController' => 'CallKit.CXCallController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F5F22 /* #3974 'CXCallDirectoryExtensionContext' => 'CallKit.CXCallDirectoryExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F6322 /* #3975 'CXCallDirectoryManager' => 'CallKit.CXCallDirectoryManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x320122 /* #3976 'BusinessChat_BCChatButton_BCChatButtonAppearance' => 'BusinessChat.BCChatButton+BCChatButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1F8922 /* #3977 'BCChatButton' => 'BusinessChat.BCChatButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1F8E22 /* #3978 'BADownloadManager' => 'BackgroundAssets.BADownloadManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FA422 /* #3979 'ASAccountAuthenticationModificationExtensionContext' => 'AuthenticationServices.ASAccountAuthenticationModificationExtensionContext, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x320422 /* #3980 'AuthenticationServices_ASAuthorizationAppleIdButton_ASAuthorizationAppleIdButtonAppearance' => 'AuthenticationServices.ASAuthorizationAppleIdButton+ASAuthorizationAppleIdButtonAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1FA922 /* #3981 'ASAuthorizationAppleIDButton' => 'AuthenticationServices.ASAuthorizationAppleIdButton, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FAC22 /* #3982 'ASAuthorizationAppleIDCredential' => 'AuthenticationServices.ASAuthorizationAppleIdCredential, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FAD22 /* #3983 'ASAuthorizationAppleIDProvider' => 'AuthenticationServices.ASAuthorizationAppleIdProvider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FCB22 /* #3984 'ASAuthorizationProviderExtensionAuthorizationRequest' => 'AuthenticationServices.ASAuthorizationProviderExtensionAuthorizationRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE322 /* #3985 'ASAuthorizationSecurityKeyPublicKeyCredentialDescriptor' => 'AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialDescriptor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE922 /* #3986 'ASAuthorizationSingleSignOnCredential' => 'AuthenticationServices.ASAuthorizationSingleSignOnCredential, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FED22 /* #3987 'ASCredentialIdentityStore' => 'AuthenticationServices.ASCredentialIdentityStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x203722 /* #3988 'AUAudioUnit' => 'AudioUnit.AUAudioUnit, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x210922 /* #3989 'ALAsset' => 'AssetsLibrary.ALAsset, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x211122 /* #3990 'ALAssetsLibrary' => 'AssetsLibrary.ALAssetsLibrary, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x323D22 /* #3991 'UIKit_UIPreviewInteraction__UIPreviewInteractionDelegate' => 'UIKit.UIPreviewInteraction+_UIPreviewInteractionDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x211D22 /* #3992 'UIPreviewInteraction' => 'UIKit.UIPreviewInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x324122 /* #3993 '__MonoMac_FuncBoolDispatcher' => 'UIKit.UIAccessibilityCustomAction+FuncBoolDispatcher, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x212422 /* #3994 'UIAccessibilityCustomAction' => 'UIKit.UIAccessibilityCustomAction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x324222 /* #3995 'UIKit_UIActionSheet__UIActionSheetDelegate' => 'UIKit.UIActionSheet+_UIActionSheetDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x324322 /* #3996 'UIKit_UIActionSheet_UIActionSheetAppearance' => 'UIKit.UIActionSheet+UIActionSheetAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x212522 /* #3997 'UIActionSheet' => 'UIKit.UIActionSheet, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x324522 /* #3998 'UIKit_UIAlertView__UIAlertViewDelegate' => 'UIKit.UIAlertView+_UIAlertViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x324622 /* #3999 'UIKit_UIAlertView_UIAlertViewAppearance' => 'UIKit.UIAlertView+UIAlertViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x212822 /* #4000 'UIAlertView' => 'UIKit.UIAlertView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x212B22 /* #4001 'UIApplication' => 'UIKit.UIApplication, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x324A22 /* #4002 'UIKit_UIBarButtonItem_Callback' => 'UIKit.UIBarButtonItem+Callback, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x324F22 /* #4003 'UIKit_UICollectionView_UICollectionViewAppearance' => 'UIKit.UICollectionView+UICollectionViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x213522 /* #4004 'UICollectionView' => 'UIKit.UICollectionView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x213922 /* #4005 'UIColor' => 'UIKit.UIColor, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x214122 /* #4006 'UIDevice' => 'UIKit.UIDevice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x214222 /* #4007 'UIDocumentBrowserViewController' => 'UIKit.UIDocumentBrowserViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x325B22 /* #4008 'UIKit_UIDocumentMenuViewController__UIDocumentMenuDelegate' => 'UIKit.UIDocumentMenuViewController+_UIDocumentMenuDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x214322 /* #4009 'UIDocumentMenuViewController' => 'UIKit.UIDocumentMenuViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x325D22 /* #4010 'UIKit_UIDocumentPickerViewController__UIDocumentPickerDelegate' => 'UIKit.UIDocumentPickerViewController+_UIDocumentPickerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x214422 /* #4011 'UIDocumentPickerViewController' => 'UIKit.UIDocumentPickerViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x214622 /* #4012 'UIDynamicAnimator' => 'UIKit.UIDynamicAnimator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x326122 /* #4013 '__UIGestureRecognizerToken' => 'UIKit.UIGestureRecognizer+Token, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x326222 /* #4014 '__UIGestureRecognizerGenericCB' => 'UIKit.UIGestureRecognizer+Callback`1, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x326322 /* #4015 '__UIGestureRecognizerParameterlessToken' => 'UIKit.UIGestureRecognizer+ParameterlessDispatch, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x326422 /* #4016 '__UIGestureRecognizerParametrizedToken' => 'UIKit.UIGestureRecognizer+ParametrizedDispatch, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x326522 /* #4017 'UIKit_UIGestureRecognizer__UIGestureRecognizerDelegate' => 'UIKit.UIGestureRecognizer+_UIGestureRecognizerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x215C22 /* #4018 'UIImage' => 'UIKit.UIImage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x327122 /* #4019 'UIKit_UIImagePickerController__UIImagePickerControllerDelegate' => 'UIKit.UIImagePickerController+_UIImagePickerControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x215E22 /* #4020 'UIImagePickerController' => 'UIKit.UIImagePickerController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x327322 /* #4021 'UIKit_UINavigationBar_UINavigationBarAppearance' => 'UIKit.UINavigationBar+UINavigationBarAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x216322 /* #4022 'UINavigationBar' => 'UIKit.UINavigationBar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x327422 /* #4023 'UIKit_UIPageViewController__UIPageViewControllerDelegate' => 'UIKit.UIPageViewController+_UIPageViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x327522 /* #4024 'UIKit_UIPageViewController__UIPageViewControllerDataSource' => 'UIKit.UIPageViewController+_UIPageViewControllerDataSource, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x216622 /* #4025 'UIPageViewController' => 'UIKit.UIPageViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x216722 /* #4026 'UIPasteboard' => 'UIKit.UIPasteboard, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x327C22 /* #4027 'UIKit_UIPickerView_UIPickerViewAppearance' => 'UIKit.UIPickerView+UIPickerViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x216822 /* #4028 'UIPickerView' => 'UIKit.UIPickerView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x327D22 /* #4029 'UIKit_UIPopoverController__UIPopoverControllerDelegate' => 'UIKit.UIPopoverController+_UIPopoverControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x216922 /* #4030 'UIPopoverController' => 'UIKit.UIPopoverController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x327E22 /* #4031 'UIKit_UIPopoverPresentationController__UIPopoverPresentationControllerDelegate' => 'UIKit.UIPopoverPresentationController+_UIPopoverPresentationControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x216A22 /* #4032 'UIPopoverPresentationController' => 'UIKit.UIPopoverPresentationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x327F22 /* #4033 'UIKit_UIPrintInteractionController__UIPrintInteractionControllerDelegate' => 'UIKit.UIPrintInteractionController+_UIPrintInteractionControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x216E22 /* #4034 'UIPrintInteractionController' => 'UIKit.UIPrintInteractionController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x217022 /* #4035 'UIScreen' => 'UIKit.UIScreen, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x328922 /* #4036 'UIKit_UISearchBar_UISearchBarAppearance' => 'UIKit.UISearchBar+UISearchBarAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x328A22 /* #4037 'UIKit_UISearchBar__UISearchBarDelegate' => 'UIKit.UISearchBar+_UISearchBarDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x217222 /* #4038 'UISearchBar' => 'UIKit.UISearchBar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x328B22 /* #4039 'UIKit_UISearchController___Xamarin_UISearchResultsUpdating' => 'UIKit.UISearchController+__Xamarin_UISearchResultsUpdating, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x217322 /* #4040 'UISearchController' => 'UIKit.UISearchController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x328C22 /* #4041 'UIKit_UISegmentedControl_UISegmentedControlAppearance' => 'UIKit.UISegmentedControl+UISegmentedControlAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x217522 /* #4042 'UISegmentedControl' => 'UIKit.UISegmentedControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x328D22 /* #4043 'UIKit_UITableView_UITableViewAppearance' => 'UIKit.UITableView+UITableViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x217B22 /* #4044 'UITableView' => 'UIKit.UITableView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x329022 /* #4045 'UIKit_UITableViewCell_UITableViewCellAppearance' => 'UIKit.UITableViewCell+UITableViewCellAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x217C22 /* #4046 'UITableViewCell' => 'UIKit.UITableViewCell, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x329122 /* #4047 'UIKit_UITextField__UITextFieldDelegate' => 'UIKit.UITextField+_UITextFieldDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x329222 /* #4048 'UIKit_UITextField_UITextFieldAppearance' => 'UIKit.UITextField+UITextFieldAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x218122 /* #4049 'UITextField' => 'UIKit.UITextField, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32EF22 /* #4050 'UIKit_UIScrollView__UIScrollViewDelegate' => 'UIKit.UIScrollView+_UIScrollViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x329422 /* #4051 'UIKit_UITextView__UITextViewDelegate' => 'UIKit.UITextView+_UITextViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x329522 /* #4052 'UIKit_UITextView_UITextViewAppearance' => 'UIKit.UITextView+UITextViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x218222 /* #4053 'UITextView' => 'UIKit.UITextView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x329722 /* #4054 'UIKit_UIToolbar_UIToolbarAppearance' => 'UIKit.UIToolbar+UIToolbarAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x218322 /* #4055 'UIToolbar' => 'UIKit.UIToolbar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x329922 /* #4056 'UIKit_UIView__UIViewStaticCallback' => 'UIKit.UIView+_UIViewStaticCallback, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x221222 /* #4057 'NSFileProviderExtension' => 'UIKit.NSFileProviderExtension, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32C022 /* #4058 'UIKit_NSTextStorage__NSTextStorageDelegate' => 'UIKit.NSTextStorage+_NSTextStorageDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x226422 /* #4059 'NSTextStorage' => 'UIKit.NSTextStorage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32C222 /* #4060 'UIKit_UIAccelerometer__UIAccelerometerDelegate' => 'UIKit.UIAccelerometer+_UIAccelerometerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x227622 /* #4061 'UIAccelerometer' => 'UIKit.UIAccelerometer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32C322 /* #4062 'UIKit_UIActivityIndicatorView_UIActivityIndicatorViewAppearance' => 'UIKit.UIActivityIndicatorView+UIActivityIndicatorViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x22A622 /* #4063 'UIActivityIndicatorView' => 'UIKit.UIActivityIndicatorView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32C422 /* #4064 'UIKit_UICalendarView_UICalendarViewAppearance' => 'UIKit.UICalendarView+UICalendarViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x230222 /* #4065 'UICalendarView' => 'UIKit.UICalendarView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32C522 /* #4066 'UIKit_UICollectionReusableView_UICollectionReusableViewAppearance' => 'UIKit.UICollectionReusableView+UICollectionReusableViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x232822 /* #4067 'UICollectionReusableView' => 'UIKit.UICollectionReusableView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32C622 /* #4068 'UIKit_UICollectionViewCell_UICollectionViewCellAppearance' => 'UIKit.UICollectionViewCell+UICollectionViewCellAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x232B22 /* #4069 'UICollectionViewCell' => 'UIKit.UICollectionViewCell, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x234022 /* #4070 'UICollectionViewDiffableDataSource' => 'UIKit.UICollectionViewDiffableDataSource`2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32C922 /* #4071 'UIKit_UICollectionViewListCell_UICollectionViewListCellAppearance' => 'UIKit.UICollectionViewListCell+UICollectionViewListCellAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x235822 /* #4072 'UICollectionViewListCell' => 'UIKit.UICollectionViewListCell, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32CA22 /* #4073 'UIKit_UICollisionBehavior__UICollisionBehaviorDelegate' => 'UIKit.UICollisionBehavior+_UICollisionBehaviorDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x236322 /* #4074 'UICollisionBehavior' => 'UIKit.UICollisionBehavior, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32CB22 /* #4075 'UIKit_UIColorWell_UIColorWellAppearance' => 'UIKit.UIColorWell+UIColorWellAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x237222 /* #4076 'UIColorWell' => 'UIKit.UIColorWell, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32CC22 /* #4077 'UIKit_UIDatePicker_UIDatePickerAppearance' => 'UIKit.UIDatePicker+UIDatePickerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x239F22 /* #4078 'UIDatePicker' => 'UIKit.UIDatePicker, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32D422 /* #4079 'UIKit_UIDocumentInteractionController__UIDocumentInteractionControllerDelegate' => 'UIKit.UIDocumentInteractionController+_UIDocumentInteractionControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x23B422 /* #4080 'UIDocumentInteractionController' => 'UIKit.UIDocumentInteractionController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32D522 /* #4081 'UIKit_UIEventAttributionView_UIEventAttributionViewAppearance' => 'UIKit.UIEventAttributionView+UIEventAttributionViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x23F922 /* #4082 'UIEventAttributionView' => 'UIKit.UIEventAttributionView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x240922 /* #4083 'UIFocusAnimationCoordinator' => 'UIKit.UIFocusAnimationCoordinator, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32D922 /* #4084 'UIKit_UIImageView_UIImageViewAppearance' => 'UIKit.UIImageView+UIImageViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x245A22 /* #4085 'UIImageView' => 'UIKit.UIImageView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32DA22 /* #4086 'UIKit_UIInputView_UIInputViewAppearance' => 'UIKit.UIInputView+UIInputViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x246222 /* #4087 'UIInputView' => 'UIKit.UIInputView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x246522 /* #4088 'UIInputViewController' => 'UIKit.UIInputViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32DC22 /* #4089 'UIKit_UILabel_UILabelAppearance' => 'UIKit.UILabel+UILabelAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x247822 /* #4090 'UILabel' => 'UIKit.UILabel, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x247922 /* #4091 'UILargeContentViewerInteraction' => 'UIKit.UILargeContentViewerInteraction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32DE22 /* #4092 'UIKit_UIListContentView_UIListContentViewAppearance' => 'UIKit.UIListContentView+UIListContentViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x249322 /* #4093 'UIListContentView' => 'UIKit.UIListContentView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249B22 /* #4094 'UIMenuController' => 'UIKit.UIMenuController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32E022 /* #4095 'UIKit_UIPageControl_UIPageControlAppearance' => 'UIKit.UIPageControl+UIPageControlAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x24CB22 /* #4096 'UIPageControl' => 'UIKit.UIPageControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32E122 /* #4097 'UIKit_UIPasteControl_UIPasteControlAppearance' => 'UIKit.UIPasteControl+UIPasteControlAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x24E622 /* #4098 'UIPasteControl' => 'UIKit.UIPasteControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250B22 /* #4099 'UIPointerLockState' => 'UIKit.UIPointerLockState, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32E322 /* #4100 'UIKit_UIPopoverBackgroundView_UIPopoverBackgroundViewAppearance' => 'UIKit.UIPopoverBackgroundView+UIPopoverBackgroundViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x251122 /* #4101 'UIPopoverBackgroundView' => 'UIKit.UIPopoverBackgroundView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x252F22 /* #4102 'UIPrinter' => 'UIKit.UIPrinter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x253322 /* #4103 'UIPrinterPickerController' => 'UIKit.UIPrinterPickerController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32EB22 /* #4104 'UIKit_UIProgressView_UIProgressViewAppearance' => 'UIKit.UIProgressView+UIProgressViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x254B22 /* #4105 'UIProgressView' => 'UIKit.UIProgressView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32EC22 /* #4106 'UIKit_UIRefreshControl_UIRefreshControlAppearance' => 'UIKit.UIRefreshControl+UIRefreshControlAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x255122 /* #4107 'UIRefreshControl' => 'UIKit.UIRefreshControl, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F122 /* #4108 'UIKit_UISearchTextField_UISearchTextFieldAppearance' => 'UIKit.UISearchTextField+UISearchTextFieldAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25A522 /* #4109 'UISearchTextField' => 'UIKit.UISearchTextField, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F222 /* #4110 'UIKit_UISlider_UISliderAppearance' => 'UIKit.UISlider+UISliderAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25BB22 /* #4111 'UISlider' => 'UIKit.UISlider, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F322 /* #4112 'UIKit_UISplitViewController__UISplitViewControllerDelegate' => 'UIKit.UISplitViewController+_UISplitViewControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25BD22 /* #4113 'UISplitViewController' => 'UIKit.UISplitViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F422 /* #4114 'UIKit_UIStackView_UIStackViewAppearance' => 'UIKit.UIStackView+UIStackViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25DB22 /* #4115 'UIStackView' => 'UIKit.UIStackView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F522 /* #4116 'UIKit_UIStepper_UIStepperAppearance' => 'UIKit.UIStepper+UIStepperAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25E622 /* #4117 'UIStepper' => 'UIKit.UIStepper, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F622 /* #4118 'UIKit_UISwitch_UISwitchAppearance' => 'UIKit.UISwitch+UISwitchAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25EC22 /* #4119 'UISwitch' => 'UIKit.UISwitch, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F722 /* #4120 'UIKit_UITabBar__UITabBarDelegate' => 'UIKit.UITabBar+_UITabBarDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x32F822 /* #4121 'UIKit_UITabBar_UITabBarAppearance' => 'UIKit.UITabBar+UITabBarAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25EF22 /* #4122 'UITabBar' => 'UIKit.UITabBar, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32F922 /* #4123 'UIKit_UITabBarController__UITabBarControllerDelegate' => 'UIKit.UITabBarController+_UITabBarControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25F422 /* #4124 'UITabBarController' => 'UIKit.UITabBarController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32FA22 /* #4125 'UIKit_UITabBarItem_UITabBarItemAppearance' => 'UIKit.UITabBarItem+UITabBarItemAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x260022 /* #4126 'UITabBarItem' => 'UIKit.UITabBarItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x261A22 /* #4127 'UITableViewDiffableDataSource' => 'UIKit.UITableViewDiffableDataSource`2, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32FD22 /* #4128 'UIKit_UITableViewHeaderFooterView_UITableViewHeaderFooterViewAppearance' => 'UIKit.UITableViewHeaderFooterView+UITableViewHeaderFooterViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x262D22 /* #4129 'UITableViewHeaderFooterView' => 'UIKit.UITableViewHeaderFooterView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266F22 /* #4130 'UITextInputMode' => 'UIKit.UITextInputMode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x32FF22 /* #4131 'UIKit_UIVideoEditorController__UIVideoEditorControllerDelegate' => 'UIKit.UIVideoEditorController+_UIVideoEditorControllerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x26C822 /* #4132 'UIVideoEditorController' => 'UIKit.UIVideoEditorController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x330022 /* #4133 'UIKit_UIVisualEffectView_UIVisualEffectViewAppearance' => 'UIKit.UIVisualEffectView+UIVisualEffectViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x26FD22 /* #4134 'UIVisualEffectView' => 'UIKit.UIVisualEffectView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x330122 /* #4135 'UIKit_UIWebView__UIWebViewDelegate' => 'UIKit.UIWebView+_UIWebViewDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x330222 /* #4136 'UIKit_UIWebView_UIWebViewAppearance' => 'UIKit.UIWebView+UIWebViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x270022 /* #4137 'UIWebView' => 'UIKit.UIWebView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271D22 /* #4138 'ABNewPersonViewController' => 'AddressBookUI.ABNewPersonViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x330422 /* #4139 'AddressBookUI_ABPeoplePickerNavigationController_ABPeoplePickerNavigationControllerAppearance' => 'AddressBookUI.ABPeoplePickerNavigationController+ABPeoplePickerNavigationControllerAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x272322 /* #4140 'ABPeoplePickerNavigationController' => 'AddressBookUI.ABPeoplePickerNavigationController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x272622 /* #4141 'ABPersonViewController' => 'AddressBookUI.ABPersonViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x272922 /* #4142 'ABUnknownPersonViewController' => 'AddressBookUI.ABUnknownPersonViewController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x276C22 /* #4143 'ACAccountStore' => 'Accounts.ACAccountStore, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x279C22 /* #4144 'AVCustomRoutingController' => 'AVRouting.AVCustomRoutingController, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x331B22 /* #4145 'AVKit_AVRoutePickerView_AVRoutePickerViewAppearance' => 'AVKit.AVRoutePickerView+AVRoutePickerViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x27BB22 /* #4146 'AVRoutePickerView' => 'AVKit.AVRoutePickerView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27CD22 /* #4147 'AVAudioSession' => 'AVFoundation.AVAudioSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x331D22 /* #4148 'AVFoundation_AVCaptureFileOutput_recordingProxy' => 'AVFoundation.AVCaptureFileOutput+recordingProxy, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x27DC22 /* #4149 'AVCaptureVideoPreviewLayer' => 'AVFoundation.AVCaptureVideoPreviewLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E722 /* #4150 'AVAudioUnitComponentManager' => 'AVFoundation.AVAudioUnitComponentManager, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27E822 /* #4151 'AVSampleBufferAudioRenderer' => 'AVFoundation.AVSampleBufferAudioRenderer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27ED22 /* #4152 'AVFoundation_AVPlayerInterstitialEventObserver' => 'AVFoundation.AVPlayerInterstitialEventObserver, Xamarin.iOS' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x27F822 /* #4153 'AVPlayerItemVideoOutput' => 'AVFoundation.AVPlayerItemVideoOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x27F922 /* #4154 'AVPlayerItem' => 'AVFoundation.AVPlayerItem, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x282822 /* #4155 'AVAssetExportSession' => 'AVFoundation.AVAssetExportSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x284C22 /* #4156 'AVAssetWriter' => 'AVFoundation.AVAssetWriter, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x285D22 /* #4157 'AVAsynchronousVideoCompositionRequest' => 'AVFoundation.AVAsynchronousVideoCompositionRequest, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x286C22 /* #4158 'AVAudioEngine' => 'AVFoundation.AVAudioEngine, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x288522 /* #4159 'AVAudioPlayerNode' => 'AVFoundation.AVAudioPlayerNode, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28AF22 /* #4160 'AVAudioUnitComponent' => 'AVFoundation.AVAudioUnitComponent, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28D622 /* #4161 'AVCaptureDevice' => 'AVFoundation.AVCaptureDevice, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x28F822 /* #4162 'AVCapturePhotoOutput' => 'AVFoundation.AVCapturePhotoOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x290222 /* #4163 'AVCaptureStillImageOutput' => 'AVFoundation.AVCaptureStillImageOutput, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x292922 /* #4164 'AVContentKeySession' => 'AVFoundation.AVContentKeySession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x294E22 /* #4165 'AVFragmentedMovie' => 'AVFoundation.AVFragmentedMovie, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x295122 /* #4166 'AVFragmentedMovieTrack' => 'AVFoundation.AVFragmentedMovieTrack, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x297022 /* #4167 'AVMIDIPlayer' => 'AVFoundation.AVMidiPlayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x298022 /* #4168 'AVMutableMovie' => 'AVFoundation.AVMutableMovie, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29F222 /* #4169 'AVVideoComposition' => 'AVFoundation.AVVideoComposition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x298822 /* #4170 'AVMutableVideoComposition' => 'AVFoundation.AVMutableVideoComposition, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29F422 /* #4171 'AVVideoCompositionInstruction' => 'AVFoundation.AVVideoCompositionInstruction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x298922 /* #4172 'AVMutableVideoCompositionInstruction' => 'AVFoundation.AVMutableVideoCompositionInstruction, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29BB22 /* #4173 'AVPlayerMediaSelectionCriteria' => 'AVFoundation.AVPlayerMediaSelectionCriteria, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29CD22 /* #4174 'AVRouteDetector' => 'AVFoundation.AVRouteDetector, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29CE22 /* #4175 'AVSampleBufferDisplayLayer' => 'AVFoundation.AVSampleBufferDisplayLayer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29D022 /* #4176 'AVSampleBufferRenderSynchronizer' => 'AVFoundation.AVSampleBufferRenderSynchronizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x338B22 /* #4177 'AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate' => 'AVFoundation.AVSpeechSynthesizer+_AVSpeechSynthesizerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x29DB22 /* #4178 'AVSpeechSynthesizer' => 'AVFoundation.AVSpeechSynthesizer, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x339022 /* #4179 'ARKit_ARCoachingOverlayView_ARCoachingOverlayViewAppearance' => 'ARKit.ARCoachingOverlayView+ARCoachingOverlayViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2A2922 /* #4180 'ARCoachingOverlayView' => 'ARKit.ARCoachingOverlayView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A4122 /* #4181 'ARGeoTrackingConfiguration' => 'ARKit.ARGeoTrackingConfiguration, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A5F22 /* #4182 'ARReferenceImage' => 'ARKit.ARReferenceImage, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x339422 /* #4183 'ARKit_ARSCNView_ARSCNViewAppearance' => 'ARKit.ARSCNView+ARSCNViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2A6522 /* #4184 'ARSCNView' => 'ARKit.ARSCNView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A6B22 /* #4185 'ARSession' => 'ARKit.ARSession, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x339B22 /* #4186 'ARKit_ARSKView_ARSKViewAppearance' => 'ARKit.ARSKView+ARSKViewAppearance, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2A7A22 /* #4187 'ARSKView' => 'ARKit.ARSKView, Xamarin.iOS' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C5F22 /* #4188 'System_Net_Http_NSUrlSessionHandler_NSUrlSessionHandlerDelegate' => 'System.Net.Http.NSUrlSessionHandler+NSUrlSessionHandlerDelegate, Xamarin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xE2E /* #4189 'Xamarin_Forms_Platform_iOS_iOS7ButtonContainer' => 'Xamarin.Forms.Platform.iOS.iOS7ButtonContainer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x102E /* #4190 'Xamarin_Forms_Platform_iOS_GlobalCloseContextGestureRecognizer' => 'Xamarin.Forms.Platform.iOS.GlobalCloseContextGestureRecognizer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x182E /* #4191 'Xamarin_Forms_Platform_iOS_PlatformRenderer' => 'Xamarin.Forms.Platform.iOS.PlatformRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x212E /* #4192 'Xamarin_Forms_Platform_iOS_VisualElementRenderer_1' => 'Xamarin.Forms.Platform.iOS.VisualElementRenderer`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1E2E /* #4193 'Xamarin_Forms_Platform_iOS_ViewRenderer_2' => 'Xamarin.Forms.Platform.iOS.ViewRenderer`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1D2E /* #4194 'Xamarin_Forms_Platform_iOS_ViewRenderer' => 'Xamarin.Forms.Platform.iOS.ViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x242E /* #4195 'Xamarin_Forms_Platform_iOS_CellTableViewCell' => 'Xamarin.Forms.Platform.iOS.CellTableViewCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x332E /* #4196 'Xamarin_Forms_Platform_iOS_ActivityIndicatorRenderer' => 'Xamarin.Forms.Platform.iOS.ActivityIndicatorRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x342E /* #4197 'Xamarin_Forms_Platform_iOS_BoxRenderer' => 'Xamarin.Forms.Platform.iOS.BoxRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x352E /* #4198 'Xamarin_Forms_Platform_iOS_ButtonRenderer' => 'Xamarin.Forms.Platform.iOS.ButtonRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x372E /* #4199 'Xamarin_Forms_Platform_iOS_NoCaretField' => 'Xamarin.Forms.Platform.iOS.NoCaretField, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x392E /* #4200 'Xamarin_Forms_Platform_iOS_DatePickerRendererBase_1' => 'Xamarin.Forms.Platform.iOS.DatePickerRendererBase`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x382E /* #4201 'Xamarin_Forms_Platform_iOS_DatePickerRenderer' => 'Xamarin.Forms.Platform.iOS.DatePickerRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3B2E /* #4202 'Xamarin_Forms_Platform_iOS_EditorRendererBase_1' => 'Xamarin.Forms.Platform.iOS.EditorRendererBase`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3A2E /* #4203 'Xamarin_Forms_Platform_iOS_EditorRenderer' => 'Xamarin.Forms.Platform.iOS.EditorRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3E2E /* #4204 'Xamarin_Forms_Platform_iOS_EntryRendererBase_1' => 'Xamarin.Forms.Platform.iOS.EntryRendererBase`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3D2E /* #4205 'Xamarin_Forms_Platform_iOS_EntryRenderer' => 'Xamarin.Forms.Platform.iOS.EntryRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4D2E /* #4206 'Xamarin_Forms_Platform_iOS_HeaderWrapperView' => 'Xamarin.Forms.Platform.iOS.HeaderWrapperView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4F2E /* #4207 'Xamarin_Forms_Platform_iOS_FormsRefreshControl' => 'Xamarin.Forms.Platform.iOS.FormsRefreshControl, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x532E /* #4208 'Xamarin_Forms_Platform_iOS_ReadOnlyField' => 'Xamarin.Forms.Platform.iOS.ReadOnlyField, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x552E /* #4209 'Xamarin_Forms_Platform_iOS_PickerRendererBase_1' => 'Xamarin.Forms.Platform.iOS.PickerRendererBase`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x542E /* #4210 'Xamarin_Forms_Platform_iOS_PickerRenderer' => 'Xamarin.Forms.Platform.iOS.PickerRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x562E /* #4211 'Xamarin_Forms_Platform_iOS_ProgressBarRenderer' => 'Xamarin.Forms.Platform.iOS.ProgressBarRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x572E /* #4212 'Xamarin_Forms_Platform_iOS_ScrollViewRenderer' => 'Xamarin.Forms.Platform.iOS.ScrollViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x582E /* #4213 'Xamarin_Forms_Platform_iOS_SearchBarRenderer' => 'Xamarin.Forms.Platform.iOS.SearchBarRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x592E /* #4214 'Xamarin_Forms_Platform_iOS_SliderRenderer' => 'Xamarin.Forms.Platform.iOS.SliderRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5A2E /* #4215 'Xamarin_Forms_Platform_iOS_StepperRenderer' => 'Xamarin.Forms.Platform.iOS.StepperRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5B2E /* #4216 'Xamarin_Forms_Platform_iOS_SwitchRenderer' => 'Xamarin.Forms.Platform.iOS.SwitchRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5D2E /* #4217 'Xamarin_Forms_Platform_iOS_TableViewModelRenderer' => 'Xamarin.Forms.Platform.iOS.TableViewModelRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5E2E /* #4218 'Xamarin_Forms_Platform_iOS_UnEvenTableViewModelRenderer' => 'Xamarin.Forms.Platform.iOS.UnEvenTableViewModelRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5F2E /* #4219 'Xamarin_Forms_Platform_iOS_TableViewRenderer' => 'Xamarin.Forms.Platform.iOS.TableViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x612E /* #4220 'Xamarin_Forms_Platform_iOS_TimePickerRendererBase_1' => 'Xamarin.Forms.Platform.iOS.TimePickerRendererBase`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x602E /* #4221 'Xamarin_Forms_Platform_iOS_TimePickerRenderer' => 'Xamarin.Forms.Platform.iOS.TimePickerRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7E2E /* #4222 'Xamarin_Forms_Platform_iOS_ItemsViewDelegator_2' => 'Xamarin.Forms.Platform.iOS.ItemsViewDelegator`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x642E /* #4223 'Xamarin_Forms_Platform_iOS_CarouselViewDelegator' => 'Xamarin.Forms.Platform.iOS.CarouselViewDelegator, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x732E /* #4224 'Xamarin_Forms_Platform_iOS_ItemsViewRenderer_2' => 'Xamarin.Forms.Platform.iOS.ItemsViewRenderer`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x652E /* #4225 'Xamarin_Forms_Platform_iOS_CarouselViewRenderer' => 'Xamarin.Forms.Platform.iOS.CarouselViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x822E /* #4226 'Xamarin_Forms_Platform_iOS_StructuredItemsViewRenderer_2' => 'Xamarin.Forms.Platform.iOS.StructuredItemsViewRenderer`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7C2E /* #4227 'Xamarin_Forms_Platform_iOS_SelectableItemsViewRenderer_2' => 'Xamarin.Forms.Platform.iOS.SelectableItemsViewRenderer`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6A2E /* #4228 'Xamarin_Forms_Platform_iOS_GroupableItemsViewRenderer_2' => 'Xamarin.Forms.Platform.iOS.GroupableItemsViewRenderer`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x662E /* #4229 'Xamarin_Forms_Platform_iOS_CollectionViewRenderer' => 'Xamarin.Forms.Platform.iOS.CollectionViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x762E /* #4230 'Xamarin_Forms_Platform_iOS_ItemsViewController_1' => 'Xamarin.Forms.Platform.iOS.ItemsViewController`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x812E /* #4231 'Xamarin_Forms_Platform_iOS_StructuredItemsViewController_1' => 'Xamarin.Forms.Platform.iOS.StructuredItemsViewController`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7A2E /* #4232 'Xamarin_Forms_Platform_iOS_SelectableItemsViewController_1' => 'Xamarin.Forms.Platform.iOS.SelectableItemsViewController`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x682E /* #4233 'Xamarin_Forms_Platform_iOS_GroupableItemsViewController_1' => 'Xamarin.Forms.Platform.iOS.GroupableItemsViewController`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7B2E /* #4234 'Xamarin_Forms_Platform_iOS_SelectableItemsViewDelegator_2' => 'Xamarin.Forms.Platform.iOS.SelectableItemsViewDelegator`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x692E /* #4235 'Xamarin_Forms_Platform_iOS_GroupableItemsViewDelegator_2' => 'Xamarin.Forms.Platform.iOS.GroupableItemsViewDelegator`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x722E /* #4236 'Xamarin_Forms_Platform_iOS_ItemsViewCell' => 'Xamarin.Forms.Platform.iOS.ItemsViewCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8B2E /* #4237 'Xamarin_Forms_Platform_iOS_TemplatedCell' => 'Xamarin.Forms.Platform.iOS.TemplatedCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8C2E /* #4238 'Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell' => 'Xamarin.Forms.Platform.iOS.HeightConstrainedTemplatedCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6B2E /* #4239 'Xamarin_Forms_Platform_iOS_HorizontalCell' => 'Xamarin.Forms.Platform.iOS.HorizontalCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x742E /* #4240 'Xamarin_Forms_Platform_iOS_DefaultCell' => 'Xamarin.Forms.Platform.iOS.DefaultCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6C2E /* #4241 'Xamarin_Forms_Platform_iOS_HorizontalDefaultSupplementalView' => 'Xamarin.Forms.Platform.iOS.HorizontalDefaultSupplementalView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6D2E /* #4242 'Xamarin_Forms_Platform_iOS_HorizontalSupplementaryView' => 'Xamarin.Forms.Platform.iOS.HorizontalSupplementaryView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x752E /* #4243 'Xamarin_Forms_Platform_iOS_HorizontalDefaultCell' => 'Xamarin.Forms.Platform.iOS.HorizontalDefaultCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8E2E /* #4244 'Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell' => 'Xamarin.Forms.Platform.iOS.WidthConstrainedTemplatedCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7F2E /* #4245 'Xamarin_Forms_Platform_iOS_VerticalCell' => 'Xamarin.Forms.Platform.iOS.VerticalCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x832E /* #4246 'Xamarin_Forms_Platform_iOS_VerticalDefaultCell' => 'Xamarin.Forms.Platform.iOS.VerticalDefaultCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x852E /* #4247 'Xamarin_Forms_Platform_iOS_ItemsViewLayout' => 'Xamarin.Forms.Platform.iOS.ItemsViewLayout, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x842E /* #4248 'Xamarin_Forms_Platform_iOS_GridViewLayout' => 'Xamarin.Forms.Platform.iOS.GridViewLayout, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x872E /* #4249 'Xamarin_Forms_Platform_iOS_ListViewLayout' => 'Xamarin.Forms.Platform.iOS.ListViewLayout, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8D2E /* #4250 'Xamarin_Forms_Platform_iOS_VerticalDefaultSupplementalView' => 'Xamarin.Forms.Platform.iOS.VerticalDefaultSupplementalView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8F2E /* #4251 'Xamarin_Forms_Platform_iOS_VerticalSupplementaryView' => 'Xamarin.Forms.Platform.iOS.VerticalSupplementaryView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9C2E /* #4252 'Xamarin_Forms_Platform_iOS_FormsCAKeyFrameAnimation' => 'Xamarin.Forms.Platform.iOS.FormsCAKeyFrameAnimation, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9D2E /* #4253 'Xamarin_Forms_Platform_iOS_FormsCheckBox' => 'Xamarin.Forms.Platform.iOS.FormsCheckBox, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9E2E /* #4254 'Xamarin_Forms_Platform_iOS_FormsUIImageView' => 'Xamarin.Forms.Platform.iOS.FormsUIImageView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xA32E /* #4255 'Xamarin_Forms_Platform_iOS_NativeViewWrapperRenderer' => 'Xamarin.Forms.Platform.iOS.NativeViewWrapperRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xA92E /* #4256 'Xamarin_Forms_Platform_iOS_PageContainer' => 'Xamarin.Forms.Platform.iOS.PageContainer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAA2E /* #4257 'Xamarin_Forms_Platform_iOS_CheckBoxRendererBase_1' => 'Xamarin.Forms.Platform.iOS.CheckBoxRendererBase`1, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAB2E /* #4258 'Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer' => 'Xamarin.Forms.Platform.iOS.PhoneFlyoutPageRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAC2E /* #4259 'Xamarin_Forms_Platform_iOS_PhoneMasterDetailRenderer' => 'Xamarin.Forms.Platform.iOS.PhoneMasterDetailRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAE2E /* #4260 'Xamarin_Forms_Platform_iOS_ChildViewController' => 'Xamarin.Forms.Platform.iOS.ChildViewController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xB02E /* #4261 'Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer' => 'Xamarin.Forms.Platform.iOS.TabletFlyoutPageRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xB12E /* #4262 'Xamarin_Forms_Platform_iOS_TabletMasterDetailRenderer' => 'Xamarin.Forms.Platform.iOS.TabletMasterDetailRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xC42E /* #4263 'Xamarin_Forms_Platform_iOS_ShellItemRenderer' => 'Xamarin.Forms.Platform.iOS.ShellItemRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xC92E /* #4264 'Xamarin_Forms_Platform_iOS_ShellSearchResultsRenderer' => 'Xamarin.Forms.Platform.iOS.ShellSearchResultsRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCE2E /* #4265 'Xamarin_Forms_Platform_iOS_ShellTableViewController' => 'Xamarin.Forms.Platform.iOS.ShellTableViewController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD12E /* #4266 'Xamarin_Forms_Platform_iOS_TabletShellFlyoutRenderer' => 'Xamarin.Forms.Platform.iOS.TabletShellFlyoutRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD22E /* #4267 'Xamarin_Forms_Platform_iOS_UIContainerCell' => 'Xamarin.Forms.Platform.iOS.UIContainerCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD32E /* #4268 'Xamarin_Forms_Platform_iOS_UIContainerView' => 'Xamarin.Forms.Platform.iOS.UIContainerView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDB2E /* #4269 'Xamarin_Forms_Platform_iOS_NativeViewPropertyListener' => 'Xamarin.Forms.Platform.iOS.NativeViewPropertyListener, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xE82E /* #4270 'Xamarin_Forms_Platform_iOS_CheckBoxRenderer' => 'Xamarin.Forms.Platform.iOS.CheckBoxRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xE92E /* #4271 'Xamarin_Forms_Platform_iOS_CarouselViewLayout' => 'Xamarin.Forms.Platform.iOS.CarouselViewLayout, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xEA2E /* #4272 'Xamarin_Forms_Platform_iOS_CarouselViewController' => 'Xamarin.Forms.Platform.iOS.CarouselViewController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xEC2E /* #4273 'Xamarin_Forms_Platform_iOS_CarouselTemplatedCell' => 'Xamarin.Forms.Platform.iOS.CarouselTemplatedCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xED2E /* #4274 'Xamarin_Forms_Platform_iOS_RefreshViewRenderer' => 'Xamarin.Forms.Platform.iOS.RefreshViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xEF2E /* #4275 'Xamarin_Forms_Platform_iOS_IndicatorViewRenderer' => 'Xamarin.Forms.Platform.iOS.IndicatorViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF02E /* #4276 'Xamarin_Forms_Platform_iOS_FormsPageControl' => 'Xamarin.Forms.Platform.iOS.FormsPageControl, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF62E /* #4277 'Xamarin_Forms_Platform_iOS_ShapeRenderer_2' => 'Xamarin.Forms.Platform.iOS.ShapeRenderer`2, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF72E /* #4278 'Xamarin_Forms_Platform_iOS_ShapeView' => 'Xamarin.Forms.Platform.iOS.ShapeView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF82E /* #4279 'Xamarin_Forms_Platform_iOS_ShapeLayer' => 'Xamarin.Forms.Platform.iOS.ShapeLayer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF92E /* #4280 'Xamarin_Forms_Platform_iOS_PathRenderer' => 'Xamarin.Forms.Platform.iOS.PathRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xFB2E /* #4281 'Xamarin_Forms_Platform_iOS_PathView' => 'Xamarin.Forms.Platform.iOS.PathView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xFD2E /* #4282 'Xamarin_Forms_Platform_iOS_EllipseRenderer' => 'Xamarin.Forms.Platform.iOS.EllipseRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xFE2E /* #4283 'Xamarin_Forms_Platform_iOS_EllipseView' => 'Xamarin.Forms.Platform.iOS.EllipseView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xFF2E /* #4284 'Xamarin_Forms_Platform_iOS_LineRenderer' => 'Xamarin.Forms.Platform.iOS.LineRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1002E /* #4285 'Xamarin_Forms_Platform_iOS_LineView' => 'Xamarin.Forms.Platform.iOS.LineView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1012E /* #4286 'Xamarin_Forms_Platform_iOS_PolygonRenderer' => 'Xamarin.Forms.Platform.iOS.PolygonRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1022E /* #4287 'Xamarin_Forms_Platform_iOS_PolygonView' => 'Xamarin.Forms.Platform.iOS.PolygonView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1032E /* #4288 'Xamarin_Forms_Platform_iOS_PolylineRenderer' => 'Xamarin.Forms.Platform.iOS.PolylineRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1042E /* #4289 'Xamarin_Forms_Platform_iOS_PolylineView' => 'Xamarin.Forms.Platform.iOS.PolylineView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1052E /* #4290 'Xamarin_Forms_Platform_iOS_RectangleRenderer' => 'Xamarin.Forms.Platform.iOS.RectangleRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1062E /* #4291 'Xamarin_Forms_Platform_iOS_RectangleView' => 'Xamarin.Forms.Platform.iOS.RectangleView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x10C2E /* #4292 'Xamarin_Forms_Platform_iOS_ShellFlyoutHeaderContainer' => 'Xamarin.Forms.Platform.iOS.ShellFlyoutHeaderContainer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1162E /* #4293 'Xamarin_Forms_Platform_iOS_ContextActionsCell_SelectGestureRecognizer' => 'Xamarin.Forms.Platform.iOS.ContextActionsCell+SelectGestureRecognizer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1172E /* #4294 'Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetController' => 'Xamarin.Forms.Platform.iOS.ContextActionsCell+MoreActionSheetController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1182E /* #4295 'Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetDelegate' => 'Xamarin.Forms.Platform.iOS.ContextActionsCell+MoreActionSheetDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD2E /* #4296 'Xamarin_Forms_Platform_iOS_ContextActionsCell' => 'Xamarin.Forms.Platform.iOS.ContextActionsCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF2E /* #4297 'Xamarin_Forms_Platform_iOS_ContextScrollViewDelegate' => 'Xamarin.Forms.Platform.iOS.ContextScrollViewDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1262E /* #4298 'Xamarin_Forms_Platform_iOS_Platform_DefaultRenderer' => 'Xamarin.Forms.Platform.iOS.Platform+DefaultRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1352E /* #4299 'Xamarin_Forms_Platform_iOS_EntryCellRenderer_EntryCellTableViewCell' => 'Xamarin.Forms.Platform.iOS.EntryCellRenderer+EntryCellTableViewCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1382E /* #4300 'Xamarin_Forms_Platform_iOS_ViewCellRenderer_ViewTableCell' => 'Xamarin.Forms.Platform.iOS.ViewCellRenderer+ViewTableCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x13F2E /* #4301 'Xamarin_Forms_Platform_iOS_CarouselPageRenderer_CarouselPageContainer' => 'Xamarin.Forms.Platform.iOS.CarouselPageRenderer+CarouselPageContainer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x362E /* #4302 'Xamarin_Forms_Platform_iOS_CarouselPageRenderer' => 'Xamarin.Forms.Platform.iOS.CarouselPageRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1412E /* #4303 'Xamarin_Forms_Platform_iOS_EditorRendererBase_1_FormsUITextView' => 'Xamarin.Forms.Platform.iOS.EditorRendererBase`1+FormsUITextView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1422E /* #4304 'Xamarin_Forms_Platform_iOS_FrameRenderer_FrameView' => 'Xamarin.Forms.Platform.iOS.FrameRenderer+FrameView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x402E /* #4305 'Xamarin_Forms_Platform_iOS_FrameRenderer' => 'Xamarin.Forms.Platform.iOS.FrameRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x422E /* #4306 'Xamarin_Forms_Platform_iOS_ImageRenderer' => 'Xamarin.Forms.Platform.iOS.ImageRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14B2E /* #4307 'Xamarin_Forms_Platform_iOS_LabelRenderer_FormsLabel' => 'Xamarin.Forms.Platform.iOS.LabelRenderer+FormsLabel, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4B2E /* #4308 'Xamarin_Forms_Platform_iOS_LabelRenderer' => 'Xamarin.Forms.Platform.iOS.LabelRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14D2E /* #4309 'Xamarin_Forms_Platform_iOS_ListViewRenderer_ListViewDataSource' => 'Xamarin.Forms.Platform.iOS.ListViewRenderer+ListViewDataSource, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14C2E /* #4310 'Xamarin_Forms_Platform_iOS_ListViewRenderer_UnevenListViewDataSource' => 'Xamarin.Forms.Platform.iOS.ListViewRenderer+UnevenListViewDataSource, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4C2E /* #4311 'Xamarin_Forms_Platform_iOS_ListViewRenderer' => 'Xamarin.Forms.Platform.iOS.ListViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4E2E /* #4312 'Xamarin_Forms_Platform_iOS_FormsUITableViewController' => 'Xamarin.Forms.Platform.iOS.FormsUITableViewController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1562E /* #4313 'Xamarin_Forms_Platform_iOS_NavigationRenderer_FormsNavigationBar' => 'Xamarin.Forms.Platform.iOS.NavigationRenderer+FormsNavigationBar, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1572E /* #4314 'Xamarin_Forms_Platform_iOS_NavigationRenderer_Container' => 'Xamarin.Forms.Platform.iOS.NavigationRenderer+Container, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1612E /* #4315 'Xamarin_Forms_Platform_iOS_OpenGLViewRenderer_Delegate' => 'Xamarin.Forms.Platform.iOS.OpenGLViewRenderer+Delegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x512E /* #4316 'Xamarin_Forms_Platform_iOS_OpenGLViewRenderer' => 'Xamarin.Forms.Platform.iOS.OpenGLViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1642E /* #4317 'Xamarin_Forms_Platform_iOS_PickerRendererBase_1_PickerSource' => 'Xamarin.Forms.Platform.iOS.PickerRendererBase`1+PickerSource, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5C2E /* #4318 'Xamarin_Forms_Platform_iOS_TabbedRenderer' => 'Xamarin.Forms.Platform.iOS.TabbedRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1782E /* #4319 'Xamarin_Forms_Platform_iOS_DragAndDropDelegate_CustomLocalStateData' => 'Xamarin.Forms.Platform.iOS.DragAndDropDelegate+CustomLocalStateData, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x912E /* #4320 'Xamarin_Forms_Platform_iOS_DragAndDropDelegate' => 'Xamarin.Forms.Platform.iOS.DragAndDropDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9B2E /* #4321 'Xamarin_Forms_Platform_iOS_ModalWrapper' => 'Xamarin.Forms.Platform.iOS.ModalWrapper, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18A2E /* #4322 'Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer_ChildViewController' => 'Xamarin.Forms.Platform.iOS.PhoneFlyoutPageRenderer+ChildViewController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18F2E /* #4323 'Xamarin_Forms_Platform_iOS_EventedViewController_FlyoutView' => 'Xamarin.Forms.Platform.iOS.EventedViewController+FlyoutView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAF2E /* #4324 'Xamarin_Forms_Platform_iOS_EventedViewController' => 'Xamarin.Forms.Platform.iOS.EventedViewController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1902E /* #4325 'Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer_InnerDelegate' => 'Xamarin.Forms.Platform.iOS.TabletFlyoutPageRenderer+InnerDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xC22E /* #4326 'Xamarin_Forms_Platform_iOS_ShellFlyoutContentRenderer' => 'Xamarin.Forms.Platform.iOS.ShellFlyoutContentRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xC32E /* #4327 'Xamarin_Forms_Platform_iOS_ShellFlyoutRenderer' => 'Xamarin.Forms.Platform.iOS.ShellFlyoutRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1A32E /* #4328 'Xamarin_Forms_Platform_iOS_ShellPageRendererTracker_TitleViewContainer' => 'Xamarin.Forms.Platform.iOS.ShellPageRendererTracker+TitleViewContainer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xC72E /* #4329 'Xamarin_Forms_Platform_iOS_ShellRenderer' => 'Xamarin.Forms.Platform.iOS.ShellRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B22E /* #4330 'Xamarin_Forms_Platform_iOS_ShellSectionRootHeader_ShellSectionHeaderCell' => 'Xamarin.Forms.Platform.iOS.ShellSectionRootHeader+ShellSectionHeaderCell, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCA2E /* #4331 'Xamarin_Forms_Platform_iOS_ShellSectionRootHeader' => 'Xamarin.Forms.Platform.iOS.ShellSectionRootHeader, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCB2E /* #4332 'Xamarin_Forms_Platform_iOS_ShellSectionRootRenderer' => 'Xamarin.Forms.Platform.iOS.ShellSectionRootRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B52E /* #4333 'Xamarin_Forms_Platform_iOS_ShellSectionRenderer_GestureDelegate' => 'Xamarin.Forms.Platform.iOS.ShellSectionRenderer+GestureDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B62E /* #4334 'Xamarin_Forms_Platform_iOS_ShellSectionRenderer_NavDelegate' => 'Xamarin.Forms.Platform.iOS.ShellSectionRenderer+NavDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCD2E /* #4335 'Xamarin_Forms_Platform_iOS_ShellSectionRenderer' => 'Xamarin.Forms.Platform.iOS.ShellSectionRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1BD2E /* #4336 'Xamarin_Forms_Platform_iOS_ShellTableViewSource_SeparatorView' => 'Xamarin.Forms.Platform.iOS.ShellTableViewSource+SeparatorView, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCF2E /* #4337 'Xamarin_Forms_Platform_iOS_ShellTableViewSource' => 'Xamarin.Forms.Platform.iOS.ShellTableViewSource, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xD72E /* #4338 'Xamarin_Forms_Platform_iOS_ImageButtonRenderer' => 'Xamarin.Forms.Platform.iOS.ImageButtonRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF12E /* #4339 'Xamarin_Forms_Platform_iOS_SwipeViewRenderer' => 'Xamarin.Forms.Platform.iOS.SwipeViewRenderer, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1392E /* #4340 'Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_PrimaryToolbarItem' => 'Xamarin.Forms.Platform.iOS.ToolbarItemExtensions+PrimaryToolbarItem, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1DE2E /* #4341 'Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem_SecondaryToolbarItemContent' => 'Xamarin.Forms.Platform.iOS.ToolbarItemExtensions+SecondaryToolbarItem+SecondaryToolbarItemContent, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x13A2E /* #4342 'Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem' => 'Xamarin.Forms.Platform.iOS.ToolbarItemExtensions+SecondaryToolbarItem, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1542E /* #4343 'Xamarin_Forms_Platform_iOS_NavigationRenderer_SecondaryToolbar' => 'Xamarin.Forms.Platform.iOS.NavigationRenderer+SecondaryToolbar, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1552E /* #4344 'Xamarin_Forms_Platform_iOS_NavigationRenderer_ParentingViewController' => 'Xamarin.Forms.Platform.iOS.NavigationRenderer+ParentingViewController, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1912E /* #4345 'Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewNavigationDelegate' => 'Xamarin.Forms.Platform.iOS.WkWebViewRenderer+CustomWebViewNavigationDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1922E /* #4346 'Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewUIDelegate' => 'Xamarin.Forms.Platform.iOS.WkWebViewRenderer+CustomWebViewUIDelegate, Xamarin.Forms.Platform.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1542 /* #4347 'Plugin_FirebasePushNotification_FirebasePushNotificationManager' => 'Plugin.FirebasePushNotification.FirebasePushNotificationManager, Plugin.FirebasePushNotification' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1644 /* #4348 'FIRMessagingMessageInfo' => 'Firebase.CloudMessaging.MessageInfo, Firebase.CloudMessaging' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x2A44 /* #4349 'ApiDefinition__Firebase_CloudMessaging_MessagingDelegate' => 'Firebase.CloudMessaging.MessagingDelegate, Firebase.CloudMessaging' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x2B44 /* #4350 'FIRMessagingExtensionHelper' => 'Firebase.CloudMessaging.MessagingExtensionHelper, Firebase.CloudMessaging' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x2C44 /* #4351 'FIRMessagingRemoteMessage' => 'Firebase.CloudMessaging.RemoteMessage, Firebase.CloudMessaging' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x1744 /* #4352 'FIRMessaging' => 'Firebase.CloudMessaging.Messaging, Firebase.CloudMessaging' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x746 /* #4353 'FIRApp' => 'Firebase.Core.App, Firebase.Core' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0xA46 /* #4354 'FIRConfiguration' => 'Firebase.Core.Configuration, Firebase.Core' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0xB46 /* #4355 'FIROptions' => 'Firebase.Core.Options, Firebase.Core' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x1A48 /* #4356 'FIRInstallationsAuthTokenResult' => 'Firebase.Installations.InstallationsAuthTokenResult, Firebase.Installations' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0xF48 /* #4357 'FIRInstallations' => 'Firebase.Installations.Installations, Firebase.Installations' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x214A /* #4358 'FIRInstanceIDResult' => 'Firebase.InstanceID.InstanceIdResult, Firebase.InstanceID' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x174A /* #4359 'FIRInstanceID' => 'Firebase.InstanceID.InstanceId, Firebase.InstanceID' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x10F4C /* #4360 'Xamarin_Essentials_ShareActivityItemSource' => 'Xamarin.Essentials.ShareActivityItemSource, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1104C /* #4361 'Xamarin_Essentials_AuthManager' => 'Xamarin.Essentials.AuthManager, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1154C /* #4362 'Xamarin_Essentials_SingleLocationListener' => 'Xamarin.Essentials.SingleLocationListener, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x304C /* #4363 'Xamarin_Essentials_Contacts_ContactPickerDelegate' => 'Xamarin.Essentials.Contacts+ContactPickerDelegate, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x424C /* #4364 'Xamarin_Essentials_FilePicker_PickerDelegate' => 'Xamarin.Essentials.FilePicker+PickerDelegate, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x784C /* #4365 'Xamarin_Essentials_MediaPicker_PhotoPickerDelegate' => 'Xamarin.Essentials.MediaPicker+PhotoPickerDelegate, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xBB4C /* #4366 'Xamarin_Essentials_Platform_UIPresentationControllerDelegate' => 'Xamarin.Essentials.Platform+UIPresentationControllerDelegate, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1004C /* #4367 'Xamarin_Essentials_WebAuthenticator_NativeSFSafariViewControllerDelegate' => 'Xamarin.Essentials.WebAuthenticator+NativeSFSafariViewControllerDelegate, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1014C /* #4368 'Xamarin_Essentials_WebAuthenticator_ContextProvider' => 'Xamarin.Essentials.WebAuthenticator+ContextProvider, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x934C /* #4369 'Xamarin_Essentials_Permissions_LocationWhenInUse_ManagerDelegate' => 'Xamarin.Essentials.Permissions+LocationWhenInUse+ManagerDelegate, Xamarin.Essentials' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x10F4E /* #4370 'OpenTK_Platform_iPhoneOS_CADisplayLinkTimeSource' => 'OpenTK.Platform.iPhoneOS.CADisplayLinkTimeSource, OpenTK-1.0' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1114E /* #4371 'OpenTK_Platform_iPhoneOS_iPhoneOSGameView' => 'OpenTK.Platform.iPhoneOS.iPhoneOSGameView, OpenTK-1.0' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xE50 /* #4372 'Xamarin_Forms_PancakeView_iOS_PancakeViewRenderer' => 'Xamarin.Forms.PancakeView.iOS.PancakeViewRenderer, Xamarin.Forms.PancakeView' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5B4 /* #4373 'Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeRoundedStackView' => 'Xamarin.CommunityToolkit.Views.Snackbar.Helpers.NativeRoundedStackView, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7B4 /* #4374 'Xamarin_CommunityToolkit_iOS_UI_Views_SideMenuViewRenderer' => 'Xamarin.CommunityToolkit.iOS.UI.Views.SideMenuViewRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14B4 /* #4375 'Xamarin_CommunityToolkit_iOS_Effects_TouchEventsGestureRecognizer' => 'Xamarin.CommunityToolkit.iOS.Effects.TouchEventsGestureRecognizer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x16B4 /* #4376 'Xamarin_CommunityToolkit_iOS_Effects_ShouldRecognizeSimultaneouslyRecognizerDelegate' => 'Xamarin.CommunityToolkit.iOS.Effects.ShouldRecognizeSimultaneouslyRecognizerDelegate, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x68B4 /* #4377 'Xamarin_CommunityToolkit_UI_Views_PhotoCaptureDelegate' => 'Xamarin.CommunityToolkit.UI.Views.PhotoCaptureDelegate, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6CB4 /* #4378 'Xamarin_CommunityToolkit_UI_Views_MediaElementRenderer' => 'Xamarin.CommunityToolkit.UI.Views.MediaElementRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6EB4 /* #4379 'Xamarin_CommunityToolkit_UI_Views_SemanticOrderViewRenderer' => 'Xamarin.CommunityToolkit.UI.Views.SemanticOrderViewRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6FB4 /* #4380 'Xamarin_CommunityToolkit_UI_Views_ImageSwitcherRenderer' => 'Xamarin.CommunityToolkit.UI.Views.ImageSwitcherRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x70B4 /* #4381 'Xamarin_CommunityToolkit_UI_Views_TextSwitcherRenderer' => 'Xamarin.CommunityToolkit.UI.Views.TextSwitcherRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x73B4 /* #4382 'Xamarin_CommunityToolkit_UI_Views_Helpers_PaddedLabel' => 'Xamarin.CommunityToolkit.UI.Views.Helpers.PaddedLabel, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x79B4 /* #4383 'Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBar_BaseSnackBarView' => 'Xamarin.CommunityToolkit.UI.Views.Helpers.iOS.SnackBar.BaseSnackBarView, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x78B4 /* #4384 'Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBarViews_MessageSnackBarView' => 'Xamarin.CommunityToolkit.UI.Views.Helpers.iOS.SnackBarViews.MessageSnackBarView, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x77B4 /* #4385 'Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_ActionMessageSnackBarView' => 'Xamarin.CommunityToolkit.UI.Views.Helpers.iOS.ActionMessageSnackBarView, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6B4 /* #4386 'Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeSnackButton' => 'Xamarin.CommunityToolkit.Views.Snackbar.Helpers.NativeSnackButton, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x11B4 /* #4387 'Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizer' => 'Xamarin.CommunityToolkit.iOS.Effects.TouchUITapGestureRecognizer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12B4 /* #4388 'Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizerDelegate' => 'Xamarin.CommunityToolkit.iOS.Effects.TouchUITapGestureRecognizerDelegate, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x66B4 /* #4389 'Xamarin_CommunityToolkit_UI_Views_CameraViewRenderer' => 'Xamarin.CommunityToolkit.UI.Views.CameraViewRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x67B4 /* #4390 'Xamarin_CommunityToolkit_UI_Views_FormsCameraView' => 'Xamarin.CommunityToolkit.UI.Views.FormsCameraView, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x69B4 /* #4391 'Xamarin_CommunityToolkit_UI_Views_DrawingViewRenderer' => 'Xamarin.CommunityToolkit.UI.Views.DrawingViewRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x17CB4 /* #4392 'Xamarin_CommunityToolkit_UI_Views_PopupRenderer_PopoverDelegate' => 'Xamarin.CommunityToolkit.UI.Views.PopupRenderer+PopoverDelegate, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6DB4 /* #4393 'Xamarin_CommunityToolkit_UI_Views_PopupRenderer' => 'Xamarin.CommunityToolkit.UI.Views.PopupRenderer, Xamarin.CommunityToolkit' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2C6 /* #4394 'ImageCircle_Forms_Plugin_iOS_ImageCircleRenderer' => 'ImageCircle.Forms.Plugin.iOS.ImageCircleRenderer, ImageCircle.Forms.Plugin' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8CA /* #4395 'AiForms_Effects_iOS_NumberPickerSource' => 'AiForms.Effects.iOS.NumberPickerSource, AiForms.Effects.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xACA /* #4396 'AiForms_Effects_iOS_PaddingLabel' => 'AiForms.Effects.iOS.PaddingLabel, AiForms.Effects.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x11CA /* #4397 'AiForms_Effects_iOS_NoCaretField' => 'AiForms.Effects.iOS.NoCaretField, AiForms.Effects.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x16CA /* #4398 'AiForms_Effects_iOS_TouchEffectGestureRecognizer' => 'AiForms.Effects.iOS.TouchEffectGestureRecognizer, AiForms.Effects.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18CA /* #4399 'AiForms_Effects_iOS_AlwaysSimultaneouslyGestureRecognizerDelegate' => 'AiForms.Effects.iOS.AlwaysSimultaneouslyGestureRecognizerDelegate, AiForms.Effects.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9CC /* #4400 'IQKeyboardManager' => 'Xamarin.IQKeyboardManager, IQKeyboardManager' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0xACC /* #4401 'IQKeyboardReturnKeyHandler' => 'Xamarin.IQKeyboardReturnKeyHandler, IQKeyboardManager' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x8CC /* #4402 'Xamarin_IQBarButtonItem_IQBarButtonItemAppearance' => 'Xamarin.IQBarButtonItem+IQBarButtonItemAppearance, IQKeyboardManager' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7CC /* #4403 'IQBarButtonItem' => 'Xamarin.IQBarButtonItem, IQKeyboardManager' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0xCCC /* #4404 'Xamarin_IQPreviousNextView_IQPreviousNextViewAppearance' => 'Xamarin.IQPreviousNextView+IQPreviousNextViewAppearance, IQKeyboardManager' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xBCC /* #4405 'IQPreviousNextView' => 'Xamarin.IQPreviousNextView, IQKeyboardManager' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0xECC /* #4406 'Xamarin_IQTextView_IQTextViewAppearance' => 'Xamarin.IQTextView+IQTextViewAppearance, IQKeyboardManager' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDCC /* #4407 'IQTextView' => 'Xamarin.IQTextView, IQKeyboardManager' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x10CC /* #4408 'Xamarin_IQTitleBarButtonItem_IQTitleBarButtonItemAppearance' => 'Xamarin.IQTitleBarButtonItem+IQTitleBarButtonItemAppearance, IQKeyboardManager' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xFCC /* #4409 'IQTitleBarButtonItem' => 'Xamarin.IQTitleBarButtonItem, IQKeyboardManager' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x12CC /* #4410 'Xamarin_IQToolbar_IQToolbarAppearance' => 'Xamarin.IQToolbar+IQToolbarAppearance, IQKeyboardManager' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x11CC /* #4411 'IQToolbar' => 'Xamarin.IQToolbar, IQKeyboardManager' */, (MTTypeFlags) (1) /* CustomType */ },
		{ NULL, 0x1ACC /* #4412 'Xamarin_UIView_IQToolbarAddition_UIView_IQToolbarAdditionAppearance' => 'Xamarin.UIView_IQToolbarAddition+UIView_IQToolbarAdditionAppearance, IQKeyboardManager' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2CE /* #4413 'SVG_Forms_Plugin_iOS_SvgImageRenderer' => 'SVG.Forms.Plugin.iOS.SvgImageRenderer, SVG.Forms.Plugin.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x19D8 /* #4414 'Syncfusion_SfPdfViewer_XForms_iOS_InkViewPanGestureDelegate' => 'Syncfusion.SfPdfViewer.XForms.iOS.InkViewPanGestureDelegate, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1AD8 /* #4415 'Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBorder' => 'Syncfusion.SfPdfViewer.XForms.iOS.CustomViewBorder, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1BD8 /* #4416 'Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBubble' => 'Syncfusion.SfPdfViewer.XForms.iOS.CustomViewBubble, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1DD8 /* #4417 'Syncfusion_SfPdfViewer_XForms_iOS_CustomViewHolder' => 'Syncfusion.SfPdfViewer.XForms.iOS.CustomViewHolder, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1ED8 /* #4418 'Syncfusion_SfPdfViewer_XForms_iOS_CustomViewSelection' => 'Syncfusion.SfPdfViewer.XForms.iOS.CustomViewSelection, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x23D8 /* #4419 'Syncfusion_SfPdfViewer_XForms_iOS_StampIcon' => 'Syncfusion.SfPdfViewer.XForms.iOS.StampIcon, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x24D8 /* #4420 'Syncfusion_SfPdfViewer_XForms_iOS_TextBubbleView' => 'Syncfusion.SfPdfViewer.XForms.iOS.TextBubbleView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25D8 /* #4421 'Syncfusion_SfPdfViewer_XForms_iOS_SelectionBorderView' => 'Syncfusion.SfPdfViewer.XForms.iOS.SelectionBorderView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x26D8 /* #4422 'Syncfusion_SfPdfViewer_XForms_iOS_TextSelectionView' => 'Syncfusion.SfPdfViewer.XForms.iOS.TextSelectionView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x27D8 /* #4423 'Syncfusion_SfPdfViewer_XForms_iOS_TextView' => 'Syncfusion.SfPdfViewer.XForms.iOS.TextView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x28D8 /* #4424 'Syncfusion_SfPdfViewer_XForms_iOS_ListPopupView' => 'Syncfusion.SfPdfViewer.XForms.iOS.ListPopupView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x29D8 /* #4425 'Syncfusion_SfPdfViewer_XForms_iOS_PopupListCell' => 'Syncfusion.SfPdfViewer.XForms.iOS.PopupListCell, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2AD8 /* #4426 'Syncfusion_SfPdfViewer_XForms_iOS_PopupListSource' => 'Syncfusion.SfPdfViewer.XForms.iOS.PopupListSource, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2BD8 /* #4427 'Syncfusion_SfPdfViewer_XForms_iOS_PdfWidget' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfWidget, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2DD8 /* #4428 'Syncfusion_SfPdfViewer_XForms_iOS_PdfTextField' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfTextField, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2ED8 /* #4429 'Syncfusion_SfPdfViewer_XForms_iOS_PdfTextFieldDelegate' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfTextFieldDelegate, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2FD8 /* #4430 'Syncfusion_SfPdfViewer_XForms_iOS_PdfCheckBox' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfCheckBox, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x30D8 /* #4431 'Syncfusion_SfPdfViewer_XForms_iOS_PdfComboBox' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfComboBox, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x31D8 /* #4432 'Syncfusion_SfPdfViewer_XForms_iOS_PdfListBox' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfListBox, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x32D8 /* #4433 'Syncfusion_SfPdfViewer_XForms_iOS_ListBoxSource' => 'Syncfusion.SfPdfViewer.XForms.iOS.ListBoxSource, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x33D8 /* #4434 'Syncfusion_SfPdfViewer_XForms_iOS_PdfRadioButton' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfRadioButton, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x41D8 /* #4435 'Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectBorderView' => 'Syncfusion.SfPdfViewer.XForms.iOS.ShapeSelectBorderView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x44D8 /* #4436 'Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectionView' => 'Syncfusion.SfPdfViewer.XForms.iOS.ShapeSelectionView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x45D8 /* #4437 'Syncfusion_SfPdfViewer_XForms_iOS_SignaturePad' => 'Syncfusion.SfPdfViewer.XForms.iOS.SignaturePad, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x46D8 /* #4438 'Syncfusion_SfPdfViewer_XForms_iOS_SignatureView' => 'Syncfusion.SfPdfViewer.XForms.iOS.SignatureView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x50D8 /* #4439 'PdfContentView' => 'Syncfusion.SfPdfViewer.XForms.iOS.ContentViewEx, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5BD8 /* #4440 'CurrentHighlightedView' => 'Syncfusion.SfPdfViewer.XForms.iOS.HighlightedView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5DD8 /* #4441 'Syncfusion_SfPdfViewer_XForms_iOS_AlertViewDelegate' => 'Syncfusion.SfPdfViewer.XForms.iOS.AlertViewDelegate, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5FD8 /* #4442 'Syncfusion_SfPdfViewer_XForms_iOS_AlertViewTextBoxDelegate' => 'Syncfusion.SfPdfViewer.XForms.iOS.AlertViewTextBoxDelegate, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x61D8 /* #4443 'Syncfusion_SfPdfViewer_XForms_iOS_CustomSearchRenderer' => 'Syncfusion.SfPdfViewer.XForms.iOS.CustomSearchRenderer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x62D8 /* #4444 'Syncfusion_SfPdfViewer_XForms_iOS_CustomPageRenderer' => 'Syncfusion.SfPdfViewer.XForms.iOS.CustomPageRenderer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x64D8 /* #4445 'Syncfusion_SfPdfViewer_XForms_iOS_EditTextPopup' => 'Syncfusion.SfPdfViewer.XForms.iOS.EditTextPopup, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x65D8 /* #4446 'Syncfusion_SfPdfViewer_XForms_iOS_HyperlinkAnnotation' => 'Syncfusion.SfPdfViewer.XForms.iOS.HyperlinkAnnotation, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x67D8 /* #4447 'Syncfusion_SfPdfViewer_XForms_iOS_BubbleView' => 'Syncfusion.SfPdfViewer.XForms.iOS.BubbleView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6DD8 /* #4448 'Syncfusion_SfPdfViewer_XForms_iOS_InkSetting' => 'Syncfusion.SfPdfViewer.XForms.iOS.InkSetting, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x70D8 /* #4449 'Syncfusion_SfPdfViewer_XForms_iOS_SelectBorderView' => 'Syncfusion.SfPdfViewer.XForms.iOS.SelectBorderView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x72D8 /* #4450 'Syncfusion_SfPdfViewer_XForms_iOS_SelectionView' => 'Syncfusion.SfPdfViewer.XForms.iOS.SelectionView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x74D8 /* #4451 'Syncfusion_SfPdfViewer_XForms_iOS_PasswordDialogView' => 'Syncfusion.SfPdfViewer.XForms.iOS.PasswordDialogView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x75D8 /* #4452 'Syncfusion_SfPdfViewer_XForms_iOS_SfLabelRendererIOS' => 'Syncfusion.SfPdfViewer.XForms.iOS.SfLabelRendererIOS, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x77D8 /* #4453 'Syncfusion_SfPdfViewer_XForms_iOS_SfFontButtonRenderer' => 'Syncfusion.SfPdfViewer.XForms.iOS.SfFontButtonRenderer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x79D8 /* #4454 'Syncfusion_SfPdfViewer_XForms_iOS_SfPdfDocumentViewRenderer' => 'Syncfusion.SfPdfViewer.XForms.iOS.SfPdfDocumentViewRenderer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7AD8 /* #4455 'Syncfusion_SfPdfViewer_XForms_iOS_MaterialSfPdfDocumentViewRenderer' => 'Syncfusion.SfPdfViewer.XForms.iOS.MaterialSfPdfDocumentViewRenderer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7FD8 /* #4456 'Syncfusion_SfPdfViewer_XForms_iOS_CustomStackLayoutRendereriOS' => 'Syncfusion.SfPdfViewer.XForms.iOS.CustomStackLayoutRendereriOS, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x80D8 /* #4457 'Syncfusion_SfPdfViewer_XForms_iOS_SliderCustomRenderer' => 'Syncfusion.SfPdfViewer.XForms.iOS.SliderCustomRenderer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x83D8 /* #4458 'Syncfusion_SfPdfViewer_XForms_iOS_ImageAndCanvasContainer' => 'Syncfusion.SfPdfViewer.XForms.iOS.ImageAndCanvasContainer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x86D8 /* #4459 'Syncfusion_SfPdfViewer_XForms_iOS_PageScrollView' => 'Syncfusion.SfPdfViewer.XForms.iOS.PageScrollView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x87D8 /* #4460 'Syncfusion_SfPdfViewer_XForms_iOS_PageScrollViewContainer' => 'Syncfusion.SfPdfViewer.XForms.iOS.PageScrollViewContainer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8AD8 /* #4461 'Syncfusion_SfPdfViewer_XForms_iOS_SinglePageViewer' => 'Syncfusion.SfPdfViewer.XForms.iOS.SinglePageViewer, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8DD8 /* #4462 'Syncfusion_SfPdfViewer_XForms_iOS_SfPdfVieweriOS' => 'Syncfusion.SfPdfViewer.XForms.iOS.SfPdfVieweriOS, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8ED8 /* #4463 'Syncfusion_SfPdfViewer_XForms_iOS_PasswordTextFieldDelegate' => 'Syncfusion.SfPdfViewer.XForms.iOS.PasswordTextFieldDelegate, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18D8 /* #4464 'Syncfusion_SfPdfViewer_XForms_iOS_PdfButton' => 'Syncfusion.SfPdfViewer.XForms.iOS.PdfButton, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x22D8 /* #4465 'Syncfusion_SfPdfViewer_XForms_iOS_StampRendererView' => 'Syncfusion.SfPdfViewer.XForms.iOS.StampRendererView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x34D8 /* #4466 'Syncfusion_SfPdfViewer_XForms_iOS_SignatureField' => 'Syncfusion.SfPdfViewer.XForms.iOS.SignatureField, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x37D8 /* #4467 'Syncfusion_SfPdfViewer_XForms_iOS_ArrowAnnotationSettings' => 'Syncfusion.SfPdfViewer.XForms.iOS.ArrowAnnotationSettings, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x38D8 /* #4468 'Syncfusion_SfPdfViewer_XForms_iOS_CircleAnnotationSettings' => 'Syncfusion.SfPdfViewer.XForms.iOS.CircleAnnotationSettings, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3AD8 /* #4469 'Syncfusion_SfPdfViewer_XForms_iOS_DummyView' => 'Syncfusion.SfPdfViewer.XForms.iOS.DummyView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3CD8 /* #4470 'Syncfusion_SfPdfViewer_XForms_iOS_LineAnnotationSettings' => 'Syncfusion.SfPdfViewer.XForms.iOS.LineAnnotationSettings, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3DD8 /* #4471 'Syncfusion_SfPdfViewer_XForms_iOS_PolygonAnnotationView' => 'Syncfusion.SfPdfViewer.XForms.iOS.PolygonAnnotationView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x40D8 /* #4472 'Syncfusion_SfPdfViewer_XForms_iOS_RectangleAnnotationSettings' => 'Syncfusion.SfPdfViewer.XForms.iOS.RectangleAnnotationSettings, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x42D8 /* #4473 'Syncfusion_SfPdfViewer_XForms_iOS_ShapeBubbleView' => 'Syncfusion.SfPdfViewer.XForms.iOS.ShapeBubbleView, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x51D8 /* #4474 'Syncfusion_SfPdfViewer_XForms_iOS_ImageViewEx' => 'Syncfusion.SfPdfViewer.XForms.iOS.ImageViewEx, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x53D8 /* #4475 'Syncfusion_SfPdfViewer_XForms_iOS_ScrollHead' => 'Syncfusion.SfPdfViewer.XForms.iOS.ScrollHead, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x54D8 /* #4476 'Syncfusion_SfPdfViewer_XForms_iOS_ScrollViewEx' => 'Syncfusion.SfPdfViewer.XForms.iOS.ScrollViewEx, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x59D8 /* #4477 'Syncfusion_SfPdfViewer_XForms_iOS_StackViewEx' => 'Syncfusion.SfPdfViewer.XForms.iOS.StackViewEx, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5AD8 /* #4478 'TransparentCanvas' => 'Syncfusion.SfPdfViewer.XForms.iOS.TransparentCanvas, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6CD8 /* #4479 'Syncfusion_SfPdfViewer_XForms_iOS_InkGroup' => 'Syncfusion.SfPdfViewer.XForms.iOS.InkGroup, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7ED8 /* #4480 'Bubble' => 'Syncfusion.SfPdfViewer.XForms.iOS.Bubble, Syncfusion.SfPdfViewer.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5DA /* #4481 'SfBusyIndicator' => 'Syncfusion.SfBusyIndicator.iOS.SfBusyIndicator, Syncfusion.SfBusyIndicator.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4DA /* #4482 'Syncfusion_SfBusyIndicator_iOS_SFBusyIndicator' => 'Syncfusion.SfBusyIndicator.iOS.SFBusyIndicator, Syncfusion.SfBusyIndicator.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3DC /* #4483 'Syncfusion_XForms_iOS_Graphics_SfGradientViewRenderer' => 'Syncfusion.XForms.iOS.Graphics.SfGradientViewRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5DC /* #4484 'Syncfusion_XForms_iOS_Shimmer_SfShimmerRenderer' => 'Syncfusion.XForms.iOS.Shimmer.SfShimmerRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6DC /* #4485 'Syncfusion_XForms_iOS_Shimmer_ShimmerViewRenderer' => 'Syncfusion.XForms.iOS.Shimmer.ShimmerViewRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7DC /* #4486 'Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorderRenderer' => 'Syncfusion.XForms.iOS.TextInputLayout.InputLayoutBorderRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8DC /* #4487 'Syncfusion_XForms_iOS_TextInputLayout_InputLayoutToggleViewRenderer' => 'Syncfusion.XForms.iOS.TextInputLayout.InputLayoutToggleViewRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9DC /* #4488 'Syncfusion_XForms_iOS_TextInputLayout_SfTextInputLayoutRenderer' => 'Syncfusion.XForms.iOS.TextInputLayout.SfTextInputLayoutRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xADC /* #4489 'Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorder' => 'Syncfusion.XForms.iOS.TextInputLayout.InputLayoutBorder, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xBDC /* #4490 'Syncfusion_XForms_iOS_TextInputLayout_InputLayoutClearButtonViewRenderer' => 'Syncfusion.XForms.iOS.TextInputLayout.InputLayoutClearButtonViewRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x10DC /* #4491 'Syncfusion_XForms_iOS_Core_FontIconLabelRenderer' => 'Syncfusion.XForms.iOS.Core.FontIconLabelRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x19DC /* #4492 'Syncfusion_XForms_iOS_EffectsView_SfEffectsViewLayer' => 'Syncfusion.XForms.iOS.EffectsView.SfEffectsViewLayer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4DC /* #4493 'Syncfusion_XForms_iOS_Shimmer_ShimmerWaveLayer' => 'Syncfusion.XForms.iOS.Shimmer.ShimmerWaveLayer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDDC /* #4494 'Syncfusion_XForms_iOS_Border_SfBorderRenderer' => 'Syncfusion.XForms.iOS.Border.SfBorderRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18DC /* #4495 'Syncfusion_XForms_iOS_EffectsView_SfEffectsViewRenderer' => 'Syncfusion.XForms.iOS.EffectsView.SfEffectsViewRenderer, Syncfusion.Core.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3DE /* #4496 'Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderRenderer' => 'Syncfusion.SfRangeSlider.XForms.iOS.SfRangeSliderRenderer, Syncfusion.SfRangeSlider.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4DE /* #4497 'Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderVisualRenderer' => 'Syncfusion.SfRangeSlider.XForms.iOS.SfRangeSliderVisualRenderer, Syncfusion.SfRangeSlider.XForms.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAE0 /* #4498 'Syncfusion_SfRangeSlider_iOS_SfLabelItems' => 'Syncfusion.SfRangeSlider.iOS.SfLabelItems, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9E0 /* #4499 'Syncfusion_SfRangeSlider_iOS_SFLabelItems' => 'Syncfusion.SfRangeSlider.iOS.SFLabelItems, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xBE0 /* #4500 'Syncfusion_SfRangeSlider_iOS_SfRangeKnobLayer' => 'Syncfusion.SfRangeSlider.iOS.SfRangeKnobLayer, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xDE0 /* #4501 'SfRangeSlider' => 'Syncfusion.SfRangeSlider.iOS.SfRangeSlider, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCE0 /* #4502 'Syncfusion_SfRangeSlider_iOS_SFRangeSlider' => 'Syncfusion.SfRangeSlider.iOS.SFRangeSlider, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14E0 /* #4503 'Syncfusion_SfRangeSlider_iOS_SfRangeTickLayer' => 'Syncfusion.SfRangeSlider.iOS.SfRangeTickLayer, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x15E0 /* #4504 'Syncfusion_SfRangeSlider_iOS_SfRangeTracker' => 'Syncfusion.SfRangeSlider.iOS.SfRangeTracker, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x17E0 /* #4505 'Syncfusion_SfRangeSlider_iOS_SfThumb' => 'Syncfusion.SfRangeSlider.iOS.SfThumb, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x16E0 /* #4506 'Syncfusion_SfRangeSlider_iOS_SFThumb' => 'Syncfusion.SfRangeSlider.iOS.SFThumb, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x19E0 /* #4507 'Syncfusion_SfRangeSlider_iOS_SfThumbItem' => 'Syncfusion.SfRangeSlider.iOS.SfThumbItem, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18E0 /* #4508 'Syncfusion_SfRangeSlider_iOS_SFThumbItem' => 'Syncfusion.SfRangeSlider.iOS.SFThumbItem, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1AE0 /* #4509 'Syncfusion_SfRangeSlider_iOS_CustomRangePanGesture' => 'Syncfusion.SfRangeSlider.iOS.CustomRangePanGesture, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1BE0 /* #4510 'Syncfusion_SfRangeSlider_iOS_BalloonLayer' => 'Syncfusion.SfRangeSlider.iOS.BalloonLayer, Syncfusion.SfRangeSlider.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2E2 /* #4511 'XamForms_Controls_iOS_CalendarButtonRenderer' => 'XamForms.Controls.iOS.CalendarButtonRenderer, XamForms.Controls.Calendar.iOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0 },
	};

	static const MTManagedClassMap __xamarin_skipped_map [] = {
		{ 0x2B722, 0x14E222 /* 'WatchKit.WKAccessibilityImageRegion' => 'Foundation.NSObject' */ },
		{ 0x2BB22, 0x14E222 /* 'WatchKit.WKInterfaceButton' => 'Foundation.NSObject' */ },
		{ 0x2BC22, 0x14E222 /* 'WatchKit.WKInterfaceController' => 'Foundation.NSObject' */ },
		{ 0x2BC22, 0x14E222 /* 'WatchKit.WKInterfaceController' => 'Foundation.NSObject' */ },
		{ 0x2BE22, 0x14E222 /* 'WatchKit.WKInterfaceDate' => 'Foundation.NSObject' */ },
		{ 0x2BF22, 0x14E222 /* 'WatchKit.WKInterfaceDevice' => 'Foundation.NSObject' */ },
		{ 0x2C022, 0x14E222 /* 'WatchKit.WKInterfaceGroup' => 'Foundation.NSObject' */ },
		{ 0x2C122, 0x14E222 /* 'WatchKit.WKInterfaceImage' => 'Foundation.NSObject' */ },
		{ 0x2C222, 0x14E222 /* 'WatchKit.WKInterfaceLabel' => 'Foundation.NSObject' */ },
		{ 0x2C322, 0x14E222 /* 'WatchKit.WKInterfaceMap' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C522, 0x14E222 /* 'WatchKit.WKInterfaceObject' => 'Foundation.NSObject' */ },
		{ 0x2C622, 0x14E222 /* 'WatchKit.WKInterfaceSeparator' => 'Foundation.NSObject' */ },
		{ 0x2C722, 0x14E222 /* 'WatchKit.WKInterfaceSlider' => 'Foundation.NSObject' */ },
		{ 0x2C822, 0x14E222 /* 'WatchKit.WKInterfaceSwitch' => 'Foundation.NSObject' */ },
		{ 0x2C922, 0x14E222 /* 'WatchKit.WKInterfaceTable' => 'Foundation.NSObject' */ },
		{ 0x2CA22, 0x14E222 /* 'WatchKit.WKInterfaceTimer' => 'Foundation.NSObject' */ },
		{ 0x2CD22, 0x14E222 /* 'WatchKit.WKUserNotificationInterfaceController' => 'Foundation.NSObject' */ },
		{ 0xE6622, 0xE6722 /* 'Intents.INIntentResolutionResult`1' => 'Intents.INIntentResolutionResult' */ },
		{ 0x112522, 0x14E222 /* 'HomeKit.HMChipServiceRequestHandler' => 'Foundation.NSObject' */ },
		{ 0x112622, 0x14E222 /* 'HomeKit.HMChipServiceTopology' => 'Foundation.NSObject' */ },
		{ 0x112722, 0x14E222 /* 'HomeKit.HMChipServiceRoom' => 'Foundation.NSObject' */ },
		{ 0x112822, 0x14E222 /* 'HomeKit.HMChipServiceHome' => 'Foundation.NSObject' */ },
		{ 0x112A22, 0x14E222 /* 'HomeKit.HMMatterRoom' => 'Foundation.NSObject' */ },
		{ 0x112B22, 0x14E222 /* 'HomeKit.HMMatterHome' => 'Foundation.NSObject' */ },
		{ 0x112C22, 0x14E222 /* 'HomeKit.HMMatterTopology' => 'Foundation.NSObject' */ },
		{ 0x112E22, 0x14E222 /* 'HomeKit.HMMatterRequestHandler' => 'Foundation.NSObject' */ },
		{ 0x12AE22, 0x12AD22 /* 'GameplayKit.GKObstacleGraph`1' => 'GameplayKit.GKObstacleGraph' */ },
		{ 0x14A922, 0x14A822 /* 'Foundation.NSArray`1' => 'Foundation.NSArray' */ },
		{ 0x14B722, 0x14B622 /* 'Foundation.NSDictionary`2' => 'Foundation.NSDictionary' */ },
		{ 0x14BB22, 0x157122 /* 'Foundation.NSEnumerator`1' => 'Foundation.NSEnumerator' */ },
		{ 0x14D222, 0x15E122 /* 'Foundation.NSMutableArray`1' => 'Foundation.NSMutableArray' */ },
		{ 0x14D622, 0x14D522 /* 'Foundation.NSMutableDictionary`2' => 'Foundation.NSMutableDictionary' */ },
		{ 0x14D722, 0x14E722 /* 'Foundation.NSMutableOrderedSet`1' => 'Foundation.NSMutableOrderedSet' */ },
		{ 0x14D922, 0x14D822 /* 'Foundation.NSMutableSet`1' => 'Foundation.NSMutableSet' */ },
		{ 0x14E822, 0x14E622 /* 'Foundation.NSOrderedSet`1' => 'Foundation.NSOrderedSet' */ },
		{ 0x14F322, 0x14F222 /* 'Foundation.NSSet`1' => 'Foundation.NSSet' */ },
		{ 0x1E7722, 0x14E222 /* 'Chip.ChipError' => 'Foundation.NSObject' */ },
		{ 0x1E7822, 0x14E222 /* 'Chip.ChipContentLaunch' => 'Foundation.NSObject' */ },
		{ 0x1E7922, 0x14E222 /* 'Chip.ChipTrustedRootCertificates' => 'Foundation.NSObject' */ },
		{ 0x1EC922, 0x14E222 /* 'CarPlay.CPEntity' => 'Foundation.NSObject' */ },
	};

	static const MTAssembly __xamarin_registration_assemblies [] = {
		{ "HrApp.iOS", "f09aa60e-4d29-4501-9155-b92a2bfbcdd3" }, 
		{ "mscorlib", "aae03b95-719e-488f-8a16-3bae4d2b5dcb" }, 
		{ "Xamarin.Forms.Core", "98e00f82-da59-41d5-b236-e30653de7bef" }, 
		{ "netstandard", "e30c5ada-4b63-4fc8-96dd-aca2299cc7a9" }, 
		{ "System.Core", "112d7157-5963-4cb1-8dc7-0888cd90afca" }, 
		{ "System", "ee6a1987-eb2f-48bd-b8b5-f0cf4659dd86" }, 
		{ "Mono.Security", "1566bc2a-9519-43ca-a7e4-c56e446cf8aa" }, 
		{ "System.Xml", "d0f4d526-8c2b-480e-9953-8ff06c03bb63" }, 
		{ "System.Numerics", "1828726c-5d96-4d09-be69-29822258bbd5" }, 
		{ "System.Data", "afc385b0-a24f-42ba-815f-7114d4e43c7e" }, 
		{ "System.Transactions", "bdc737eb-66ed-4f36-ac5d-7712fe85377e" }, 
		{ "System.Data.DataSetExtensions", "13168555-e2ec-4ed0-878e-52af149b20d0" }, 
		{ "System.Drawing.Common", "7af35eac-50a0-4cf2-9176-965ac886f8c8" }, 
		{ "System.IO.Compression", "d4e3c21c-a284-46eb-9376-3228d0f98958" }, 
		{ "System.IO.Compression.FileSystem", "84da4294-e17c-4ad4-aba2-1a3301defb55" }, 
		{ "System.ComponentModel.Composition", "d98269e4-11c8-4dee-8b6a-8318820e8084" }, 
		{ "System.Net.Http", "992c809d-e763-42e0-b46d-c1b912da2d7b" }, 
		{ "Xamarin.iOS", "234f9d17-31fd-4e1e-bf97-7b0a61b8dd61" }, 
		{ "System.Runtime.Serialization", "d94e3d5b-2d20-4829-b07d-56ac8818a128" }, 
		{ "System.ServiceModel.Internals", "79b49984-e3a8-4b8f-a8ee-0c54d07a5880" }, 
		{ "System.Web.Services", "a1eab3d6-63f2-403f-8639-0ab4e99d1c4e" }, 
		{ "System.Xml.Linq", "6510b49b-f62e-4f71-aebc-311a9c1e6056" }, 
		{ "Xamarin.Forms.Platform", "cd7f593f-9d91-4a0d-819e-e84c712d34c8" }, 
		{ "Xamarin.Forms.Platform.iOS", "95d1c404-699e-420c-91de-af9742b39577" }, 
		{ "HrApp", "2631cd84-d6f2-4893-a954-11654157fa94" }, 
		{ "Xamarin.Forms.Xaml", "b3e0c9cb-74cd-4072-8499-285f54dd980b" }, 
		{ "Prism.Unity.Forms", "99f393da-0cc5-43b1-93fd-1b65cd136519" }, 
		{ "Prism.Forms", "d07a5aed-dd89-4025-af20-f0ad006b6411" }, 
		{ "Prism", "011b0e71-2c1b-4201-896f-aad88d12e8dd" }, 
		{ "Unity.Abstractions", "18e7f358-8f56-4741-ad09-5876746761d8" }, 
		{ "System.Threading.Tasks.Extensions", "8e5b6229-d7ad-4bf4-a9fe-c326812c3d8e" }, 
		{ "Unity.Container", "7b8d41b4-b534-4639-9d39-27177e6119ae" }, 
		{ "System.Runtime.CompilerServices.Unsafe", "a8391708-f361-428d-a4a8-45fb3e6b1001" }, 
		{ "Plugin.FirebasePushNotification", "d30f959e-30de-4fa5-8a88-5a65d1c0e802" }, 
		{ "Firebase.CloudMessaging", "2f242b3a-7ef5-4cbd-9725-0faffbc3f905" }, 
		{ "Firebase.Core", "13e49f33-a116-404d-a8ea-9c0466c91244" }, 
		{ "Firebase.Installations", "a6a358e4-cac0-4281-8905-018e8942374f" }, 
		{ "Firebase.InstanceID", "d6d6a862-71e0-4d0e-9f45-28f03b05144f" }, 
		{ "Xamarin.Essentials", "c12266a9-b459-4e5f-a2f4-a79fc21c60f8" }, 
		{ "OpenTK-1.0", "c9b437be-5ef5-4069-b2d8-aa63201cf48e" }, 
		{ "Xamarin.Forms.PancakeView", "6d18d9c2-e514-45f2-a372-a80ca3b5e7a6" }, 
		{ "Microsoft.AspNetCore.SignalR.Client.Core", "012ec0f0-3128-47e3-ba7f-fa01b214580d" }, 
		{ "System.IO.Pipelines", "8237fc42-9057-410c-b2ea-693dfe59a19c" }, 
		{ "System.Memory", "24a92820-8a91-4489-985a-565d37c1904f" }, 
		{ "System.Buffers", "f3ed66a5-c6df-46d4-b32b-d144097aaeba" }, 
		{ "System.Threading.Channels", "7bf292dd-d612-4382-855d-59a1f4395399" }, 
		{ "Microsoft.Extensions.Logging.Abstractions", "9136f949-3b44-4347-83ff-69bbca324019" }, 
		{ "Microsoft.AspNetCore.SignalR.Common", "f157be6e-f8a1-459f-af73-77eab507be3a" }, 
		{ "System.Text.Json", "b88e6f69-8542-4139-8978-498cb699263f" }, 
		{ "System.Text.Encodings.Web", "8e4e14e4-c14e-4a59-be59-6841c78363e5" }, 
		{ "System.Numerics.Vectors", "593151c4-5a33-4dc2-980d-92e24af77e58" }, 
		{ "Microsoft.Bcl.AsyncInterfaces", "4dbbc860-1af7-4175-96ac-62df8c0ce7fa" }, 
		{ "Microsoft.Extensions.DependencyInjection.Abstractions", "1ba52dc0-b103-422e-ba91-ad87a1aa9fe3" }, 
		{ "Microsoft.AspNetCore.Connections.Abstractions", "060c1b19-e103-416f-bdcb-adb4a104209e" }, 
		{ "Microsoft.AspNetCore.Http.Features", "5a587684-a8ad-4f1e-a232-9c99acae91a5" }, 
		{ "Microsoft.Extensions.Primitives", "8bdce47f-b0ea-4d98-8870-ba3066ea6fda" }, 
		{ "Microsoft.Extensions.Logging", "eeae490c-3300-468d-a793-a39c7791ea02" }, 
		{ "Microsoft.Extensions.Options", "f47558ac-9e80-42de-a6fc-4617611749bc" }, 
		{ "Microsoft.Extensions.DependencyInjection", "84525b04-5edb-4043-92d9-5a20a1ee4f64" }, 
		{ "System.Diagnostics.DiagnosticSource", "5ce05d94-0d57-40f9-9c1f-db29b357924c" }, 
		{ "System.Runtime", "4239c48d-529b-4d94-92a3-41864b1c373a" }, 
		{ "System.Resources.ResourceManager", "858033b9-99ff-46a1-828a-8d67074a85ed" }, 
		{ "System.Diagnostics.Tracing", "ec1de3f2-554c-4e30-9d7f-53d80a5eabb0" }, 
		{ "System.Collections.Concurrent", "ab2702d8-97a0-4f83-8686-7c3e71a69fff" }, 
		{ "System.Collections", "445aa35a-ea86-46fa-84db-4beae1723fb6" }, 
		{ "System.Reflection", "254e09d7-c57b-4399-8c84-00f54177a638" }, 
		{ "System.Threading", "41ddade7-3378-4eab-9e8c-f5bf232513f9" }, 
		{ "System.Diagnostics.Debug", "2d399a9f-df27-4879-bb11-b7dfd7a7d51b" }, 
		{ "System.Runtime.InteropServices", "1dd466d3-dd1c-4701-925b-002d900be5f3" }, 
		{ "System.AppContext", "558eb1ff-c467-4fbf-85df-68748232d914" }, 
		{ "System.Runtime.Extensions", "4b44b311-85f2-43b2-bf3e-e7a0d1298217" }, 
		{ "Microsoft.AspNetCore.SignalR.Protocols.Json", "fe783dda-a0f0-4a01-b6e4-d64a5c4ec953" }, 
		{ "XamForms.Controls.Calendar", "bd63c89f-93d4-443b-a41e-34c8eec86011" }, 
		{ "System.ObjectModel", "c138ff4e-ded1-4c27-b9d3-27bf3bbff254" }, 
		{ "System.Threading.Tasks", "c9f85bc2-fba4-4c71-9d02-1d9e3510ee3d" }, 
		{ "System.Globalization", "8c852e53-26c5-4ba9-8176-88ca8cca1b9d" }, 
		{ "System.Linq", "cf22f0a8-ce77-4e9a-8f22-60d5dd9bb719" }, 
		{ "RestSharp", "b0dcb462-502f-49dd-84b6-08d81d00e5fd" }, 
		{ "Newtonsoft.Json", "7ca8898b-690a-4181-a32a-9cf767cedb1e" }, 
		{ "Syncfusion.SfPdfViewer.XForms", "f1869338-ff33-44d9-8035-d46d95ce48a8" }, 
		{ "Syncfusion.Core.XForms", "e1f4761f-274b-44f3-87a7-2a45062c2393" }, 
		{ "Syncfusion.Licensing", "eb3605b9-549f-44f3-8ab8-dae517eea895" }, 
		{ "System.Text.RegularExpressions", "cb99df8b-f6e9-490f-9a65-e0557ce8274e" }, 
		{ "System.Reflection.Extensions", "9d83b68a-5924-4370-928b-7c8ec14344a0" }, 
		{ "System.Text.Encoding", "ab00b7fa-854a-4ab2-9382-b2ebfdf96d7b" }, 
		{ "Syncfusion.Pdf.Portable", "594b003c-ff10-4570-9ebb-64f83474b707" }, 
		{ "Syncfusion.Compression.Portable", "78bfed10-0d57-4390-863a-cf2824de40d5" }, 
		{ "System.Text.Encoding.CodePages", "f25f4f27-c1ac-4e56-b9c8-6b913805a9bf" }, 
		{ "Syncfusion.SfProgressBar.XForms", "08451170-11f1-45f0-9695-c00da3507d6d" }, 
		{ "Syncfusion.SfRangeSlider.XForms", "65d7ffbf-97ec-4843-afb8-e40cd6baa57e" }, 
		{ "Xamarin.CommunityToolkit", "4d8fe5c5-405e-44d0-8fa2-8bbb90fc91b0" }, 
		{ "Plugin.Multilingual", "2c5a56d1-d56e-4be4-8f8b-4e14474c6bd0" }, 
		{ "Plugin.Multilingual.Abstractions", "e880e74c-40fc-49c3-a743-562db38d792f" }, 
		{ "Microsoft.CSharp", "1a5c3521-f130-4e51-be93-0c65dba057e9" }, 
		{ "Microsoft.AspNetCore.SignalR.Client", "32430612-9f92-4c90-ad50-b1f3cf336be2" }, 
		{ "Microsoft.AspNetCore.Http.Connections.Common", "f9e4ae5d-fd77-4417-8a79-10d246b2717c" }, 
		{ "Microsoft.AspNetCore.Http.Connections.Client", "6f5e2483-341d-4e95-99b2-d77c805aa7f6" }, 
		{ "Polly", "ab401ba6-fe43-4cfb-b078-4f458cf3f3ea" }, 
		{ "AiForms.Effects", "0c5d0e48-e5ab-4ae5-a93f-f86b444b3f37" }, 
		{ "ImageCircle.Forms.Plugin", "53fc96ea-a28d-4985-8ab0-283f6958ab57" }, 
		{ "SVG.Forms.Plugin.Abstractions", "0bdc7645-2810-4a2a-94aa-fa4a720d7738" }, 
		{ "AiForms.Effects.iOS", "8c2d2f80-1031-4b33-8d43-15127092f719" }, 
		{ "IQKeyboardManager", "0e8a31a5-bda5-4c2e-af1b-bb05705f33cb" }, 
		{ "SVG.Forms.Plugin.iOS", "df78751a-1351-4e18-bcfa-231d0a1e8558" }, 
		{ "NGraphics.Custom", "c787e3d8-c9e8-4290-9bf3-17040008966c" }, 
		{ "System.IO", "0a133204-8a78-4db6-a267-32f89beb16ea" }, 
		{ "System.Xml.XDocument", "dab43d10-f2be-4ca6-93a0-caa39e51e54b" }, 
		{ "NGraphics.iOS.Custom", "ab70f851-a2d4-4124-8f3d-d740fd822af0" }, 
		{ "Syncfusion.SfPdfViewer.XForms.iOS", "3d3e30f8-ccfd-44b6-b9a1-cb9c7f93677e" }, 
		{ "Syncfusion.SfBusyIndicator.iOS", "ba7ce633-e8b6-46b2-a1f9-f9c8140a4b6f" }, 
		{ "Syncfusion.Core.XForms.iOS", "9e9e4415-e42f-41cd-a922-79a130836769" }, 
		{ "Syncfusion.SfRangeSlider.XForms.iOS", "a85618ac-d608-4cc5-8844-7ce164e5d0e7" }, 
		{ "Syncfusion.SfRangeSlider.iOS", "9678c31d-868d-4627-93ee-1eea2c6a93e3" }, 
		{ "XamForms.Controls.Calendar.iOS", "600716d1-13f0-46d8-b76a-0f7ff582c3d3" }, 
		{ "I18N", "f6eff63a-a715-4da5-b237-a79dc3dbd2dc" }, 
		{ "I18N.MidEast", "de51ee33-94e2-4dce-98f1-d111e278c814" }
	};

	static const MTProtocolWrapperMap __xamarin_protocol_wrapper_map [] = {
		{ 0xA22 /* VisionKit.IVNDocumentCameraViewControllerDelegate */, 0xC22 /* VNDocumentCameraViewControllerDelegateWrapper */ },
		{ 0xF22 /* UserNotificationsUI.IUNNotificationContentExtension */, 0x1122 /* UNNotificationContentExtensionWrapper */ },
		{ 0x16CC /* Xamarin.IUIView_IQToolbarAddition */, 0x18CC /* UIView_IQToolbarAdditionWrapper */ },
		{ 0x2122 /* WatchConnectivity.IWCSessionDelegate */, 0x2322 /* WCSessionDelegateWrapper */ },
		{ 0x2744 /* Firebase.CloudMessaging.IMessagingDelegate */, 0x2944 /* MessagingDelegateWrapper */ },
		{ 0x2E22 /* Speech.ISFSpeechRecognitionTaskDelegate */, 0x3022 /* SFSpeechRecognitionTaskDelegateWrapper */ },
		{ 0x3622 /* Speech.ISFSpeechRecognizerDelegate */, 0x3822 /* SFSpeechRecognizerDelegateWrapper */ },
		{ 0x4722 /* SoundAnalysis.ISNRequest */, 0x4822 /* SNRequestWrapper */ },
		{ 0x4922 /* SoundAnalysis.ISNResult */, 0x4A22 /* SNResultWrapper */ },
		{ 0x4B22 /* SoundAnalysis.ISNResultsObserving */, 0x4D22 /* SNResultsObservingWrapper */ },
		{ 0x6922 /* SharedWithYou.ISWCollaborationViewDelegate */, 0x6B22 /* SWCollaborationViewDelegateWrapper */ },
		{ 0x6F22 /* SharedWithYou.ISWHighlightCenterDelegate */, 0x7022 /* SWHighlightCenterDelegateWrapper */ },
		{ 0x7522 /* SharedWithYou.ISWHighlightEvent */, 0x7622 /* SWHighlightEventWrapper */ },
		{ 0x8F22 /* SafariServices.ISFSafariViewControllerDelegate */, 0x9122 /* SFSafariViewControllerDelegateWrapper */ },
		{ 0xA622 /* QuickLook.IQLPreviewControllerDataSource */, 0xA722 /* QLPreviewControllerDataSourceWrapper */ },
		{ 0xA922 /* QuickLook.IQLPreviewControllerDelegate */, 0xAB22 /* QLPreviewControllerDelegateWrapper */ },
		{ 0xAD22 /* QuickLook.IQLPreviewingController */, 0xAF22 /* QLPreviewingControllerWrapper */ },
		{ 0xB022 /* QuickLook.IQLPreviewItem */, 0xB122 /* QLPreviewItemWrapper */ },
		{ 0xDA22 /* PushKit.IPKPushRegistryDelegate */, 0xDC22 /* PKPushRegistryDelegateWrapper */ },
		{ 0xDF22 /* PhotosUI.IPHContentEditingController */, 0xE022 /* PHContentEditingControllerWrapper */ },
		{ 0xE522 /* PhotosUI.IPHLivePhotoViewDelegate */, 0xE722 /* PHLivePhotoViewDelegateWrapper */ },
		{ 0xF122 /* PhotosUI.IPHPickerViewControllerDelegate */, 0xF222 /* PHPickerViewControllerDelegateWrapper */ },
		{ 0x14822 /* PencilKit.IPKCanvasViewDelegate */, 0x14A22 /* PKCanvasViewDelegateWrapper */ },
		{ 0x15B22 /* PencilKit.IPKToolPickerObserver */, 0x15D22 /* PKToolPickerObserverWrapper */ },
		{ 0x16222 /* OSLog.IOSLogEntryFromProcess */, 0x16322 /* OSLogEntryFromProcessWrapper */ },
		{ 0x16922 /* OSLog.IOSLogEntryWithPayload */, 0x16A22 /* OSLogEntryWithPayloadWrapper */ },
		{ 0x17522 /* NotificationCenter.INCWidgetProviding */, 0x17722 /* NCWidgetProvidingWrapper */ },
		{ 0x18822 /* Messages.IMSMessagesAppTranscriptPresentation */, 0x18922 /* MSMessagesAppTranscriptPresentationWrapper */ },
		{ 0x19022 /* Messages.IMSStickerBrowserViewDataSource */, 0x19122 /* MSStickerBrowserViewDataSourceWrapper */ },
		{ 0x1B722 /* IntentsUI.IINUIAddVoiceShortcutButtonDelegate */, 0x1B822 /* INUIAddVoiceShortcutButtonDelegateWrapper */ },
		{ 0x1BC22 /* IntentsUI.IINUIAddVoiceShortcutViewControllerDelegate */, 0x1BD22 /* INUIAddVoiceShortcutViewControllerDelegateWrapper */ },
		{ 0x1C022 /* IntentsUI.IINUIEditVoiceShortcutViewControllerDelegate */, 0x1C122 /* INUIEditVoiceShortcutViewControllerDelegateWrapper */ },
		{ 0x1C422 /* IntentsUI.IINUIHostedViewControlling */, 0x1C622 /* INUIHostedViewControllingWrapper */ },
		{ 0x1C722 /* IntentsUI.IINUIHostedViewSiriProviding */, 0x1C922 /* INUIHostedViewSiriProvidingWrapper */ },
		{ 0x1D822 /* IdentityLookup.IILMessageFilterCapabilitiesQueryHandling */, 0x1D922 /* ILMessageFilterCapabilitiesQueryHandlingWrapper */ },
		{ 0x1E022 /* IdentityLookup.IILMessageFilterQueryHandling */, 0x1E122 /* ILMessageFilterQueryHandlingWrapper */ },
		{ 0x1EC22 /* ExternalAccessory.IEAAccessoryDelegate */, 0x1EE22 /* EAAccessoryDelegateWrapper */ },
		{ 0x1F922 /* ExternalAccessory.IEAWiFiUnconfiguredAccessoryBrowserDelegate */, 0x1FA22 /* EAWiFiUnconfiguredAccessoryBrowserDelegateWrapper */ },
		{ 0x25122 /* CoreHaptics.ICHHapticAdvancedPatternPlayer */, 0x25222 /* CHHapticAdvancedPatternPlayerWrapper */ },
		{ 0x25522 /* CoreHaptics.ICHHapticDeviceCapability */, 0x25622 /* CHHapticDeviceCapabilityWrapper */ },
		{ 0x26422 /* CoreHaptics.ICHHapticParameterAttributes */, 0x26522 /* CHHapticParameterAttributesWrapper */ },
		{ 0x26B22 /* CoreHaptics.ICHHapticPatternPlayer */, 0x26C22 /* CHHapticPatternPlayerWrapper */ },
		{ 0x27522 /* ContactsUI.ICNContactPickerDelegate */, 0x27722 /* CNContactPickerDelegateWrapper */ },
		{ 0x27B22 /* ContactsUI.ICNContactViewControllerDelegate */, 0x27D22 /* CNContactViewControllerDelegateWrapper */ },
		{ 0x28E22 /* AutomaticAssessmentConfiguration.IAEAssessmentSessionDelegate */, 0x29022 /* AEAssessmentSessionDelegateWrapper */ },
		{ 0x30D22 /* Vision.IVNFaceObservationAccepting */, 0x30E22 /* VNFaceObservationAcceptingWrapper */ },
		{ 0x34322 /* Vision.IVNRequestProgressProviding */, 0x34422 /* VNRequestProgressProvidingWrapper */ },
		{ 0x34622 /* Vision.IVNRequestRevisionProviding */, 0x34722 /* VNRequestRevisionProvidingWrapper */ },
		{ 0x3A122 /* VideoSubscriberAccount.IVSAccountManagerDelegate */, 0x3A322 /* VSAccountManagerDelegateWrapper */ },
		{ 0x3CA22 /* UserNotifications.IUNNotificationContentProviding */, 0x3CB22 /* UNNotificationContentProvidingWrapper */ },
		{ 0x3DB22 /* UserNotifications.IUNUserNotificationCenterDelegate */, 0x3DD22 /* UNUserNotificationCenterDelegateWrapper */ },
		{ 0x40622 /* StoreKit.ISKCloudServiceSetupViewControllerDelegate */, 0x40822 /* SKCloudServiceSetupViewControllerDelegateWrapper */ },
		{ 0x41122 /* StoreKit.ISKOverlayDelegate */, 0x41322 /* SKOverlayDelegateWrapper */ },
		{ 0x41922 /* StoreKit.ISKPaymentQueueDelegate */, 0x41B22 /* SKPaymentQueueDelegateWrapper */ },
		{ 0x41E22 /* StoreKit.ISKPaymentTransactionObserver */, 0x41F22 /* SKPaymentTransactionObserverWrapper */ },
		{ 0x42822 /* StoreKit.ISKProductsRequestDelegate */, 0x42922 /* SKProductsRequestDelegateWrapper */ },
		{ 0x43122 /* StoreKit.ISKRequestDelegate */, 0x43322 /* SKRequestDelegateWrapper */ },
		{ 0x43822 /* StoreKit.ISKStoreProductViewControllerDelegate */, 0x43A22 /* SKStoreProductViewControllerDelegateWrapper */ },
		{ 0x45F22 /* SpriteKit.ISKPhysicsContactDelegate */, 0x46122 /* SKPhysicsContactDelegateWrapper */ },
		{ 0x47122 /* SpriteKit.ISKSceneDelegate */, 0x47322 /* SKSceneDelegateWrapper */ },
		{ 0x48922 /* SpriteKit.ISKViewDelegate */, 0x48B22 /* SKViewDelegateWrapper */ },
		{ 0x48D22 /* SpriteKit.ISKWarpable */, 0x48E22 /* SKWarpableWrapper */ },
		{ 0x4C422 /* SharedWithYouCore.ISWCollaborationActionHandler */, 0x4C522 /* SWCollaborationActionHandlerWrapper */ },
		{ 0x4EE22 /* SensorKit.ISRSensorReaderDelegate */, 0x4F022 /* SRSensorReaderDelegateWrapper */ },
		{ 0x56D22 /* SceneKit.ISCNActionable */, 0x56F22 /* SCNActionableWrapper */ },
		{ 0x57222 /* SceneKit.ISCNAnimatable */, 0x57422 /* SCNAnimatableWrapper */ },
		{ 0x57822 /* SceneKit.ISCNAnimationProtocol */, 0x57922 /* SCNAnimationProtocolWrapper */ },
		{ 0x57E22 /* SceneKit.ISCNAvoidOccluderConstraintDelegate */, 0x58022 /* SCNAvoidOccluderConstraintDelegateWrapper */ },
		{ 0x58522 /* SceneKit.ISCNBoundingVolume */, 0x58622 /* SCNBoundingVolumeWrapper */ },
		{ 0x58A22 /* SceneKit.ISCNBufferStream */, 0x58B22 /* SCNBufferStreamWrapper */ },
		{ 0x58D22 /* SceneKit.ISCNCameraControlConfiguration */, 0x58E22 /* SCNCameraControlConfigurationWrapper */ },
		{ 0x59022 /* SceneKit.ISCNCameraControllerDelegate */, 0x59222 /* SCNCameraControllerDelegateWrapper */ },
		{ 0x5BB22 /* SceneKit.ISCNNodeRendererDelegate */, 0x5BD22 /* SCNNodeRendererDelegateWrapper */ },
		{ 0x5D122 /* SceneKit.ISCNPhysicsContactDelegate */, 0x5D322 /* SCNPhysicsContactDelegateWrapper */ },
		{ 0x5E522 /* SceneKit.ISCNProgramDelegate */, 0x5E722 /* SCNProgramDelegateWrapper */ },
		{ 0x5F222 /* SceneKit.ISCNSceneExportDelegate */, 0x5F422 /* SCNSceneExportDelegateWrapper */ },
		{ 0x5F622 /* SceneKit.ISCNSceneRenderer */, 0x5F722 /* SCNSceneRendererWrapper */ },
		{ 0x5F822 /* SceneKit.ISCNSceneRendererDelegate */, 0x5FA22 /* SCNSceneRendererDelegateWrapper */ },
		{ 0x60022 /* SceneKit.ISCNShadable */, 0x60222 /* SCNShadableWrapper */ },
		{ 0x60922 /* SceneKit.ISCNTechniqueSupport */, 0x60A22 /* SCNTechniqueSupportWrapper */ },
		{ 0x62822 /* ReplayKit.IRPBroadcastActivityViewControllerDelegate */, 0x62922 /* RPBroadcastActivityViewControllerDelegateWrapper */ },
		{ 0x62C22 /* ReplayKit.IRPBroadcastControllerDelegate */, 0x62E22 /* RPBroadcastControllerDelegateWrapper */ },
		{ 0x63522 /* ReplayKit.IRPPreviewViewControllerDelegate */, 0x63722 /* RPPreviewViewControllerDelegateWrapper */ },
		{ 0x63D22 /* ReplayKit.IRPScreenRecorderDelegate */, 0x63F22 /* RPScreenRecorderDelegateWrapper */ },
		{ 0x67722 /* Photos.IPHLivePhotoFrame */, 0x67822 /* PHLivePhotoFrameWrapper */ },
		{ 0x68622 /* Photos.IPHPhotoLibraryAvailabilityObserver */, 0x68722 /* PHPhotoLibraryAvailabilityObserverWrapper */ },
		{ 0x68822 /* Photos.IPHPhotoLibraryChangeObserver */, 0x68922 /* PHPhotoLibraryChangeObserverWrapper */ },
		{ 0x6C322 /* PdfKit.IPdfDocumentDelegate */, 0x6C522 /* PdfDocumentDelegateWrapper */ },
		{ 0x6D122 /* PdfKit.IPdfPageOverlayViewProvider */, 0x6D322 /* PdfPageOverlayViewProviderWrapper */ },
		{ 0x6DB22 /* PdfKit.IPdfViewDelegate */, 0x6DD22 /* PdfViewDelegateWrapper */ },
		{ 0x6EA22 /* PassKit.IPKAddPassesViewControllerDelegate */, 0x6EC22 /* PKAddPassesViewControllerDelegateWrapper */ },
		{ 0x6F322 /* PassKit.IPKAddPaymentPassViewControllerDelegate */, 0x6F422 /* PKAddPaymentPassViewControllerDelegateWrapper */ },
		{ 0x6FB22 /* PassKit.IPKAddSecureElementPassViewControllerDelegate */, 0x6FC22 /* PKAddSecureElementPassViewControllerDelegateWrapper */ },
		{ 0x70E22 /* PassKit.IPKDisbursementAuthorizationControllerDelegate */, 0x70F22 /* PKDisbursementAuthorizationControllerDelegateWrapper */ },
		{ 0x71B22 /* PassKit.IPKIdentityDocumentDescriptor */, 0x71C22 /* PKIdentityDocumentDescriptorWrapper */ },
		{ 0x72322 /* PassKit.IPKIssuerProvisioningExtensionAuthorizationProviding */, 0x72422 /* PKIssuerProvisioningExtensionAuthorizationProvidingWrapper */ },
		{ 0x73822 /* PassKit.IPKPaymentAuthorizationControllerDelegate */, 0x73A22 /* PKPaymentAuthorizationControllerDelegateWrapper */ },
		{ 0x74922 /* PassKit.IPKPaymentAuthorizationViewControllerDelegate */, 0x74B22 /* PKPaymentAuthorizationViewControllerDelegateWrapper */ },
		{ 0x75422 /* PassKit.IPKPaymentInformationRequestHandling */, 0x75522 /* PKPaymentInformationRequestHandlingWrapper */ },
		{ 0x77122 /* PassKit.IPKShareSecureElementPassViewControllerDelegate */, 0x77322 /* PKShareSecureElementPassViewControllerDelegateWrapper */ },
		{ 0x77E22 /* PassKit.IPKVehicleConnectionDelegate */, 0x77F22 /* PKVehicleConnectionDelegateWrapper */ },
		{ 0x78C22 /* OpenGLES.IEAGLDrawable */, 0x78D22 /* EAGLDrawableWrapper */ },
		{ 0x7A922 /* NetworkExtension.INEAppPushDelegate */, 0x7AA22 /* NEAppPushDelegateWrapper */ },
		{ 0x81322 /* NetworkExtension.INWTcpConnectionAuthenticationDelegate */, 0x81522 /* NWTcpConnectionAuthenticationDelegateWrapper */ },
		{ 0x87B22 /* NearbyInteraction.INIDeviceCapability */, 0x87C22 /* NIDeviceCapabilityWrapper */ },
		{ 0x88522 /* NearbyInteraction.INISessionDelegate */, 0x88722 /* NISessionDelegateWrapper */ },
		{ 0x8AE22 /* MultipeerConnectivity.IMCAdvertiserAssistantDelegate */, 0x8B022 /* MCAdvertiserAssistantDelegateWrapper */ },
		{ 0x8B322 /* MultipeerConnectivity.IMCBrowserViewControllerDelegate */, 0x8B522 /* MCBrowserViewControllerDelegateWrapper */ },
		{ 0x8BB22 /* MultipeerConnectivity.IMCNearbyServiceAdvertiserDelegate */, 0x8BD22 /* MCNearbyServiceAdvertiserDelegateWrapper */ },
		{ 0x8C022 /* MultipeerConnectivity.IMCNearbyServiceBrowserDelegate */, 0x8C222 /* MCNearbyServiceBrowserDelegateWrapper */ },
		{ 0x8C422 /* MultipeerConnectivity.IMCSessionDelegate */, 0x8C622 /* MCSessionDelegateWrapper */ },
		{ 0x8E522 /* ModelIO.IMDLAssetResolver */, 0x8E622 /* MDLAssetResolverWrapper */ },
		{ 0x8EC22 /* ModelIO.IMDLComponent */, 0x8ED22 /* MDLComponentWrapper */ },
		{ 0x8F122 /* ModelIO.IMDLJointAnimation */, 0x8F222 /* MDLJointAnimationWrapper */ },
		{ 0x8F522 /* ModelIO.IMDLLightProbeIrradianceDataSource */, 0x8F722 /* MDLLightProbeIrradianceDataSourceWrapper */ },
		{ 0x90522 /* ModelIO.IMDLMeshBuffer */, 0x90722 /* MDLMeshBufferWrapper */ },
		{ 0x90822 /* ModelIO.IMDLMeshBufferAllocator */, 0x90922 /* MDLMeshBufferAllocatorWrapper */ },
		{ 0x90E22 /* ModelIO.IMDLMeshBufferZone */, 0x91022 /* MDLMeshBufferZoneWrapper */ },
		{ 0x91222 /* ModelIO.IMDLNamed */, 0x91322 /* MDLNamedWrapper */ },
		{ 0x91822 /* ModelIO.IMDLObjectContainerComponent */, 0x91A22 /* MDLObjectContainerComponentWrapper */ },
		{ 0x92C22 /* ModelIO.IMDLTransformComponent */, 0x92D22 /* MDLTransformComponentWrapper */ },
		{ 0x92F22 /* ModelIO.IMDLTransformOp */, 0x93022 /* MDLTransformOpWrapper */ },
		{ 0x96222 /* MetricKit.IMXMetricManagerSubscriber */, 0x96422 /* MXMetricManagerSubscriberWrapper */ },
		{ 0x9F122 /* MetalPerformanceShaders.IMPSCnnBatchNormalizationDataSource */, 0x9F322 /* MPSCnnBatchNormalizationDataSourceWrapper */ },
		{ 0x9FF22 /* MetalPerformanceShaders.IMPSCnnConvolutionDataSource */, 0xA0122 /* MPSCnnConvolutionDataSourceWrapper */ },
		{ 0xA1E22 /* MetalPerformanceShaders.IMPSCnnInstanceNormalizationDataSource */, 0xA2022 /* MPSCnnInstanceNormalizationDataSourceWrapper */ },
		{ 0xA8922 /* MetalPerformanceShaders.IMPSDeviceProvider */, 0xA8A22 /* MPSDeviceProviderWrapper */ },
		{ 0xA8C22 /* MetalPerformanceShaders.IMPSHandle */, 0xA8D22 /* MPSHandleWrapper */ },
		{ 0xA8E22 /* MetalPerformanceShaders.IMPSHeapProvider */, 0xA9022 /* MPSHeapProviderWrapper */ },
		{ 0xA9222 /* MetalPerformanceShaders.IMPSImageAllocator */, 0xA9422 /* MPSImageAllocatorWrapper */ },
		{ 0xAB622 /* MetalPerformanceShaders.IMPSImageSizeEncodingState */, 0xAB722 /* MPSImageSizeEncodingStateWrapper */ },
		{ 0xABD22 /* MetalPerformanceShaders.IMPSImageTransformProvider */, 0xABE22 /* MPSImageTransformProviderWrapper */ },
		{ 0xAE622 /* MetalPerformanceShaders.IMPSNDArrayAllocator */, 0xAE722 /* MPSNDArrayAllocatorWrapper */ },
		{ 0xB0322 /* MetalPerformanceShaders.IMPSNNLossCallback */, 0xB0422 /* MPSNNLossCallbackWrapper */ },
		{ 0xB0F22 /* MetalPerformanceShaders.IMPSNNPadding */, 0xB1122 /* MPSNNPaddingWrapper */ },
		{ 0xB4322 /* MetalPerformanceShaders.IMPSNNTrainableNode */, 0xB4422 /* MPSNNTrainableNodeWrapper */ },
		{ 0xB7322 /* MetalKit.IMTKViewDelegate */, 0xB7422 /* MTKViewDelegateWrapper */ },
		{ 0xBA322 /* Metal.IMTLAccelerationStructure */, 0xBA422 /* MTLAccelerationStructureWrapper */ },
		{ 0xBA622 /* Metal.IMTLAccelerationStructureCommandEncoder */, 0xBA822 /* MTLAccelerationStructureCommandEncoderWrapper */ },
		{ 0xBB522 /* Metal.IMTLArgumentEncoder */, 0xBB622 /* MTLArgumentEncoderWrapper */ },
		{ 0xBBD22 /* Metal.IMTLBinaryArchive */, 0xBBF22 /* MTLBinaryArchiveWrapper */ },
		{ 0xBC522 /* Metal.IMTLBlitCommandEncoder */, 0xBC722 /* MTLBlitCommandEncoderWrapper */ },
		{ 0xBCB22 /* Metal.IMTLBuffer */, 0xBCD22 /* MTLBufferWrapper */ },
		{ 0xBD422 /* Metal.IMTLCaptureScope */, 0xBD522 /* MTLCaptureScopeWrapper */ },
		{ 0xBD822 /* Metal.IMTLCommandBuffer */, 0xBDA22 /* MTLCommandBufferWrapper */ },
		{ 0xBDC22 /* Metal.IMTLCommandBufferEncoderInfo */, 0xBDD22 /* MTLCommandBufferEncoderInfoWrapper */ },
		{ 0xBE222 /* Metal.IMTLCommandEncoder */, 0xBE322 /* MTLCommandEncoderWrapper */ },
		{ 0xBE522 /* Metal.IMTLCommandQueue */, 0xBE722 /* MTLCommandQueueWrapper */ },
		{ 0xBEC22 /* Metal.IMTLComputeCommandEncoder */, 0xBEE22 /* MTLComputeCommandEncoderWrapper */ },
		{ 0xBF322 /* Metal.IMTLComputePipelineState */, 0xBF522 /* MTLComputePipelineStateWrapper */ },
		{ 0xBF622 /* Metal.IMTLCounter */, 0xBF722 /* MTLCounterWrapper */ },
		{ 0xBF922 /* Metal.IMTLCounterSampleBuffer */, 0xBFA22 /* MTLCounterSampleBufferWrapper */ },
		{ 0xC0022 /* Metal.IMTLCounterSet */, 0xC0122 /* MTLCounterSetWrapper */ },
		{ 0xC0822 /* Metal.IMTLDepthStencilState */, 0xC0922 /* MTLDepthStencilStateWrapper */ },
		{ 0xC0A22 /* Metal.IMTLDevice */, 0xC0B22 /* MTLDeviceWrapper */ },
		{ 0xC0D22 /* Metal.IMTLDrawable */, 0xC0F22 /* MTLDrawableWrapper */ },
		{ 0xC1122 /* Metal.IMTLDynamicLibrary */, 0xC1222 /* MTLDynamicLibraryWrapper */ },
		{ 0xC1522 /* Metal.IMTLEvent */, 0xC1622 /* MTLEventWrapper */ },
		{ 0xC1822 /* Metal.IMTLFence */, 0xC1922 /* MTLFenceWrapper */ },
		{ 0xC1A22 /* Metal.IMTLFunction */, 0xC1C22 /* MTLFunctionWrapper */ },
		{ 0xC2022 /* Metal.IMTLFunctionHandle */, 0xC2122 /* MTLFunctionHandleWrapper */ },
		{ 0xC2222 /* Metal.IMTLFunctionLog */, 0xC2322 /* MTLFunctionLogWrapper */ },
		{ 0xC2422 /* Metal.IMTLFunctionLogDebugLocation */, 0xC2522 /* MTLFunctionLogDebugLocationWrapper */ },
		{ 0xC2822 /* Metal.IMTLFunctionStitchingAttribute */, 0xC2922 /* MTLFunctionStitchingAttributeWrapper */ },
		{ 0xC2D22 /* Metal.IMTLFunctionStitchingNode */, 0xC2E22 /* MTLFunctionStitchingNodeWrapper */ },
		{ 0xC3222 /* Metal.IMTLHeap */, 0xC3422 /* MTLHeapWrapper */ },
		{ 0xC3822 /* Metal.IMTLIndirectCommandBuffer */, 0xC3A22 /* MTLIndirectCommandBufferWrapper */ },
		{ 0xC3D22 /* Metal.IMTLIndirectComputeCommand */, 0xC3F22 /* MTLIndirectComputeCommandWrapper */ },
		{ 0xC4022 /* Metal.IMTLIndirectRenderCommand */, 0xC4222 /* MTLIndirectRenderCommandWrapper */ },
		{ 0xC4622 /* Metal.IMTLIntersectionFunctionTable */, 0xC4722 /* MTLIntersectionFunctionTableWrapper */ },
		{ 0xC4A22 /* Metal.IMTLLibrary */, 0xC4C22 /* MTLLibraryWrapper */ },
		{ 0xC5222 /* Metal.IMTLLogContainer */, 0xC5322 /* MTLLogContainerWrapper */ },
		{ 0xC5922 /* Metal.IMTLParallelRenderCommandEncoder */, 0xC5B22 /* MTLParallelRenderCommandEncoderWrapper */ },
		{ 0xC6622 /* Metal.IMTLRasterizationRateMap */, 0xC6722 /* MTLRasterizationRateMapWrapper */ },
		{ 0xC6B22 /* Metal.IMTLRenderCommandEncoder */, 0xC6D22 /* MTLRenderCommandEncoderWrapper */ },
		{ 0xC7922 /* Metal.IMTLRenderPipelineState */, 0xC7B22 /* MTLRenderPipelineStateWrapper */ },
		{ 0xC7D22 /* Metal.IMTLResource */, 0xC7F22 /* MTLResourceWrapper */ },
		{ 0xC8122 /* Metal.IMTLResourceStateCommandEncoder */, 0xC8222 /* MTLResourceStateCommandEncoderWrapper */ },
		{ 0xC8B22 /* Metal.IMTLSamplerState */, 0xC8C22 /* MTLSamplerStateWrapper */ },
		{ 0xC8D22 /* Metal.IMTLSharedEvent */, 0xC8E22 /* MTLSharedEventWrapper */ },
		{ 0xCA122 /* Metal.IMTLTexture */, 0xCA322 /* MTLTextureWrapper */ },
		{ 0xCB422 /* Metal.IMTLVisibleFunctionTable */, 0xCB522 /* MTLVisibleFunctionTableWrapper */ },
		{ 0xCC622 /* MessageUI.IMFMailComposeViewControllerDelegate */, 0xCC822 /* MFMailComposeViewControllerDelegateWrapper */ },
		{ 0xCCA22 /* MessageUI.IMFMessageComposeViewControllerDelegate */, 0xCCB22 /* MFMessageComposeViewControllerDelegateWrapper */ },
		{ 0xCFD22 /* MediaPlayer.IMPMediaPickerControllerDelegate */, 0xCFF22 /* MPMediaPickerControllerDelegateWrapper */ },
		{ 0xD0122 /* MediaPlayer.IMPMediaPlayback */, 0xD0222 /* MPMediaPlaybackWrapper */ },
		{ 0xD2D22 /* MediaPlayer.IMPNowPlayingSessionDelegate */, 0xD2F22 /* MPNowPlayingSessionDelegateWrapper */ },
		{ 0xD3122 /* MediaPlayer.IMPPlayableContentDataSource */, 0xD3322 /* MPPlayableContentDataSourceWrapper */ },
		{ 0xD3422 /* MediaPlayer.IMPPlayableContentDelegate */, 0xD3522 /* MPPlayableContentDelegateWrapper */ },
		{ 0xD4222 /* MediaPlayer.IMPSystemMusicPlayerController */, 0xD4322 /* MPSystemMusicPlayerControllerWrapper */ },
		{ 0xD6C22 /* MapKit.IMKAnnotation */, 0xD6E22 /* MKAnnotationWrapper */ },
		{ 0xD8522 /* MapKit.IMKGeoJsonObject */, 0xD8622 /* MKGeoJsonObjectWrapper */ },
		{ 0xD8D22 /* MapKit.IMKLocalSearchCompleterDelegate */, 0xD8F22 /* MKLocalSearchCompleterDelegateWrapper */ },
		{ 0xD9D22 /* MapKit.IMKLookAroundViewControllerDelegate */, 0xD9F22 /* MKLookAroundViewControllerDelegateWrapper */ },
		{ 0xDBA22 /* MapKit.IMKMapViewDelegate */, 0xDBC22 /* MKMapViewDelegateWrapper */ },
		{ 0xDC322 /* MapKit.IMKOverlay */, 0xDC522 /* MKOverlayWrapper */ },
		{ 0xDD722 /* MapKit.IMKReverseGeocoderDelegate */, 0xDD822 /* MKReverseGeocoderDelegateWrapper */ },
		{ 0xE4F22 /* JavaScriptCore.IJSExport */, 0xE5022 /* JSExportWrapper */ },
		{ 0xE8322 /* Intents.IINActivateCarSignalIntentHandling */, 0xE8522 /* INActivateCarSignalIntentHandlingWrapper */ },
		{ 0xE8922 /* Intents.IINAddMediaIntentHandling */, 0xE8B22 /* INAddMediaIntentHandlingWrapper */ },
		{ 0xE9322 /* Intents.IINAddTasksIntentHandling */, 0xE9522 /* INAddTasksIntentHandlingWrapper */ },
		{ 0xEA122 /* Intents.IINAnswerCallIntentHandling */, 0xEA322 /* INAnswerCallIntentHandlingWrapper */ },
		{ 0xEA722 /* Intents.IINAppendToNoteIntentHandling */, 0xEA922 /* INAppendToNoteIntentHandlingWrapper */ },
		{ 0xEB722 /* Intents.IINBookRestaurantReservationIntentHandling */, 0xEB922 /* INBookRestaurantReservationIntentHandlingWrapper */ },
		{ 0xECA22 /* Intents.IINCallsDomainHandling */, 0xECB22 /* INCallsDomainHandlingWrapper */ },
		{ 0xECD22 /* Intents.IINCancelRideIntentHandling */, 0xECF22 /* INCancelRideIntentHandlingWrapper */ },
		{ 0xED322 /* Intents.IINCancelWorkoutIntentHandling */, 0xED522 /* INCancelWorkoutIntentHandlingWrapper */ },
		{ 0xEDD22 /* Intents.IINCarCommandsDomainHandling */, 0xEDE22 /* INCarCommandsDomainHandlingWrapper */ },
		{ 0xEE122 /* Intents.IINCarPlayDomainHandling */, 0xEE222 /* INCarPlayDomainHandlingWrapper */ },
		{ 0xEE722 /* Intents.IINCreateNoteIntentHandling */, 0xEE922 /* INCreateNoteIntentHandlingWrapper */ },
		{ 0xEED22 /* Intents.IINCreateTaskListIntentHandling */, 0xEEF22 /* INCreateTaskListIntentHandlingWrapper */ },
		{ 0xEFF22 /* Intents.IINDeleteTasksIntentHandling */, 0xF0122 /* INDeleteTasksIntentHandlingWrapper */ },
		{ 0xF0A22 /* Intents.IINEndWorkoutIntentHandling */, 0xF0C22 /* INEndWorkoutIntentHandlingWrapper */ },
		{ 0xF1A22 /* Intents.IINGetAvailableRestaurantReservationBookingDefaultsIntentHandling */, 0xF1C22 /* INGetAvailableRestaurantReservationBookingDefaultsIntentHandlingWrapper */ },
		{ 0xF2122 /* Intents.IINGetAvailableRestaurantReservationBookingsIntentHandling */, 0xF2322 /* INGetAvailableRestaurantReservationBookingsIntentHandlingWrapper */ },
		{ 0xF2622 /* Intents.IINGetCarLockStatusIntentHandling */, 0xF2822 /* INGetCarLockStatusIntentHandlingWrapper */ },
		{ 0xF2B22 /* Intents.IINGetCarPowerLevelStatusIntentHandling */, 0xF2D22 /* INGetCarPowerLevelStatusIntentHandlingWrapper */ },
		{ 0xF2F22 /* Intents.IINGetCarPowerLevelStatusIntentResponseObserver */, 0xF3022 /* INGetCarPowerLevelStatusIntentResponseObserverWrapper */ },
		{ 0xF3522 /* Intents.IINGetRestaurantGuestIntentHandling */, 0xF3722 /* INGetRestaurantGuestIntentHandlingWrapper */ },
		{ 0xF3B22 /* Intents.IINGetRideStatusIntentHandling */, 0xF3D22 /* INGetRideStatusIntentHandlingWrapper */ },
		{ 0xF4022 /* Intents.IINGetRideStatusIntentResponseObserver */, 0xF4122 /* INGetRideStatusIntentResponseObserverWrapper */ },
		{ 0xF4322 /* Intents.IINGetUserCurrentRestaurantReservationBookingsIntentHandling */, 0xF4522 /* INGetUserCurrentRestaurantReservationBookingsIntentHandlingWrapper */ },
		{ 0xF4922 /* Intents.IINGetVisualCodeIntentHandling */, 0xF4B22 /* INGetVisualCodeIntentHandlingWrapper */ },
		{ 0xF4F22 /* Intents.IINHangUpCallIntentHandling */, 0xF5122 /* INHangUpCallIntentHandlingWrapper */ },
		{ 0xF5B22 /* Intents.IINIntentHandlerProviding */, 0xF5C22 /* INIntentHandlerProvidingWrapper */ },
		{ 0xF6422 /* Intents.IINListCarsIntentHandling */, 0xF6622 /* INListCarsIntentHandlingWrapper */ },
		{ 0xF6A22 /* Intents.IINListRideOptionsIntentHandling */, 0xF6C22 /* INListRideOptionsIntentHandlingWrapper */ },
		{ 0xF8422 /* Intents.IINMessagesDomainHandling */, 0xF8522 /* INMessagesDomainHandlingWrapper */ },
		{ 0xF8822 /* Intents.IINNotebookDomainHandling */, 0xF8922 /* INNotebookDomainHandlingWrapper */ },
		{ 0xF9922 /* Intents.IINPauseWorkoutIntentHandling */, 0xF9B22 /* INPauseWorkoutIntentHandlingWrapper */ },
		{ 0xF9F22 /* Intents.IINPayBillIntentHandling */, 0xFA122 /* INPayBillIntentHandlingWrapper */ },
		{ 0xFAC22 /* Intents.IINPaymentsDomainHandling */, 0xFAD22 /* INPaymentsDomainHandlingWrapper */ },
		{ 0xFB822 /* Intents.IINPhotosDomainHandling */, 0xFB922 /* INPhotosDomainHandlingWrapper */ },
		{ 0xFC022 /* Intents.IINPlayMediaIntentHandling */, 0xFC222 /* INPlayMediaIntentHandlingWrapper */ },
		{ 0xFC922 /* Intents.IINRadioDomainHandling */, 0xFCA22 /* INRadioDomainHandlingWrapper */ },
		{ 0xFD922 /* Intents.IINRequestPaymentIntentHandling */, 0xFDB22 /* INRequestPaymentIntentHandlingWrapper */ },
		{ 0xFE122 /* Intents.IINRequestRideIntentHandling */, 0xFE322 /* INRequestRideIntentHandlingWrapper */ },
		{ 0xFF422 /* Intents.IINResumeWorkoutIntentHandling */, 0xFF622 /* INResumeWorkoutIntentHandlingWrapper */ },
		{ 0xFFE22 /* Intents.IINRidesharingDomainHandling */, 0xFFF22 /* INRidesharingDomainHandlingWrapper */ },
		{ 0x100122 /* Intents.IINSaveProfileInCarIntentHandling */, 0x100322 /* INSaveProfileInCarIntentHandlingWrapper */ },
		{ 0x100622 /* Intents.IINSearchCallHistoryIntentHandling */, 0x100822 /* INSearchCallHistoryIntentHandlingWrapper */ },
		{ 0x100C22 /* Intents.IINSearchForAccountsIntentHandling */, 0x100E22 /* INSearchForAccountsIntentHandlingWrapper */ },
		{ 0x101222 /* Intents.IINSearchForBillsIntentHandling */, 0x101422 /* INSearchForBillsIntentHandlingWrapper */ },
		{ 0x101822 /* Intents.IINSearchForMediaIntentHandling */, 0x101A22 /* INSearchForMediaIntentHandlingWrapper */ },
		{ 0x102022 /* Intents.IINSearchForMessagesIntentHandling */, 0x102222 /* INSearchForMessagesIntentHandlingWrapper */ },
		{ 0x102622 /* Intents.IINSearchForNotebookItemsIntentHandling */, 0x102822 /* INSearchForNotebookItemsIntentHandlingWrapper */ },
		{ 0x102C22 /* Intents.IINSearchForPhotosIntentHandling */, 0x102E22 /* INSearchForPhotosIntentHandlingWrapper */ },
		{ 0x103522 /* Intents.IINSendMessageIntentHandling */, 0x103722 /* INSendMessageIntentHandlingWrapper */ },
		{ 0x103F22 /* Intents.IINSendPaymentIntentHandling */, 0x104122 /* INSendPaymentIntentHandlingWrapper */ },
		{ 0x104722 /* Intents.IINSendRideFeedbackIntentHandling */, 0x104922 /* INSendRideFeedbackIntentHandlingWrapper */ },
		{ 0x104D22 /* Intents.IINSetAudioSourceInCarIntentHandling */, 0x104F22 /* INSetAudioSourceInCarIntentHandlingWrapper */ },
		{ 0x105222 /* Intents.IINSetCarLockStatusIntentHandling */, 0x105422 /* INSetCarLockStatusIntentHandlingWrapper */ },
		{ 0x105722 /* Intents.IINSetClimateSettingsInCarIntentHandling */, 0x105922 /* INSetClimateSettingsInCarIntentHandlingWrapper */ },
		{ 0x105C22 /* Intents.IINSetDefrosterSettingsInCarIntentHandling */, 0x105E22 /* INSetDefrosterSettingsInCarIntentHandlingWrapper */ },
		{ 0x106222 /* Intents.IINSetMessageAttributeIntentHandling */, 0x106422 /* INSetMessageAttributeIntentHandlingWrapper */ },
		{ 0x106722 /* Intents.IINSetProfileInCarIntentHandling */, 0x106922 /* INSetProfileInCarIntentHandlingWrapper */ },
		{ 0x106D22 /* Intents.IINSetRadioStationIntentHandling */, 0x106F22 /* INSetRadioStationIntentHandlingWrapper */ },
		{ 0x107222 /* Intents.IINSetSeatSettingsInCarIntentHandling */, 0x107422 /* INSetSeatSettingsInCarIntentHandlingWrapper */ },
		{ 0x107822 /* Intents.IINSetTaskAttributeIntentHandling */, 0x107A22 /* INSetTaskAttributeIntentHandlingWrapper */ },
		{ 0x108022 /* Intents.IINShareFocusStatusIntentHandling */, 0x108222 /* INShareFocusStatusIntentHandlingWrapper */ },
		{ 0x108922 /* Intents.IINSnoozeTasksIntentHandling */, 0x108B22 /* INSnoozeTasksIntentHandlingWrapper */ },
		{ 0x109422 /* Intents.IINSpeakable */, 0x109622 /* INSpeakableWrapper */ },
		{ 0x109A22 /* Intents.IINStartAudioCallIntentHandling */, 0x109C22 /* INStartAudioCallIntentHandlingWrapper */ },
		{ 0x10A622 /* Intents.IINStartCallIntentHandling */, 0x10A822 /* INStartCallIntentHandlingWrapper */ },
		{ 0x10AC22 /* Intents.IINStartPhotoPlaybackIntentHandling */, 0x10AE22 /* INStartPhotoPlaybackIntentHandlingWrapper */ },
		{ 0x10B222 /* Intents.IINStartVideoCallIntentHandling */, 0x10B422 /* INStartVideoCallIntentHandlingWrapper */ },
		{ 0x10B722 /* Intents.IINStartWorkoutIntentHandling */, 0x10B922 /* INStartWorkoutIntentHandlingWrapper */ },
		{ 0x10D422 /* Intents.IINTransferMoneyIntentHandling */, 0x10D622 /* INTransferMoneyIntentHandlingWrapper */ },
		{ 0x10DC22 /* Intents.IINUpdateMediaAffinityIntentHandling */, 0x10DE22 /* INUpdateMediaAffinityIntentHandlingWrapper */ },
		{ 0x10E522 /* Intents.IINVisualCodeDomainHandling */, 0x10E622 /* INVisualCodeDomainHandlingWrapper */ },
		{ 0x10F222 /* Intents.IINWorkoutsDomainHandling */, 0x10F322 /* INWorkoutsDomainHandlingWrapper */ },
		{ 0x113A22 /* HomeKit.IHMAccessoryBrowserDelegate */, 0x113C22 /* HMAccessoryBrowserDelegateWrapper */ },
		{ 0x114122 /* HomeKit.IHMAccessoryDelegate */, 0x114322 /* HMAccessoryDelegateWrapper */ },
		{ 0x115622 /* HomeKit.IHMCameraSnapshotControlDelegate */, 0x115822 /* HMCameraSnapshotControlDelegateWrapper */ },
		{ 0x115D22 /* HomeKit.IHMCameraStreamControlDelegate */, 0x115F22 /* HMCameraStreamControlDelegateWrapper */ },
		{ 0x11AD22 /* HomeKit.IHMHomeDelegate */, 0x11AF22 /* HMHomeDelegateWrapper */ },
		{ 0x11B722 /* HomeKit.IHMHomeManagerDelegate */, 0x11B922 /* HMHomeManagerDelegateWrapper */ },
		{ 0x11C422 /* HomeKit.IHMNetworkConfigurationProfileDelegate */, 0x11C622 /* HMNetworkConfigurationProfileDelegateWrapper */ },
		{ 0x12BA22 /* GameplayKit.IGKAgentDelegate */, 0x12BC22 /* GKAgentDelegateWrapper */ },
		{ 0x12C822 /* GameplayKit.IGKGameModel */, 0x12CA22 /* GKGameModelWrapper */ },
		{ 0x12CB22 /* GameplayKit.IGKGameModelPlayer */, 0x12CD22 /* GKGameModelPlayerWrapper */ },
		{ 0x12CE22 /* GameplayKit.IGKGameModelUpdate */, 0x12CF22 /* GKGameModelUpdateWrapper */ },
		{ 0x12E622 /* GameplayKit.IGKRandom */, 0x12E722 /* GKRandomWrapper */ },
		{ 0x12F022 /* GameplayKit.IGKSceneRootNodeType */, 0x12F122 /* GKSceneRootNodeTypeWrapper */ },
		{ 0x12F722 /* GameplayKit.IGKStrategist */, 0x12F822 /* GKStrategistWrapper */ },
		{ 0x131622 /* GameKit.IGKAchievementViewControllerDelegate */, 0x131722 /* GKAchievementViewControllerDelegateWrapper */ },
		{ 0x131C22 /* GameKit.IGKChallengeEventHandlerDelegate */, 0x131E22 /* GKChallengeEventHandlerDelegateWrapper */ },
		{ 0x132022 /* GameKit.IGKChallengeListener */, 0x132222 /* GKChallengeListenerWrapper */ },
		{ 0x132A22 /* GameKit.IGKFriendRequestComposeViewControllerDelegate */, 0x132B22 /* GKFriendRequestComposeViewControllerDelegateWrapper */ },
		{ 0x132E22 /* GameKit.IGKGameCenterControllerDelegate */, 0x132F22 /* GKGameCenterControllerDelegateWrapper */ },
		{ 0x133522 /* GameKit.IGKGameSessionEventListener */, 0x133722 /* GKGameSessionEventListenerWrapper */ },
		{ 0x133A22 /* GameKit.IGKInviteEventListener */, 0x133C22 /* GKInviteEventListenerWrapper */ },
		{ 0x134A22 /* GameKit.IGKLeaderboardViewControllerDelegate */, 0x134B22 /* GKLeaderboardViewControllerDelegateWrapper */ },
		{ 0x135022 /* GameKit.IGKLocalPlayerListener */, 0x135122 /* GKLocalPlayerListenerWrapper */ },
		{ 0x135822 /* GameKit.IGKMatchDelegate */, 0x135A22 /* GKMatchDelegateWrapper */ },
		{ 0x136222 /* GameKit.IGKMatchmakerViewControllerDelegate */, 0x136422 /* GKMatchmakerViewControllerDelegateWrapper */ },
		{ 0x137022 /* GameKit.IGKSavedGameListener */, 0x137222 /* GKSavedGameListenerWrapper */ },
		{ 0x137622 /* GameKit.IGKSessionDelegate */, 0x137822 /* GKSessionDelegateWrapper */ },
		{ 0x137D22 /* GameKit.IGKTurnBasedEventHandlerDelegate */, 0x137F22 /* GKTurnBasedEventHandlerDelegateWrapper */ },
		{ 0x138122 /* GameKit.IGKTurnBasedEventListener */, 0x138322 /* GKTurnBasedEventListenerWrapper */ },
		{ 0x138822 /* GameKit.IGKTurnBasedMatchmakerViewControllerDelegate */, 0x138922 /* GKTurnBasedMatchmakerViewControllerDelegateWrapper */ },
		{ 0x138F22 /* GameKit.IGKVoiceChatClient */, 0x139122 /* GKVoiceChatClientWrapper */ },
		{ 0x13BE22 /* GameController.IGCAxisElement */, 0x13BF22 /* GCAxisElementWrapper */ },
		{ 0x13C022 /* GameController.IGCAxisInput */, 0x13C122 /* GCAxisInputWrapper */ },
		{ 0x13C222 /* GameController.IGCButtonElement */, 0x13C322 /* GCButtonElementWrapper */ },
		{ 0x13CC22 /* GameController.IGCDevice */, 0x13CD22 /* GCDeviceWrapper */ },
		{ 0x13D322 /* GameController.IGCDevicePhysicalInput */, 0x13D422 /* GCDevicePhysicalInputWrapper */ },
		{ 0x13D622 /* GameController.IGCDevicePhysicalInputState */, 0x13D722 /* GCDevicePhysicalInputStateWrapper */ },
		{ 0x13D822 /* GameController.IGCDevicePhysicalInputStateDiff */, 0x13D922 /* GCDevicePhysicalInputStateDiffWrapper */ },
		{ 0x13DB22 /* GameController.IGCDirectionPadElement */, 0x13DC22 /* GCDirectionPadElementWrapper */ },
		{ 0x13F122 /* GameController.IGCLinearInput */, 0x13F222 /* GCLinearInputWrapper */ },
		{ 0x13F822 /* GameController.IGCPhysicalInputElement */, 0x13F922 /* GCPhysicalInputElementWrapper */ },
		{ 0x13FB22 /* GameController.IGCPressedStateInput */, 0x13FC22 /* GCPressedStateInputWrapper */ },
		{ 0x13FE22 /* GameController.IGCRelativeInput */, 0x13FF22 /* GCRelativeInputWrapper */ },
		{ 0x140022 /* GameController.IGCSwitchElement */, 0x140122 /* GCSwitchElementWrapper */ },
		{ 0x140222 /* GameController.IGCSwitchPositionInput */, 0x140322 /* GCSwitchPositionInputWrapper */ },
		{ 0x140522 /* GameController.IGCTouchedStateInput */, 0x140622 /* GCTouchedStateInputWrapper */ },
		{ 0x143322 /* GLKit.IGLKNamedEffect */, 0x143422 /* GLKNamedEffectWrapper */ },
		{ 0x143D22 /* GLKit.IGLKViewControllerDelegate */, 0x143F22 /* GLKViewControllerDelegateWrapper */ },
		{ 0x144122 /* GLKit.IGLKViewDelegate */, 0x144222 /* GLKViewDelegateWrapper */ },
		{ 0x145522 /* WebKit.IWKDownloadDelegate */, 0x145722 /* WKDownloadDelegateWrapper */ },
		{ 0x146122 /* WebKit.IWKHttpCookieStoreObserver */, 0x146322 /* WKHttpCookieStoreObserverWrapper */ },
		{ 0x146A22 /* WebKit.IWKNavigationDelegate */, 0x146C22 /* WKNavigationDelegateWrapper */ },
		{ 0x147322 /* WebKit.IWKPreviewActionItem */, 0x147422 /* WKPreviewActionItemWrapper */ },
		{ 0x147922 /* WebKit.IWKScriptMessageHandler */, 0x147A22 /* WKScriptMessageHandlerWrapper */ },
		{ 0x147C22 /* WebKit.IWKScriptMessageHandlerWithReply */, 0x147D22 /* WKScriptMessageHandlerWithReplyWrapper */ },
		{ 0x148122 /* WebKit.IWKUIDelegate */, 0x148322 /* WKUIDelegateWrapper */ },
		{ 0x148522 /* WebKit.IWKUrlSchemeHandler */, 0x148622 /* WKUrlSchemeHandlerWrapper */ },
		{ 0x148722 /* WebKit.IWKUrlSchemeTask */, 0x148822 /* WKUrlSchemeTaskWrapper */ },
		{ 0x153D22 /* Foundation.INSCacheDelegate */, 0x153F22 /* NSCacheDelegateWrapper */ },
		{ 0x154722 /* Foundation.INSCoding */, 0x154822 /* NSCodingWrapper */ },
		{ 0x155322 /* Foundation.INSCopying */, 0x155422 /* NSCopyingWrapper */ },
		{ 0x156A22 /* Foundation.INSDiscardableContent */, 0x156B22 /* NSDiscardableContentWrapper */ },
		{ 0x157622 /* Foundation.INSExtensionRequestHandling */, 0x157722 /* NSExtensionRequestHandlingWrapper */ },
		{ 0x157F22 /* Foundation.INSFileManagerDelegate */, 0x158022 /* NSFileManagerDelegateWrapper */ },
		{ 0x158222 /* Foundation.INSFilePresenter */, 0x158422 /* NSFilePresenterWrapper */ },
		{ 0x15A122 /* Foundation.INSItemProviderReading */, 0x15A222 /* NSItemProviderReadingWrapper */ },
		{ 0x15A422 /* Foundation.INSItemProviderWriting */, 0x15A622 /* NSItemProviderWritingWrapper */ },
		{ 0x15AC22 /* Foundation.INSKeyedArchiverDelegate */, 0x15AE22 /* NSKeyedArchiverDelegateWrapper */ },
		{ 0x15B022 /* Foundation.INSKeyedUnarchiverDelegate */, 0x15B222 /* NSKeyedUnarchiverDelegateWrapper */ },
		{ 0x15C822 /* Foundation.INSLocking */, 0x15C922 /* NSLockingWrapper */ },
		{ 0x15CB22 /* Foundation.INSMachPortDelegate */, 0x15CD22 /* NSMachPortDelegateWrapper */ },
		{ 0x15D922 /* Foundation.INSMetadataQueryDelegate */, 0x15DB22 /* NSMetadataQueryDelegateWrapper */ },
		{ 0x15E322 /* Foundation.INSMutableCopying */, 0x15E422 /* NSMutableCopyingWrapper */ },
		{ 0x15ED22 /* Foundation.INSNetServiceBrowserDelegate */, 0x15EF22 /* NSNetServiceBrowserDelegateWrapper */ },
		{ 0x15F122 /* Foundation.INSNetServiceDelegate */, 0x15F322 /* NSNetServiceDelegateWrapper */ },
		{ 0x15FF22 /* Foundation.INSObjectProtocol */, 0x160122 /* NSObjectProtocolWrapper */ },
		{ 0x160D22 /* Foundation.INSPortDelegate */, 0x160F22 /* NSPortDelegateWrapper */ },
		{ 0x161F22 /* Foundation.INSProgressReporting */, 0x162122 /* NSProgressReportingWrapper */ },
		{ 0x163322 /* Foundation.INSSecureCoding */, 0x163422 /* NSSecureCodingWrapper */ },
		{ 0x163A22 /* Foundation.INSStreamDelegate */, 0x163C22 /* NSStreamDelegateWrapper */ },
		{ 0x165622 /* Foundation.INSURLAuthenticationChallengeSender */, 0x165822 /* NSURLAuthenticationChallengeSenderWrapper */ },
		{ 0x165F22 /* Foundation.INSUrlConnectionDataDelegate */, 0x166122 /* NSUrlConnectionDataDelegateWrapper */ },
		{ 0x166322 /* Foundation.INSUrlConnectionDelegate */, 0x166522 /* NSUrlConnectionDelegateWrapper */ },
		{ 0x166722 /* Foundation.INSUrlConnectionDownloadDelegate */, 0x166922 /* NSUrlConnectionDownloadDelegateWrapper */ },
		{ 0x167022 /* Foundation.INSUrlProtocolClient */, 0x167122 /* NSUrlProtocolClientWrapper */ },
		{ 0x167E22 /* Foundation.INSUrlSessionDataDelegate */, 0x168022 /* NSUrlSessionDataDelegateWrapper */ },
		{ 0x168422 /* Foundation.INSUrlSessionDelegate */, 0x168622 /* NSUrlSessionDelegateWrapper */ },
		{ 0x168822 /* Foundation.INSUrlSessionDownloadDelegate */, 0x168A22 /* NSUrlSessionDownloadDelegateWrapper */ },
		{ 0x168F22 /* Foundation.INSUrlSessionStreamDelegate */, 0x169122 /* NSUrlSessionStreamDelegateWrapper */ },
		{ 0x169622 /* Foundation.INSUrlSessionTaskDelegate */, 0x169822 /* NSUrlSessionTaskDelegateWrapper */ },
		{ 0x16A222 /* Foundation.INSUrlSessionWebSocketDelegate */, 0x16A422 /* NSUrlSessionWebSocketDelegateWrapper */ },
		{ 0x16AC22 /* Foundation.INSUserActivityDelegate */, 0x16AE22 /* NSUserActivityDelegateWrapper */ },
		{ 0x16B622 /* Foundation.INSXpcListenerDelegate */, 0x16B822 /* NSXpcListenerDelegateWrapper */ },
		{ 0x16F122 /* FileProvider.INSFileProviderChangeObserver */, 0x16F322 /* NSFileProviderChangeObserverWrapper */ },
		{ 0x16F622 /* FileProvider.INSFileProviderCustomAction */, 0x16F722 /* NSFileProviderCustomActionWrapper */ },
		{ 0x16FB22 /* FileProvider.INSFileProviderDomainState */, 0x16FC22 /* NSFileProviderDomainStateWrapper */ },
		{ 0x16FF22 /* FileProvider.INSFileProviderEnumerating */, 0x170022 /* NSFileProviderEnumeratingWrapper */ },
		{ 0x170122 /* FileProvider.INSFileProviderEnumerationObserver */, 0x170322 /* NSFileProviderEnumerationObserverWrapper */ },
		{ 0x170422 /* FileProvider.INSFileProviderEnumerator */, 0x170622 /* NSFileProviderEnumeratorWrapper */ },
		{ 0x170C22 /* FileProvider.INSFileProviderIncrementalContentFetching */, 0x170D22 /* NSFileProviderIncrementalContentFetchingWrapper */ },
		{ 0x170E22 /* FileProvider.INSFileProviderItem */, 0x171022 /* NSFileProviderItemWrapper */ },
		{ 0x171A22 /* FileProvider.INSFileProviderPendingSetEnumerator */, 0x171C22 /* NSFileProviderPendingSetEnumeratorWrapper */ },
		{ 0x171D22 /* FileProvider.INSFileProviderReplicatedExtension */, 0x171F22 /* NSFileProviderReplicatedExtensionWrapper */ },
		{ 0x172122 /* FileProvider.INSFileProviderServiceSource */, 0x172322 /* NSFileProviderServiceSourceWrapper */ },
		{ 0x172422 /* FileProvider.INSFileProviderServicing */, 0x172522 /* NSFileProviderServicingWrapper */ },
		{ 0x172622 /* FileProvider.INSFileProviderTestingChildrenEnumeration */, 0x172722 /* NSFileProviderTestingChildrenEnumerationWrapper */ },
		{ 0x172822 /* FileProvider.INSFileProviderTestingCollisionResolution */, 0x172922 /* NSFileProviderTestingCollisionResolutionWrapper */ },
		{ 0x172A22 /* FileProvider.INSFileProviderTestingContentFetch */, 0x172B22 /* NSFileProviderTestingContentFetchWrapper */ },
		{ 0x172C22 /* FileProvider.INSFileProviderTestingCreation */, 0x172D22 /* NSFileProviderTestingCreationWrapper */ },
		{ 0x172E22 /* FileProvider.INSFileProviderTestingDeletion */, 0x172F22 /* NSFileProviderTestingDeletionWrapper */ },
		{ 0x173022 /* FileProvider.INSFileProviderTestingIngestion */, 0x173122 /* NSFileProviderTestingIngestionWrapper */ },
		{ 0x173222 /* FileProvider.INSFileProviderTestingLookup */, 0x173322 /* NSFileProviderTestingLookupWrapper */ },
		{ 0x173422 /* FileProvider.INSFileProviderTestingModification */, 0x173522 /* NSFileProviderTestingModificationWrapper */ },
		{ 0x173622 /* FileProvider.INSFileProviderTestingOperation */, 0x173722 /* NSFileProviderTestingOperationWrapper */ },
		{ 0x173A22 /* FileProvider.INSFileProviderThumbnailing */, 0x173B22 /* NSFileProviderThumbnailingWrapper */ },
		{ 0x174622 /* EventKitUI.IEKCalendarChooserDelegate */, 0x174822 /* EKCalendarChooserDelegateWrapper */ },
		{ 0x174C22 /* EventKitUI.IEKEventEditViewDelegate */, 0x174E22 /* EKEventEditViewDelegateWrapper */ },
		{ 0x175222 /* EventKitUI.IEKEventViewDelegate */, 0x175322 /* EKEventViewDelegateWrapper */ },
		{ 0x183122 /* CoreTelephony.ICTSubscriberDelegate */, 0x183222 /* CTSubscriberDelegateWrapper */ },
		{ 0x183522 /* CoreTelephony.ICTTelephonyNetworkInfoDelegate */, 0x183722 /* CTTelephonyNetworkInfoDelegateWrapper */ },
		{ 0x184722 /* CoreSpotlight.ICSSearchableIndexDelegate */, 0x184922 /* CSSearchableIndexDelegateWrapper */ },
		{ 0x186D22 /* CoreMotion.ICMHeadphoneMotionManagerDelegate */, 0x186F22 /* CMHeadphoneMotionManagerDelegateWrapper */ },
		{ 0x18B122 /* CoreMidi.IMidiCIProfileResponderDelegate */, 0x18B322 /* MidiCIProfileResponderDelegateWrapper */ },
		{ 0x18FD22 /* CoreML.IMLBatchProvider */, 0x18FE22 /* MLBatchProviderWrapper */ },
		{ 0x190022 /* CoreML.IMLCustomLayer */, 0x190222 /* MLCustomLayerWrapper */ },
		{ 0x190322 /* CoreML.IMLCustomModel */, 0x190522 /* MLCustomModelWrapper */ },
		{ 0x190922 /* CoreML.IMLFeatureProvider */, 0x190A22 /* MLFeatureProviderWrapper */ },
		{ 0x193222 /* CoreML.IMLWritable */, 0x193322 /* MLWritableWrapper */ },
		{ 0x195122 /* CoreLocation.ICLLocationManagerDelegate */, 0x195322 /* CLLocationManagerDelegateWrapper */ },
		{ 0x195722 /* CoreLocation.ICLLocationPushServiceExtension */, 0x195922 /* CLLocationPushServiceExtensionWrapper */ },
		{ 0x197222 /* CoreImage.ICIAccordionFoldTransitionProtocol */, 0x197322 /* CIAccordionFoldTransitionProtocolWrapper */ },
		{ 0x197622 /* CoreImage.ICIAffineClampProtocol */, 0x197722 /* CIAffineClampProtocolWrapper */ },
		{ 0x197A22 /* CoreImage.ICIAffineTileProtocol */, 0x197B22 /* CIAffineTileProtocolWrapper */ },
		{ 0x197E22 /* CoreImage.ICIAreaAverageProtocol */, 0x197F22 /* CIAreaAverageProtocolWrapper */ },
		{ 0x198122 /* CoreImage.ICIAreaHistogramProtocol */, 0x198222 /* CIAreaHistogramProtocolWrapper */ },
		{ 0x198422 /* CoreImage.ICIAreaLogarithmicHistogramProtocol */, 0x198522 /* CIAreaLogarithmicHistogramProtocolWrapper */ },
		{ 0x198822 /* CoreImage.ICIAreaMaximumAlphaProtocol */, 0x198922 /* CIAreaMaximumAlphaProtocolWrapper */ },
		{ 0x198A22 /* CoreImage.ICIAreaMaximumProtocol */, 0x198B22 /* CIAreaMaximumProtocolWrapper */ },
		{ 0x198E22 /* CoreImage.ICIAreaMinimumAlphaProtocol */, 0x198F22 /* CIAreaMinimumAlphaProtocolWrapper */ },
		{ 0x199022 /* CoreImage.ICIAreaMinimumProtocol */, 0x199122 /* CIAreaMinimumProtocolWrapper */ },
		{ 0x199322 /* CoreImage.ICIAreaMinMaxProtocol */, 0x199422 /* CIAreaMinMaxProtocolWrapper */ },
		{ 0x199622 /* CoreImage.ICIAreaMinMaxRedProtocol */, 0x199722 /* CIAreaMinMaxRedProtocolWrapper */ },
		{ 0x199822 /* CoreImage.ICIAreaReductionFilterProtocol */, 0x199922 /* CIAreaReductionFilterProtocolWrapper */ },
		{ 0x199B22 /* CoreImage.ICIAttributedTextImageGeneratorProtocol */, 0x199D22 /* CIAttributedTextImageGeneratorProtocolWrapper */ },
		{ 0x19A022 /* CoreImage.ICIAztecCodeGeneratorProtocol */, 0x19A122 /* CIAztecCodeGeneratorProtocolWrapper */ },
		{ 0x19A422 /* CoreImage.ICIBarcodeGeneratorProtocol */, 0x19A522 /* CIBarcodeGeneratorProtocolWrapper */ },
		{ 0x19A722 /* CoreImage.ICIBarsSwipeTransitionProtocol */, 0x19A822 /* CIBarsSwipeTransitionProtocolWrapper */ },
		{ 0x19AA22 /* CoreImage.ICIBicubicScaleTransformProtocol */, 0x19AB22 /* CIBicubicScaleTransformProtocolWrapper */ },
		{ 0x19B122 /* CoreImage.ICIBlendWithMaskProtocol */, 0x19B222 /* CIBlendWithMaskProtocolWrapper */ },
		{ 0x19B522 /* CoreImage.ICIBloomProtocol */, 0x19B622 /* CIBloomProtocolWrapper */ },
		{ 0x19B822 /* CoreImage.ICIBokehBlurProtocol */, 0x19B922 /* CIBokehBlurProtocolWrapper */ },
		{ 0x19BB22 /* CoreImage.ICIBoxBlurProtocol */, 0x19BC22 /* CIBoxBlurProtocolWrapper */ },
		{ 0x19BF22 /* CoreImage.ICIBumpDistortionLinearProtocol */, 0x19C022 /* CIBumpDistortionLinearProtocolWrapper */ },
		{ 0x19C122 /* CoreImage.ICIBumpDistortionProtocol */, 0x19C222 /* CIBumpDistortionProtocolWrapper */ },
		{ 0x19C522 /* CoreImage.ICICheckerboardGeneratorProtocol */, 0x19C622 /* CICheckerboardGeneratorProtocolWrapper */ },
		{ 0x19C822 /* CoreImage.ICICircleSplashDistortionProtocol */, 0x19C922 /* CICircleSplashDistortionProtocolWrapper */ },
		{ 0x19CB22 /* CoreImage.ICICircularScreenProtocol */, 0x19CC22 /* CICircularScreenProtocolWrapper */ },
		{ 0x19CE22 /* CoreImage.ICICircularWrapProtocol */, 0x19CF22 /* CICircularWrapProtocolWrapper */ },
		{ 0x19D222 /* CoreImage.ICICmykHalftoneProtocol */, 0x19D322 /* CICmykHalftoneProtocolWrapper */ },
		{ 0x19D522 /* CoreImage.ICICode128BarcodeGeneratorProtocol */, 0x19D622 /* CICode128BarcodeGeneratorProtocolWrapper */ },
		{ 0x19D922 /* CoreImage.ICIColorAbsoluteDifferenceProtocol */, 0x19DA22 /* CIColorAbsoluteDifferenceProtocolWrapper */ },
		{ 0x19DE22 /* CoreImage.ICIColorClampProtocol */, 0x19DF22 /* CIColorClampProtocolWrapper */ },
		{ 0x19E122 /* CoreImage.ICIColorControlsProtocol */, 0x19E222 /* CIColorControlsProtocolWrapper */ },
		{ 0x19E422 /* CoreImage.ICIColorCrossPolynomialProtocol */, 0x19E522 /* CIColorCrossPolynomialProtocolWrapper */ },
		{ 0x19E722 /* CoreImage.ICIColorCubeProtocol */, 0x19E922 /* CIColorCubeProtocolWrapper */ },
		{ 0x19EB22 /* CoreImage.ICIColorCubesMixedWithMaskProtocol */, 0x19ED22 /* CIColorCubesMixedWithMaskProtocolWrapper */ },
		{ 0x19EF22 /* CoreImage.ICIColorCubeWithColorSpaceProtocol */, 0x19F122 /* CIColorCubeWithColorSpaceProtocolWrapper */ },
		{ 0x19F322 /* CoreImage.ICIColorCurvesProtocol */, 0x19F422 /* CIColorCurvesProtocolWrapper */ },
		{ 0x19F722 /* CoreImage.ICIColorInvertProtocol */, 0x19F822 /* CIColorInvertProtocolWrapper */ },
		{ 0x19FB22 /* CoreImage.ICIColorMapProtocol */, 0x19FC22 /* CIColorMapProtocolWrapper */ },
		{ 0x19FE22 /* CoreImage.ICIColorMatrixProtocol */, 0x19FF22 /* CIColorMatrixProtocolWrapper */ },
		{ 0x1A0122 /* CoreImage.ICIColorMonochromeProtocol */, 0x1A0222 /* CIColorMonochromeProtocolWrapper */ },
		{ 0x1A0422 /* CoreImage.ICIColorPolynomialProtocol */, 0x1A0522 /* CIColorPolynomialProtocolWrapper */ },
		{ 0x1A0722 /* CoreImage.ICIColorPosterizeProtocol */, 0x1A0822 /* CIColorPosterizeProtocolWrapper */ },
		{ 0x1A0B22 /* CoreImage.ICIColorThresholdOtsuProtocol */, 0x1A0C22 /* CIColorThresholdOtsuProtocolWrapper */ },
		{ 0x1A0D22 /* CoreImage.ICIColorThresholdProtocol */, 0x1A0E22 /* CIColorThresholdProtocolWrapper */ },
		{ 0x1A1022 /* CoreImage.ICIColumnAverageProtocol */, 0x1A1122 /* CIColumnAverageProtocolWrapper */ },
		{ 0x1A1322 /* CoreImage.ICIComicEffectProtocol */, 0x1A1422 /* CIComicEffectProtocolWrapper */ },
		{ 0x1A1522 /* CoreImage.ICICompositeOperationProtocol */, 0x1A1622 /* CICompositeOperationProtocolWrapper */ },
		{ 0x1A1C22 /* CoreImage.ICIConvertLabProtocol */, 0x1A1D22 /* CIConvertLabProtocolWrapper */ },
		{ 0x1A2422 /* CoreImage.ICIConvolutionProtocol */, 0x1A2522 /* CIConvolutionProtocolWrapper */ },
		{ 0x1A2C22 /* CoreImage.ICICopyMachineTransitionProtocol */, 0x1A2D22 /* CICopyMachineTransitionProtocolWrapper */ },
		{ 0x1A2F22 /* CoreImage.ICICoreMLModelProtocol */, 0x1A3022 /* CICoreMLModelProtocolWrapper */ },
		{ 0x1A3322 /* CoreImage.ICICrystallizeProtocol */, 0x1A3422 /* CICrystallizeProtocolWrapper */ },
		{ 0x1A3B22 /* CoreImage.ICIDepthOfFieldProtocol */, 0x1A3C22 /* CIDepthOfFieldProtocolWrapper */ },
		{ 0x1A3E22 /* CoreImage.ICIDepthToDisparityProtocol */, 0x1A3F22 /* CIDepthToDisparityProtocolWrapper */ },
		{ 0x1A4222 /* CoreImage.ICIDiscBlurProtocol */, 0x1A4322 /* CIDiscBlurProtocolWrapper */ },
		{ 0x1A4522 /* CoreImage.ICIDisintegrateWithMaskTransitionProtocol */, 0x1A4622 /* CIDisintegrateWithMaskTransitionProtocolWrapper */ },
		{ 0x1A4822 /* CoreImage.ICIDisparityToDepthProtocol */, 0x1A4922 /* CIDisparityToDepthProtocolWrapper */ },
		{ 0x1A4B22 /* CoreImage.ICIDisplacementDistortionProtocol */, 0x1A4C22 /* CIDisplacementDistortionProtocolWrapper */ },
		{ 0x1A4E22 /* CoreImage.ICIDissolveTransitionProtocol */, 0x1A4F22 /* CIDissolveTransitionProtocolWrapper */ },
		{ 0x1A5222 /* CoreImage.ICIDitherProtocol */, 0x1A5322 /* CIDitherProtocolWrapper */ },
		{ 0x1A5622 /* CoreImage.ICIDocumentEnhancerProtocol */, 0x1A5722 /* CIDocumentEnhancerProtocolWrapper */ },
		{ 0x1A5922 /* CoreImage.ICIDotScreenProtocol */, 0x1A5A22 /* CIDotScreenProtocolWrapper */ },
		{ 0x1A5C22 /* CoreImage.ICIDrosteProtocol */, 0x1A5D22 /* CIDrosteProtocolWrapper */ },
		{ 0x1A5F22 /* CoreImage.ICIEdgePreserveUpsampleProtocol */, 0x1A6022 /* CIEdgePreserveUpsampleProtocolWrapper */ },
		{ 0x1A6222 /* CoreImage.ICIEdgesProtocol */, 0x1A6322 /* CIEdgesProtocolWrapper */ },
		{ 0x1A6522 /* CoreImage.ICIEdgeWorkProtocol */, 0x1A6622 /* CIEdgeWorkProtocolWrapper */ },
		{ 0x1A6822 /* CoreImage.ICIEightfoldReflectedTileProtocol */, 0x1A6922 /* CIEightfoldReflectedTileProtocolWrapper */ },
		{ 0x1A6C22 /* CoreImage.ICIExposureAdjustProtocol */, 0x1A6D22 /* CIExposureAdjustProtocolWrapper */ },
		{ 0x1A7122 /* CoreImage.ICIFalseColorProtocol */, 0x1A7222 /* CIFalseColorProtocolWrapper */ },
		{ 0x1A7622 /* CoreImage.ICIFilterConstructor */, 0x1A7722 /* CIFilterConstructorWrapper */ },
		{ 0x1A7A22 /* CoreImage.ICIFilterProtocol */, 0x1A7B22 /* CIFilterProtocolWrapper */ },
		{ 0x1A7E22 /* CoreImage.ICIFlashTransitionProtocol */, 0x1A7F22 /* CIFlashTransitionProtocolWrapper */ },
		{ 0x1A8122 /* CoreImage.ICIFourCoordinateGeometryFilterProtocol */, 0x1A8222 /* CIFourCoordinateGeometryFilterProtocolWrapper */ },
		{ 0x1A8422 /* CoreImage.ICIFourfoldReflectedTileProtocol */, 0x1A8522 /* CIFourfoldReflectedTileProtocolWrapper */ },
		{ 0x1A8722 /* CoreImage.ICIFourfoldRotatedTileProtocol */, 0x1A8822 /* CIFourfoldRotatedTileProtocolWrapper */ },
		{ 0x1A8A22 /* CoreImage.ICIFourfoldTranslatedTileProtocol */, 0x1A8B22 /* CIFourfoldTranslatedTileProtocolWrapper */ },
		{ 0x1A8D22 /* CoreImage.ICIGaborGradientsProtocol */, 0x1A8E22 /* CIGaborGradientsProtocolWrapper */ },
		{ 0x1A9022 /* CoreImage.ICIGammaAdjustProtocol */, 0x1A9122 /* CIGammaAdjustProtocolWrapper */ },
		{ 0x1A9322 /* CoreImage.ICIGaussianBlurProtocol */, 0x1A9422 /* CIGaussianBlurProtocolWrapper */ },
		{ 0x1A9622 /* CoreImage.ICIGaussianGradientProtocol */, 0x1A9722 /* CIGaussianGradientProtocolWrapper */ },
		{ 0x1A9922 /* CoreImage.ICIGlassDistortionProtocol */, 0x1A9A22 /* CIGlassDistortionProtocolWrapper */ },
		{ 0x1A9C22 /* CoreImage.ICIGlassLozengeProtocol */, 0x1A9D22 /* CIGlassLozengeProtocolWrapper */ },
		{ 0x1A9F22 /* CoreImage.ICIGlideReflectedTileProtocol */, 0x1AA022 /* CIGlideReflectedTileProtocolWrapper */ },
		{ 0x1AA222 /* CoreImage.ICIGloomProtocol */, 0x1AA322 /* CIGloomProtocolWrapper */ },
		{ 0x1AA722 /* CoreImage.ICIHatchedScreenProtocol */, 0x1AA822 /* CIHatchedScreenProtocolWrapper */ },
		{ 0x1AAA22 /* CoreImage.ICIHeightFieldFromMaskProtocol */, 0x1AAB22 /* CIHeightFieldFromMaskProtocolWrapper */ },
		{ 0x1AAD22 /* CoreImage.ICIHexagonalPixellateProtocol */, 0x1AAE22 /* CIHexagonalPixellateProtocolWrapper */ },
		{ 0x1AB022 /* CoreImage.ICIHighlightShadowAdjustProtocol */, 0x1AB122 /* CIHighlightShadowAdjustProtocolWrapper */ },
		{ 0x1AB322 /* CoreImage.ICIHistogramDisplayProtocol */, 0x1AB422 /* CIHistogramDisplayProtocolWrapper */ },
		{ 0x1AB622 /* CoreImage.ICIHoleDistortionProtocol */, 0x1AB722 /* CIHoleDistortionProtocolWrapper */ },
		{ 0x1AB922 /* CoreImage.ICIHueAdjustProtocol */, 0x1ABA22 /* CIHueAdjustProtocolWrapper */ },
		{ 0x1ABD22 /* CoreImage.ICIHueSaturationValueGradientProtocol */, 0x1ABE22 /* CIHueSaturationValueGradientProtocolWrapper */ },
		{ 0x1AC322 /* CoreImage.ICIImageProcessorInput */, 0x1AC522 /* CIImageProcessorInputWrapper */ },
		{ 0x1AC722 /* CoreImage.ICIImageProcessorOutput */, 0x1AC922 /* CIImageProcessorOutputWrapper */ },
		{ 0x1AD122 /* CoreImage.ICIKaleidoscopeProtocol */, 0x1AD222 /* CIKaleidoscopeProtocolWrapper */ },
		{ 0x1AD622 /* CoreImage.ICIKeystoneCorrectionCombinedProtocol */, 0x1AD722 /* CIKeystoneCorrectionCombinedProtocolWrapper */ },
		{ 0x1AD922 /* CoreImage.ICIKeystoneCorrectionHorizontalProtocol */, 0x1ADA22 /* CIKeystoneCorrectionHorizontalProtocolWrapper */ },
		{ 0x1ADC22 /* CoreImage.ICIKeystoneCorrectionVerticalProtocol */, 0x1ADD22 /* CIKeystoneCorrectionVerticalProtocolWrapper */ },
		{ 0x1ADF22 /* CoreImage.ICIKMeansProtocol */, 0x1AE022 /* CIKMeansProtocolWrapper */ },
		{ 0x1AE222 /* CoreImage.ICILabDeltaEProtocol */, 0x1AE322 /* CILabDeltaEProtocolWrapper */ },
		{ 0x1AE522 /* CoreImage.ICILanczosScaleTransformProtocol */, 0x1AE622 /* CILanczosScaleTransformProtocolWrapper */ },
		{ 0x1AE822 /* CoreImage.ICILenticularHaloGeneratorProtocol */, 0x1AE922 /* CILenticularHaloGeneratorProtocolWrapper */ },
		{ 0x1AEC22 /* CoreImage.ICILightTunnelProtocol */, 0x1AED22 /* CILightTunnelProtocolWrapper */ },
		{ 0x1AF222 /* CoreImage.ICILinearGradientProtocol */, 0x1AF322 /* CILinearGradientProtocolWrapper */ },
		{ 0x1AF622 /* CoreImage.ICILinearToSrgbToneCurveProtocol */, 0x1AF722 /* CILinearToSrgbToneCurveProtocolWrapper */ },
		{ 0x1AF922 /* CoreImage.ICILineOverlayProtocol */, 0x1AFA22 /* CILineOverlayProtocolWrapper */ },
		{ 0x1AFC22 /* CoreImage.ICILineScreenProtocol */, 0x1AFD22 /* CILineScreenProtocolWrapper */ },
		{ 0x1B0022 /* CoreImage.ICIMaskedVariableBlurProtocol */, 0x1B0122 /* CIMaskedVariableBlurProtocolWrapper */ },
		{ 0x1B0322 /* CoreImage.ICIMaskToAlphaProtocol */, 0x1B0422 /* CIMaskToAlphaProtocolWrapper */ },
		{ 0x1B0622 /* CoreImage.ICIMaximumComponentProtocol */, 0x1B0722 /* CIMaximumComponentProtocolWrapper */ },
		{ 0x1B0A22 /* CoreImage.ICIMedianProtocol */, 0x1B0B22 /* CIMedianProtocolWrapper */ },
		{ 0x1B0D22 /* CoreImage.ICIMeshGeneratorProtocol */, 0x1B0E22 /* CIMeshGeneratorProtocolWrapper */ },
		{ 0x1B1022 /* CoreImage.ICIMinimumComponentProtocol */, 0x1B1122 /* CIMinimumComponentProtocolWrapper */ },
		{ 0x1B1422 /* CoreImage.ICIMixProtocol */, 0x1B1522 /* CIMixProtocolWrapper */ },
		{ 0x1B1722 /* CoreImage.ICIModTransitionProtocol */, 0x1B1822 /* CIModTransitionProtocolWrapper */ },
		{ 0x1B1B22 /* CoreImage.ICIMorphologyGradientProtocol */, 0x1B1C22 /* CIMorphologyGradientProtocolWrapper */ },
		{ 0x1B1E22 /* CoreImage.ICIMorphologyMaximumProtocol */, 0x1B1F22 /* CIMorphologyMaximumProtocolWrapper */ },
		{ 0x1B2122 /* CoreImage.ICIMorphologyMinimumProtocol */, 0x1B2222 /* CIMorphologyMinimumProtocolWrapper */ },
		{ 0x1B2522 /* CoreImage.ICIMorphologyRectangleMaximumProtocol */, 0x1B2622 /* CIMorphologyRectangleMaximumProtocolWrapper */ },
		{ 0x1B2822 /* CoreImage.ICIMorphologyRectangleMinimumProtocol */, 0x1B2922 /* CIMorphologyRectangleMinimumProtocolWrapper */ },
		{ 0x1B2B22 /* CoreImage.ICIMotionBlurProtocol */, 0x1B2C22 /* CIMotionBlurProtocolWrapper */ },
		{ 0x1B3022 /* CoreImage.ICINinePartStretchedProtocol */, 0x1B3122 /* CINinePartStretchedProtocolWrapper */ },
		{ 0x1B3322 /* CoreImage.ICINinePartTiledProtocol */, 0x1B3422 /* CINinePartTiledProtocolWrapper */ },
		{ 0x1B3622 /* CoreImage.ICINoiseReductionProtocol */, 0x1B3722 /* CINoiseReductionProtocolWrapper */ },
		{ 0x1B3922 /* CoreImage.ICIOpTileProtocol */, 0x1B3A22 /* CIOpTileProtocolWrapper */ },
		{ 0x1B3D22 /* CoreImage.ICIPageCurlTransitionProtocol */, 0x1B3E22 /* CIPageCurlTransitionProtocolWrapper */ },
		{ 0x1B4022 /* CoreImage.ICIPageCurlWithShadowTransitionProtocol */, 0x1B4122 /* CIPageCurlWithShadowTransitionProtocolWrapper */ },
		{ 0x1B4322 /* CoreImage.ICIPaletteCentroidProtocol */, 0x1B4422 /* CIPaletteCentroidProtocolWrapper */ },
		{ 0x1B4622 /* CoreImage.ICIPalettizeProtocol */, 0x1B4722 /* CIPalettizeProtocolWrapper */ },
		{ 0x1B4922 /* CoreImage.ICIParallelogramTileProtocol */, 0x1B4A22 /* CIParallelogramTileProtocolWrapper */ },
		{ 0x1B4C22 /* CoreImage.ICIPdf417BarcodeGeneratorProtocol */, 0x1B4D22 /* CIPdf417BarcodeGeneratorProtocolWrapper */ },
		{ 0x1B5022 /* CoreImage.ICIPersonSegmentationProtocol */, 0x1B5122 /* CIPersonSegmentationProtocolWrapper */ },
		{ 0x1B5322 /* CoreImage.ICIPerspectiveCorrectionProtocol */, 0x1B5422 /* CIPerspectiveCorrectionProtocolWrapper */ },
		{ 0x1B5622 /* CoreImage.ICIPerspectiveRotateProtocol */, 0x1B5722 /* CIPerspectiveRotateProtocolWrapper */ },
		{ 0x1B5922 /* CoreImage.ICIPerspectiveTileProtocol */, 0x1B5A22 /* CIPerspectiveTileProtocolWrapper */ },
		{ 0x1B5C22 /* CoreImage.ICIPerspectiveTransformProtocol */, 0x1B5D22 /* CIPerspectiveTransformProtocolWrapper */ },
		{ 0x1B5F22 /* CoreImage.ICIPerspectiveTransformWithExtentProtocol */, 0x1B6022 /* CIPerspectiveTransformWithExtentProtocolWrapper */ },
		{ 0x1B6822 /* CoreImage.ICIPhotoEffectProtocol */, 0x1B6922 /* CIPhotoEffectProtocolWrapper */ },
		{ 0x1B6D22 /* CoreImage.ICIPinchDistortionProtocol */, 0x1B6E22 /* CIPinchDistortionProtocolWrapper */ },
		{ 0x1B7122 /* CoreImage.ICIPixellateProtocol */, 0x1B7222 /* CIPixellateProtocolWrapper */ },
		{ 0x1B7422 /* CoreImage.ICIPointillizeProtocol */, 0x1B7522 /* CIPointillizeProtocolWrapper */ },
		{ 0x1B7A22 /* CoreImage.ICIQRCodeGeneratorProtocol */, 0x1B7B22 /* CIQRCodeGeneratorProtocolWrapper */ },
		{ 0x1B7D22 /* CoreImage.ICIRadialGradientProtocol */, 0x1B7E22 /* CIRadialGradientProtocolWrapper */ },
		{ 0x1B8022 /* CoreImage.ICIRandomGeneratorProtocol */, 0x1B8122 /* CIRandomGeneratorProtocolWrapper */ },
		{ 0x1B8E22 /* CoreImage.ICIRippleTransitionProtocol */, 0x1B8F22 /* CIRippleTransitionProtocolWrapper */ },
		{ 0x1B9122 /* CoreImage.ICIRoundedRectangleGeneratorProtocol */, 0x1B9222 /* CIRoundedRectangleGeneratorProtocolWrapper */ },
		{ 0x1B9422 /* CoreImage.ICIRowAverageProtocol */, 0x1B9522 /* CIRowAverageProtocolWrapper */ },
		{ 0x1B9722 /* CoreImage.ICISaliencyMapProtocol */, 0x1B9822 /* CISaliencyMapProtocolWrapper */ },
		{ 0x1B9E22 /* CoreImage.ICISepiaToneProtocol */, 0x1B9F22 /* CISepiaToneProtocolWrapper */ },
		{ 0x1BA122 /* CoreImage.ICIShadedMaterialProtocol */, 0x1BA222 /* CIShadedMaterialProtocolWrapper */ },
		{ 0x1BA422 /* CoreImage.ICISharpenLuminanceProtocol */, 0x1BA522 /* CISharpenLuminanceProtocolWrapper */ },
		{ 0x1BA722 /* CoreImage.ICISixfoldReflectedTileProtocol */, 0x1BA822 /* CISixfoldReflectedTileProtocolWrapper */ },
		{ 0x1BAA22 /* CoreImage.ICISixfoldRotatedTileProtocol */, 0x1BAB22 /* CISixfoldRotatedTileProtocolWrapper */ },
		{ 0x1BAD22 /* CoreImage.ICISmoothLinearGradientProtocol */, 0x1BAE22 /* CISmoothLinearGradientProtocolWrapper */ },
		{ 0x1BB522 /* CoreImage.ICISpotColorProtocol */, 0x1BB622 /* CISpotColorProtocolWrapper */ },
		{ 0x1BB822 /* CoreImage.ICISpotLightProtocol */, 0x1BB922 /* CISpotLightProtocolWrapper */ },
		{ 0x1BBB22 /* CoreImage.ICISrgbToneCurveToLinearProtocol */, 0x1BBC22 /* CISrgbToneCurveToLinearProtocolWrapper */ },
		{ 0x1BBE22 /* CoreImage.ICIStarShineGeneratorProtocol */, 0x1BBF22 /* CIStarShineGeneratorProtocolWrapper */ },
		{ 0x1BC122 /* CoreImage.ICIStraightenProtocol */, 0x1BC222 /* CIStraightenProtocolWrapper */ },
		{ 0x1BC422 /* CoreImage.ICIStretchCropProtocol */, 0x1BC522 /* CIStretchCropProtocolWrapper */ },
		{ 0x1BC722 /* CoreImage.ICIStripesGeneratorProtocol */, 0x1BC822 /* CIStripesGeneratorProtocolWrapper */ },
		{ 0x1BCB22 /* CoreImage.ICISunbeamsGeneratorProtocol */, 0x1BCC22 /* CISunbeamsGeneratorProtocolWrapper */ },
		{ 0x1BCE22 /* CoreImage.ICISwipeTransitionProtocol */, 0x1BCF22 /* CISwipeTransitionProtocolWrapper */ },
		{ 0x1BD122 /* CoreImage.ICITemperatureAndTintProtocol */, 0x1BD222 /* CITemperatureAndTintProtocolWrapper */ },
		{ 0x1BD522 /* CoreImage.ICITextImageGeneratorProtocol */, 0x1BD722 /* CITextImageGeneratorProtocolWrapper */ },
		{ 0x1BD922 /* CoreImage.ICIThermalProtocol */, 0x1BDA22 /* CIThermalProtocolWrapper */ },
		{ 0x1BDD22 /* CoreImage.ICIToneCurveProtocol */, 0x1BDE22 /* CIToneCurveProtocolWrapper */ },
		{ 0x1BE022 /* CoreImage.ICITorusLensDistortionProtocol */, 0x1BE122 /* CITorusLensDistortionProtocolWrapper */ },
		{ 0x1BE322 /* CoreImage.ICITransitionFilterProtocol */, 0x1BE422 /* CITransitionFilterProtocolWrapper */ },
		{ 0x1BE622 /* CoreImage.ICITriangleKaleidoscopeProtocol */, 0x1BE722 /* CITriangleKaleidoscopeProtocolWrapper */ },
		{ 0x1BE922 /* CoreImage.ICITriangleTileProtocol */, 0x1BEA22 /* CITriangleTileProtocolWrapper */ },
		{ 0x1BEC22 /* CoreImage.ICITwelvefoldReflectedTileProtocol */, 0x1BED22 /* CITwelvefoldReflectedTileProtocolWrapper */ },
		{ 0x1BEF22 /* CoreImage.ICITwirlDistortionProtocol */, 0x1BF022 /* CITwirlDistortionProtocolWrapper */ },
		{ 0x1BF322 /* CoreImage.ICIUnsharpMaskProtocol */, 0x1BF422 /* CIUnsharpMaskProtocolWrapper */ },
		{ 0x1BF622 /* CoreImage.ICIVibranceProtocol */, 0x1BF722 /* CIVibranceProtocolWrapper */ },
		{ 0x1BFA22 /* CoreImage.ICIVignetteEffectProtocol */, 0x1BFB22 /* CIVignetteEffectProtocolWrapper */ },
		{ 0x1BFC22 /* CoreImage.ICIVignetteProtocol */, 0x1BFD22 /* CIVignetteProtocolWrapper */ },
		{ 0x1C0022 /* CoreImage.ICIVortexDistortionProtocol */, 0x1C0122 /* CIVortexDistortionProtocolWrapper */ },
		{ 0x1C0422 /* CoreImage.ICIWhitePointAdjustProtocol */, 0x1C0522 /* CIWhitePointAdjustProtocolWrapper */ },
		{ 0x1C0722 /* CoreImage.ICIXRayProtocol */, 0x1C0822 /* CIXRayProtocolWrapper */ },
		{ 0x1C0A22 /* CoreImage.ICIZoomBlurProtocol */, 0x1C0B22 /* CIZoomBlurProtocolWrapper */ },
		{ 0x1CCC22 /* CoreData.INSFetchedResultsControllerDelegate */, 0x1CCE22 /* NSFetchedResultsControllerDelegateWrapper */ },
		{ 0x1CD022 /* CoreData.INSFetchedResultsSectionInfo */, 0x1CD122 /* NSFetchedResultsSectionInfoWrapper */ },
		{ 0x1CD822 /* CoreData.INSFetchRequestResult */, 0x1CD922 /* NSFetchRequestResultWrapper */ },
		{ 0x1D3422 /* CoreBluetooth.ICBCentralManagerDelegate */, 0x1D3622 /* CBCentralManagerDelegateWrapper */ },
		{ 0x1D4F22 /* CoreBluetooth.ICBPeripheralDelegate */, 0x1D5122 /* CBPeripheralDelegateWrapper */ },
		{ 0x1D5B22 /* CoreBluetooth.ICBPeripheralManagerDelegate */, 0x1D5D22 /* CBPeripheralManagerDelegateWrapper */ },
		{ 0x1D7322 /* CoreAnimation.ICAAction */, 0x1D7422 /* CAActionWrapper */ },
		{ 0x1D7622 /* CoreAnimation.ICAAnimationDelegate */, 0x1D7822 /* CAAnimationDelegateWrapper */ },
		{ 0x1D8722 /* CoreAnimation.ICALayerDelegate */, 0x1D8922 /* CALayerDelegateWrapper */ },
		{ 0x1D8A22 /* CoreAnimation.ICAMediaTiming */, 0x1D8B22 /* CAMediaTimingWrapper */ },
		{ 0x1D8D22 /* CoreAnimation.ICAMetalDrawable */, 0x1D8E22 /* CAMetalDrawableWrapper */ },
		{ 0x1DB122 /* Contacts.ICNChangeHistoryEventVisitor */, 0x1DB322 /* CNChangeHistoryEventVisitorWrapper */ },
		{ 0x1DD222 /* Contacts.ICNKeyDescriptor */, 0x1DD322 /* CNKeyDescriptorWrapper */ },
		{ 0x1E2C22 /* CloudKit.ICKRecordValue */, 0x1E2D22 /* CKRecordValueWrapper */ },
		{ 0x1E6422 /* ClassKit.ICLSContextProvider */, 0x1E6522 /* CLSContextProviderWrapper */ },
		{ 0x1E6A22 /* ClassKit.ICLSDataStoreDelegate */, 0x1E6B22 /* CLSDataStoreDelegateWrapper */ },
		{ 0x1ED022 /* CarPlay.ICPApplicationDelegate */, 0x1ED222 /* CPApplicationDelegateWrapper */ },
		{ 0x1ED922 /* CarPlay.ICPBarButtonProviding */, 0x1EDB22 /* CPBarButtonProvidingWrapper */ },
		{ 0x1EEF22 /* CarPlay.ICPInstrumentClusterControllerDelegate */, 0x1EF122 /* CPInstrumentClusterControllerDelegateWrapper */ },
		{ 0x1EF522 /* CarPlay.ICPInterfaceControllerDelegate */, 0x1EF722 /* CPInterfaceControllerDelegateWrapper */ },
		{ 0x1F0022 /* CarPlay.ICPListTemplateDelegate */, 0x1F0122 /* CPListTemplateDelegateWrapper */ },
		{ 0x1F0322 /* CarPlay.ICPListTemplateItem */, 0x1F0522 /* CPListTemplateItemWrapper */ },
		{ 0x1F0A22 /* CarPlay.ICPMapTemplateDelegate */, 0x1F0C22 /* CPMapTemplateDelegateWrapper */ },
		{ 0x1F1E22 /* CarPlay.ICPNowPlayingTemplateObserver */, 0x1F2022 /* CPNowPlayingTemplateObserverWrapper */ },
		{ 0x1F2422 /* CarPlay.ICPPointOfInterestTemplateDelegate */, 0x1F2622 /* CPPointOfInterestTemplateDelegateWrapper */ },
		{ 0x1F2A22 /* CarPlay.ICPSearchTemplateDelegate */, 0x1F2C22 /* CPSearchTemplateDelegateWrapper */ },
		{ 0x1F2E22 /* CarPlay.ICPSelectableListItem */, 0x1F2F22 /* CPSelectableListItemWrapper */ },
		{ 0x1F3122 /* CarPlay.ICPSessionConfigurationDelegate */, 0x1F3322 /* CPSessionConfigurationDelegateWrapper */ },
		{ 0x1F3622 /* CarPlay.ICPTabBarTemplateDelegate */, 0x1F3722 /* CPTabBarTemplateDelegateWrapper */ },
		{ 0x1F3B22 /* CarPlay.ICPTemplateApplicationDashboardSceneDelegate */, 0x1F3D22 /* CPTemplateApplicationDashboardSceneDelegateWrapper */ },
		{ 0x1F4022 /* CarPlay.ICPTemplateApplicationInstrumentClusterSceneDelegate */, 0x1F4222 /* CPTemplateApplicationInstrumentClusterSceneDelegateWrapper */ },
		{ 0x1F4522 /* CarPlay.ICPTemplateApplicationSceneDelegate */, 0x1F4722 /* CPTemplateApplicationSceneDelegateWrapper */ },
		{ 0x1F6022 /* CallKit.ICXCallDirectoryExtensionContextDelegate */, 0x1F6122 /* CXCallDirectoryExtensionContextDelegateWrapper */ },
		{ 0x1F6722 /* CallKit.ICXCallObserverDelegate */, 0x1F6822 /* CXCallObserverDelegateWrapper */ },
		{ 0x1F7B22 /* CallKit.ICXProviderDelegate */, 0x1F7D22 /* CXProviderDelegateWrapper */ },
		{ 0x1F9122 /* BackgroundAssets.IBADownloaderExtension */, 0x1F9322 /* BADownloaderExtensionWrapper */ },
		{ 0x1F9422 /* BackgroundAssets.IBADownloadManagerDelegate */, 0x1F9622 /* BADownloadManagerDelegateWrapper */ },
		{ 0x1F9E22 /* AuthenticationServices.IASAccountAuthenticationModificationControllerDelegate */, 0x1FA022 /* ASAccountAuthenticationModificationControllerDelegateWrapper */ },
		{ 0x1FA222 /* AuthenticationServices.IASAccountAuthenticationModificationControllerPresentationContextProviding */, 0x1FA322 /* ASAccountAuthenticationModificationControllerPresentationContextProvidingWrapper */ },
		{ 0x1FB122 /* AuthenticationServices.IASAuthorizationControllerDelegate */, 0x1FB322 /* ASAuthorizationControllerDelegateWrapper */ },
		{ 0x1FB522 /* AuthenticationServices.IASAuthorizationControllerPresentationContextProviding */, 0x1FB622 /* ASAuthorizationControllerPresentationContextProvidingWrapper */ },
		{ 0x1FB822 /* AuthenticationServices.IASAuthorizationCredential */, 0x1FB922 /* ASAuthorizationCredentialWrapper */ },
		{ 0x1FC722 /* AuthenticationServices.IASAuthorizationProvider */, 0x1FC822 /* ASAuthorizationProviderWrapper */ },
		{ 0x1FCC22 /* AuthenticationServices.IASAuthorizationProviderExtensionAuthorizationRequestHandler */, 0x1FCE22 /* ASAuthorizationProviderExtensionAuthorizationRequestHandlerWrapper */ },
		{ 0x1FD022 /* AuthenticationServices.IASAuthorizationPublicKeyCredentialAssertion */, 0x1FD122 /* ASAuthorizationPublicKeyCredentialAssertionWrapper */ },
		{ 0x1FD222 /* AuthenticationServices.IASAuthorizationPublicKeyCredentialAssertionRequest */, 0x1FD322 /* ASAuthorizationPublicKeyCredentialAssertionRequestWrapper */ },
		{ 0x1FD522 /* AuthenticationServices.IASAuthorizationPublicKeyCredentialDescriptor */, 0x1FD622 /* ASAuthorizationPublicKeyCredentialDescriptorWrapper */ },
		{ 0x1FD822 /* AuthenticationServices.IASAuthorizationPublicKeyCredentialRegistration */, 0x1FD922 /* ASAuthorizationPublicKeyCredentialRegistrationWrapper */ },
		{ 0x1FDA22 /* AuthenticationServices.IASAuthorizationPublicKeyCredentialRegistrationRequest */, 0x1FDB22 /* ASAuthorizationPublicKeyCredentialRegistrationRequestWrapper */ },
		{ 0x1FF922 /* AuthenticationServices.IASPublicKeyCredential */, 0x1FFA22 /* ASPublicKeyCredentialWrapper */ },
		{ 0x1FFC22 /* AuthenticationServices.IASWebAuthenticationPresentationContextProviding */, 0x1FFD22 /* ASWebAuthenticationPresentationContextProvidingWrapper */ },
		{ 0x203C22 /* AudioUnit.IAUAudioUnitFactory */, 0x203D22 /* AUAudioUnitFactoryWrapper */ },
		{ 0x21FA22 /* UIKit.INSCollectionLayoutContainer */, 0x21FB22 /* NSCollectionLayoutContainerWrapper */ },
		{ 0x21FF22 /* UIKit.INSCollectionLayoutEnvironment */, 0x220022 /* NSCollectionLayoutEnvironmentWrapper */ },
		{ 0x220822 /* UIKit.INSCollectionLayoutVisibleItem */, 0x220922 /* NSCollectionLayoutVisibleItemWrapper */ },
		{ 0x221822 /* UIKit.INSLayoutManagerDelegate */, 0x221A22 /* NSLayoutManagerDelegateWrapper */ },
		{ 0x222822 /* UIKit.INSTextAttachmentContainer */, 0x222922 /* NSTextAttachmentContainerWrapper */ },
		{ 0x222B22 /* UIKit.INSTextAttachmentLayout */, 0x222C22 /* NSTextAttachmentLayoutWrapper */ },
		{ 0x223022 /* UIKit.INSTextContentManagerDelegate */, 0x223222 /* NSTextContentManagerDelegateWrapper */ },
		{ 0x223622 /* UIKit.INSTextContentStorageDelegate */, 0x223822 /* NSTextContentStorageDelegateWrapper */ },
		{ 0x223C22 /* UIKit.INSTextElementProvider */, 0x223E22 /* NSTextElementProviderWrapper */ },
		{ 0x224322 /* UIKit.INSTextLayoutManagerDelegate */, 0x224522 /* NSTextLayoutManagerDelegateWrapper */ },
		{ 0x224A22 /* UIKit.INSTextLayoutOrientationProvider */, 0x224B22 /* NSTextLayoutOrientationProviderWrapper */ },
		{ 0x225222 /* UIKit.INSTextLocation */, 0x225322 /* NSTextLocationWrapper */ },
		{ 0x225922 /* UIKit.INSTextSelectionDataSource */, 0x225B22 /* NSTextSelectionDataSourceWrapper */ },
		{ 0x226622 /* UIKit.INSTextStorageDelegate */, 0x226822 /* NSTextStorageDelegateWrapper */ },
		{ 0x226B22 /* UIKit.INSTextStorageObserving */, 0x226C22 /* NSTextStorageObservingWrapper */ },
		{ 0x226F22 /* UIKit.INSTextViewportLayoutControllerDelegate */, 0x227122 /* NSTextViewportLayoutControllerDelegateWrapper */ },
		{ 0x227822 /* UIKit.IUIAccelerometerDelegate */, 0x227A22 /* UIAccelerometerDelegateWrapper */ },
		{ 0x227F22 /* UIKit.IUIAccessibilityContainerDataTable */, 0x228122 /* UIAccessibilityContainerDataTableWrapper */ },
		{ 0x228322 /* UIKit.IUIAccessibilityContainerDataTableCell */, 0x228422 /* UIAccessibilityContainerDataTableCellWrapper */ },
		{ 0x228622 /* UIKit.IUIAccessibilityContentSizeCategoryImageAdjusting */, 0x228722 /* UIAccessibilityContentSizeCategoryImageAdjustingWrapper */ },
		{ 0x229022 /* UIKit.IUIAccessibilityIdentification */, 0x229122 /* UIAccessibilityIdentificationWrapper */ },
		{ 0x229422 /* UIKit.IUIAccessibilityReadingContent */, 0x229622 /* UIAccessibilityReadingContentWrapper */ },
		{ 0x229F22 /* UIKit.IUIActionSheetDelegate */, 0x22A122 /* UIActionSheetDelegateWrapper */ },
		{ 0x22AE22 /* UIKit.IUIActivityItemsConfigurationProviding */, 0x22AF22 /* UIActivityItemsConfigurationProvidingWrapper */ },
		{ 0x22B022 /* UIKit.IUIActivityItemsConfigurationReading */, 0x22B222 /* UIActivityItemsConfigurationReadingWrapper */ },
		{ 0x22B322 /* UIKit.IUIActivityItemSource */, 0x22B522 /* UIActivityItemSourceWrapper */ },
		{ 0x22B822 /* UIKit.IUIAdaptivePresentationControllerDelegate */, 0x22B922 /* UIAdaptivePresentationControllerDelegateWrapper */ },
		{ 0x22BF22 /* UIKit.IUIAlertViewDelegate */, 0x22C122 /* UIAlertViewDelegateWrapper */ },
		{ 0x22C422 /* UIKit.IUIAppearance */, 0x22C522 /* UIAppearanceWrapper */ },
		{ 0x22C622 /* UIKit.IUIAppearanceContainer */, 0x22C722 /* UIAppearanceContainerWrapper */ },
		{ 0x22C922 /* UIKit.IUIApplicationDelegate */, 0x22CB22 /* UIApplicationDelegateWrapper */ },
		{ 0x22E322 /* UIKit.IUIBarPositioning */, 0x22E422 /* UIBarPositioningWrapper */ },
		{ 0x22E622 /* UIKit.IUIBarPositioningDelegate */, 0x22E822 /* UIBarPositioningDelegateWrapper */ },
		{ 0x22F922 /* UIKit.IUICalendarSelectionMultiDateDelegate */, 0x22FB22 /* UICalendarSelectionMultiDateDelegateWrapper */ },
		{ 0x22FE22 /* UIKit.IUICalendarSelectionSingleDateDelegate */, 0x230022 /* UICalendarSelectionSingleDateDelegateWrapper */ },
		{ 0x230522 /* UIKit.IUICalendarViewDelegate */, 0x230722 /* UICalendarViewDelegateWrapper */ },
		{ 0x231B22 /* UIKit.IUICloudSharingControllerDelegate */, 0x231D22 /* UICloudSharingControllerDelegateWrapper */ },
		{ 0x233122 /* UIKit.IUICollectionViewDataSource */, 0x233322 /* UICollectionViewDataSourceWrapper */ },
		{ 0x233522 /* UIKit.IUICollectionViewDataSourcePrefetching */, 0x233722 /* UICollectionViewDataSourcePrefetchingWrapper */ },
		{ 0x233822 /* UIKit.IUICollectionViewDelegate */, 0x233A22 /* UICollectionViewDelegateWrapper */ },
		{ 0x233C22 /* UIKit.IUICollectionViewDelegateFlowLayout */, 0x233E22 /* UICollectionViewDelegateFlowLayoutWrapper */ },
		{ 0x234322 /* UIKit.IUICollectionViewDragDelegate */, 0x234522 /* UICollectionViewDragDelegateWrapper */ },
		{ 0x234722 /* UIKit.IUICollectionViewDropCoordinator */, 0x234822 /* UICollectionViewDropCoordinatorWrapper */ },
		{ 0x234922 /* UIKit.IUICollectionViewDropDelegate */, 0x234B22 /* UICollectionViewDropDelegateWrapper */ },
		{ 0x234E22 /* UIKit.IUICollectionViewDropItem */, 0x234F22 /* UICollectionViewDropItemWrapper */ },
		{ 0x235122 /* UIKit.IUICollectionViewDropPlaceholderContext */, 0x235222 /* UICollectionViewDropPlaceholderContextWrapper */ },
		{ 0x236822 /* UIKit.IUICollisionBehaviorDelegate */, 0x236A22 /* UICollisionBehaviorDelegateWrapper */ },
		{ 0x236E22 /* UIKit.IUIColorPickerViewControllerDelegate */, 0x237022 /* UIColorPickerViewControllerDelegateWrapper */ },
		{ 0x237522 /* UIKit.IUIConfigurationState */, 0x237622 /* UIConfigurationStateWrapper */ },
		{ 0x237722 /* UIKit.IUIContentConfiguration */, 0x237822 /* UIContentConfigurationWrapper */ },
		{ 0x237922 /* UIKit.IUIContentContainer */, 0x237A22 /* UIContentContainerWrapper */ },
		{ 0x237E22 /* UIKit.IUIContentSizeCategoryAdjusting */, 0x237F22 /* UIContentSizeCategoryAdjustingWrapper */ },
		{ 0x238022 /* UIKit.IUIContentView */, 0x238222 /* UIContentViewWrapper */ },
		{ 0x238622 /* UIKit.IUIContextMenuInteractionAnimating */, 0x238722 /* UIContextMenuInteractionAnimatingWrapper */ },
		{ 0x238922 /* UIKit.IUIContextMenuInteractionCommitAnimating */, 0x238A22 /* UIContextMenuInteractionCommitAnimatingWrapper */ },
		{ 0x238C22 /* UIKit.IUIContextMenuInteractionDelegate */, 0x238E22 /* UIContextMenuInteractionDelegateWrapper */ },
		{ 0x239622 /* UIKit.IUICoordinateSpace */, 0x239722 /* UICoordinateSpaceWrapper */ },
		{ 0x239B22 /* UIKit.IUIDataSourceModelAssociation */, 0x239C22 /* UIDataSourceModelAssociationWrapper */ },
		{ 0x239D22 /* UIKit.IUIDataSourceTranslating */, 0x239E22 /* UIDataSourceTranslatingWrapper */ },
		{ 0x23AF22 /* UIKit.IUIDocumentBrowserViewControllerDelegate */, 0x23B122 /* UIDocumentBrowserViewControllerDelegateWrapper */ },
		{ 0x23B622 /* UIKit.IUIDocumentInteractionControllerDelegate */, 0x23B822 /* UIDocumentInteractionControllerDelegateWrapper */ },
		{ 0x23BA22 /* UIKit.IUIDocumentMenuDelegate */, 0x23BB22 /* UIDocumentMenuDelegateWrapper */ },
		{ 0x23BF22 /* UIKit.IUIDocumentPickerDelegate */, 0x23C122 /* UIDocumentPickerDelegateWrapper */ },
		{ 0x23CA22 /* UIKit.IUIDragAnimating */, 0x23CB22 /* UIDragAnimatingWrapper */ },
		{ 0x23CC22 /* UIKit.IUIDragDropSession */, 0x23CD22 /* UIDragDropSessionWrapper */ },
		{ 0x23CF22 /* UIKit.IUIDragInteractionDelegate */, 0x23D122 /* UIDragInteractionDelegateWrapper */ },
		{ 0x23D722 /* UIKit.IUIDragSession */, 0x23D822 /* UIDragSessionWrapper */ },
		{ 0x23DA22 /* UIKit.IUIDropInteractionDelegate */, 0x23DC22 /* UIDropInteractionDelegateWrapper */ },
		{ 0x23E022 /* UIKit.IUIDropSession */, 0x23E122 /* UIDropSessionWrapper */ },
		{ 0x23E322 /* UIKit.IUIDynamicAnimatorDelegate */, 0x23E422 /* UIDynamicAnimatorDelegateWrapper */ },
		{ 0x23E722 /* UIKit.IUIDynamicItem */, 0x23E922 /* UIDynamicItemWrapper */ },
		{ 0x23F222 /* UIKit.IUIEditMenuInteractionAnimating */, 0x23F322 /* UIEditMenuInteractionAnimatingWrapper */ },
		{ 0x23F422 /* UIKit.IUIEditMenuInteractionDelegate */, 0x23F622 /* UIEditMenuInteractionDelegateWrapper */ },
		{ 0x240122 /* UIKit.IUIFindInteractionDelegate */, 0x240322 /* UIFindInteractionDelegateWrapper */ },
		{ 0x240722 /* UIKit.IUIFocusAnimationContext */, 0x240822 /* UIFocusAnimationContextWrapper */ },
		{ 0x240B22 /* UIKit.IUIFocusDebuggerOutput */, 0x240C22 /* UIFocusDebuggerOutputWrapper */ },
		{ 0x240E22 /* UIKit.IUIFocusEnvironment */, 0x241022 /* UIFocusEnvironmentWrapper */ },
		{ 0x241622 /* UIKit.IUIFocusItem */, 0x241822 /* UIFocusItemWrapper */ },
		{ 0x241922 /* UIKit.IUIFocusItemContainer */, 0x241A22 /* UIFocusItemContainerWrapper */ },
		{ 0x241B22 /* UIKit.IUIFocusItemScrollableContainer */, 0x241C22 /* UIFocusItemScrollableContainerWrapper */ },
		{ 0x242522 /* UIKit.IUIFontPickerViewControllerDelegate */, 0x242722 /* UIFontPickerViewControllerDelegateWrapper */ },
		{ 0x243022 /* UIKit.IUIGestureRecognizerDelegate */, 0x243222 /* UIGestureRecognizerDelegateWrapper */ },
		{ 0x244322 /* UIKit.IUIGuidedAccessRestrictionDelegate */, 0x244522 /* UIGuidedAccessRestrictionDelegateWrapper */ },
		{ 0x244E22 /* UIKit.IUIImagePickerControllerDelegate */, 0x245022 /* UIImagePickerControllerDelegateWrapper */ },
		{ 0x245E22 /* UIKit.IUIIndirectScribbleInteractionDelegate */, 0x246022 /* UIIndirectScribbleInteractionDelegateWrapper */ },
		{ 0x246322 /* UIKit.IUIInputViewAudioFeedback */, 0x246422 /* UIInputViewAudioFeedbackWrapper */ },
		{ 0x246722 /* UIKit.IUIInteraction */, 0x246822 /* UIInteractionWrapper */ },
		{ 0x246D22 /* UIKit.IUIItemProviderPresentationSizeProviding */, 0x246E22 /* UIItemProviderPresentationSizeProvidingWrapper */ },
		{ 0x247522 /* UIKit.IUIKeyInput */, 0x247622 /* UIKeyInputWrapper */ },
		{ 0x247A22 /* UIKit.IUILargeContentViewerInteractionDelegate */, 0x247C22 /* UILargeContentViewerInteractionDelegateWrapper */ },
		{ 0x247E22 /* UIKit.IUILargeContentViewerItem */, 0x247F22 /* UILargeContentViewerItemWrapper */ },
		{ 0x248322 /* UIKit.IUILayoutGuideAspectFitting */, 0x248422 /* UILayoutGuideAspectFittingWrapper */ },
		{ 0x248622 /* UIKit.IUILayoutSupport */, 0x248822 /* UILayoutSupportWrapper */ },
		{ 0x249922 /* UIKit.IUIMenuBuilder */, 0x249A22 /* UIMenuBuilderWrapper */ },
		{ 0x24A422 /* UIKit.IUIMenuLeaf */, 0x24A522 /* UIMenuLeafWrapper */ },
		{ 0x24B022 /* UIKit.IUINavigationBarDelegate */, 0x24B222 /* UINavigationBarDelegateWrapper */ },
		{ 0x24B522 /* UIKit.IUINavigationControllerDelegate */, 0x24B722 /* UINavigationControllerDelegateWrapper */ },
		{ 0x24BD22 /* UIKit.IUINavigationItemRenameDelegate */, 0x24BF22 /* UINavigationItemRenameDelegateWrapper */ },
		{ 0x24C722 /* UIKit.IUIObjectRestoration */, 0x24C822 /* UIObjectRestorationWrapper */ },
		{ 0x24D122 /* UIKit.IUIPageViewControllerDataSource */, 0x24D322 /* UIPageViewControllerDataSourceWrapper */ },
		{ 0x24D522 /* UIKit.IUIPageViewControllerDelegate */, 0x24D722 /* UIPageViewControllerDelegateWrapper */ },
		{ 0x24E322 /* UIKit.IUIPasteConfigurationSupporting */, 0x24E522 /* UIPasteConfigurationSupportingWrapper */ },
		{ 0x24EA22 /* UIKit.IUIPencilInteractionDelegate */, 0x24EC22 /* UIPencilInteractionDelegateWrapper */ },
		{ 0x24F022 /* UIKit.IUIPickerViewAccessibilityDelegate */, 0x24F222 /* UIPickerViewAccessibilityDelegateWrapper */ },
		{ 0x24F422 /* UIKit.IUIPickerViewDataSource */, 0x24F522 /* UIPickerViewDataSourceWrapper */ },
		{ 0x24F722 /* UIKit.IUIPickerViewDelegate */, 0x24F922 /* UIPickerViewDelegateWrapper */ },
		{ 0x250422 /* UIKit.IUIPointerInteractionAnimating */, 0x250522 /* UIPointerInteractionAnimatingWrapper */ },
		{ 0x250622 /* UIKit.IUIPointerInteractionDelegate */, 0x250822 /* UIPointerInteractionDelegateWrapper */ },
		{ 0x251222 /* UIKit.IUIPopoverBackgroundViewMethods */, 0x251322 /* UIPopoverBackgroundViewMethodsWrapper */ },
		{ 0x251522 /* UIKit.IUIPopoverControllerDelegate */, 0x251722 /* UIPopoverControllerDelegateWrapper */ },
		{ 0x251A22 /* UIKit.IUIPopoverPresentationControllerDelegate */, 0x251B22 /* UIPopoverPresentationControllerDelegateWrapper */ },
		{ 0x251C22 /* UIKit.IUIPopoverPresentationControllerSourceItem */, 0x251D22 /* UIPopoverPresentationControllerSourceItemWrapper */ },
		{ 0x252522 /* UIKit.IUIPreviewActionItem */, 0x252622 /* UIPreviewActionItemWrapper */ },
		{ 0x252922 /* UIKit.IUIPreviewInteractionDelegate */, 0x252B22 /* UIPreviewInteractionDelegateWrapper */ },
		{ 0x253522 /* UIKit.IUIPrinterPickerControllerDelegate */, 0x253722 /* UIPrinterPickerControllerDelegateWrapper */ },
		{ 0x254322 /* UIKit.IUIPrintInteractionControllerDelegate */, 0x254522 /* UIPrintInteractionControllerDelegateWrapper */ },
		{ 0x255622 /* UIKit.IUIResponderStandardEditActions */, 0x255822 /* UIResponderStandardEditActionsWrapper */ },
		{ 0x256022 /* UIKit.IUISceneDelegate */, 0x256222 /* UISceneDelegateWrapper */ },
		{ 0x257022 /* UIKit.IUIScreenshotServiceDelegate */, 0x257222 /* UIScreenshotServiceDelegateWrapper */ },
		{ 0x257522 /* UIKit.IUIScribbleInteractionDelegate */, 0x257722 /* UIScribbleInteractionDelegateWrapper */ },
		{ 0x257F22 /* UIKit.IUIScrollViewAccessibilityDelegate */, 0x258122 /* UIScrollViewAccessibilityDelegateWrapper */ },
		{ 0x258422 /* UIKit.IUIScrollViewDelegate */, 0x258622 /* UIScrollViewDelegateWrapper */ },
		{ 0x258D22 /* UIKit.IUISearchBarDelegate */, 0x258F22 /* UISearchBarDelegateWrapper */ },
		{ 0x259422 /* UIKit.IUISearchControllerDelegate */, 0x259622 /* UISearchControllerDelegateWrapper */ },
		{ 0x259922 /* UIKit.IUISearchDisplayDelegate */, 0x259B22 /* UISearchDisplayDelegateWrapper */ },
		{ 0x259D22 /* UIKit.IUISearchResultsUpdating */, 0x259F22 /* UISearchResultsUpdatingWrapper */ },
		{ 0x25A122 /* UIKit.IUISearchSuggestion */, 0x25A322 /* UISearchSuggestionWrapper */ },
		{ 0x25A622 /* UIKit.IUISearchTextFieldDelegate */, 0x25A822 /* UISearchTextFieldDelegateWrapper */ },
		{ 0x25AA22 /* UIKit.IUISearchTextFieldPasteItem */, 0x25AB22 /* UISearchTextFieldPasteItemWrapper */ },
		{ 0x25B222 /* UIKit.IUISheetPresentationControllerDelegate */, 0x25B422 /* UISheetPresentationControllerDelegateWrapper */ },
		{ 0x25B922 /* UIKit.IUISheetPresentationControllerDetentResolutionContext */, 0x25BA22 /* UISheetPresentationControllerDetentResolutionContextWrapper */ },
		{ 0x25C622 /* UIKit.IUISplitViewControllerDelegate */, 0x25C822 /* UISplitViewControllerDelegateWrapper */ },
		{ 0x25D022 /* UIKit.IUISpringLoadedInteractionBehavior */, 0x25D222 /* UISpringLoadedInteractionBehaviorWrapper */ },
		{ 0x25D322 /* UIKit.IUISpringLoadedInteractionContext */, 0x25D422 /* UISpringLoadedInteractionContextWrapper */ },
		{ 0x25D522 /* UIKit.IUISpringLoadedInteractionEffect */, 0x25D622 /* UISpringLoadedInteractionEffectWrapper */ },
		{ 0x25D822 /* UIKit.IUISpringLoadedInteractionSupporting */, 0x25D922 /* UISpringLoadedInteractionSupportingWrapper */ },
		{ 0x25DF22 /* UIKit.IUIStateRestoring */, 0x25E122 /* UIStateRestoringWrapper */ },
		{ 0x25F822 /* UIKit.IUITabBarControllerDelegate */, 0x25FA22 /* UITabBarControllerDelegateWrapper */ },
		{ 0x25FC22 /* UIKit.IUITabBarDelegate */, 0x25FE22 /* UITabBarDelegateWrapper */ },
		{ 0x260F22 /* UIKit.IUITableViewDataSource */, 0x261122 /* UITableViewDataSourceWrapper */ },
		{ 0x261322 /* UIKit.IUITableViewDataSourcePrefetching */, 0x261522 /* UITableViewDataSourcePrefetchingWrapper */ },
		{ 0x261622 /* UIKit.IUITableViewDelegate */, 0x261822 /* UITableViewDelegateWrapper */ },
		{ 0x261B22 /* UIKit.IUITableViewDragDelegate */, 0x261D22 /* UITableViewDragDelegateWrapper */ },
		{ 0x261F22 /* UIKit.IUITableViewDropCoordinator */, 0x262022 /* UITableViewDropCoordinatorWrapper */ },
		{ 0x262122 /* UIKit.IUITableViewDropDelegate */, 0x262322 /* UITableViewDropDelegateWrapper */ },
		{ 0x262622 /* UIKit.IUITableViewDropItem */, 0x262722 /* UITableViewDropItemWrapper */ },
		{ 0x262922 /* UIKit.IUITableViewDropPlaceholderContext */, 0x262A22 /* UITableViewDropPlaceholderContextWrapper */ },
		{ 0x264222 /* UIKit.IUITextDocumentProxy */, 0x264422 /* UITextDocumentProxyWrapper */ },
		{ 0x264622 /* UIKit.IUITextDragDelegate */, 0x264822 /* UITextDragDelegateWrapper */ },
		{ 0x264A22 /* UIKit.IUITextDraggable */, 0x264B22 /* UITextDraggableWrapper */ },
		{ 0x264E22 /* UIKit.IUITextDragRequest */, 0x264F22 /* UITextDragRequestWrapper */ },
		{ 0x265122 /* UIKit.IUITextDropDelegate */, 0x265322 /* UITextDropDelegateWrapper */ },
		{ 0x265622 /* UIKit.IUITextDroppable */, 0x265722 /* UITextDroppableWrapper */ },
		{ 0x265B22 /* UIKit.IUITextDropRequest */, 0x265C22 /* UITextDropRequestWrapper */ },
		{ 0x265D22 /* UIKit.IUITextFieldDelegate */, 0x265F22 /* UITextFieldDelegateWrapper */ },
		{ 0x266422 /* UIKit.IUITextFormattingCoordinatorDelegate */, 0x266522 /* UITextFormattingCoordinatorDelegateWrapper */ },
		{ 0x266822 /* UIKit.IUITextInput */, 0x266A22 /* UITextInputWrapper */ },
		{ 0x266C22 /* UIKit.IUITextInputDelegate */, 0x266D22 /* UITextInputDelegateWrapper */ },
		{ 0x267222 /* UIKit.IUITextInputTokenizer */, 0x267322 /* UITextInputTokenizerWrapper */ },
		{ 0x267522 /* UIKit.IUITextInputTraits */, 0x267722 /* UITextInputTraitsWrapper */ },
		{ 0x267922 /* UIKit.IUITextInteractionDelegate */, 0x267B22 /* UITextInteractionDelegateWrapper */ },
		{ 0x268022 /* UIKit.IUITextPasteConfigurationSupporting */, 0x268122 /* UITextPasteConfigurationSupportingWrapper */ },
		{ 0x268222 /* UIKit.IUITextPasteDelegate */, 0x268422 /* UITextPasteDelegateWrapper */ },
		{ 0x268622 /* UIKit.IUITextPasteItem */, 0x268722 /* UITextPasteItemWrapper */ },
		{ 0x268B22 /* UIKit.IUITextSearchAggregator */, 0x268C22 /* UITextSearchAggregatorWrapper */ },
		{ 0x268E22 /* UIKit.IUITextSearching */, 0x269022 /* UITextSearchingWrapper */ },
		{ 0x269A22 /* UIKit.IUITextViewDelegate */, 0x269C22 /* UITextViewDelegateWrapper */ },
		{ 0x269F22 /* UIKit.IUITimingCurveProvider */, 0x26A022 /* UITimingCurveProviderWrapper */ },
		{ 0x26A322 /* UIKit.IUIToolbarDelegate */, 0x26A422 /* UIToolbarDelegateWrapper */ },
		{ 0x26A922 /* UIKit.IUIToolTipInteractionDelegate */, 0x26AB22 /* UIToolTipInteractionDelegateWrapper */ },
		{ 0x26B222 /* UIKit.IUITraitEnvironment */, 0x26B322 /* UITraitEnvironmentWrapper */ },
		{ 0x26B822 /* UIKit.IUIUserActivityRestoring */, 0x26B922 /* UIUserActivityRestoringWrapper */ },
		{ 0x26CA22 /* UIKit.IUIVideoEditorControllerDelegate */, 0x26CC22 /* UIVideoEditorControllerDelegateWrapper */ },
		{ 0x26CF22 /* UIKit.IUIViewAnimating */, 0x26D022 /* UIViewAnimatingWrapper */ },
		{ 0x26D922 /* UIKit.IUIViewControllerAnimatedTransitioning */, 0x26DB22 /* UIViewControllerAnimatedTransitioningWrapper */ },
		{ 0x26DD22 /* UIKit.IUIViewControllerContextTransitioning */, 0x26DF22 /* UIViewControllerContextTransitioningWrapper */ },
		{ 0x26E122 /* UIKit.IUIViewControllerInteractiveTransitioning */, 0x26E322 /* UIViewControllerInteractiveTransitioningWrapper */ },
		{ 0x26E522 /* UIKit.IUIViewControllerPreviewing */, 0x26E622 /* UIViewControllerPreviewingWrapper */ },
		{ 0x26E722 /* UIKit.IUIViewControllerPreviewingDelegate */, 0x26E822 /* UIViewControllerPreviewingDelegateWrapper */ },
		{ 0x26EA22 /* UIKit.IUIViewControllerRestoration */, 0x26EB22 /* UIViewControllerRestorationWrapper */ },
		{ 0x26EC22 /* UIKit.IUIViewControllerTransitionCoordinator */, 0x26EE22 /* UIViewControllerTransitionCoordinatorWrapper */ },
		{ 0x26EF22 /* UIKit.IUIViewControllerTransitionCoordinatorContext */, 0x26F022 /* UIViewControllerTransitionCoordinatorContextWrapper */ },
		{ 0x26F122 /* UIKit.IUIViewControllerTransitioningDelegate */, 0x26F322 /* UIViewControllerTransitioningDelegateWrapper */ },
		{ 0x26F522 /* UIKit.IUIViewImplicitlyAnimating */, 0x26F722 /* UIViewImplicitlyAnimatingWrapper */ },
		{ 0x270222 /* UIKit.IUIWebViewDelegate */, 0x270422 /* UIWebViewDelegateWrapper */ },
		{ 0x270D22 /* UIKit.IUIWindowSceneDelegate */, 0x270F22 /* UIWindowSceneDelegateWrapper */ },
		{ 0x272C22 /* AddressBookUI.IABNewPersonViewControllerDelegate */, 0x272D22 /* ABNewPersonViewControllerDelegateWrapper */ },
		{ 0x272F22 /* AddressBookUI.IABPeoplePickerNavigationControllerDelegate */, 0x273122 /* ABPeoplePickerNavigationControllerDelegateWrapper */ },
		{ 0x273422 /* AddressBookUI.IABPersonViewControllerDelegate */, 0x273522 /* ABPersonViewControllerDelegateWrapper */ },
		{ 0x273722 /* AddressBookUI.IABUnknownPersonViewControllerDelegate */, 0x273922 /* ABUnknownPersonViewControllerDelegateWrapper */ },
		{ 0x277822 /* Accessibility.IAXBrailleMapRenderer */, 0x277922 /* AXBrailleMapRendererWrapper */ },
		{ 0x277B22 /* Accessibility.IAXChart */, 0x277C22 /* AXChartWrapper */ },
		{ 0x278122 /* Accessibility.IAXCustomContentProvider */, 0x278222 /* AXCustomContentProviderWrapper */ },
		{ 0x278322 /* Accessibility.IAXDataAxisDescriptor */, 0x278422 /* AXDataAxisDescriptorWrapper */ },
		{ 0x27A322 /* AVKit.IAVCustomRoutingControllerDelegate */, 0x27A522 /* AVCustomRoutingControllerDelegateWrapper */ },
		{ 0x27AC22 /* AVKit.IAVPictureInPictureControllerDelegate */, 0x27AE22 /* AVPictureInPictureControllerDelegateWrapper */ },
		{ 0x27B022 /* AVKit.IAVPictureInPictureSampleBufferPlaybackDelegate */, 0x27B222 /* AVPictureInPictureSampleBufferPlaybackDelegateWrapper */ },
		{ 0x27B622 /* AVKit.IAVPlayerViewControllerDelegate */, 0x27B822 /* AVPlayerViewControllerDelegateWrapper */ },
		{ 0x27BC22 /* AVKit.IAVRoutePickerViewDelegate */, 0x27BE22 /* AVRoutePickerViewDelegateWrapper */ },
		{ 0x281E22 /* AVFoundation.IAVAssetDownloadDelegate */, 0x282022 /* AVAssetDownloadDelegateWrapper */ },
		{ 0x283822 /* AVFoundation.IAVAssetResourceLoaderDelegate */, 0x283A22 /* AVAssetResourceLoaderDelegateWrapper */ },
		{ 0x284D22 /* AVFoundation.IAVAssetWriterDelegate */, 0x284F22 /* AVAssetWriterDelegateWrapper */ },
		{ 0x285A22 /* AVFoundation.IAVAsynchronousKeyValueLoading */, 0x285B22 /* AVAsynchronousKeyValueLoadingWrapper */ },
		{ 0x285E22 /* AVFoundation.IAVAudio3DMixing */, 0x286022 /* AVAudio3DMixingWrapper */ },
		{ 0x287A22 /* AVFoundation.IAVAudioMixing */, 0x287C22 /* AVAudioMixingWrapper */ },
		{ 0x288122 /* AVFoundation.IAVAudioPlayerDelegate */, 0x288322 /* AVAudioPlayerDelegateWrapper */ },
		{ 0x288922 /* AVFoundation.IAVAudioRecorderDelegate */, 0x288B22 /* AVAudioRecorderDelegateWrapper */ },
		{ 0x289222 /* AVFoundation.IAVAudioSessionDelegate */, 0x289422 /* AVAudioSessionDelegateWrapper */ },
		{ 0x28A822 /* AVFoundation.IAVAudioStereoMixing */, 0x28A922 /* AVAudioStereoMixingWrapper */ },
		{ 0x28C622 /* AVFoundation.IAVCaptureAudioDataOutputSampleBufferDelegate */, 0x28C722 /* AVCaptureAudioDataOutputSampleBufferDelegateWrapper */ },
		{ 0x28CE22 /* AVFoundation.IAVCaptureDataOutputSynchronizerDelegate */, 0x28CF22 /* AVCaptureDataOutputSynchronizerDelegateWrapper */ },
		{ 0x28D222 /* AVFoundation.IAVCaptureDepthDataOutputDelegate */, 0x28D422 /* AVCaptureDepthDataOutputDelegateWrapper */ },
		{ 0x28DD22 /* AVFoundation.IAVCaptureFileOutputRecordingDelegate */, 0x28DF22 /* AVCaptureFileOutputRecordingDelegateWrapper */ },
		{ 0x28E622 /* AVFoundation.IAVCaptureMetadataOutputObjectsDelegate */, 0x28E822 /* AVCaptureMetadataOutputObjectsDelegateWrapper */ },
		{ 0x28F122 /* AVFoundation.IAVCapturePhotoCaptureDelegate */, 0x28F322 /* AVCapturePhotoCaptureDelegateWrapper */ },
		{ 0x28F522 /* AVFoundation.IAVCapturePhotoFileDataRepresentationCustomizer */, 0x28F722 /* AVCapturePhotoFileDataRepresentationCustomizerWrapper */ },
		{ 0x290D22 /* AVFoundation.IAVCaptureVideoDataOutputSampleBufferDelegate */, 0x290F22 /* AVCaptureVideoDataOutputSampleBufferDelegateWrapper */ },
		{ 0x292022 /* AVFoundation.IAVContentKeyRecipient */, 0x292222 /* AVContentKeyRecipientWrapper */ },
		{ 0x292B22 /* AVFoundation.IAVContentKeySessionDelegate */, 0x292D22 /* AVContentKeySessionDelegateWrapper */ },
		{ 0x295222 /* AVFoundation.IAVFragmentMinding */, 0x295322 /* AVFragmentMindingWrapper */ },
		{ 0x299122 /* AVFoundation.IAVPlaybackCoordinatorPlaybackControlDelegate */, 0x299222 /* AVPlaybackCoordinatorPlaybackControlDelegateWrapper */ },
		{ 0x299F22 /* AVFoundation.IAVPlayerItemLegibleOutputPushDelegate */, 0x29A122 /* AVPlayerItemLegibleOutputPushDelegateWrapper */ },
		{ 0x29A522 /* AVFoundation.IAVPlayerItemMetadataCollectorPushDelegate */, 0x29A622 /* AVPlayerItemMetadataCollectorPushDelegateWrapper */ },
		{ 0x29A922 /* AVFoundation.IAVPlayerItemMetadataOutputPushDelegate */, 0x29AB22 /* AVPlayerItemMetadataOutputPushDelegateWrapper */ },
		{ 0x29AE22 /* AVFoundation.IAVPlayerItemOutputPullDelegate */, 0x29B022 /* AVPlayerItemOutputPullDelegateWrapper */ },
		{ 0x29B222 /* AVFoundation.IAVPlayerItemOutputPushDelegate */, 0x29B422 /* AVPlayerItemOutputPushDelegateWrapper */ },
		{ 0x29BD22 /* AVFoundation.IAVPlayerPlaybackCoordinatorDelegate */, 0x29BF22 /* AVPlayerPlaybackCoordinatorDelegateWrapper */ },
		{ 0x29C822 /* AVFoundation.IAVQueuedSampleBufferRendering */, 0x29CA22 /* AVQueuedSampleBufferRenderingWrapper */ },
		{ 0x29DE22 /* AVFoundation.IAVSpeechSynthesizerDelegate */, 0x29E022 /* AVSpeechSynthesizerDelegateWrapper */ },
		{ 0x29EE22 /* AVFoundation.IAVVideoCompositing */, 0x29F022 /* AVVideoCompositingWrapper */ },
		{ 0x29F822 /* AVFoundation.IAVVideoCompositionValidationHandling */, 0x29FA22 /* AVVideoCompositionValidationHandlingWrapper */ },
		{ 0x2A1E22 /* ARKit.IARAnchorCopying */, 0x2A1F22 /* ARAnchorCopyingWrapper */ },
		{ 0x2A2A22 /* ARKit.IARCoachingOverlayViewDelegate */, 0x2A2C22 /* ARCoachingOverlayViewDelegateWrapper */ },
		{ 0x2A6622 /* ARKit.IARSCNViewDelegate */, 0x2A6822 /* ARSCNViewDelegateWrapper */ },
		{ 0x2A6D22 /* ARKit.IARSessionDelegate */, 0x2A6F22 /* ARSessionDelegateWrapper */ },
		{ 0x2A7122 /* ARKit.IARSessionObserver */, 0x2A7322 /* ARSessionObserverWrapper */ },
		{ 0x2A7422 /* ARKit.IARSessionProviding */, 0x2A7522 /* ARSessionProvidingWrapper */ },
		{ 0x2A7B22 /* ARKit.IARSKViewDelegate */, 0x2A7D22 /* ARSKViewDelegateWrapper */ },
		{ 0x2A7F22 /* ARKit.IARTrackable */, 0x2A8022 /* ARTrackableWrapper */ },
	};

	static const uint32_t __xamarin_protocol_tokens [] = {
		0xA22, /* VisionKit.IVNDocumentCameraViewControllerDelegate */
		0xF22, /* UserNotificationsUI.IUNNotificationContentExtension */
		0x16CC, /* Xamarin.IUIView_IQToolbarAddition */
		0x2122, /* WatchConnectivity.IWCSessionDelegate */
		0x2744, /* Firebase.CloudMessaging.IMessagingDelegate */
		0x2E22, /* Speech.ISFSpeechRecognitionTaskDelegate */
		0x3622, /* Speech.ISFSpeechRecognizerDelegate */
		0x4722, /* SoundAnalysis.ISNRequest */
		0x4922, /* SoundAnalysis.ISNResult */
		0x4B22, /* SoundAnalysis.ISNResultsObserving */
		0x6922, /* SharedWithYou.ISWCollaborationViewDelegate */
		0x6F22, /* SharedWithYou.ISWHighlightCenterDelegate */
		0x7522, /* SharedWithYou.ISWHighlightEvent */
		0x8F22, /* SafariServices.ISFSafariViewControllerDelegate */
		0xA622, /* QuickLook.IQLPreviewControllerDataSource */
		0xA922, /* QuickLook.IQLPreviewControllerDelegate */
		0xAD22, /* QuickLook.IQLPreviewingController */
		0xB022, /* QuickLook.IQLPreviewItem */
		0xDA22, /* PushKit.IPKPushRegistryDelegate */
		0xDF22, /* PhotosUI.IPHContentEditingController */
		0xE522, /* PhotosUI.IPHLivePhotoViewDelegate */
		0xF122, /* PhotosUI.IPHPickerViewControllerDelegate */
		0x14822, /* PencilKit.IPKCanvasViewDelegate */
		0x15B22, /* PencilKit.IPKToolPickerObserver */
		0x16222, /* OSLog.IOSLogEntryFromProcess */
		0x16922, /* OSLog.IOSLogEntryWithPayload */
		0x17522, /* NotificationCenter.INCWidgetProviding */
		0x18822, /* Messages.IMSMessagesAppTranscriptPresentation */
		0x19022, /* Messages.IMSStickerBrowserViewDataSource */
		0x1B722, /* IntentsUI.IINUIAddVoiceShortcutButtonDelegate */
		0x1BC22, /* IntentsUI.IINUIAddVoiceShortcutViewControllerDelegate */
		0x1C022, /* IntentsUI.IINUIEditVoiceShortcutViewControllerDelegate */
		0x1C422, /* IntentsUI.IINUIHostedViewControlling */
		0x1C722, /* IntentsUI.IINUIHostedViewSiriProviding */
		0x1D822, /* IdentityLookup.IILMessageFilterCapabilitiesQueryHandling */
		0x1E022, /* IdentityLookup.IILMessageFilterQueryHandling */
		0x1EC22, /* ExternalAccessory.IEAAccessoryDelegate */
		0x1F922, /* ExternalAccessory.IEAWiFiUnconfiguredAccessoryBrowserDelegate */
		0x25122, /* CoreHaptics.ICHHapticAdvancedPatternPlayer */
		0x25522, /* CoreHaptics.ICHHapticDeviceCapability */
		0x26422, /* CoreHaptics.ICHHapticParameterAttributes */
		0x26B22, /* CoreHaptics.ICHHapticPatternPlayer */
		0x27522, /* ContactsUI.ICNContactPickerDelegate */
		0x27B22, /* ContactsUI.ICNContactViewControllerDelegate */
		0x28E22, /* AutomaticAssessmentConfiguration.IAEAssessmentSessionDelegate */
		0x30D22, /* Vision.IVNFaceObservationAccepting */
		0x34322, /* Vision.IVNRequestProgressProviding */
		0x34622, /* Vision.IVNRequestRevisionProviding */
		0x3A122, /* VideoSubscriberAccount.IVSAccountManagerDelegate */
		0x3CA22, /* UserNotifications.IUNNotificationContentProviding */
		0x3DB22, /* UserNotifications.IUNUserNotificationCenterDelegate */
		0x40622, /* StoreKit.ISKCloudServiceSetupViewControllerDelegate */
		0x41122, /* StoreKit.ISKOverlayDelegate */
		0x41922, /* StoreKit.ISKPaymentQueueDelegate */
		0x41E22, /* StoreKit.ISKPaymentTransactionObserver */
		0x42822, /* StoreKit.ISKProductsRequestDelegate */
		0x43122, /* StoreKit.ISKRequestDelegate */
		0x43822, /* StoreKit.ISKStoreProductViewControllerDelegate */
		0x45F22, /* SpriteKit.ISKPhysicsContactDelegate */
		0x47122, /* SpriteKit.ISKSceneDelegate */
		0x48922, /* SpriteKit.ISKViewDelegate */
		0x48D22, /* SpriteKit.ISKWarpable */
		0x4C422, /* SharedWithYouCore.ISWCollaborationActionHandler */
		0x4EE22, /* SensorKit.ISRSensorReaderDelegate */
		0x56D22, /* SceneKit.ISCNActionable */
		0x57222, /* SceneKit.ISCNAnimatable */
		0x57822, /* SceneKit.ISCNAnimationProtocol */
		0x57E22, /* SceneKit.ISCNAvoidOccluderConstraintDelegate */
		0x58522, /* SceneKit.ISCNBoundingVolume */
		0x58A22, /* SceneKit.ISCNBufferStream */
		0x58D22, /* SceneKit.ISCNCameraControlConfiguration */
		0x59022, /* SceneKit.ISCNCameraControllerDelegate */
		0x5BB22, /* SceneKit.ISCNNodeRendererDelegate */
		0x5D122, /* SceneKit.ISCNPhysicsContactDelegate */
		0x5E522, /* SceneKit.ISCNProgramDelegate */
		0x5F222, /* SceneKit.ISCNSceneExportDelegate */
		0x5F622, /* SceneKit.ISCNSceneRenderer */
		0x5F822, /* SceneKit.ISCNSceneRendererDelegate */
		0x60022, /* SceneKit.ISCNShadable */
		0x60922, /* SceneKit.ISCNTechniqueSupport */
		0x62822, /* ReplayKit.IRPBroadcastActivityViewControllerDelegate */
		0x62C22, /* ReplayKit.IRPBroadcastControllerDelegate */
		0x63522, /* ReplayKit.IRPPreviewViewControllerDelegate */
		0x63D22, /* ReplayKit.IRPScreenRecorderDelegate */
		0x67722, /* Photos.IPHLivePhotoFrame */
		0x68622, /* Photos.IPHPhotoLibraryAvailabilityObserver */
		0x68822, /* Photos.IPHPhotoLibraryChangeObserver */
		0x6C322, /* PdfKit.IPdfDocumentDelegate */
		0x6D122, /* PdfKit.IPdfPageOverlayViewProvider */
		0x6DB22, /* PdfKit.IPdfViewDelegate */
		0x6EA22, /* PassKit.IPKAddPassesViewControllerDelegate */
		0x6F322, /* PassKit.IPKAddPaymentPassViewControllerDelegate */
		0x6FB22, /* PassKit.IPKAddSecureElementPassViewControllerDelegate */
		0x70E22, /* PassKit.IPKDisbursementAuthorizationControllerDelegate */
		0x71B22, /* PassKit.IPKIdentityDocumentDescriptor */
		0x72322, /* PassKit.IPKIssuerProvisioningExtensionAuthorizationProviding */
		0x73822, /* PassKit.IPKPaymentAuthorizationControllerDelegate */
		0x74922, /* PassKit.IPKPaymentAuthorizationViewControllerDelegate */
		0x75422, /* PassKit.IPKPaymentInformationRequestHandling */
		0x77122, /* PassKit.IPKShareSecureElementPassViewControllerDelegate */
		0x77E22, /* PassKit.IPKVehicleConnectionDelegate */
		0x78C22, /* OpenGLES.IEAGLDrawable */
		0x7A922, /* NetworkExtension.INEAppPushDelegate */
		0x81322, /* NetworkExtension.INWTcpConnectionAuthenticationDelegate */
		0x87B22, /* NearbyInteraction.INIDeviceCapability */
		0x88522, /* NearbyInteraction.INISessionDelegate */
		0x8AE22, /* MultipeerConnectivity.IMCAdvertiserAssistantDelegate */
		0x8B322, /* MultipeerConnectivity.IMCBrowserViewControllerDelegate */
		0x8BB22, /* MultipeerConnectivity.IMCNearbyServiceAdvertiserDelegate */
		0x8C022, /* MultipeerConnectivity.IMCNearbyServiceBrowserDelegate */
		0x8C422, /* MultipeerConnectivity.IMCSessionDelegate */
		0x8E522, /* ModelIO.IMDLAssetResolver */
		0x8EC22, /* ModelIO.IMDLComponent */
		0x8F122, /* ModelIO.IMDLJointAnimation */
		0x8F522, /* ModelIO.IMDLLightProbeIrradianceDataSource */
		0x90522, /* ModelIO.IMDLMeshBuffer */
		0x90822, /* ModelIO.IMDLMeshBufferAllocator */
		0x90E22, /* ModelIO.IMDLMeshBufferZone */
		0x91222, /* ModelIO.IMDLNamed */
		0x91822, /* ModelIO.IMDLObjectContainerComponent */
		0x92C22, /* ModelIO.IMDLTransformComponent */
		0x92F22, /* ModelIO.IMDLTransformOp */
		0x96222, /* MetricKit.IMXMetricManagerSubscriber */
		0x9F122, /* MetalPerformanceShaders.IMPSCnnBatchNormalizationDataSource */
		0x9FF22, /* MetalPerformanceShaders.IMPSCnnConvolutionDataSource */
		0xA1E22, /* MetalPerformanceShaders.IMPSCnnInstanceNormalizationDataSource */
		0xA8922, /* MetalPerformanceShaders.IMPSDeviceProvider */
		0xA8C22, /* MetalPerformanceShaders.IMPSHandle */
		0xA8E22, /* MetalPerformanceShaders.IMPSHeapProvider */
		0xA9222, /* MetalPerformanceShaders.IMPSImageAllocator */
		0xAB622, /* MetalPerformanceShaders.IMPSImageSizeEncodingState */
		0xABD22, /* MetalPerformanceShaders.IMPSImageTransformProvider */
		0xAE622, /* MetalPerformanceShaders.IMPSNDArrayAllocator */
		0xB0322, /* MetalPerformanceShaders.IMPSNNLossCallback */
		0xB0F22, /* MetalPerformanceShaders.IMPSNNPadding */
		0xB4322, /* MetalPerformanceShaders.IMPSNNTrainableNode */
		0xB7322, /* MetalKit.IMTKViewDelegate */
		0xBA322, /* Metal.IMTLAccelerationStructure */
		0xBA622, /* Metal.IMTLAccelerationStructureCommandEncoder */
		0xBB522, /* Metal.IMTLArgumentEncoder */
		0xBBD22, /* Metal.IMTLBinaryArchive */
		0xBC522, /* Metal.IMTLBlitCommandEncoder */
		0xBCB22, /* Metal.IMTLBuffer */
		0xBD422, /* Metal.IMTLCaptureScope */
		0xBD822, /* Metal.IMTLCommandBuffer */
		0xBDC22, /* Metal.IMTLCommandBufferEncoderInfo */
		0xBE222, /* Metal.IMTLCommandEncoder */
		0xBE522, /* Metal.IMTLCommandQueue */
		0xBEC22, /* Metal.IMTLComputeCommandEncoder */
		0xBF322, /* Metal.IMTLComputePipelineState */
		0xBF622, /* Metal.IMTLCounter */
		0xBF922, /* Metal.IMTLCounterSampleBuffer */
		0xC0022, /* Metal.IMTLCounterSet */
		0xC0822, /* Metal.IMTLDepthStencilState */
		0xC0A22, /* Metal.IMTLDevice */
		0xC0D22, /* Metal.IMTLDrawable */
		0xC1122, /* Metal.IMTLDynamicLibrary */
		0xC1522, /* Metal.IMTLEvent */
		0xC1822, /* Metal.IMTLFence */
		0xC1A22, /* Metal.IMTLFunction */
		0xC2022, /* Metal.IMTLFunctionHandle */
		0xC2222, /* Metal.IMTLFunctionLog */
		0xC2422, /* Metal.IMTLFunctionLogDebugLocation */
		0xC2822, /* Metal.IMTLFunctionStitchingAttribute */
		0xC2D22, /* Metal.IMTLFunctionStitchingNode */
		0xC3222, /* Metal.IMTLHeap */
		0xC3822, /* Metal.IMTLIndirectCommandBuffer */
		0xC3D22, /* Metal.IMTLIndirectComputeCommand */
		0xC4022, /* Metal.IMTLIndirectRenderCommand */
		0xC4622, /* Metal.IMTLIntersectionFunctionTable */
		0xC4A22, /* Metal.IMTLLibrary */
		0xC5222, /* Metal.IMTLLogContainer */
		0xC5922, /* Metal.IMTLParallelRenderCommandEncoder */
		0xC6622, /* Metal.IMTLRasterizationRateMap */
		0xC6B22, /* Metal.IMTLRenderCommandEncoder */
		0xC7922, /* Metal.IMTLRenderPipelineState */
		0xC7D22, /* Metal.IMTLResource */
		0xC8122, /* Metal.IMTLResourceStateCommandEncoder */
		0xC8B22, /* Metal.IMTLSamplerState */
		0xC8D22, /* Metal.IMTLSharedEvent */
		0xCA122, /* Metal.IMTLTexture */
		0xCB422, /* Metal.IMTLVisibleFunctionTable */
		0xCC622, /* MessageUI.IMFMailComposeViewControllerDelegate */
		0xCCA22, /* MessageUI.IMFMessageComposeViewControllerDelegate */
		0xCFD22, /* MediaPlayer.IMPMediaPickerControllerDelegate */
		0xD0122, /* MediaPlayer.IMPMediaPlayback */
		0xD2D22, /* MediaPlayer.IMPNowPlayingSessionDelegate */
		0xD3122, /* MediaPlayer.IMPPlayableContentDataSource */
		0xD3422, /* MediaPlayer.IMPPlayableContentDelegate */
		0xD4222, /* MediaPlayer.IMPSystemMusicPlayerController */
		0xD6C22, /* MapKit.IMKAnnotation */
		0xD8522, /* MapKit.IMKGeoJsonObject */
		0xD8D22, /* MapKit.IMKLocalSearchCompleterDelegate */
		0xD9D22, /* MapKit.IMKLookAroundViewControllerDelegate */
		0xDBA22, /* MapKit.IMKMapViewDelegate */
		0xDC322, /* MapKit.IMKOverlay */
		0xDD722, /* MapKit.IMKReverseGeocoderDelegate */
		0xE4F22, /* JavaScriptCore.IJSExport */
		0xE8322, /* Intents.IINActivateCarSignalIntentHandling */
		0xE8922, /* Intents.IINAddMediaIntentHandling */
		0xE9322, /* Intents.IINAddTasksIntentHandling */
		0xEA122, /* Intents.IINAnswerCallIntentHandling */
		0xEA722, /* Intents.IINAppendToNoteIntentHandling */
		0xEB722, /* Intents.IINBookRestaurantReservationIntentHandling */
		0xECA22, /* Intents.IINCallsDomainHandling */
		0xECD22, /* Intents.IINCancelRideIntentHandling */
		0xED322, /* Intents.IINCancelWorkoutIntentHandling */
		0xEDD22, /* Intents.IINCarCommandsDomainHandling */
		0xEE122, /* Intents.IINCarPlayDomainHandling */
		0xEE722, /* Intents.IINCreateNoteIntentHandling */
		0xEED22, /* Intents.IINCreateTaskListIntentHandling */
		0xEFF22, /* Intents.IINDeleteTasksIntentHandling */
		0xF0A22, /* Intents.IINEndWorkoutIntentHandling */
		0xF1A22, /* Intents.IINGetAvailableRestaurantReservationBookingDefaultsIntentHandling */
		0xF2122, /* Intents.IINGetAvailableRestaurantReservationBookingsIntentHandling */
		0xF2622, /* Intents.IINGetCarLockStatusIntentHandling */
		0xF2B22, /* Intents.IINGetCarPowerLevelStatusIntentHandling */
		0xF2F22, /* Intents.IINGetCarPowerLevelStatusIntentResponseObserver */
		0xF3522, /* Intents.IINGetRestaurantGuestIntentHandling */
		0xF3B22, /* Intents.IINGetRideStatusIntentHandling */
		0xF4022, /* Intents.IINGetRideStatusIntentResponseObserver */
		0xF4322, /* Intents.IINGetUserCurrentRestaurantReservationBookingsIntentHandling */
		0xF4922, /* Intents.IINGetVisualCodeIntentHandling */
		0xF4F22, /* Intents.IINHangUpCallIntentHandling */
		0xF5B22, /* Intents.IINIntentHandlerProviding */
		0xF6422, /* Intents.IINListCarsIntentHandling */
		0xF6A22, /* Intents.IINListRideOptionsIntentHandling */
		0xF8422, /* Intents.IINMessagesDomainHandling */
		0xF8822, /* Intents.IINNotebookDomainHandling */
		0xF9922, /* Intents.IINPauseWorkoutIntentHandling */
		0xF9F22, /* Intents.IINPayBillIntentHandling */
		0xFAC22, /* Intents.IINPaymentsDomainHandling */
		0xFB822, /* Intents.IINPhotosDomainHandling */
		0xFC022, /* Intents.IINPlayMediaIntentHandling */
		0xFC922, /* Intents.IINRadioDomainHandling */
		0xFD922, /* Intents.IINRequestPaymentIntentHandling */
		0xFE122, /* Intents.IINRequestRideIntentHandling */
		0xFF422, /* Intents.IINResumeWorkoutIntentHandling */
		0xFFE22, /* Intents.IINRidesharingDomainHandling */
		0x100122, /* Intents.IINSaveProfileInCarIntentHandling */
		0x100622, /* Intents.IINSearchCallHistoryIntentHandling */
		0x100C22, /* Intents.IINSearchForAccountsIntentHandling */
		0x101222, /* Intents.IINSearchForBillsIntentHandling */
		0x101822, /* Intents.IINSearchForMediaIntentHandling */
		0x102022, /* Intents.IINSearchForMessagesIntentHandling */
		0x102622, /* Intents.IINSearchForNotebookItemsIntentHandling */
		0x102C22, /* Intents.IINSearchForPhotosIntentHandling */
		0x103522, /* Intents.IINSendMessageIntentHandling */
		0x103F22, /* Intents.IINSendPaymentIntentHandling */
		0x104722, /* Intents.IINSendRideFeedbackIntentHandling */
		0x104D22, /* Intents.IINSetAudioSourceInCarIntentHandling */
		0x105222, /* Intents.IINSetCarLockStatusIntentHandling */
		0x105722, /* Intents.IINSetClimateSettingsInCarIntentHandling */
		0x105C22, /* Intents.IINSetDefrosterSettingsInCarIntentHandling */
		0x106222, /* Intents.IINSetMessageAttributeIntentHandling */
		0x106722, /* Intents.IINSetProfileInCarIntentHandling */
		0x106D22, /* Intents.IINSetRadioStationIntentHandling */
		0x107222, /* Intents.IINSetSeatSettingsInCarIntentHandling */
		0x107822, /* Intents.IINSetTaskAttributeIntentHandling */
		0x108022, /* Intents.IINShareFocusStatusIntentHandling */
		0x108922, /* Intents.IINSnoozeTasksIntentHandling */
		0x109422, /* Intents.IINSpeakable */
		0x109A22, /* Intents.IINStartAudioCallIntentHandling */
		0x10A622, /* Intents.IINStartCallIntentHandling */
		0x10AC22, /* Intents.IINStartPhotoPlaybackIntentHandling */
		0x10B222, /* Intents.IINStartVideoCallIntentHandling */
		0x10B722, /* Intents.IINStartWorkoutIntentHandling */
		0x10D422, /* Intents.IINTransferMoneyIntentHandling */
		0x10DC22, /* Intents.IINUpdateMediaAffinityIntentHandling */
		0x10E522, /* Intents.IINVisualCodeDomainHandling */
		0x10F222, /* Intents.IINWorkoutsDomainHandling */
		0x113A22, /* HomeKit.IHMAccessoryBrowserDelegate */
		0x114122, /* HomeKit.IHMAccessoryDelegate */
		0x115622, /* HomeKit.IHMCameraSnapshotControlDelegate */
		0x115D22, /* HomeKit.IHMCameraStreamControlDelegate */
		0x11AD22, /* HomeKit.IHMHomeDelegate */
		0x11B722, /* HomeKit.IHMHomeManagerDelegate */
		0x11C422, /* HomeKit.IHMNetworkConfigurationProfileDelegate */
		0x12BA22, /* GameplayKit.IGKAgentDelegate */
		0x12C822, /* GameplayKit.IGKGameModel */
		0x12CB22, /* GameplayKit.IGKGameModelPlayer */
		0x12CE22, /* GameplayKit.IGKGameModelUpdate */
		0x12E622, /* GameplayKit.IGKRandom */
		0x12F022, /* GameplayKit.IGKSceneRootNodeType */
		0x12F722, /* GameplayKit.IGKStrategist */
		0x131622, /* GameKit.IGKAchievementViewControllerDelegate */
		0x131C22, /* GameKit.IGKChallengeEventHandlerDelegate */
		0x132022, /* GameKit.IGKChallengeListener */
		0x132A22, /* GameKit.IGKFriendRequestComposeViewControllerDelegate */
		0x132E22, /* GameKit.IGKGameCenterControllerDelegate */
		0x133522, /* GameKit.IGKGameSessionEventListener */
		0x133A22, /* GameKit.IGKInviteEventListener */
		0x134A22, /* GameKit.IGKLeaderboardViewControllerDelegate */
		0x135022, /* GameKit.IGKLocalPlayerListener */
		0x135822, /* GameKit.IGKMatchDelegate */
		0x136222, /* GameKit.IGKMatchmakerViewControllerDelegate */
		0x137022, /* GameKit.IGKSavedGameListener */
		0x137622, /* GameKit.IGKSessionDelegate */
		0x137D22, /* GameKit.IGKTurnBasedEventHandlerDelegate */
		0x138122, /* GameKit.IGKTurnBasedEventListener */
		0x138822, /* GameKit.IGKTurnBasedMatchmakerViewControllerDelegate */
		0x138F22, /* GameKit.IGKVoiceChatClient */
		0x13BE22, /* GameController.IGCAxisElement */
		0x13C022, /* GameController.IGCAxisInput */
		0x13C222, /* GameController.IGCButtonElement */
		0x13CC22, /* GameController.IGCDevice */
		0x13D322, /* GameController.IGCDevicePhysicalInput */
		0x13D622, /* GameController.IGCDevicePhysicalInputState */
		0x13D822, /* GameController.IGCDevicePhysicalInputStateDiff */
		0x13DB22, /* GameController.IGCDirectionPadElement */
		0x13F122, /* GameController.IGCLinearInput */
		0x13F822, /* GameController.IGCPhysicalInputElement */
		0x13FB22, /* GameController.IGCPressedStateInput */
		0x13FE22, /* GameController.IGCRelativeInput */
		0x140022, /* GameController.IGCSwitchElement */
		0x140222, /* GameController.IGCSwitchPositionInput */
		0x140522, /* GameController.IGCTouchedStateInput */
		0x143322, /* GLKit.IGLKNamedEffect */
		0x143D22, /* GLKit.IGLKViewControllerDelegate */
		0x144122, /* GLKit.IGLKViewDelegate */
		0x145522, /* WebKit.IWKDownloadDelegate */
		0x146122, /* WebKit.IWKHttpCookieStoreObserver */
		0x146A22, /* WebKit.IWKNavigationDelegate */
		0x147322, /* WebKit.IWKPreviewActionItem */
		0x147922, /* WebKit.IWKScriptMessageHandler */
		0x147C22, /* WebKit.IWKScriptMessageHandlerWithReply */
		0x148122, /* WebKit.IWKUIDelegate */
		0x148522, /* WebKit.IWKUrlSchemeHandler */
		0x148722, /* WebKit.IWKUrlSchemeTask */
		0x153D22, /* Foundation.INSCacheDelegate */
		0x154722, /* Foundation.INSCoding */
		0x155322, /* Foundation.INSCopying */
		0x156A22, /* Foundation.INSDiscardableContent */
		0x157622, /* Foundation.INSExtensionRequestHandling */
		0x157F22, /* Foundation.INSFileManagerDelegate */
		0x158222, /* Foundation.INSFilePresenter */
		0x15A122, /* Foundation.INSItemProviderReading */
		0x15A422, /* Foundation.INSItemProviderWriting */
		0x15AC22, /* Foundation.INSKeyedArchiverDelegate */
		0x15B022, /* Foundation.INSKeyedUnarchiverDelegate */
		0x15C822, /* Foundation.INSLocking */
		0x15CB22, /* Foundation.INSMachPortDelegate */
		0x15D922, /* Foundation.INSMetadataQueryDelegate */
		0x15E322, /* Foundation.INSMutableCopying */
		0x15ED22, /* Foundation.INSNetServiceBrowserDelegate */
		0x15F122, /* Foundation.INSNetServiceDelegate */
		0x15FF22, /* Foundation.INSObjectProtocol */
		0x160D22, /* Foundation.INSPortDelegate */
		0x161F22, /* Foundation.INSProgressReporting */
		0x163322, /* Foundation.INSSecureCoding */
		0x163A22, /* Foundation.INSStreamDelegate */
		0x165622, /* Foundation.INSURLAuthenticationChallengeSender */
		0x165F22, /* Foundation.INSUrlConnectionDataDelegate */
		0x166322, /* Foundation.INSUrlConnectionDelegate */
		0x166722, /* Foundation.INSUrlConnectionDownloadDelegate */
		0x167022, /* Foundation.INSUrlProtocolClient */
		0x167E22, /* Foundation.INSUrlSessionDataDelegate */
		0x168422, /* Foundation.INSUrlSessionDelegate */
		0x168822, /* Foundation.INSUrlSessionDownloadDelegate */
		0x168F22, /* Foundation.INSUrlSessionStreamDelegate */
		0x169622, /* Foundation.INSUrlSessionTaskDelegate */
		0x16A222, /* Foundation.INSUrlSessionWebSocketDelegate */
		0x16AC22, /* Foundation.INSUserActivityDelegate */
		0x16B622, /* Foundation.INSXpcListenerDelegate */
		0x16F122, /* FileProvider.INSFileProviderChangeObserver */
		0x16F622, /* FileProvider.INSFileProviderCustomAction */
		0x16FB22, /* FileProvider.INSFileProviderDomainState */
		0x16FF22, /* FileProvider.INSFileProviderEnumerating */
		0x170122, /* FileProvider.INSFileProviderEnumerationObserver */
		0x170422, /* FileProvider.INSFileProviderEnumerator */
		0x170C22, /* FileProvider.INSFileProviderIncrementalContentFetching */
		0x170E22, /* FileProvider.INSFileProviderItem */
		0x171A22, /* FileProvider.INSFileProviderPendingSetEnumerator */
		0x171D22, /* FileProvider.INSFileProviderReplicatedExtension */
		0x172122, /* FileProvider.INSFileProviderServiceSource */
		0x172422, /* FileProvider.INSFileProviderServicing */
		0x172622, /* FileProvider.INSFileProviderTestingChildrenEnumeration */
		0x172822, /* FileProvider.INSFileProviderTestingCollisionResolution */
		0x172A22, /* FileProvider.INSFileProviderTestingContentFetch */
		0x172C22, /* FileProvider.INSFileProviderTestingCreation */
		0x172E22, /* FileProvider.INSFileProviderTestingDeletion */
		0x173022, /* FileProvider.INSFileProviderTestingIngestion */
		0x173222, /* FileProvider.INSFileProviderTestingLookup */
		0x173422, /* FileProvider.INSFileProviderTestingModification */
		0x173622, /* FileProvider.INSFileProviderTestingOperation */
		0x173A22, /* FileProvider.INSFileProviderThumbnailing */
		0x174622, /* EventKitUI.IEKCalendarChooserDelegate */
		0x174C22, /* EventKitUI.IEKEventEditViewDelegate */
		0x175222, /* EventKitUI.IEKEventViewDelegate */
		0x183122, /* CoreTelephony.ICTSubscriberDelegate */
		0x183522, /* CoreTelephony.ICTTelephonyNetworkInfoDelegate */
		0x184722, /* CoreSpotlight.ICSSearchableIndexDelegate */
		0x186D22, /* CoreMotion.ICMHeadphoneMotionManagerDelegate */
		0x18B122, /* CoreMidi.IMidiCIProfileResponderDelegate */
		0x18FD22, /* CoreML.IMLBatchProvider */
		0x190022, /* CoreML.IMLCustomLayer */
		0x190322, /* CoreML.IMLCustomModel */
		0x190922, /* CoreML.IMLFeatureProvider */
		0x193222, /* CoreML.IMLWritable */
		0x195122, /* CoreLocation.ICLLocationManagerDelegate */
		0x195722, /* CoreLocation.ICLLocationPushServiceExtension */
		0x197222, /* CoreImage.ICIAccordionFoldTransitionProtocol */
		0x197622, /* CoreImage.ICIAffineClampProtocol */
		0x197A22, /* CoreImage.ICIAffineTileProtocol */
		0x197E22, /* CoreImage.ICIAreaAverageProtocol */
		0x198122, /* CoreImage.ICIAreaHistogramProtocol */
		0x198422, /* CoreImage.ICIAreaLogarithmicHistogramProtocol */
		0x198822, /* CoreImage.ICIAreaMaximumAlphaProtocol */
		0x198A22, /* CoreImage.ICIAreaMaximumProtocol */
		0x198E22, /* CoreImage.ICIAreaMinimumAlphaProtocol */
		0x199022, /* CoreImage.ICIAreaMinimumProtocol */
		0x199322, /* CoreImage.ICIAreaMinMaxProtocol */
		0x199622, /* CoreImage.ICIAreaMinMaxRedProtocol */
		0x199822, /* CoreImage.ICIAreaReductionFilterProtocol */
		0x199B22, /* CoreImage.ICIAttributedTextImageGeneratorProtocol */
		0x19A022, /* CoreImage.ICIAztecCodeGeneratorProtocol */
		0x19A422, /* CoreImage.ICIBarcodeGeneratorProtocol */
		0x19A722, /* CoreImage.ICIBarsSwipeTransitionProtocol */
		0x19AA22, /* CoreImage.ICIBicubicScaleTransformProtocol */
		0x19B122, /* CoreImage.ICIBlendWithMaskProtocol */
		0x19B522, /* CoreImage.ICIBloomProtocol */
		0x19B822, /* CoreImage.ICIBokehBlurProtocol */
		0x19BB22, /* CoreImage.ICIBoxBlurProtocol */
		0x19BF22, /* CoreImage.ICIBumpDistortionLinearProtocol */
		0x19C122, /* CoreImage.ICIBumpDistortionProtocol */
		0x19C522, /* CoreImage.ICICheckerboardGeneratorProtocol */
		0x19C822, /* CoreImage.ICICircleSplashDistortionProtocol */
		0x19CB22, /* CoreImage.ICICircularScreenProtocol */
		0x19CE22, /* CoreImage.ICICircularWrapProtocol */
		0x19D222, /* CoreImage.ICICmykHalftoneProtocol */
		0x19D522, /* CoreImage.ICICode128BarcodeGeneratorProtocol */
		0x19D922, /* CoreImage.ICIColorAbsoluteDifferenceProtocol */
		0x19DE22, /* CoreImage.ICIColorClampProtocol */
		0x19E122, /* CoreImage.ICIColorControlsProtocol */
		0x19E422, /* CoreImage.ICIColorCrossPolynomialProtocol */
		0x19E722, /* CoreImage.ICIColorCubeProtocol */
		0x19EB22, /* CoreImage.ICIColorCubesMixedWithMaskProtocol */
		0x19EF22, /* CoreImage.ICIColorCubeWithColorSpaceProtocol */
		0x19F322, /* CoreImage.ICIColorCurvesProtocol */
		0x19F722, /* CoreImage.ICIColorInvertProtocol */
		0x19FB22, /* CoreImage.ICIColorMapProtocol */
		0x19FE22, /* CoreImage.ICIColorMatrixProtocol */
		0x1A0122, /* CoreImage.ICIColorMonochromeProtocol */
		0x1A0422, /* CoreImage.ICIColorPolynomialProtocol */
		0x1A0722, /* CoreImage.ICIColorPosterizeProtocol */
		0x1A0B22, /* CoreImage.ICIColorThresholdOtsuProtocol */
		0x1A0D22, /* CoreImage.ICIColorThresholdProtocol */
		0x1A1022, /* CoreImage.ICIColumnAverageProtocol */
		0x1A1322, /* CoreImage.ICIComicEffectProtocol */
		0x1A1522, /* CoreImage.ICICompositeOperationProtocol */
		0x1A1C22, /* CoreImage.ICIConvertLabProtocol */
		0x1A2422, /* CoreImage.ICIConvolutionProtocol */
		0x1A2C22, /* CoreImage.ICICopyMachineTransitionProtocol */
		0x1A2F22, /* CoreImage.ICICoreMLModelProtocol */
		0x1A3322, /* CoreImage.ICICrystallizeProtocol */
		0x1A3B22, /* CoreImage.ICIDepthOfFieldProtocol */
		0x1A3E22, /* CoreImage.ICIDepthToDisparityProtocol */
		0x1A4222, /* CoreImage.ICIDiscBlurProtocol */
		0x1A4522, /* CoreImage.ICIDisintegrateWithMaskTransitionProtocol */
		0x1A4822, /* CoreImage.ICIDisparityToDepthProtocol */
		0x1A4B22, /* CoreImage.ICIDisplacementDistortionProtocol */
		0x1A4E22, /* CoreImage.ICIDissolveTransitionProtocol */
		0x1A5222, /* CoreImage.ICIDitherProtocol */
		0x1A5622, /* CoreImage.ICIDocumentEnhancerProtocol */
		0x1A5922, /* CoreImage.ICIDotScreenProtocol */
		0x1A5C22, /* CoreImage.ICIDrosteProtocol */
		0x1A5F22, /* CoreImage.ICIEdgePreserveUpsampleProtocol */
		0x1A6222, /* CoreImage.ICIEdgesProtocol */
		0x1A6522, /* CoreImage.ICIEdgeWorkProtocol */
		0x1A6822, /* CoreImage.ICIEightfoldReflectedTileProtocol */
		0x1A6C22, /* CoreImage.ICIExposureAdjustProtocol */
		0x1A7122, /* CoreImage.ICIFalseColorProtocol */
		0x1A7622, /* CoreImage.ICIFilterConstructor */
		0x1A7A22, /* CoreImage.ICIFilterProtocol */
		0x1A7E22, /* CoreImage.ICIFlashTransitionProtocol */
		0x1A8122, /* CoreImage.ICIFourCoordinateGeometryFilterProtocol */
		0x1A8422, /* CoreImage.ICIFourfoldReflectedTileProtocol */
		0x1A8722, /* CoreImage.ICIFourfoldRotatedTileProtocol */
		0x1A8A22, /* CoreImage.ICIFourfoldTranslatedTileProtocol */
		0x1A8D22, /* CoreImage.ICIGaborGradientsProtocol */
		0x1A9022, /* CoreImage.ICIGammaAdjustProtocol */
		0x1A9322, /* CoreImage.ICIGaussianBlurProtocol */
		0x1A9622, /* CoreImage.ICIGaussianGradientProtocol */
		0x1A9922, /* CoreImage.ICIGlassDistortionProtocol */
		0x1A9C22, /* CoreImage.ICIGlassLozengeProtocol */
		0x1A9F22, /* CoreImage.ICIGlideReflectedTileProtocol */
		0x1AA222, /* CoreImage.ICIGloomProtocol */
		0x1AA722, /* CoreImage.ICIHatchedScreenProtocol */
		0x1AAA22, /* CoreImage.ICIHeightFieldFromMaskProtocol */
		0x1AAD22, /* CoreImage.ICIHexagonalPixellateProtocol */
		0x1AB022, /* CoreImage.ICIHighlightShadowAdjustProtocol */
		0x1AB322, /* CoreImage.ICIHistogramDisplayProtocol */
		0x1AB622, /* CoreImage.ICIHoleDistortionProtocol */
		0x1AB922, /* CoreImage.ICIHueAdjustProtocol */
		0x1ABD22, /* CoreImage.ICIHueSaturationValueGradientProtocol */
		0x1AC322, /* CoreImage.ICIImageProcessorInput */
		0x1AC722, /* CoreImage.ICIImageProcessorOutput */
		0x1AD122, /* CoreImage.ICIKaleidoscopeProtocol */
		0x1AD622, /* CoreImage.ICIKeystoneCorrectionCombinedProtocol */
		0x1AD922, /* CoreImage.ICIKeystoneCorrectionHorizontalProtocol */
		0x1ADC22, /* CoreImage.ICIKeystoneCorrectionVerticalProtocol */
		0x1ADF22, /* CoreImage.ICIKMeansProtocol */
		0x1AE222, /* CoreImage.ICILabDeltaEProtocol */
		0x1AE522, /* CoreImage.ICILanczosScaleTransformProtocol */
		0x1AE822, /* CoreImage.ICILenticularHaloGeneratorProtocol */
		0x1AEC22, /* CoreImage.ICILightTunnelProtocol */
		0x1AF222, /* CoreImage.ICILinearGradientProtocol */
		0x1AF622, /* CoreImage.ICILinearToSrgbToneCurveProtocol */
		0x1AF922, /* CoreImage.ICILineOverlayProtocol */
		0x1AFC22, /* CoreImage.ICILineScreenProtocol */
		0x1B0022, /* CoreImage.ICIMaskedVariableBlurProtocol */
		0x1B0322, /* CoreImage.ICIMaskToAlphaProtocol */
		0x1B0622, /* CoreImage.ICIMaximumComponentProtocol */
		0x1B0A22, /* CoreImage.ICIMedianProtocol */
		0x1B0D22, /* CoreImage.ICIMeshGeneratorProtocol */
		0x1B1022, /* CoreImage.ICIMinimumComponentProtocol */
		0x1B1422, /* CoreImage.ICIMixProtocol */
		0x1B1722, /* CoreImage.ICIModTransitionProtocol */
		0x1B1B22, /* CoreImage.ICIMorphologyGradientProtocol */
		0x1B1E22, /* CoreImage.ICIMorphologyMaximumProtocol */
		0x1B2122, /* CoreImage.ICIMorphologyMinimumProtocol */
		0x1B2522, /* CoreImage.ICIMorphologyRectangleMaximumProtocol */
		0x1B2822, /* CoreImage.ICIMorphologyRectangleMinimumProtocol */
		0x1B2B22, /* CoreImage.ICIMotionBlurProtocol */
		0x1B3022, /* CoreImage.ICINinePartStretchedProtocol */
		0x1B3322, /* CoreImage.ICINinePartTiledProtocol */
		0x1B3622, /* CoreImage.ICINoiseReductionProtocol */
		0x1B3922, /* CoreImage.ICIOpTileProtocol */
		0x1B3D22, /* CoreImage.ICIPageCurlTransitionProtocol */
		0x1B4022, /* CoreImage.ICIPageCurlWithShadowTransitionProtocol */
		0x1B4322, /* CoreImage.ICIPaletteCentroidProtocol */
		0x1B4622, /* CoreImage.ICIPalettizeProtocol */
		0x1B4922, /* CoreImage.ICIParallelogramTileProtocol */
		0x1B4C22, /* CoreImage.ICIPdf417BarcodeGeneratorProtocol */
		0x1B5022, /* CoreImage.ICIPersonSegmentationProtocol */
		0x1B5322, /* CoreImage.ICIPerspectiveCorrectionProtocol */
		0x1B5622, /* CoreImage.ICIPerspectiveRotateProtocol */
		0x1B5922, /* CoreImage.ICIPerspectiveTileProtocol */
		0x1B5C22, /* CoreImage.ICIPerspectiveTransformProtocol */
		0x1B5F22, /* CoreImage.ICIPerspectiveTransformWithExtentProtocol */
		0x1B6822, /* CoreImage.ICIPhotoEffectProtocol */
		0x1B6D22, /* CoreImage.ICIPinchDistortionProtocol */
		0x1B7122, /* CoreImage.ICIPixellateProtocol */
		0x1B7422, /* CoreImage.ICIPointillizeProtocol */
		0x1B7A22, /* CoreImage.ICIQRCodeGeneratorProtocol */
		0x1B7D22, /* CoreImage.ICIRadialGradientProtocol */
		0x1B8022, /* CoreImage.ICIRandomGeneratorProtocol */
		0x1B8E22, /* CoreImage.ICIRippleTransitionProtocol */
		0x1B9122, /* CoreImage.ICIRoundedRectangleGeneratorProtocol */
		0x1B9422, /* CoreImage.ICIRowAverageProtocol */
		0x1B9722, /* CoreImage.ICISaliencyMapProtocol */
		0x1B9E22, /* CoreImage.ICISepiaToneProtocol */
		0x1BA122, /* CoreImage.ICIShadedMaterialProtocol */
		0x1BA422, /* CoreImage.ICISharpenLuminanceProtocol */
		0x1BA722, /* CoreImage.ICISixfoldReflectedTileProtocol */
		0x1BAA22, /* CoreImage.ICISixfoldRotatedTileProtocol */
		0x1BAD22, /* CoreImage.ICISmoothLinearGradientProtocol */
		0x1BB522, /* CoreImage.ICISpotColorProtocol */
		0x1BB822, /* CoreImage.ICISpotLightProtocol */
		0x1BBB22, /* CoreImage.ICISrgbToneCurveToLinearProtocol */
		0x1BBE22, /* CoreImage.ICIStarShineGeneratorProtocol */
		0x1BC122, /* CoreImage.ICIStraightenProtocol */
		0x1BC422, /* CoreImage.ICIStretchCropProtocol */
		0x1BC722, /* CoreImage.ICIStripesGeneratorProtocol */
		0x1BCB22, /* CoreImage.ICISunbeamsGeneratorProtocol */
		0x1BCE22, /* CoreImage.ICISwipeTransitionProtocol */
		0x1BD122, /* CoreImage.ICITemperatureAndTintProtocol */
		0x1BD522, /* CoreImage.ICITextImageGeneratorProtocol */
		0x1BD922, /* CoreImage.ICIThermalProtocol */
		0x1BDD22, /* CoreImage.ICIToneCurveProtocol */
		0x1BE022, /* CoreImage.ICITorusLensDistortionProtocol */
		0x1BE322, /* CoreImage.ICITransitionFilterProtocol */
		0x1BE622, /* CoreImage.ICITriangleKaleidoscopeProtocol */
		0x1BE922, /* CoreImage.ICITriangleTileProtocol */
		0x1BEC22, /* CoreImage.ICITwelvefoldReflectedTileProtocol */
		0x1BEF22, /* CoreImage.ICITwirlDistortionProtocol */
		0x1BF322, /* CoreImage.ICIUnsharpMaskProtocol */
		0x1BF622, /* CoreImage.ICIVibranceProtocol */
		0x1BFA22, /* CoreImage.ICIVignetteEffectProtocol */
		0x1BFC22, /* CoreImage.ICIVignetteProtocol */
		0x1C0022, /* CoreImage.ICIVortexDistortionProtocol */
		0x1C0422, /* CoreImage.ICIWhitePointAdjustProtocol */
		0x1C0722, /* CoreImage.ICIXRayProtocol */
		0x1C0A22, /* CoreImage.ICIZoomBlurProtocol */
		0x1CCC22, /* CoreData.INSFetchedResultsControllerDelegate */
		0x1CD022, /* CoreData.INSFetchedResultsSectionInfo */
		0x1CD822, /* CoreData.INSFetchRequestResult */
		0x1D3422, /* CoreBluetooth.ICBCentralManagerDelegate */
		0x1D4F22, /* CoreBluetooth.ICBPeripheralDelegate */
		0x1D5B22, /* CoreBluetooth.ICBPeripheralManagerDelegate */
		0x1D7322, /* CoreAnimation.ICAAction */
		0x1D7622, /* CoreAnimation.ICAAnimationDelegate */
		0x1D8722, /* CoreAnimation.ICALayerDelegate */
		0x1D8A22, /* CoreAnimation.ICAMediaTiming */
		0x1D8D22, /* CoreAnimation.ICAMetalDrawable */
		0x1DB122, /* Contacts.ICNChangeHistoryEventVisitor */
		0x1DD222, /* Contacts.ICNKeyDescriptor */
		0x1E2C22, /* CloudKit.ICKRecordValue */
		0x1E6422, /* ClassKit.ICLSContextProvider */
		0x1E6A22, /* ClassKit.ICLSDataStoreDelegate */
		0x1ED022, /* CarPlay.ICPApplicationDelegate */
		0x1ED922, /* CarPlay.ICPBarButtonProviding */
		0x1EEF22, /* CarPlay.ICPInstrumentClusterControllerDelegate */
		0x1EF522, /* CarPlay.ICPInterfaceControllerDelegate */
		0x1F0022, /* CarPlay.ICPListTemplateDelegate */
		0x1F0322, /* CarPlay.ICPListTemplateItem */
		0x1F0A22, /* CarPlay.ICPMapTemplateDelegate */
		0x1F1E22, /* CarPlay.ICPNowPlayingTemplateObserver */
		0x1F2422, /* CarPlay.ICPPointOfInterestTemplateDelegate */
		0x1F2A22, /* CarPlay.ICPSearchTemplateDelegate */
		0x1F2E22, /* CarPlay.ICPSelectableListItem */
		0x1F3122, /* CarPlay.ICPSessionConfigurationDelegate */
		0x1F3622, /* CarPlay.ICPTabBarTemplateDelegate */
		0x1F3B22, /* CarPlay.ICPTemplateApplicationDashboardSceneDelegate */
		0x1F4022, /* CarPlay.ICPTemplateApplicationInstrumentClusterSceneDelegate */
		0x1F4522, /* CarPlay.ICPTemplateApplicationSceneDelegate */
		0x1F6022, /* CallKit.ICXCallDirectoryExtensionContextDelegate */
		0x1F6722, /* CallKit.ICXCallObserverDelegate */
		0x1F7B22, /* CallKit.ICXProviderDelegate */
		0x1F9122, /* BackgroundAssets.IBADownloaderExtension */
		0x1F9422, /* BackgroundAssets.IBADownloadManagerDelegate */
		0x1F9E22, /* AuthenticationServices.IASAccountAuthenticationModificationControllerDelegate */
		0x1FA222, /* AuthenticationServices.IASAccountAuthenticationModificationControllerPresentationContextProviding */
		0x1FB122, /* AuthenticationServices.IASAuthorizationControllerDelegate */
		0x1FB522, /* AuthenticationServices.IASAuthorizationControllerPresentationContextProviding */
		0x1FB822, /* AuthenticationServices.IASAuthorizationCredential */
		0x1FC722, /* AuthenticationServices.IASAuthorizationProvider */
		0x1FCC22, /* AuthenticationServices.IASAuthorizationProviderExtensionAuthorizationRequestHandler */
		0x1FD022, /* AuthenticationServices.IASAuthorizationPublicKeyCredentialAssertion */
		0x1FD222, /* AuthenticationServices.IASAuthorizationPublicKeyCredentialAssertionRequest */
		0x1FD522, /* AuthenticationServices.IASAuthorizationPublicKeyCredentialDescriptor */
		0x1FD822, /* AuthenticationServices.IASAuthorizationPublicKeyCredentialRegistration */
		0x1FDA22, /* AuthenticationServices.IASAuthorizationPublicKeyCredentialRegistrationRequest */
		0x1FF922, /* AuthenticationServices.IASPublicKeyCredential */
		0x1FFC22, /* AuthenticationServices.IASWebAuthenticationPresentationContextProviding */
		0x203C22, /* AudioUnit.IAUAudioUnitFactory */
		0x21FA22, /* UIKit.INSCollectionLayoutContainer */
		0x21FF22, /* UIKit.INSCollectionLayoutEnvironment */
		0x220822, /* UIKit.INSCollectionLayoutVisibleItem */
		0x221822, /* UIKit.INSLayoutManagerDelegate */
		0x222822, /* UIKit.INSTextAttachmentContainer */
		0x222B22, /* UIKit.INSTextAttachmentLayout */
		0x223022, /* UIKit.INSTextContentManagerDelegate */
		0x223622, /* UIKit.INSTextContentStorageDelegate */
		0x223C22, /* UIKit.INSTextElementProvider */
		0x224322, /* UIKit.INSTextLayoutManagerDelegate */
		0x224A22, /* UIKit.INSTextLayoutOrientationProvider */
		0x225222, /* UIKit.INSTextLocation */
		0x225922, /* UIKit.INSTextSelectionDataSource */
		0x226622, /* UIKit.INSTextStorageDelegate */
		0x226B22, /* UIKit.INSTextStorageObserving */
		0x226F22, /* UIKit.INSTextViewportLayoutControllerDelegate */
		0x227822, /* UIKit.IUIAccelerometerDelegate */
		0x227F22, /* UIKit.IUIAccessibilityContainerDataTable */
		0x228322, /* UIKit.IUIAccessibilityContainerDataTableCell */
		0x228622, /* UIKit.IUIAccessibilityContentSizeCategoryImageAdjusting */
		0x229022, /* UIKit.IUIAccessibilityIdentification */
		0x229422, /* UIKit.IUIAccessibilityReadingContent */
		0x229F22, /* UIKit.IUIActionSheetDelegate */
		0x22AE22, /* UIKit.IUIActivityItemsConfigurationProviding */
		0x22B022, /* UIKit.IUIActivityItemsConfigurationReading */
		0x22B322, /* UIKit.IUIActivityItemSource */
		0x22B822, /* UIKit.IUIAdaptivePresentationControllerDelegate */
		0x22BF22, /* UIKit.IUIAlertViewDelegate */
		0x22C422, /* UIKit.IUIAppearance */
		0x22C622, /* UIKit.IUIAppearanceContainer */
		0x22C922, /* UIKit.IUIApplicationDelegate */
		0x22E322, /* UIKit.IUIBarPositioning */
		0x22E622, /* UIKit.IUIBarPositioningDelegate */
		0x22F922, /* UIKit.IUICalendarSelectionMultiDateDelegate */
		0x22FE22, /* UIKit.IUICalendarSelectionSingleDateDelegate */
		0x230522, /* UIKit.IUICalendarViewDelegate */
		0x231B22, /* UIKit.IUICloudSharingControllerDelegate */
		0x233122, /* UIKit.IUICollectionViewDataSource */
		0x233522, /* UIKit.IUICollectionViewDataSourcePrefetching */
		0x233822, /* UIKit.IUICollectionViewDelegate */
		0x233C22, /* UIKit.IUICollectionViewDelegateFlowLayout */
		0x234322, /* UIKit.IUICollectionViewDragDelegate */
		0x234722, /* UIKit.IUICollectionViewDropCoordinator */
		0x234922, /* UIKit.IUICollectionViewDropDelegate */
		0x234E22, /* UIKit.IUICollectionViewDropItem */
		0x235122, /* UIKit.IUICollectionViewDropPlaceholderContext */
		0x236822, /* UIKit.IUICollisionBehaviorDelegate */
		0x236E22, /* UIKit.IUIColorPickerViewControllerDelegate */
		0x237522, /* UIKit.IUIConfigurationState */
		0x237722, /* UIKit.IUIContentConfiguration */
		0x237922, /* UIKit.IUIContentContainer */
		0x237E22, /* UIKit.IUIContentSizeCategoryAdjusting */
		0x238022, /* UIKit.IUIContentView */
		0x238622, /* UIKit.IUIContextMenuInteractionAnimating */
		0x238922, /* UIKit.IUIContextMenuInteractionCommitAnimating */
		0x238C22, /* UIKit.IUIContextMenuInteractionDelegate */
		0x239622, /* UIKit.IUICoordinateSpace */
		0x239B22, /* UIKit.IUIDataSourceModelAssociation */
		0x239D22, /* UIKit.IUIDataSourceTranslating */
		0x23AF22, /* UIKit.IUIDocumentBrowserViewControllerDelegate */
		0x23B622, /* UIKit.IUIDocumentInteractionControllerDelegate */
		0x23BA22, /* UIKit.IUIDocumentMenuDelegate */
		0x23BF22, /* UIKit.IUIDocumentPickerDelegate */
		0x23CA22, /* UIKit.IUIDragAnimating */
		0x23CC22, /* UIKit.IUIDragDropSession */
		0x23CF22, /* UIKit.IUIDragInteractionDelegate */
		0x23D722, /* UIKit.IUIDragSession */
		0x23DA22, /* UIKit.IUIDropInteractionDelegate */
		0x23E022, /* UIKit.IUIDropSession */
		0x23E322, /* UIKit.IUIDynamicAnimatorDelegate */
		0x23E722, /* UIKit.IUIDynamicItem */
		0x23F222, /* UIKit.IUIEditMenuInteractionAnimating */
		0x23F422, /* UIKit.IUIEditMenuInteractionDelegate */
		0x240122, /* UIKit.IUIFindInteractionDelegate */
		0x240722, /* UIKit.IUIFocusAnimationContext */
		0x240B22, /* UIKit.IUIFocusDebuggerOutput */
		0x240E22, /* UIKit.IUIFocusEnvironment */
		0x241622, /* UIKit.IUIFocusItem */
		0x241922, /* UIKit.IUIFocusItemContainer */
		0x241B22, /* UIKit.IUIFocusItemScrollableContainer */
		0x242522, /* UIKit.IUIFontPickerViewControllerDelegate */
		0x243022, /* UIKit.IUIGestureRecognizerDelegate */
		0x244322, /* UIKit.IUIGuidedAccessRestrictionDelegate */
		0x244E22, /* UIKit.IUIImagePickerControllerDelegate */
		0x245E22, /* UIKit.IUIIndirectScribbleInteractionDelegate */
		0x246322, /* UIKit.IUIInputViewAudioFeedback */
		0x246722, /* UIKit.IUIInteraction */
		0x246D22, /* UIKit.IUIItemProviderPresentationSizeProviding */
		0x247522, /* UIKit.IUIKeyInput */
		0x247A22, /* UIKit.IUILargeContentViewerInteractionDelegate */
		0x247E22, /* UIKit.IUILargeContentViewerItem */
		0x248322, /* UIKit.IUILayoutGuideAspectFitting */
		0x248622, /* UIKit.IUILayoutSupport */
		0x249922, /* UIKit.IUIMenuBuilder */
		0x24A422, /* UIKit.IUIMenuLeaf */
		0x24B022, /* UIKit.IUINavigationBarDelegate */
		0x24B522, /* UIKit.IUINavigationControllerDelegate */
		0x24BD22, /* UIKit.IUINavigationItemRenameDelegate */
		0x24C722, /* UIKit.IUIObjectRestoration */
		0x24D122, /* UIKit.IUIPageViewControllerDataSource */
		0x24D522, /* UIKit.IUIPageViewControllerDelegate */
		0x24E322, /* UIKit.IUIPasteConfigurationSupporting */
		0x24EA22, /* UIKit.IUIPencilInteractionDelegate */
		0x24F022, /* UIKit.IUIPickerViewAccessibilityDelegate */
		0x24F422, /* UIKit.IUIPickerViewDataSource */
		0x24F722, /* UIKit.IUIPickerViewDelegate */
		0x250422, /* UIKit.IUIPointerInteractionAnimating */
		0x250622, /* UIKit.IUIPointerInteractionDelegate */
		0x251222, /* UIKit.IUIPopoverBackgroundViewMethods */
		0x251522, /* UIKit.IUIPopoverControllerDelegate */
		0x251A22, /* UIKit.IUIPopoverPresentationControllerDelegate */
		0x251C22, /* UIKit.IUIPopoverPresentationControllerSourceItem */
		0x252522, /* UIKit.IUIPreviewActionItem */
		0x252922, /* UIKit.IUIPreviewInteractionDelegate */
		0x253522, /* UIKit.IUIPrinterPickerControllerDelegate */
		0x254322, /* UIKit.IUIPrintInteractionControllerDelegate */
		0x255622, /* UIKit.IUIResponderStandardEditActions */
		0x256022, /* UIKit.IUISceneDelegate */
		0x257022, /* UIKit.IUIScreenshotServiceDelegate */
		0x257522, /* UIKit.IUIScribbleInteractionDelegate */
		0x257F22, /* UIKit.IUIScrollViewAccessibilityDelegate */
		0x258422, /* UIKit.IUIScrollViewDelegate */
		0x258D22, /* UIKit.IUISearchBarDelegate */
		0x259422, /* UIKit.IUISearchControllerDelegate */
		0x259922, /* UIKit.IUISearchDisplayDelegate */
		0x259D22, /* UIKit.IUISearchResultsUpdating */
		0x25A122, /* UIKit.IUISearchSuggestion */
		0x25A622, /* UIKit.IUISearchTextFieldDelegate */
		0x25AA22, /* UIKit.IUISearchTextFieldPasteItem */
		0x25B222, /* UIKit.IUISheetPresentationControllerDelegate */
		0x25B922, /* UIKit.IUISheetPresentationControllerDetentResolutionContext */
		0x25C622, /* UIKit.IUISplitViewControllerDelegate */
		0x25D022, /* UIKit.IUISpringLoadedInteractionBehavior */
		0x25D322, /* UIKit.IUISpringLoadedInteractionContext */
		0x25D522, /* UIKit.IUISpringLoadedInteractionEffect */
		0x25D822, /* UIKit.IUISpringLoadedInteractionSupporting */
		0x25DF22, /* UIKit.IUIStateRestoring */
		0x25F822, /* UIKit.IUITabBarControllerDelegate */
		0x25FC22, /* UIKit.IUITabBarDelegate */
		0x260F22, /* UIKit.IUITableViewDataSource */
		0x261322, /* UIKit.IUITableViewDataSourcePrefetching */
		0x261622, /* UIKit.IUITableViewDelegate */
		0x261B22, /* UIKit.IUITableViewDragDelegate */
		0x261F22, /* UIKit.IUITableViewDropCoordinator */
		0x262122, /* UIKit.IUITableViewDropDelegate */
		0x262622, /* UIKit.IUITableViewDropItem */
		0x262922, /* UIKit.IUITableViewDropPlaceholderContext */
		0x264222, /* UIKit.IUITextDocumentProxy */
		0x264622, /* UIKit.IUITextDragDelegate */
		0x264A22, /* UIKit.IUITextDraggable */
		0x264E22, /* UIKit.IUITextDragRequest */
		0x265122, /* UIKit.IUITextDropDelegate */
		0x265622, /* UIKit.IUITextDroppable */
		0x265B22, /* UIKit.IUITextDropRequest */
		0x265D22, /* UIKit.IUITextFieldDelegate */
		0x266422, /* UIKit.IUITextFormattingCoordinatorDelegate */
		0x266822, /* UIKit.IUITextInput */
		0x266C22, /* UIKit.IUITextInputDelegate */
		0x267222, /* UIKit.IUITextInputTokenizer */
		0x267522, /* UIKit.IUITextInputTraits */
		0x267922, /* UIKit.IUITextInteractionDelegate */
		0x268022, /* UIKit.IUITextPasteConfigurationSupporting */
		0x268222, /* UIKit.IUITextPasteDelegate */
		0x268622, /* UIKit.IUITextPasteItem */
		0x268B22, /* UIKit.IUITextSearchAggregator */
		0x268E22, /* UIKit.IUITextSearching */
		0x269A22, /* UIKit.IUITextViewDelegate */
		0x269F22, /* UIKit.IUITimingCurveProvider */
		0x26A322, /* UIKit.IUIToolbarDelegate */
		0x26A922, /* UIKit.IUIToolTipInteractionDelegate */
		0x26B222, /* UIKit.IUITraitEnvironment */
		0x26B822, /* UIKit.IUIUserActivityRestoring */
		0x26CA22, /* UIKit.IUIVideoEditorControllerDelegate */
		0x26CF22, /* UIKit.IUIViewAnimating */
		0x26D922, /* UIKit.IUIViewControllerAnimatedTransitioning */
		0x26DD22, /* UIKit.IUIViewControllerContextTransitioning */
		0x26E122, /* UIKit.IUIViewControllerInteractiveTransitioning */
		0x26E522, /* UIKit.IUIViewControllerPreviewing */
		0x26E722, /* UIKit.IUIViewControllerPreviewingDelegate */
		0x26EA22, /* UIKit.IUIViewControllerRestoration */
		0x26EC22, /* UIKit.IUIViewControllerTransitionCoordinator */
		0x26EF22, /* UIKit.IUIViewControllerTransitionCoordinatorContext */
		0x26F122, /* UIKit.IUIViewControllerTransitioningDelegate */
		0x26F522, /* UIKit.IUIViewImplicitlyAnimating */
		0x270222, /* UIKit.IUIWebViewDelegate */
		0x270D22, /* UIKit.IUIWindowSceneDelegate */
		0x272C22, /* AddressBookUI.IABNewPersonViewControllerDelegate */
		0x272F22, /* AddressBookUI.IABPeoplePickerNavigationControllerDelegate */
		0x273422, /* AddressBookUI.IABPersonViewControllerDelegate */
		0x273722, /* AddressBookUI.IABUnknownPersonViewControllerDelegate */
		0x277822, /* Accessibility.IAXBrailleMapRenderer */
		0x277B22, /* Accessibility.IAXChart */
		0x278122, /* Accessibility.IAXCustomContentProvider */
		0x278322, /* Accessibility.IAXDataAxisDescriptor */
		0x27A322, /* AVKit.IAVCustomRoutingControllerDelegate */
		0x27AC22, /* AVKit.IAVPictureInPictureControllerDelegate */
		0x27B022, /* AVKit.IAVPictureInPictureSampleBufferPlaybackDelegate */
		0x27B622, /* AVKit.IAVPlayerViewControllerDelegate */
		0x27BC22, /* AVKit.IAVRoutePickerViewDelegate */
		0x281E22, /* AVFoundation.IAVAssetDownloadDelegate */
		0x283822, /* AVFoundation.IAVAssetResourceLoaderDelegate */
		0x284D22, /* AVFoundation.IAVAssetWriterDelegate */
		0x285A22, /* AVFoundation.IAVAsynchronousKeyValueLoading */
		0x285E22, /* AVFoundation.IAVAudio3DMixing */
		0x287A22, /* AVFoundation.IAVAudioMixing */
		0x288122, /* AVFoundation.IAVAudioPlayerDelegate */
		0x288922, /* AVFoundation.IAVAudioRecorderDelegate */
		0x289222, /* AVFoundation.IAVAudioSessionDelegate */
		0x28A822, /* AVFoundation.IAVAudioStereoMixing */
		0x28C622, /* AVFoundation.IAVCaptureAudioDataOutputSampleBufferDelegate */
		0x28CE22, /* AVFoundation.IAVCaptureDataOutputSynchronizerDelegate */
		0x28D222, /* AVFoundation.IAVCaptureDepthDataOutputDelegate */
		0x28DD22, /* AVFoundation.IAVCaptureFileOutputRecordingDelegate */
		0x28E622, /* AVFoundation.IAVCaptureMetadataOutputObjectsDelegate */
		0x28F122, /* AVFoundation.IAVCapturePhotoCaptureDelegate */
		0x28F522, /* AVFoundation.IAVCapturePhotoFileDataRepresentationCustomizer */
		0x290D22, /* AVFoundation.IAVCaptureVideoDataOutputSampleBufferDelegate */
		0x292022, /* AVFoundation.IAVContentKeyRecipient */
		0x292B22, /* AVFoundation.IAVContentKeySessionDelegate */
		0x295222, /* AVFoundation.IAVFragmentMinding */
		0x299122, /* AVFoundation.IAVPlaybackCoordinatorPlaybackControlDelegate */
		0x299F22, /* AVFoundation.IAVPlayerItemLegibleOutputPushDelegate */
		0x29A522, /* AVFoundation.IAVPlayerItemMetadataCollectorPushDelegate */
		0x29A922, /* AVFoundation.IAVPlayerItemMetadataOutputPushDelegate */
		0x29AE22, /* AVFoundation.IAVPlayerItemOutputPullDelegate */
		0x29B222, /* AVFoundation.IAVPlayerItemOutputPushDelegate */
		0x29BD22, /* AVFoundation.IAVPlayerPlaybackCoordinatorDelegate */
		0x29C822, /* AVFoundation.IAVQueuedSampleBufferRendering */
		0x29DE22, /* AVFoundation.IAVSpeechSynthesizerDelegate */
		0x29EE22, /* AVFoundation.IAVVideoCompositing */
		0x29F822, /* AVFoundation.IAVVideoCompositionValidationHandling */
		0x2A1E22, /* ARKit.IARAnchorCopying */
		0x2A2A22, /* ARKit.IARCoachingOverlayViewDelegate */
		0x2A6622, /* ARKit.IARSCNViewDelegate */
		0x2A6D22, /* ARKit.IARSessionDelegate */
		0x2A7122, /* ARKit.IARSessionObserver */
		0x2A7422, /* ARKit.IARSessionProviding */
		0x2A7B22, /* ARKit.IARSKViewDelegate */
		0x2A7F22, /* ARKit.IARTrackable */
	};
	static const Protocol* __xamarin_protocols [] = {
		@protocol (VNDocumentCameraViewControllerDelegate), /* VisionKit.IVNDocumentCameraViewControllerDelegate */
		@protocol (UNNotificationContentExtension), /* UserNotificationsUI.IUNNotificationContentExtension */
		@protocol (UIView_IQToolbarAddition), /* Xamarin.IUIView_IQToolbarAddition */
		@protocol (WCSessionDelegate), /* WatchConnectivity.IWCSessionDelegate */
		@protocol (FIRMessagingDelegate), /* Firebase.CloudMessaging.IMessagingDelegate */
		@protocol (SFSpeechRecognitionTaskDelegate), /* Speech.ISFSpeechRecognitionTaskDelegate */
		@protocol (SFSpeechRecognizerDelegate), /* Speech.ISFSpeechRecognizerDelegate */
		@protocol (SNRequest), /* SoundAnalysis.ISNRequest */
		@protocol (SNResult), /* SoundAnalysis.ISNResult */
		@protocol (SNResultsObserving), /* SoundAnalysis.ISNResultsObserving */
		@protocol (SWCollaborationViewDelegate), /* SharedWithYou.ISWCollaborationViewDelegate */
		@protocol (SWHighlightCenterDelegate), /* SharedWithYou.ISWHighlightCenterDelegate */
		@protocol (SWHighlightEvent), /* SharedWithYou.ISWHighlightEvent */
		@protocol (SFSafariViewControllerDelegate), /* SafariServices.ISFSafariViewControllerDelegate */
		@protocol (QLPreviewControllerDataSource), /* QuickLook.IQLPreviewControllerDataSource */
		@protocol (QLPreviewControllerDelegate), /* QuickLook.IQLPreviewControllerDelegate */
		@protocol (QLPreviewingController), /* QuickLook.IQLPreviewingController */
		@protocol (QLPreviewItem), /* QuickLook.IQLPreviewItem */
		@protocol (PKPushRegistryDelegate), /* PushKit.IPKPushRegistryDelegate */
		@protocol (PHContentEditingController), /* PhotosUI.IPHContentEditingController */
		@protocol (PHLivePhotoViewDelegate), /* PhotosUI.IPHLivePhotoViewDelegate */
		@protocol (PHPickerViewControllerDelegate), /* PhotosUI.IPHPickerViewControllerDelegate */
		@protocol (PKCanvasViewDelegate), /* PencilKit.IPKCanvasViewDelegate */
		@protocol (PKToolPickerObserver), /* PencilKit.IPKToolPickerObserver */
		@protocol (OSLogEntryFromProcess), /* OSLog.IOSLogEntryFromProcess */
		@protocol (OSLogEntryWithPayload), /* OSLog.IOSLogEntryWithPayload */
		@protocol (NCWidgetProviding), /* NotificationCenter.INCWidgetProviding */
		@protocol (MSMessagesAppTranscriptPresentation), /* Messages.IMSMessagesAppTranscriptPresentation */
		@protocol (MSStickerBrowserViewDataSource), /* Messages.IMSStickerBrowserViewDataSource */
		@protocol (INUIAddVoiceShortcutButtonDelegate), /* IntentsUI.IINUIAddVoiceShortcutButtonDelegate */
		@protocol (INUIAddVoiceShortcutViewControllerDelegate), /* IntentsUI.IINUIAddVoiceShortcutViewControllerDelegate */
		@protocol (INUIEditVoiceShortcutViewControllerDelegate), /* IntentsUI.IINUIEditVoiceShortcutViewControllerDelegate */
		@protocol (INUIHostedViewControlling), /* IntentsUI.IINUIHostedViewControlling */
		@protocol (INUIHostedViewSiriProviding), /* IntentsUI.IINUIHostedViewSiriProviding */
		@protocol (ILMessageFilterCapabilitiesQueryHandling), /* IdentityLookup.IILMessageFilterCapabilitiesQueryHandling */
		@protocol (ILMessageFilterQueryHandling), /* IdentityLookup.IILMessageFilterQueryHandling */
		@protocol (EAAccessoryDelegate), /* ExternalAccessory.IEAAccessoryDelegate */
		@protocol (EAWiFiUnconfiguredAccessoryBrowserDelegate), /* ExternalAccessory.IEAWiFiUnconfiguredAccessoryBrowserDelegate */
		@protocol (CHHapticAdvancedPatternPlayer), /* CoreHaptics.ICHHapticAdvancedPatternPlayer */
		@protocol (CHHapticDeviceCapability), /* CoreHaptics.ICHHapticDeviceCapability */
		@protocol (CHHapticParameterAttributes), /* CoreHaptics.ICHHapticParameterAttributes */
		@protocol (CHHapticPatternPlayer), /* CoreHaptics.ICHHapticPatternPlayer */
		@protocol (CNContactPickerDelegate), /* ContactsUI.ICNContactPickerDelegate */
		@protocol (CNContactViewControllerDelegate), /* ContactsUI.ICNContactViewControllerDelegate */
		@protocol (AEAssessmentSessionDelegate), /* AutomaticAssessmentConfiguration.IAEAssessmentSessionDelegate */
		@protocol (VNFaceObservationAccepting), /* Vision.IVNFaceObservationAccepting */
		@protocol (VNRequestProgressProviding), /* Vision.IVNRequestProgressProviding */
		@protocol (VNRequestRevisionProviding), /* Vision.IVNRequestRevisionProviding */
		@protocol (VSAccountManagerDelegate), /* VideoSubscriberAccount.IVSAccountManagerDelegate */
		@protocol (UNNotificationContentProviding), /* UserNotifications.IUNNotificationContentProviding */
		@protocol (UNUserNotificationCenterDelegate), /* UserNotifications.IUNUserNotificationCenterDelegate */
		@protocol (SKCloudServiceSetupViewControllerDelegate), /* StoreKit.ISKCloudServiceSetupViewControllerDelegate */
		@protocol (SKOverlayDelegate), /* StoreKit.ISKOverlayDelegate */
		@protocol (SKPaymentQueueDelegate), /* StoreKit.ISKPaymentQueueDelegate */
		@protocol (SKPaymentTransactionObserver), /* StoreKit.ISKPaymentTransactionObserver */
		@protocol (SKProductsRequestDelegate), /* StoreKit.ISKProductsRequestDelegate */
		@protocol (SKRequestDelegate), /* StoreKit.ISKRequestDelegate */
		@protocol (SKStoreProductViewControllerDelegate), /* StoreKit.ISKStoreProductViewControllerDelegate */
		@protocol (SKPhysicsContactDelegate), /* SpriteKit.ISKPhysicsContactDelegate */
		@protocol (SKSceneDelegate), /* SpriteKit.ISKSceneDelegate */
		@protocol (SKViewDelegate), /* SpriteKit.ISKViewDelegate */
		@protocol (SKWarpable), /* SpriteKit.ISKWarpable */
		@protocol (SWCollaborationActionHandler), /* SharedWithYouCore.ISWCollaborationActionHandler */
		@protocol (SRSensorReaderDelegate), /* SensorKit.ISRSensorReaderDelegate */
		@protocol (SCNActionable), /* SceneKit.ISCNActionable */
		@protocol (SCNAnimatable), /* SceneKit.ISCNAnimatable */
		@protocol (SCNAnimation), /* SceneKit.ISCNAnimationProtocol */
		@protocol (SCNAvoidOccluderConstraintDelegate), /* SceneKit.ISCNAvoidOccluderConstraintDelegate */
		@protocol (SCNBoundingVolume), /* SceneKit.ISCNBoundingVolume */
		@protocol (SCNBufferStream), /* SceneKit.ISCNBufferStream */
		@protocol (SCNCameraControlConfiguration), /* SceneKit.ISCNCameraControlConfiguration */
		@protocol (SCNCameraControllerDelegate), /* SceneKit.ISCNCameraControllerDelegate */
		@protocol (SCNNodeRendererDelegate), /* SceneKit.ISCNNodeRendererDelegate */
		@protocol (SCNPhysicsContactDelegate), /* SceneKit.ISCNPhysicsContactDelegate */
		@protocol (SCNProgramDelegate), /* SceneKit.ISCNProgramDelegate */
		@protocol (SCNSceneExportDelegate), /* SceneKit.ISCNSceneExportDelegate */
		@protocol (SCNSceneRenderer), /* SceneKit.ISCNSceneRenderer */
		@protocol (SCNSceneRendererDelegate), /* SceneKit.ISCNSceneRendererDelegate */
		@protocol (SCNShadable), /* SceneKit.ISCNShadable */
		@protocol (SCNTechniqueSupport), /* SceneKit.ISCNTechniqueSupport */
		@protocol (RPBroadcastActivityViewControllerDelegate), /* ReplayKit.IRPBroadcastActivityViewControllerDelegate */
		@protocol (RPBroadcastControllerDelegate), /* ReplayKit.IRPBroadcastControllerDelegate */
		@protocol (RPPreviewViewControllerDelegate), /* ReplayKit.IRPPreviewViewControllerDelegate */
		@protocol (RPScreenRecorderDelegate), /* ReplayKit.IRPScreenRecorderDelegate */
		@protocol (PHLivePhotoFrame), /* Photos.IPHLivePhotoFrame */
		@protocol (PHPhotoLibraryAvailabilityObserver), /* Photos.IPHPhotoLibraryAvailabilityObserver */
		@protocol (PHPhotoLibraryChangeObserver), /* Photos.IPHPhotoLibraryChangeObserver */
		@protocol (PDFDocumentDelegate), /* PdfKit.IPdfDocumentDelegate */
		@protocol (PDFPageOverlayViewProvider), /* PdfKit.IPdfPageOverlayViewProvider */
		@protocol (PDFViewDelegate), /* PdfKit.IPdfViewDelegate */
		@protocol (PKAddPassesViewControllerDelegate), /* PassKit.IPKAddPassesViewControllerDelegate */
		@protocol (PKAddPaymentPassViewControllerDelegate), /* PassKit.IPKAddPaymentPassViewControllerDelegate */
		@protocol (PKAddSecureElementPassViewControllerDelegate), /* PassKit.IPKAddSecureElementPassViewControllerDelegate */
		@protocol (PKDisbursementAuthorizationControllerDelegate), /* PassKit.IPKDisbursementAuthorizationControllerDelegate */
		@protocol (PKIdentityDocumentDescriptor), /* PassKit.IPKIdentityDocumentDescriptor */
		@protocol (PKIssuerProvisioningExtensionAuthorizationProviding), /* PassKit.IPKIssuerProvisioningExtensionAuthorizationProviding */
		@protocol (PKPaymentAuthorizationControllerDelegate), /* PassKit.IPKPaymentAuthorizationControllerDelegate */
		@protocol (PKPaymentAuthorizationViewControllerDelegate), /* PassKit.IPKPaymentAuthorizationViewControllerDelegate */
		@protocol (PKPaymentInformationRequestHandling), /* PassKit.IPKPaymentInformationRequestHandling */
		@protocol (PKShareSecureElementPassViewControllerDelegate), /* PassKit.IPKShareSecureElementPassViewControllerDelegate */
		@protocol (PKVehicleConnectionDelegate), /* PassKit.IPKVehicleConnectionDelegate */
		@protocol (EAGLDrawable), /* OpenGLES.IEAGLDrawable */
		@protocol (NEAppPushDelegate), /* NetworkExtension.INEAppPushDelegate */
		@protocol (NWTCPConnectionAuthenticationDelegate), /* NetworkExtension.INWTcpConnectionAuthenticationDelegate */
		@protocol (NIDeviceCapability), /* NearbyInteraction.INIDeviceCapability */
		@protocol (NISessionDelegate), /* NearbyInteraction.INISessionDelegate */
		@protocol (MCAdvertiserAssistantDelegate), /* MultipeerConnectivity.IMCAdvertiserAssistantDelegate */
		@protocol (MCBrowserViewControllerDelegate), /* MultipeerConnectivity.IMCBrowserViewControllerDelegate */
		@protocol (MCNearbyServiceAdvertiserDelegate), /* MultipeerConnectivity.IMCNearbyServiceAdvertiserDelegate */
		@protocol (MCNearbyServiceBrowserDelegate), /* MultipeerConnectivity.IMCNearbyServiceBrowserDelegate */
		@protocol (MCSessionDelegate), /* MultipeerConnectivity.IMCSessionDelegate */
		@protocol (MDLAssetResolver), /* ModelIO.IMDLAssetResolver */
		@protocol (MDLComponent), /* ModelIO.IMDLComponent */
		@protocol (MDLJointAnimation), /* ModelIO.IMDLJointAnimation */
		@protocol (MDLLightProbeIrradianceDataSource), /* ModelIO.IMDLLightProbeIrradianceDataSource */
		@protocol (MDLMeshBuffer), /* ModelIO.IMDLMeshBuffer */
		@protocol (MDLMeshBufferAllocator), /* ModelIO.IMDLMeshBufferAllocator */
		@protocol (MDLMeshBufferZone), /* ModelIO.IMDLMeshBufferZone */
		@protocol (MDLNamed), /* ModelIO.IMDLNamed */
		@protocol (MDLObjectContainerComponent), /* ModelIO.IMDLObjectContainerComponent */
		@protocol (MDLTransformComponent), /* ModelIO.IMDLTransformComponent */
		@protocol (MDLTransformOp), /* ModelIO.IMDLTransformOp */
		@protocol (MXMetricManagerSubscriber), /* MetricKit.IMXMetricManagerSubscriber */
		@protocol (MPSCNNBatchNormalizationDataSource), /* MetalPerformanceShaders.IMPSCnnBatchNormalizationDataSource */
		@protocol (MPSCNNConvolutionDataSource), /* MetalPerformanceShaders.IMPSCnnConvolutionDataSource */
		@protocol (MPSCNNInstanceNormalizationDataSource), /* MetalPerformanceShaders.IMPSCnnInstanceNormalizationDataSource */
		@protocol (MPSDeviceProvider), /* MetalPerformanceShaders.IMPSDeviceProvider */
		@protocol (MPSHandle), /* MetalPerformanceShaders.IMPSHandle */
		@protocol (MPSHeapProvider), /* MetalPerformanceShaders.IMPSHeapProvider */
		@protocol (MPSImageAllocator), /* MetalPerformanceShaders.IMPSImageAllocator */
		@protocol (MPSImageSizeEncodingState), /* MetalPerformanceShaders.IMPSImageSizeEncodingState */
		@protocol (MPSImageTransformProvider), /* MetalPerformanceShaders.IMPSImageTransformProvider */
		@protocol (MPSNDArrayAllocator), /* MetalPerformanceShaders.IMPSNDArrayAllocator */
		@protocol (MPSNNLossCallback), /* MetalPerformanceShaders.IMPSNNLossCallback */
		@protocol (MPSNNPadding), /* MetalPerformanceShaders.IMPSNNPadding */
		@protocol (MPSNNTrainableNode), /* MetalPerformanceShaders.IMPSNNTrainableNode */
		@protocol (MTKViewDelegate), /* MetalKit.IMTKViewDelegate */
		@protocol (MTLAccelerationStructure), /* Metal.IMTLAccelerationStructure */
		@protocol (MTLAccelerationStructureCommandEncoder), /* Metal.IMTLAccelerationStructureCommandEncoder */
		@protocol (MTLArgumentEncoder), /* Metal.IMTLArgumentEncoder */
		@protocol (MTLBinaryArchive), /* Metal.IMTLBinaryArchive */
		@protocol (MTLBlitCommandEncoder), /* Metal.IMTLBlitCommandEncoder */
		@protocol (MTLBuffer), /* Metal.IMTLBuffer */
		@protocol (MTLCaptureScope), /* Metal.IMTLCaptureScope */
		@protocol (MTLCommandBuffer), /* Metal.IMTLCommandBuffer */
		@protocol (MTLCommandBufferEncoderInfo), /* Metal.IMTLCommandBufferEncoderInfo */
		@protocol (MTLCommandEncoder), /* Metal.IMTLCommandEncoder */
		@protocol (MTLCommandQueue), /* Metal.IMTLCommandQueue */
		@protocol (MTLComputeCommandEncoder), /* Metal.IMTLComputeCommandEncoder */
		@protocol (MTLComputePipelineState), /* Metal.IMTLComputePipelineState */
		@protocol (MTLCounter), /* Metal.IMTLCounter */
		@protocol (MTLCounterSampleBuffer), /* Metal.IMTLCounterSampleBuffer */
		@protocol (MTLCounterSet), /* Metal.IMTLCounterSet */
		@protocol (MTLDepthStencilState), /* Metal.IMTLDepthStencilState */
		@protocol (MTLDevice), /* Metal.IMTLDevice */
		@protocol (MTLDrawable), /* Metal.IMTLDrawable */
		@protocol (MTLDynamicLibrary), /* Metal.IMTLDynamicLibrary */
		@protocol (MTLEvent), /* Metal.IMTLEvent */
		@protocol (MTLFence), /* Metal.IMTLFence */
		@protocol (MTLFunction), /* Metal.IMTLFunction */
		@protocol (MTLFunctionHandle), /* Metal.IMTLFunctionHandle */
		@protocol (MTLFunctionLog), /* Metal.IMTLFunctionLog */
		@protocol (MTLFunctionLogDebugLocation), /* Metal.IMTLFunctionLogDebugLocation */
		@protocol (MTLFunctionStitchingAttribute), /* Metal.IMTLFunctionStitchingAttribute */
		@protocol (MTLFunctionStitchingNode), /* Metal.IMTLFunctionStitchingNode */
		@protocol (MTLHeap), /* Metal.IMTLHeap */
		@protocol (MTLIndirectCommandBuffer), /* Metal.IMTLIndirectCommandBuffer */
		@protocol (MTLIndirectComputeCommand), /* Metal.IMTLIndirectComputeCommand */
		@protocol (MTLIndirectRenderCommand), /* Metal.IMTLIndirectRenderCommand */
		@protocol (MTLIntersectionFunctionTable), /* Metal.IMTLIntersectionFunctionTable */
		@protocol (MTLLibrary), /* Metal.IMTLLibrary */
		@protocol (MTLLogContainer), /* Metal.IMTLLogContainer */
		@protocol (MTLParallelRenderCommandEncoder), /* Metal.IMTLParallelRenderCommandEncoder */
		@protocol (MTLRasterizationRateMap), /* Metal.IMTLRasterizationRateMap */
		@protocol (MTLRenderCommandEncoder), /* Metal.IMTLRenderCommandEncoder */
		@protocol (MTLRenderPipelineState), /* Metal.IMTLRenderPipelineState */
		@protocol (MTLResource), /* Metal.IMTLResource */
		@protocol (MTLResourceStateCommandEncoder), /* Metal.IMTLResourceStateCommandEncoder */
		@protocol (MTLSamplerState), /* Metal.IMTLSamplerState */
		@protocol (MTLSharedEvent), /* Metal.IMTLSharedEvent */
		@protocol (MTLTexture), /* Metal.IMTLTexture */
		@protocol (MTLVisibleFunctionTable), /* Metal.IMTLVisibleFunctionTable */
		@protocol (MFMailComposeViewControllerDelegate), /* MessageUI.IMFMailComposeViewControllerDelegate */
		@protocol (MFMessageComposeViewControllerDelegate), /* MessageUI.IMFMessageComposeViewControllerDelegate */
		@protocol (MPMediaPickerControllerDelegate), /* MediaPlayer.IMPMediaPickerControllerDelegate */
		@protocol (MPMediaPlayback), /* MediaPlayer.IMPMediaPlayback */
		@protocol (MPNowPlayingSessionDelegate), /* MediaPlayer.IMPNowPlayingSessionDelegate */
		@protocol (MPPlayableContentDataSource), /* MediaPlayer.IMPPlayableContentDataSource */
		@protocol (MPPlayableContentDelegate), /* MediaPlayer.IMPPlayableContentDelegate */
		@protocol (MPSystemMusicPlayerController), /* MediaPlayer.IMPSystemMusicPlayerController */
		@protocol (MKAnnotation), /* MapKit.IMKAnnotation */
		@protocol (MKGeoJSONObject), /* MapKit.IMKGeoJsonObject */
		@protocol (MKLocalSearchCompleterDelegate), /* MapKit.IMKLocalSearchCompleterDelegate */
		@protocol (MKLookAroundViewControllerDelegate), /* MapKit.IMKLookAroundViewControllerDelegate */
		@protocol (MKMapViewDelegate), /* MapKit.IMKMapViewDelegate */
		@protocol (MKOverlay), /* MapKit.IMKOverlay */
		@protocol (MKReverseGeocoderDelegate), /* MapKit.IMKReverseGeocoderDelegate */
		@protocol (JSExport), /* JavaScriptCore.IJSExport */
		@protocol (INActivateCarSignalIntentHandling), /* Intents.IINActivateCarSignalIntentHandling */
		@protocol (INAddMediaIntentHandling), /* Intents.IINAddMediaIntentHandling */
		@protocol (INAddTasksIntentHandling), /* Intents.IINAddTasksIntentHandling */
		@protocol (INAnswerCallIntentHandling), /* Intents.IINAnswerCallIntentHandling */
		@protocol (INAppendToNoteIntentHandling), /* Intents.IINAppendToNoteIntentHandling */
		@protocol (INBookRestaurantReservationIntentHandling), /* Intents.IINBookRestaurantReservationIntentHandling */
		@protocol (INCallsDomainHandling), /* Intents.IINCallsDomainHandling */
		@protocol (INCancelRideIntentHandling), /* Intents.IINCancelRideIntentHandling */
		@protocol (INCancelWorkoutIntentHandling), /* Intents.IINCancelWorkoutIntentHandling */
		@protocol (INCarCommandsDomainHandling), /* Intents.IINCarCommandsDomainHandling */
		@protocol (INCarPlayDomainHandling), /* Intents.IINCarPlayDomainHandling */
		@protocol (INCreateNoteIntentHandling), /* Intents.IINCreateNoteIntentHandling */
		@protocol (INCreateTaskListIntentHandling), /* Intents.IINCreateTaskListIntentHandling */
		@protocol (INDeleteTasksIntentHandling), /* Intents.IINDeleteTasksIntentHandling */
		@protocol (INEndWorkoutIntentHandling), /* Intents.IINEndWorkoutIntentHandling */
		@protocol (INGetAvailableRestaurantReservationBookingDefaultsIntentHandling), /* Intents.IINGetAvailableRestaurantReservationBookingDefaultsIntentHandling */
		@protocol (INGetAvailableRestaurantReservationBookingsIntentHandling), /* Intents.IINGetAvailableRestaurantReservationBookingsIntentHandling */
		@protocol (INGetCarLockStatusIntentHandling), /* Intents.IINGetCarLockStatusIntentHandling */
		@protocol (INGetCarPowerLevelStatusIntentHandling), /* Intents.IINGetCarPowerLevelStatusIntentHandling */
		@protocol (INGetCarPowerLevelStatusIntentResponseObserver), /* Intents.IINGetCarPowerLevelStatusIntentResponseObserver */
		@protocol (INGetRestaurantGuestIntentHandling), /* Intents.IINGetRestaurantGuestIntentHandling */
		@protocol (INGetRideStatusIntentHandling), /* Intents.IINGetRideStatusIntentHandling */
		@protocol (INGetRideStatusIntentResponseObserver), /* Intents.IINGetRideStatusIntentResponseObserver */
		@protocol (INGetUserCurrentRestaurantReservationBookingsIntentHandling), /* Intents.IINGetUserCurrentRestaurantReservationBookingsIntentHandling */
		@protocol (INGetVisualCodeIntentHandling), /* Intents.IINGetVisualCodeIntentHandling */
		@protocol (INHangUpCallIntentHandling), /* Intents.IINHangUpCallIntentHandling */
		@protocol (INIntentHandlerProviding), /* Intents.IINIntentHandlerProviding */
		@protocol (INListCarsIntentHandling), /* Intents.IINListCarsIntentHandling */
		@protocol (INListRideOptionsIntentHandling), /* Intents.IINListRideOptionsIntentHandling */
		@protocol (INMessagesDomainHandling), /* Intents.IINMessagesDomainHandling */
		@protocol (INNotebookDomainHandling), /* Intents.IINNotebookDomainHandling */
		@protocol (INPauseWorkoutIntentHandling), /* Intents.IINPauseWorkoutIntentHandling */
		@protocol (INPayBillIntentHandling), /* Intents.IINPayBillIntentHandling */
		@protocol (INPaymentsDomainHandling), /* Intents.IINPaymentsDomainHandling */
		@protocol (INPhotosDomainHandling), /* Intents.IINPhotosDomainHandling */
		@protocol (INPlayMediaIntentHandling), /* Intents.IINPlayMediaIntentHandling */
		@protocol (INRadioDomainHandling), /* Intents.IINRadioDomainHandling */
		@protocol (INRequestPaymentIntentHandling), /* Intents.IINRequestPaymentIntentHandling */
		@protocol (INRequestRideIntentHandling), /* Intents.IINRequestRideIntentHandling */
		@protocol (INResumeWorkoutIntentHandling), /* Intents.IINResumeWorkoutIntentHandling */
		@protocol (INRidesharingDomainHandling), /* Intents.IINRidesharingDomainHandling */
		@protocol (INSaveProfileInCarIntentHandling), /* Intents.IINSaveProfileInCarIntentHandling */
		@protocol (INSearchCallHistoryIntentHandling), /* Intents.IINSearchCallHistoryIntentHandling */
		@protocol (INSearchForAccountsIntentHandling), /* Intents.IINSearchForAccountsIntentHandling */
		@protocol (INSearchForBillsIntentHandling), /* Intents.IINSearchForBillsIntentHandling */
		@protocol (INSearchForMediaIntentHandling), /* Intents.IINSearchForMediaIntentHandling */
		@protocol (INSearchForMessagesIntentHandling), /* Intents.IINSearchForMessagesIntentHandling */
		@protocol (INSearchForNotebookItemsIntentHandling), /* Intents.IINSearchForNotebookItemsIntentHandling */
		@protocol (INSearchForPhotosIntentHandling), /* Intents.IINSearchForPhotosIntentHandling */
		@protocol (INSendMessageIntentHandling), /* Intents.IINSendMessageIntentHandling */
		@protocol (INSendPaymentIntentHandling), /* Intents.IINSendPaymentIntentHandling */
		@protocol (INSendRideFeedbackIntentHandling), /* Intents.IINSendRideFeedbackIntentHandling */
		@protocol (INSetAudioSourceInCarIntentHandling), /* Intents.IINSetAudioSourceInCarIntentHandling */
		@protocol (INSetCarLockStatusIntentHandling), /* Intents.IINSetCarLockStatusIntentHandling */
		@protocol (INSetClimateSettingsInCarIntentHandling), /* Intents.IINSetClimateSettingsInCarIntentHandling */
		@protocol (INSetDefrosterSettingsInCarIntentHandling), /* Intents.IINSetDefrosterSettingsInCarIntentHandling */
		@protocol (INSetMessageAttributeIntentHandling), /* Intents.IINSetMessageAttributeIntentHandling */
		@protocol (INSetProfileInCarIntentHandling), /* Intents.IINSetProfileInCarIntentHandling */
		@protocol (INSetRadioStationIntentHandling), /* Intents.IINSetRadioStationIntentHandling */
		@protocol (INSetSeatSettingsInCarIntentHandling), /* Intents.IINSetSeatSettingsInCarIntentHandling */
		@protocol (INSetTaskAttributeIntentHandling), /* Intents.IINSetTaskAttributeIntentHandling */
		@protocol (INShareFocusStatusIntentHandling), /* Intents.IINShareFocusStatusIntentHandling */
		@protocol (INSnoozeTasksIntentHandling), /* Intents.IINSnoozeTasksIntentHandling */
		@protocol (INSpeakable), /* Intents.IINSpeakable */
		@protocol (INStartAudioCallIntentHandling), /* Intents.IINStartAudioCallIntentHandling */
		@protocol (INStartCallIntentHandling), /* Intents.IINStartCallIntentHandling */
		@protocol (INStartPhotoPlaybackIntentHandling), /* Intents.IINStartPhotoPlaybackIntentHandling */
		@protocol (INStartVideoCallIntentHandling), /* Intents.IINStartVideoCallIntentHandling */
		@protocol (INStartWorkoutIntentHandling), /* Intents.IINStartWorkoutIntentHandling */
		@protocol (INTransferMoneyIntentHandling), /* Intents.IINTransferMoneyIntentHandling */
		@protocol (INUpdateMediaAffinityIntentHandling), /* Intents.IINUpdateMediaAffinityIntentHandling */
		@protocol (INVisualCodeDomainHandling), /* Intents.IINVisualCodeDomainHandling */
		@protocol (INWorkoutsDomainHandling), /* Intents.IINWorkoutsDomainHandling */
		@protocol (HMAccessoryBrowserDelegate), /* HomeKit.IHMAccessoryBrowserDelegate */
		@protocol (HMAccessoryDelegate), /* HomeKit.IHMAccessoryDelegate */
		@protocol (HMCameraSnapshotControlDelegate), /* HomeKit.IHMCameraSnapshotControlDelegate */
		@protocol (HMCameraStreamControlDelegate), /* HomeKit.IHMCameraStreamControlDelegate */
		@protocol (HMHomeDelegate), /* HomeKit.IHMHomeDelegate */
		@protocol (HMHomeManagerDelegate), /* HomeKit.IHMHomeManagerDelegate */
		@protocol (HMNetworkConfigurationProfileDelegate), /* HomeKit.IHMNetworkConfigurationProfileDelegate */
		@protocol (GKAgentDelegate), /* GameplayKit.IGKAgentDelegate */
		@protocol (GKGameModel), /* GameplayKit.IGKGameModel */
		@protocol (GKGameModelPlayer), /* GameplayKit.IGKGameModelPlayer */
		@protocol (GKGameModelUpdate), /* GameplayKit.IGKGameModelUpdate */
		@protocol (GKRandom), /* GameplayKit.IGKRandom */
		@protocol (GKSceneRootNodeType), /* GameplayKit.IGKSceneRootNodeType */
		@protocol (GKStrategist), /* GameplayKit.IGKStrategist */
		@protocol (GKAchievementViewControllerDelegate), /* GameKit.IGKAchievementViewControllerDelegate */
		@protocol (GKChallengeEventHandlerDelegate), /* GameKit.IGKChallengeEventHandlerDelegate */
		@protocol (GKChallengeListener), /* GameKit.IGKChallengeListener */
		@protocol (GKFriendRequestComposeViewControllerDelegate), /* GameKit.IGKFriendRequestComposeViewControllerDelegate */
		@protocol (GKGameCenterControllerDelegate), /* GameKit.IGKGameCenterControllerDelegate */
		@protocol (GKGameSessionEventListener), /* GameKit.IGKGameSessionEventListener */
		@protocol (GKInviteEventListener), /* GameKit.IGKInviteEventListener */
		@protocol (GKLeaderboardViewControllerDelegate), /* GameKit.IGKLeaderboardViewControllerDelegate */
		@protocol (GKLocalPlayerListener), /* GameKit.IGKLocalPlayerListener */
		@protocol (GKMatchDelegate), /* GameKit.IGKMatchDelegate */
		@protocol (GKMatchmakerViewControllerDelegate), /* GameKit.IGKMatchmakerViewControllerDelegate */
		@protocol (GKSavedGameListener), /* GameKit.IGKSavedGameListener */
		@protocol (GKSessionDelegate), /* GameKit.IGKSessionDelegate */
		@protocol (GKTurnBasedEventHandlerDelegate), /* GameKit.IGKTurnBasedEventHandlerDelegate */
		@protocol (GKTurnBasedEventListener), /* GameKit.IGKTurnBasedEventListener */
		@protocol (GKTurnBasedMatchmakerViewControllerDelegate), /* GameKit.IGKTurnBasedMatchmakerViewControllerDelegate */
		@protocol (GKVoiceChatClient), /* GameKit.IGKVoiceChatClient */
		@protocol (GCAxisElement), /* GameController.IGCAxisElement */
		@protocol (GCAxisInput), /* GameController.IGCAxisInput */
		@protocol (GCButtonElement), /* GameController.IGCButtonElement */
		@protocol (GCDevice), /* GameController.IGCDevice */
		@protocol (GCDevicePhysicalInput), /* GameController.IGCDevicePhysicalInput */
		@protocol (GCDevicePhysicalInputState), /* GameController.IGCDevicePhysicalInputState */
		@protocol (GCDevicePhysicalInputStateDiff), /* GameController.IGCDevicePhysicalInputStateDiff */
		@protocol (GCDirectionPadElement), /* GameController.IGCDirectionPadElement */
		@protocol (GCLinearInput), /* GameController.IGCLinearInput */
		@protocol (GCPhysicalInputElement), /* GameController.IGCPhysicalInputElement */
		@protocol (GCPressedStateInput), /* GameController.IGCPressedStateInput */
		@protocol (GCRelativeInput), /* GameController.IGCRelativeInput */
		@protocol (GCSwitchElement), /* GameController.IGCSwitchElement */
		@protocol (GCSwitchPositionInput), /* GameController.IGCSwitchPositionInput */
		@protocol (GCTouchedStateInput), /* GameController.IGCTouchedStateInput */
		@protocol (GLKNamedEffect), /* GLKit.IGLKNamedEffect */
		@protocol (GLKViewControllerDelegate), /* GLKit.IGLKViewControllerDelegate */
		@protocol (GLKViewDelegate), /* GLKit.IGLKViewDelegate */
		@protocol (WKDownloadDelegate), /* WebKit.IWKDownloadDelegate */
		@protocol (WKHTTPCookieStoreObserver), /* WebKit.IWKHttpCookieStoreObserver */
		@protocol (WKNavigationDelegate), /* WebKit.IWKNavigationDelegate */
		@protocol (WKPreviewActionItem), /* WebKit.IWKPreviewActionItem */
		@protocol (WKScriptMessageHandler), /* WebKit.IWKScriptMessageHandler */
		@protocol (WKScriptMessageHandlerWithReply), /* WebKit.IWKScriptMessageHandlerWithReply */
		@protocol (WKUIDelegate), /* WebKit.IWKUIDelegate */
		@protocol (WKURLSchemeHandler), /* WebKit.IWKUrlSchemeHandler */
		@protocol (WKURLSchemeTask), /* WebKit.IWKUrlSchemeTask */
		@protocol (NSCacheDelegate), /* Foundation.INSCacheDelegate */
		@protocol (NSCoding), /* Foundation.INSCoding */
		@protocol (NSCopying), /* Foundation.INSCopying */
		@protocol (NSDiscardableContent), /* Foundation.INSDiscardableContent */
		@protocol (NSExtensionRequestHandling), /* Foundation.INSExtensionRequestHandling */
		@protocol (NSFileManagerDelegate), /* Foundation.INSFileManagerDelegate */
		@protocol (NSFilePresenter), /* Foundation.INSFilePresenter */
		@protocol (NSItemProviderReading), /* Foundation.INSItemProviderReading */
		@protocol (NSItemProviderWriting), /* Foundation.INSItemProviderWriting */
		@protocol (NSKeyedArchiverDelegate), /* Foundation.INSKeyedArchiverDelegate */
		@protocol (NSKeyedUnarchiverDelegate), /* Foundation.INSKeyedUnarchiverDelegate */
		@protocol (NSLocking), /* Foundation.INSLocking */
		@protocol (NSMachPortDelegate), /* Foundation.INSMachPortDelegate */
		@protocol (NSMetadataQueryDelegate), /* Foundation.INSMetadataQueryDelegate */
		@protocol (NSMutableCopying), /* Foundation.INSMutableCopying */
		@protocol (NSNetServiceBrowserDelegate), /* Foundation.INSNetServiceBrowserDelegate */
		@protocol (NSNetServiceDelegate), /* Foundation.INSNetServiceDelegate */
		@protocol (NSObject), /* Foundation.INSObjectProtocol */
		@protocol (NSPortDelegate), /* Foundation.INSPortDelegate */
		@protocol (NSProgressReporting), /* Foundation.INSProgressReporting */
		@protocol (NSSecureCoding), /* Foundation.INSSecureCoding */
		@protocol (NSStreamDelegate), /* Foundation.INSStreamDelegate */
		@protocol (NSURLAuthenticationChallengeSender), /* Foundation.INSURLAuthenticationChallengeSender */
		@protocol (NSURLConnectionDataDelegate), /* Foundation.INSUrlConnectionDataDelegate */
		@protocol (NSURLConnectionDelegate), /* Foundation.INSUrlConnectionDelegate */
		@protocol (NSURLConnectionDownloadDelegate), /* Foundation.INSUrlConnectionDownloadDelegate */
		@protocol (NSURLProtocolClient), /* Foundation.INSUrlProtocolClient */
		@protocol (NSURLSessionDataDelegate), /* Foundation.INSUrlSessionDataDelegate */
		@protocol (NSURLSessionDelegate), /* Foundation.INSUrlSessionDelegate */
		@protocol (NSURLSessionDownloadDelegate), /* Foundation.INSUrlSessionDownloadDelegate */
		@protocol (NSURLSessionStreamDelegate), /* Foundation.INSUrlSessionStreamDelegate */
		@protocol (NSURLSessionTaskDelegate), /* Foundation.INSUrlSessionTaskDelegate */
		@protocol (NSURLSessionWebSocketDelegate), /* Foundation.INSUrlSessionWebSocketDelegate */
		@protocol (NSUserActivityDelegate), /* Foundation.INSUserActivityDelegate */
		@protocol (NSXPCListenerDelegate), /* Foundation.INSXpcListenerDelegate */
		@protocol (NSFileProviderChangeObserver), /* FileProvider.INSFileProviderChangeObserver */
		@protocol (NSFileProviderCustomAction), /* FileProvider.INSFileProviderCustomAction */
		@protocol (NSFileProviderDomainState), /* FileProvider.INSFileProviderDomainState */
		@protocol (NSFileProviderEnumerating), /* FileProvider.INSFileProviderEnumerating */
		@protocol (NSFileProviderEnumerationObserver), /* FileProvider.INSFileProviderEnumerationObserver */
		@protocol (NSFileProviderEnumerator), /* FileProvider.INSFileProviderEnumerator */
		@protocol (NSFileProviderIncrementalContentFetching), /* FileProvider.INSFileProviderIncrementalContentFetching */
		@protocol (NSFileProviderItem), /* FileProvider.INSFileProviderItem */
		@protocol (NSFileProviderPendingSetEnumerator), /* FileProvider.INSFileProviderPendingSetEnumerator */
		@protocol (NSFileProviderReplicatedExtension), /* FileProvider.INSFileProviderReplicatedExtension */
		@protocol (NSFileProviderServiceSource), /* FileProvider.INSFileProviderServiceSource */
		@protocol (NSFileProviderServicing), /* FileProvider.INSFileProviderServicing */
		@protocol (NSFileProviderTestingChildrenEnumeration), /* FileProvider.INSFileProviderTestingChildrenEnumeration */
		@protocol (NSFileProviderTestingCollisionResolution), /* FileProvider.INSFileProviderTestingCollisionResolution */
		@protocol (NSFileProviderTestingContentFetch), /* FileProvider.INSFileProviderTestingContentFetch */
		@protocol (NSFileProviderTestingCreation), /* FileProvider.INSFileProviderTestingCreation */
		@protocol (NSFileProviderTestingDeletion), /* FileProvider.INSFileProviderTestingDeletion */
		@protocol (NSFileProviderTestingIngestion), /* FileProvider.INSFileProviderTestingIngestion */
		@protocol (NSFileProviderTestingLookup), /* FileProvider.INSFileProviderTestingLookup */
		@protocol (NSFileProviderTestingModification), /* FileProvider.INSFileProviderTestingModification */
		@protocol (NSFileProviderTestingOperation), /* FileProvider.INSFileProviderTestingOperation */
		@protocol (NSFileProviderThumbnailing), /* FileProvider.INSFileProviderThumbnailing */
		@protocol (EKCalendarChooserDelegate), /* EventKitUI.IEKCalendarChooserDelegate */
		@protocol (EKEventEditViewDelegate), /* EventKitUI.IEKEventEditViewDelegate */
		@protocol (EKEventViewDelegate), /* EventKitUI.IEKEventViewDelegate */
		@protocol (CTSubscriberDelegate), /* CoreTelephony.ICTSubscriberDelegate */
		@protocol (CTTelephonyNetworkInfoDelegate), /* CoreTelephony.ICTTelephonyNetworkInfoDelegate */
		@protocol (CSSearchableIndexDelegate), /* CoreSpotlight.ICSSearchableIndexDelegate */
		@protocol (CMHeadphoneMotionManagerDelegate), /* CoreMotion.ICMHeadphoneMotionManagerDelegate */
		@protocol (MIDICIProfileResponderDelegate), /* CoreMidi.IMidiCIProfileResponderDelegate */
		@protocol (MLBatchProvider), /* CoreML.IMLBatchProvider */
		@protocol (MLCustomLayer), /* CoreML.IMLCustomLayer */
		@protocol (MLCustomModel), /* CoreML.IMLCustomModel */
		@protocol (MLFeatureProvider), /* CoreML.IMLFeatureProvider */
		@protocol (MLWritable), /* CoreML.IMLWritable */
		@protocol (CLLocationManagerDelegate), /* CoreLocation.ICLLocationManagerDelegate */
		@protocol (CLLocationPushServiceExtension), /* CoreLocation.ICLLocationPushServiceExtension */
		@protocol (CIAccordionFoldTransition), /* CoreImage.ICIAccordionFoldTransitionProtocol */
		@protocol (CIAffineClamp), /* CoreImage.ICIAffineClampProtocol */
		@protocol (CIAffineTile), /* CoreImage.ICIAffineTileProtocol */
		@protocol (CIAreaAverage), /* CoreImage.ICIAreaAverageProtocol */
		@protocol (CIAreaHistogram), /* CoreImage.ICIAreaHistogramProtocol */
		@protocol (CIAreaLogarithmicHistogram), /* CoreImage.ICIAreaLogarithmicHistogramProtocol */
		@protocol (CIAreaMaximumAlpha), /* CoreImage.ICIAreaMaximumAlphaProtocol */
		@protocol (CIAreaMaximum), /* CoreImage.ICIAreaMaximumProtocol */
		@protocol (CIAreaMinimumAlpha), /* CoreImage.ICIAreaMinimumAlphaProtocol */
		@protocol (CIAreaMinimum), /* CoreImage.ICIAreaMinimumProtocol */
		@protocol (CIAreaMinMax), /* CoreImage.ICIAreaMinMaxProtocol */
		@protocol (CIAreaMinMaxRed), /* CoreImage.ICIAreaMinMaxRedProtocol */
		@protocol (CIAreaReductionFilter), /* CoreImage.ICIAreaReductionFilterProtocol */
		@protocol (CIAttributedTextImageGenerator), /* CoreImage.ICIAttributedTextImageGeneratorProtocol */
		@protocol (CIAztecCodeGenerator), /* CoreImage.ICIAztecCodeGeneratorProtocol */
		@protocol (CIBarcodeGenerator), /* CoreImage.ICIBarcodeGeneratorProtocol */
		@protocol (CIBarsSwipeTransition), /* CoreImage.ICIBarsSwipeTransitionProtocol */
		@protocol (CIBicubicScaleTransform), /* CoreImage.ICIBicubicScaleTransformProtocol */
		@protocol (CIBlendWithMask), /* CoreImage.ICIBlendWithMaskProtocol */
		@protocol (CIBloom), /* CoreImage.ICIBloomProtocol */
		@protocol (CIBokehBlur), /* CoreImage.ICIBokehBlurProtocol */
		@protocol (CIBoxBlur), /* CoreImage.ICIBoxBlurProtocol */
		@protocol (CIBumpDistortionLinear), /* CoreImage.ICIBumpDistortionLinearProtocol */
		@protocol (CIBumpDistortion), /* CoreImage.ICIBumpDistortionProtocol */
		@protocol (CICheckerboardGenerator), /* CoreImage.ICICheckerboardGeneratorProtocol */
		@protocol (CICircleSplashDistortion), /* CoreImage.ICICircleSplashDistortionProtocol */
		@protocol (CICircularScreen), /* CoreImage.ICICircularScreenProtocol */
		@protocol (CICircularWrap), /* CoreImage.ICICircularWrapProtocol */
		@protocol (CICMYKHalftone), /* CoreImage.ICICmykHalftoneProtocol */
		@protocol (CICode128BarcodeGenerator), /* CoreImage.ICICode128BarcodeGeneratorProtocol */
		@protocol (CIColorAbsoluteDifference), /* CoreImage.ICIColorAbsoluteDifferenceProtocol */
		@protocol (CIColorClamp), /* CoreImage.ICIColorClampProtocol */
		@protocol (CIColorControls), /* CoreImage.ICIColorControlsProtocol */
		@protocol (CIColorCrossPolynomial), /* CoreImage.ICIColorCrossPolynomialProtocol */
		@protocol (CIColorCube), /* CoreImage.ICIColorCubeProtocol */
		@protocol (CIColorCubesMixedWithMask), /* CoreImage.ICIColorCubesMixedWithMaskProtocol */
		@protocol (CIColorCubeWithColorSpace), /* CoreImage.ICIColorCubeWithColorSpaceProtocol */
		@protocol (CIColorCurves), /* CoreImage.ICIColorCurvesProtocol */
		@protocol (CIColorInvert), /* CoreImage.ICIColorInvertProtocol */
		@protocol (CIColorMap), /* CoreImage.ICIColorMapProtocol */
		@protocol (CIColorMatrix), /* CoreImage.ICIColorMatrixProtocol */
		@protocol (CIColorMonochrome), /* CoreImage.ICIColorMonochromeProtocol */
		@protocol (CIColorPolynomial), /* CoreImage.ICIColorPolynomialProtocol */
		@protocol (CIColorPosterize), /* CoreImage.ICIColorPosterizeProtocol */
		@protocol (CIColorThresholdOtsu), /* CoreImage.ICIColorThresholdOtsuProtocol */
		@protocol (CIColorThreshold), /* CoreImage.ICIColorThresholdProtocol */
		@protocol (CIColumnAverage), /* CoreImage.ICIColumnAverageProtocol */
		@protocol (CIComicEffect), /* CoreImage.ICIComicEffectProtocol */
		@protocol (CICompositeOperation), /* CoreImage.ICICompositeOperationProtocol */
		@protocol (CIConvertLab), /* CoreImage.ICIConvertLabProtocol */
		@protocol (CIConvolution), /* CoreImage.ICIConvolutionProtocol */
		@protocol (CICopyMachineTransition), /* CoreImage.ICICopyMachineTransitionProtocol */
		@protocol (CICoreMLModel), /* CoreImage.ICICoreMLModelProtocol */
		@protocol (CICrystallize), /* CoreImage.ICICrystallizeProtocol */
		@protocol (CIDepthOfField), /* CoreImage.ICIDepthOfFieldProtocol */
		@protocol (CIDepthToDisparity), /* CoreImage.ICIDepthToDisparityProtocol */
		@protocol (CIDiscBlur), /* CoreImage.ICIDiscBlurProtocol */
		@protocol (CIDisintegrateWithMaskTransition), /* CoreImage.ICIDisintegrateWithMaskTransitionProtocol */
		@protocol (CIDisparityToDepth), /* CoreImage.ICIDisparityToDepthProtocol */
		@protocol (CIDisplacementDistortion), /* CoreImage.ICIDisplacementDistortionProtocol */
		@protocol (CIDissolveTransition), /* CoreImage.ICIDissolveTransitionProtocol */
		@protocol (CIDither), /* CoreImage.ICIDitherProtocol */
		@protocol (CIDocumentEnhancer), /* CoreImage.ICIDocumentEnhancerProtocol */
		@protocol (CIDotScreen), /* CoreImage.ICIDotScreenProtocol */
		@protocol (CIDroste), /* CoreImage.ICIDrosteProtocol */
		@protocol (CIEdgePreserveUpsample), /* CoreImage.ICIEdgePreserveUpsampleProtocol */
		@protocol (CIEdges), /* CoreImage.ICIEdgesProtocol */
		@protocol (CIEdgeWork), /* CoreImage.ICIEdgeWorkProtocol */
		@protocol (CIEightfoldReflectedTile), /* CoreImage.ICIEightfoldReflectedTileProtocol */
		@protocol (CIExposureAdjust), /* CoreImage.ICIExposureAdjustProtocol */
		@protocol (CIFalseColor), /* CoreImage.ICIFalseColorProtocol */
		@protocol (CIFilterConstructor), /* CoreImage.ICIFilterConstructor */
		@protocol (CIFilter), /* CoreImage.ICIFilterProtocol */
		@protocol (CIFlashTransition), /* CoreImage.ICIFlashTransitionProtocol */
		@protocol (CIFourCoordinateGeometryFilter), /* CoreImage.ICIFourCoordinateGeometryFilterProtocol */
		@protocol (CIFourfoldReflectedTile), /* CoreImage.ICIFourfoldReflectedTileProtocol */
		@protocol (CIFourfoldRotatedTile), /* CoreImage.ICIFourfoldRotatedTileProtocol */
		@protocol (CIFourfoldTranslatedTile), /* CoreImage.ICIFourfoldTranslatedTileProtocol */
		@protocol (CIGaborGradients), /* CoreImage.ICIGaborGradientsProtocol */
		@protocol (CIGammaAdjust), /* CoreImage.ICIGammaAdjustProtocol */
		@protocol (CIGaussianBlur), /* CoreImage.ICIGaussianBlurProtocol */
		@protocol (CIGaussianGradient), /* CoreImage.ICIGaussianGradientProtocol */
		@protocol (CIGlassDistortion), /* CoreImage.ICIGlassDistortionProtocol */
		@protocol (CIGlassLozenge), /* CoreImage.ICIGlassLozengeProtocol */
		@protocol (CIGlideReflectedTile), /* CoreImage.ICIGlideReflectedTileProtocol */
		@protocol (CIGloom), /* CoreImage.ICIGloomProtocol */
		@protocol (CIHatchedScreen), /* CoreImage.ICIHatchedScreenProtocol */
		@protocol (CIHeightFieldFromMask), /* CoreImage.ICIHeightFieldFromMaskProtocol */
		@protocol (CIHexagonalPixellate), /* CoreImage.ICIHexagonalPixellateProtocol */
		@protocol (CIHighlightShadowAdjust), /* CoreImage.ICIHighlightShadowAdjustProtocol */
		@protocol (CIHistogramDisplay), /* CoreImage.ICIHistogramDisplayProtocol */
		@protocol (CIHoleDistortion), /* CoreImage.ICIHoleDistortionProtocol */
		@protocol (CIHueAdjust), /* CoreImage.ICIHueAdjustProtocol */
		@protocol (CIHueSaturationValueGradient), /* CoreImage.ICIHueSaturationValueGradientProtocol */
		@protocol (CIImageProcessorInput), /* CoreImage.ICIImageProcessorInput */
		@protocol (CIImageProcessorOutput), /* CoreImage.ICIImageProcessorOutput */
		@protocol (CIKaleidoscope), /* CoreImage.ICIKaleidoscopeProtocol */
		@protocol (CIKeystoneCorrectionCombined), /* CoreImage.ICIKeystoneCorrectionCombinedProtocol */
		@protocol (CIKeystoneCorrectionHorizontal), /* CoreImage.ICIKeystoneCorrectionHorizontalProtocol */
		@protocol (CIKeystoneCorrectionVertical), /* CoreImage.ICIKeystoneCorrectionVerticalProtocol */
		@protocol (CIKMeans), /* CoreImage.ICIKMeansProtocol */
		@protocol (CILabDeltaE), /* CoreImage.ICILabDeltaEProtocol */
		@protocol (CILanczosScaleTransform), /* CoreImage.ICILanczosScaleTransformProtocol */
		@protocol (CILenticularHaloGenerator), /* CoreImage.ICILenticularHaloGeneratorProtocol */
		@protocol (CILightTunnel), /* CoreImage.ICILightTunnelProtocol */
		@protocol (CILinearGradient), /* CoreImage.ICILinearGradientProtocol */
		@protocol (CILinearToSRGBToneCurve), /* CoreImage.ICILinearToSrgbToneCurveProtocol */
		@protocol (CILineOverlay), /* CoreImage.ICILineOverlayProtocol */
		@protocol (CILineScreen), /* CoreImage.ICILineScreenProtocol */
		@protocol (CIMaskedVariableBlur), /* CoreImage.ICIMaskedVariableBlurProtocol */
		@protocol (CIMaskToAlpha), /* CoreImage.ICIMaskToAlphaProtocol */
		@protocol (CIMaximumComponent), /* CoreImage.ICIMaximumComponentProtocol */
		@protocol (CIMedian), /* CoreImage.ICIMedianProtocol */
		@protocol (CIMeshGenerator), /* CoreImage.ICIMeshGeneratorProtocol */
		@protocol (CIMinimumComponent), /* CoreImage.ICIMinimumComponentProtocol */
		@protocol (CIMix), /* CoreImage.ICIMixProtocol */
		@protocol (CIModTransition), /* CoreImage.ICIModTransitionProtocol */
		@protocol (CIMorphologyGradient), /* CoreImage.ICIMorphologyGradientProtocol */
		@protocol (CIMorphologyMaximum), /* CoreImage.ICIMorphologyMaximumProtocol */
		@protocol (CIMorphologyMinimum), /* CoreImage.ICIMorphologyMinimumProtocol */
		@protocol (CIMorphologyRectangleMaximum), /* CoreImage.ICIMorphologyRectangleMaximumProtocol */
		@protocol (CIMorphologyRectangleMinimum), /* CoreImage.ICIMorphologyRectangleMinimumProtocol */
		@protocol (CIMotionBlur), /* CoreImage.ICIMotionBlurProtocol */
		@protocol (CINinePartStretched), /* CoreImage.ICINinePartStretchedProtocol */
		@protocol (CINinePartTiled), /* CoreImage.ICINinePartTiledProtocol */
		@protocol (CINoiseReduction), /* CoreImage.ICINoiseReductionProtocol */
		@protocol (CIOpTile), /* CoreImage.ICIOpTileProtocol */
		@protocol (CIPageCurlTransition), /* CoreImage.ICIPageCurlTransitionProtocol */
		@protocol (CIPageCurlWithShadowTransition), /* CoreImage.ICIPageCurlWithShadowTransitionProtocol */
		@protocol (CIPaletteCentroid), /* CoreImage.ICIPaletteCentroidProtocol */
		@protocol (CIPalettize), /* CoreImage.ICIPalettizeProtocol */
		@protocol (CIParallelogramTile), /* CoreImage.ICIParallelogramTileProtocol */
		@protocol (CIPDF417BarcodeGenerator), /* CoreImage.ICIPdf417BarcodeGeneratorProtocol */
		@protocol (CIPersonSegmentation), /* CoreImage.ICIPersonSegmentationProtocol */
		@protocol (CIPerspectiveCorrection), /* CoreImage.ICIPerspectiveCorrectionProtocol */
		@protocol (CIPerspectiveRotate), /* CoreImage.ICIPerspectiveRotateProtocol */
		@protocol (CIPerspectiveTile), /* CoreImage.ICIPerspectiveTileProtocol */
		@protocol (CIPerspectiveTransform), /* CoreImage.ICIPerspectiveTransformProtocol */
		@protocol (CIPerspectiveTransformWithExtent), /* CoreImage.ICIPerspectiveTransformWithExtentProtocol */
		@protocol (CIPhotoEffect), /* CoreImage.ICIPhotoEffectProtocol */
		@protocol (CIPinchDistortion), /* CoreImage.ICIPinchDistortionProtocol */
		@protocol (CIPixellate), /* CoreImage.ICIPixellateProtocol */
		@protocol (CIPointillize), /* CoreImage.ICIPointillizeProtocol */
		@protocol (CIQRCodeGenerator), /* CoreImage.ICIQRCodeGeneratorProtocol */
		@protocol (CIRadialGradient), /* CoreImage.ICIRadialGradientProtocol */
		@protocol (CIRandomGenerator), /* CoreImage.ICIRandomGeneratorProtocol */
		@protocol (CIRippleTransition), /* CoreImage.ICIRippleTransitionProtocol */
		@protocol (CIRoundedRectangleGenerator), /* CoreImage.ICIRoundedRectangleGeneratorProtocol */
		@protocol (CIRowAverage), /* CoreImage.ICIRowAverageProtocol */
		@protocol (CISaliencyMap), /* CoreImage.ICISaliencyMapProtocol */
		@protocol (CISepiaTone), /* CoreImage.ICISepiaToneProtocol */
		@protocol (CIShadedMaterial), /* CoreImage.ICIShadedMaterialProtocol */
		@protocol (CISharpenLuminance), /* CoreImage.ICISharpenLuminanceProtocol */
		@protocol (CISixfoldReflectedTile), /* CoreImage.ICISixfoldReflectedTileProtocol */
		@protocol (CISixfoldRotatedTile), /* CoreImage.ICISixfoldRotatedTileProtocol */
		@protocol (CISmoothLinearGradient), /* CoreImage.ICISmoothLinearGradientProtocol */
		@protocol (CISpotColor), /* CoreImage.ICISpotColorProtocol */
		@protocol (CISpotLight), /* CoreImage.ICISpotLightProtocol */
		@protocol (CISRGBToneCurveToLinear), /* CoreImage.ICISrgbToneCurveToLinearProtocol */
		@protocol (CIStarShineGenerator), /* CoreImage.ICIStarShineGeneratorProtocol */
		@protocol (CIStraighten), /* CoreImage.ICIStraightenProtocol */
		@protocol (CIStretchCrop), /* CoreImage.ICIStretchCropProtocol */
		@protocol (CIStripesGenerator), /* CoreImage.ICIStripesGeneratorProtocol */
		@protocol (CISunbeamsGenerator), /* CoreImage.ICISunbeamsGeneratorProtocol */
		@protocol (CISwipeTransition), /* CoreImage.ICISwipeTransitionProtocol */
		@protocol (CITemperatureAndTint), /* CoreImage.ICITemperatureAndTintProtocol */
		@protocol (CITextImageGenerator), /* CoreImage.ICITextImageGeneratorProtocol */
		@protocol (CIThermal), /* CoreImage.ICIThermalProtocol */
		@protocol (CIToneCurve), /* CoreImage.ICIToneCurveProtocol */
		@protocol (CITorusLensDistortion), /* CoreImage.ICITorusLensDistortionProtocol */
		@protocol (CITransitionFilter), /* CoreImage.ICITransitionFilterProtocol */
		@protocol (CITriangleKaleidoscope), /* CoreImage.ICITriangleKaleidoscopeProtocol */
		@protocol (CITriangleTile), /* CoreImage.ICITriangleTileProtocol */
		@protocol (CITwelvefoldReflectedTile), /* CoreImage.ICITwelvefoldReflectedTileProtocol */
		@protocol (CITwirlDistortion), /* CoreImage.ICITwirlDistortionProtocol */
		@protocol (CIUnsharpMask), /* CoreImage.ICIUnsharpMaskProtocol */
		@protocol (CIVibrance), /* CoreImage.ICIVibranceProtocol */
		@protocol (CIVignetteEffect), /* CoreImage.ICIVignetteEffectProtocol */
		@protocol (CIVignette), /* CoreImage.ICIVignetteProtocol */
		@protocol (CIVortexDistortion), /* CoreImage.ICIVortexDistortionProtocol */
		@protocol (CIWhitePointAdjust), /* CoreImage.ICIWhitePointAdjustProtocol */
		@protocol (CIXRay), /* CoreImage.ICIXRayProtocol */
		@protocol (CIZoomBlur), /* CoreImage.ICIZoomBlurProtocol */
		@protocol (NSFetchedResultsControllerDelegate), /* CoreData.INSFetchedResultsControllerDelegate */
		@protocol (NSFetchedResultsSectionInfo), /* CoreData.INSFetchedResultsSectionInfo */
		@protocol (NSFetchRequestResult), /* CoreData.INSFetchRequestResult */
		@protocol (CBCentralManagerDelegate), /* CoreBluetooth.ICBCentralManagerDelegate */
		@protocol (CBPeripheralDelegate), /* CoreBluetooth.ICBPeripheralDelegate */
		@protocol (CBPeripheralManagerDelegate), /* CoreBluetooth.ICBPeripheralManagerDelegate */
		@protocol (CAAction), /* CoreAnimation.ICAAction */
		@protocol (CAAnimationDelegate), /* CoreAnimation.ICAAnimationDelegate */
		@protocol (CALayerDelegate), /* CoreAnimation.ICALayerDelegate */
		@protocol (CAMediaTiming), /* CoreAnimation.ICAMediaTiming */
		objc_getProtocol ("CAMetalDrawable"), /* CoreAnimation.ICAMetalDrawable */
		@protocol (CNChangeHistoryEventVisitor), /* Contacts.ICNChangeHistoryEventVisitor */
		@protocol (CNKeyDescriptor), /* Contacts.ICNKeyDescriptor */
		@protocol (CKRecordValue), /* CloudKit.ICKRecordValue */
		@protocol (CLSContextProvider), /* ClassKit.ICLSContextProvider */
		@protocol (CLSDataStoreDelegate), /* ClassKit.ICLSDataStoreDelegate */
		@protocol (CPApplicationDelegate), /* CarPlay.ICPApplicationDelegate */
		@protocol (CPBarButtonProviding), /* CarPlay.ICPBarButtonProviding */
		@protocol (CPInstrumentClusterControllerDelegate), /* CarPlay.ICPInstrumentClusterControllerDelegate */
		@protocol (CPInterfaceControllerDelegate), /* CarPlay.ICPInterfaceControllerDelegate */
		@protocol (CPListTemplateDelegate), /* CarPlay.ICPListTemplateDelegate */
		@protocol (CPListTemplateItem), /* CarPlay.ICPListTemplateItem */
		@protocol (CPMapTemplateDelegate), /* CarPlay.ICPMapTemplateDelegate */
		@protocol (CPNowPlayingTemplateObserver), /* CarPlay.ICPNowPlayingTemplateObserver */
		@protocol (CPPointOfInterestTemplateDelegate), /* CarPlay.ICPPointOfInterestTemplateDelegate */
		@protocol (CPSearchTemplateDelegate), /* CarPlay.ICPSearchTemplateDelegate */
		@protocol (CPSelectableListItem), /* CarPlay.ICPSelectableListItem */
		@protocol (CPSessionConfigurationDelegate), /* CarPlay.ICPSessionConfigurationDelegate */
		@protocol (CPTabBarTemplateDelegate), /* CarPlay.ICPTabBarTemplateDelegate */
		@protocol (CPTemplateApplicationDashboardSceneDelegate), /* CarPlay.ICPTemplateApplicationDashboardSceneDelegate */
		@protocol (CPTemplateApplicationInstrumentClusterSceneDelegate), /* CarPlay.ICPTemplateApplicationInstrumentClusterSceneDelegate */
		@protocol (CPTemplateApplicationSceneDelegate), /* CarPlay.ICPTemplateApplicationSceneDelegate */
		@protocol (CXCallDirectoryExtensionContextDelegate), /* CallKit.ICXCallDirectoryExtensionContextDelegate */
		@protocol (CXCallObserverDelegate), /* CallKit.ICXCallObserverDelegate */
		@protocol (CXProviderDelegate), /* CallKit.ICXProviderDelegate */
		@protocol (BADownloaderExtension), /* BackgroundAssets.IBADownloaderExtension */
		@protocol (BADownloadManagerDelegate), /* BackgroundAssets.IBADownloadManagerDelegate */
		@protocol (ASAccountAuthenticationModificationControllerDelegate), /* AuthenticationServices.IASAccountAuthenticationModificationControllerDelegate */
		@protocol (ASAccountAuthenticationModificationControllerPresentationContextProviding), /* AuthenticationServices.IASAccountAuthenticationModificationControllerPresentationContextProviding */
		@protocol (ASAuthorizationControllerDelegate), /* AuthenticationServices.IASAuthorizationControllerDelegate */
		@protocol (ASAuthorizationControllerPresentationContextProviding), /* AuthenticationServices.IASAuthorizationControllerPresentationContextProviding */
		@protocol (ASAuthorizationCredential), /* AuthenticationServices.IASAuthorizationCredential */
		@protocol (ASAuthorizationProvider), /* AuthenticationServices.IASAuthorizationProvider */
		@protocol (ASAuthorizationProviderExtensionAuthorizationRequestHandler), /* AuthenticationServices.IASAuthorizationProviderExtensionAuthorizationRequestHandler */
		@protocol (ASAuthorizationPublicKeyCredentialAssertion), /* AuthenticationServices.IASAuthorizationPublicKeyCredentialAssertion */
		@protocol (ASAuthorizationPublicKeyCredentialAssertionRequest), /* AuthenticationServices.IASAuthorizationPublicKeyCredentialAssertionRequest */
		@protocol (ASAuthorizationPublicKeyCredentialDescriptor), /* AuthenticationServices.IASAuthorizationPublicKeyCredentialDescriptor */
		@protocol (ASAuthorizationPublicKeyCredentialRegistration), /* AuthenticationServices.IASAuthorizationPublicKeyCredentialRegistration */
		@protocol (ASAuthorizationPublicKeyCredentialRegistrationRequest), /* AuthenticationServices.IASAuthorizationPublicKeyCredentialRegistrationRequest */
		@protocol (ASPublicKeyCredential), /* AuthenticationServices.IASPublicKeyCredential */
		@protocol (ASWebAuthenticationPresentationContextProviding), /* AuthenticationServices.IASWebAuthenticationPresentationContextProviding */
		@protocol (AUAudioUnitFactory), /* AudioUnit.IAUAudioUnitFactory */
		@protocol (NSCollectionLayoutContainer), /* UIKit.INSCollectionLayoutContainer */
		@protocol (NSCollectionLayoutEnvironment), /* UIKit.INSCollectionLayoutEnvironment */
		@protocol (NSCollectionLayoutVisibleItem), /* UIKit.INSCollectionLayoutVisibleItem */
		@protocol (NSLayoutManagerDelegate), /* UIKit.INSLayoutManagerDelegate */
		@protocol (NSTextAttachmentContainer), /* UIKit.INSTextAttachmentContainer */
		@protocol (NSTextAttachmentLayout), /* UIKit.INSTextAttachmentLayout */
		@protocol (NSTextContentManagerDelegate), /* UIKit.INSTextContentManagerDelegate */
		@protocol (NSTextContentStorageDelegate), /* UIKit.INSTextContentStorageDelegate */
		@protocol (NSTextElementProvider), /* UIKit.INSTextElementProvider */
		@protocol (NSTextLayoutManagerDelegate), /* UIKit.INSTextLayoutManagerDelegate */
		@protocol (NSTextLayoutOrientationProvider), /* UIKit.INSTextLayoutOrientationProvider */
		@protocol (NSTextLocation), /* UIKit.INSTextLocation */
		@protocol (NSTextSelectionDataSource), /* UIKit.INSTextSelectionDataSource */
		@protocol (NSTextStorageDelegate), /* UIKit.INSTextStorageDelegate */
		@protocol (NSTextStorageObserving), /* UIKit.INSTextStorageObserving */
		@protocol (NSTextViewportLayoutControllerDelegate), /* UIKit.INSTextViewportLayoutControllerDelegate */
		@protocol (UIAccelerometerDelegate), /* UIKit.IUIAccelerometerDelegate */
		@protocol (UIAccessibilityContainerDataTable), /* UIKit.IUIAccessibilityContainerDataTable */
		@protocol (UIAccessibilityContainerDataTableCell), /* UIKit.IUIAccessibilityContainerDataTableCell */
		@protocol (UIAccessibilityContentSizeCategoryImageAdjusting), /* UIKit.IUIAccessibilityContentSizeCategoryImageAdjusting */
		@protocol (UIAccessibilityIdentification), /* UIKit.IUIAccessibilityIdentification */
		@protocol (UIAccessibilityReadingContent), /* UIKit.IUIAccessibilityReadingContent */
		@protocol (UIActionSheetDelegate), /* UIKit.IUIActionSheetDelegate */
		@protocol (UIActivityItemsConfigurationProviding), /* UIKit.IUIActivityItemsConfigurationProviding */
		@protocol (UIActivityItemsConfigurationReading), /* UIKit.IUIActivityItemsConfigurationReading */
		@protocol (UIActivityItemSource), /* UIKit.IUIActivityItemSource */
		@protocol (UIAdaptivePresentationControllerDelegate), /* UIKit.IUIAdaptivePresentationControllerDelegate */
		@protocol (UIAlertViewDelegate), /* UIKit.IUIAlertViewDelegate */
		@protocol (UIAppearance), /* UIKit.IUIAppearance */
		@protocol (UIAppearanceContainer), /* UIKit.IUIAppearanceContainer */
		@protocol (UIApplicationDelegate), /* UIKit.IUIApplicationDelegate */
		@protocol (UIBarPositioning), /* UIKit.IUIBarPositioning */
		@protocol (UIBarPositioningDelegate), /* UIKit.IUIBarPositioningDelegate */
		@protocol (UICalendarSelectionMultiDateDelegate), /* UIKit.IUICalendarSelectionMultiDateDelegate */
		@protocol (UICalendarSelectionSingleDateDelegate), /* UIKit.IUICalendarSelectionSingleDateDelegate */
		@protocol (UICalendarViewDelegate), /* UIKit.IUICalendarViewDelegate */
		@protocol (UICloudSharingControllerDelegate), /* UIKit.IUICloudSharingControllerDelegate */
		@protocol (UICollectionViewDataSource), /* UIKit.IUICollectionViewDataSource */
		@protocol (UICollectionViewDataSourcePrefetching), /* UIKit.IUICollectionViewDataSourcePrefetching */
		@protocol (UICollectionViewDelegate), /* UIKit.IUICollectionViewDelegate */
		@protocol (UICollectionViewDelegateFlowLayout), /* UIKit.IUICollectionViewDelegateFlowLayout */
		@protocol (UICollectionViewDragDelegate), /* UIKit.IUICollectionViewDragDelegate */
		@protocol (UICollectionViewDropCoordinator), /* UIKit.IUICollectionViewDropCoordinator */
		@protocol (UICollectionViewDropDelegate), /* UIKit.IUICollectionViewDropDelegate */
		@protocol (UICollectionViewDropItem), /* UIKit.IUICollectionViewDropItem */
		@protocol (UICollectionViewDropPlaceholderContext), /* UIKit.IUICollectionViewDropPlaceholderContext */
		@protocol (UICollisionBehaviorDelegate), /* UIKit.IUICollisionBehaviorDelegate */
		@protocol (UIColorPickerViewControllerDelegate), /* UIKit.IUIColorPickerViewControllerDelegate */
		@protocol (UIConfigurationState), /* UIKit.IUIConfigurationState */
		@protocol (UIContentConfiguration), /* UIKit.IUIContentConfiguration */
		@protocol (UIContentContainer), /* UIKit.IUIContentContainer */
		@protocol (UIContentSizeCategoryAdjusting), /* UIKit.IUIContentSizeCategoryAdjusting */
		@protocol (UIContentView), /* UIKit.IUIContentView */
		@protocol (UIContextMenuInteractionAnimating), /* UIKit.IUIContextMenuInteractionAnimating */
		@protocol (UIContextMenuInteractionCommitAnimating), /* UIKit.IUIContextMenuInteractionCommitAnimating */
		@protocol (UIContextMenuInteractionDelegate), /* UIKit.IUIContextMenuInteractionDelegate */
		@protocol (UICoordinateSpace), /* UIKit.IUICoordinateSpace */
		@protocol (UIDataSourceModelAssociation), /* UIKit.IUIDataSourceModelAssociation */
		@protocol (UIDataSourceTranslating), /* UIKit.IUIDataSourceTranslating */
		@protocol (UIDocumentBrowserViewControllerDelegate), /* UIKit.IUIDocumentBrowserViewControllerDelegate */
		@protocol (UIDocumentInteractionControllerDelegate), /* UIKit.IUIDocumentInteractionControllerDelegate */
		@protocol (UIDocumentMenuDelegate), /* UIKit.IUIDocumentMenuDelegate */
		@protocol (UIDocumentPickerDelegate), /* UIKit.IUIDocumentPickerDelegate */
		@protocol (UIDragAnimating), /* UIKit.IUIDragAnimating */
		@protocol (UIDragDropSession), /* UIKit.IUIDragDropSession */
		@protocol (UIDragInteractionDelegate), /* UIKit.IUIDragInteractionDelegate */
		@protocol (UIDragSession), /* UIKit.IUIDragSession */
		@protocol (UIDropInteractionDelegate), /* UIKit.IUIDropInteractionDelegate */
		@protocol (UIDropSession), /* UIKit.IUIDropSession */
		@protocol (UIDynamicAnimatorDelegate), /* UIKit.IUIDynamicAnimatorDelegate */
		@protocol (UIDynamicItem), /* UIKit.IUIDynamicItem */
		@protocol (UIEditMenuInteractionAnimating), /* UIKit.IUIEditMenuInteractionAnimating */
		@protocol (UIEditMenuInteractionDelegate), /* UIKit.IUIEditMenuInteractionDelegate */
		@protocol (UIFindInteractionDelegate), /* UIKit.IUIFindInteractionDelegate */
		@protocol (UIFocusAnimationContext), /* UIKit.IUIFocusAnimationContext */
		@protocol (UIFocusDebuggerOutput), /* UIKit.IUIFocusDebuggerOutput */
		@protocol (UIFocusEnvironment), /* UIKit.IUIFocusEnvironment */
		@protocol (UIFocusItem), /* UIKit.IUIFocusItem */
		@protocol (UIFocusItemContainer), /* UIKit.IUIFocusItemContainer */
		@protocol (UIFocusItemScrollableContainer), /* UIKit.IUIFocusItemScrollableContainer */
		@protocol (UIFontPickerViewControllerDelegate), /* UIKit.IUIFontPickerViewControllerDelegate */
		@protocol (UIGestureRecognizerDelegate), /* UIKit.IUIGestureRecognizerDelegate */
		@protocol (UIGuidedAccessRestrictionDelegate), /* UIKit.IUIGuidedAccessRestrictionDelegate */
		@protocol (UIImagePickerControllerDelegate), /* UIKit.IUIImagePickerControllerDelegate */
		@protocol (UIIndirectScribbleInteractionDelegate), /* UIKit.IUIIndirectScribbleInteractionDelegate */
		@protocol (UIInputViewAudioFeedback), /* UIKit.IUIInputViewAudioFeedback */
		@protocol (UIInteraction), /* UIKit.IUIInteraction */
		@protocol (UIItemProviderPresentationSizeProviding), /* UIKit.IUIItemProviderPresentationSizeProviding */
		@protocol (UIKeyInput), /* UIKit.IUIKeyInput */
		@protocol (UILargeContentViewerInteractionDelegate), /* UIKit.IUILargeContentViewerInteractionDelegate */
		@protocol (UILargeContentViewerItem), /* UIKit.IUILargeContentViewerItem */
		@protocol (UILayoutGuideAspectFitting), /* UIKit.IUILayoutGuideAspectFitting */
		@protocol (UILayoutSupport), /* UIKit.IUILayoutSupport */
		@protocol (UIMenuBuilder), /* UIKit.IUIMenuBuilder */
		@protocol (UIMenuLeaf), /* UIKit.IUIMenuLeaf */
		@protocol (UINavigationBarDelegate), /* UIKit.IUINavigationBarDelegate */
		@protocol (UINavigationControllerDelegate), /* UIKit.IUINavigationControllerDelegate */
		@protocol (UINavigationItemRenameDelegate), /* UIKit.IUINavigationItemRenameDelegate */
		@protocol (UIObjectRestoration), /* UIKit.IUIObjectRestoration */
		@protocol (UIPageViewControllerDataSource), /* UIKit.IUIPageViewControllerDataSource */
		@protocol (UIPageViewControllerDelegate), /* UIKit.IUIPageViewControllerDelegate */
		@protocol (UIPasteConfigurationSupporting), /* UIKit.IUIPasteConfigurationSupporting */
		@protocol (UIPencilInteractionDelegate), /* UIKit.IUIPencilInteractionDelegate */
		@protocol (UIPickerViewAccessibilityDelegate), /* UIKit.IUIPickerViewAccessibilityDelegate */
		@protocol (UIPickerViewDataSource), /* UIKit.IUIPickerViewDataSource */
		@protocol (UIPickerViewDelegate), /* UIKit.IUIPickerViewDelegate */
		@protocol (UIPointerInteractionAnimating), /* UIKit.IUIPointerInteractionAnimating */
		@protocol (UIPointerInteractionDelegate), /* UIKit.IUIPointerInteractionDelegate */
		@protocol (UIPopoverBackgroundViewMethods), /* UIKit.IUIPopoverBackgroundViewMethods */
		@protocol (UIPopoverControllerDelegate), /* UIKit.IUIPopoverControllerDelegate */
		@protocol (UIPopoverPresentationControllerDelegate), /* UIKit.IUIPopoverPresentationControllerDelegate */
		@protocol (UIPopoverPresentationControllerSourceItem), /* UIKit.IUIPopoverPresentationControllerSourceItem */
		@protocol (UIPreviewActionItem), /* UIKit.IUIPreviewActionItem */
		@protocol (UIPreviewInteractionDelegate), /* UIKit.IUIPreviewInteractionDelegate */
		@protocol (UIPrinterPickerControllerDelegate), /* UIKit.IUIPrinterPickerControllerDelegate */
		@protocol (UIPrintInteractionControllerDelegate), /* UIKit.IUIPrintInteractionControllerDelegate */
		@protocol (UIResponderStandardEditActions), /* UIKit.IUIResponderStandardEditActions */
		@protocol (UISceneDelegate), /* UIKit.IUISceneDelegate */
		@protocol (UIScreenshotServiceDelegate), /* UIKit.IUIScreenshotServiceDelegate */
		@protocol (UIScribbleInteractionDelegate), /* UIKit.IUIScribbleInteractionDelegate */
		@protocol (UIScrollViewAccessibilityDelegate), /* UIKit.IUIScrollViewAccessibilityDelegate */
		@protocol (UIScrollViewDelegate), /* UIKit.IUIScrollViewDelegate */
		@protocol (UISearchBarDelegate), /* UIKit.IUISearchBarDelegate */
		@protocol (UISearchControllerDelegate), /* UIKit.IUISearchControllerDelegate */
		@protocol (UISearchDisplayDelegate), /* UIKit.IUISearchDisplayDelegate */
		@protocol (UISearchResultsUpdating), /* UIKit.IUISearchResultsUpdating */
		@protocol (UISearchSuggestion), /* UIKit.IUISearchSuggestion */
		@protocol (UISearchTextFieldDelegate), /* UIKit.IUISearchTextFieldDelegate */
		@protocol (UISearchTextFieldPasteItem), /* UIKit.IUISearchTextFieldPasteItem */
		@protocol (UISheetPresentationControllerDelegate), /* UIKit.IUISheetPresentationControllerDelegate */
		@protocol (UISheetPresentationControllerDetentResolutionContext), /* UIKit.IUISheetPresentationControllerDetentResolutionContext */
		@protocol (UISplitViewControllerDelegate), /* UIKit.IUISplitViewControllerDelegate */
		@protocol (UISpringLoadedInteractionBehavior), /* UIKit.IUISpringLoadedInteractionBehavior */
		@protocol (UISpringLoadedInteractionContext), /* UIKit.IUISpringLoadedInteractionContext */
		@protocol (UISpringLoadedInteractionEffect), /* UIKit.IUISpringLoadedInteractionEffect */
		@protocol (UISpringLoadedInteractionSupporting), /* UIKit.IUISpringLoadedInteractionSupporting */
		@protocol (UIStateRestoring), /* UIKit.IUIStateRestoring */
		@protocol (UITabBarControllerDelegate), /* UIKit.IUITabBarControllerDelegate */
		@protocol (UITabBarDelegate), /* UIKit.IUITabBarDelegate */
		@protocol (UITableViewDataSource), /* UIKit.IUITableViewDataSource */
		@protocol (UITableViewDataSourcePrefetching), /* UIKit.IUITableViewDataSourcePrefetching */
		@protocol (UITableViewDelegate), /* UIKit.IUITableViewDelegate */
		@protocol (UITableViewDragDelegate), /* UIKit.IUITableViewDragDelegate */
		@protocol (UITableViewDropCoordinator), /* UIKit.IUITableViewDropCoordinator */
		@protocol (UITableViewDropDelegate), /* UIKit.IUITableViewDropDelegate */
		@protocol (UITableViewDropItem), /* UIKit.IUITableViewDropItem */
		@protocol (UITableViewDropPlaceholderContext), /* UIKit.IUITableViewDropPlaceholderContext */
		@protocol (UITextDocumentProxy), /* UIKit.IUITextDocumentProxy */
		@protocol (UITextDragDelegate), /* UIKit.IUITextDragDelegate */
		@protocol (UITextDraggable), /* UIKit.IUITextDraggable */
		@protocol (UITextDragRequest), /* UIKit.IUITextDragRequest */
		@protocol (UITextDropDelegate), /* UIKit.IUITextDropDelegate */
		@protocol (UITextDroppable), /* UIKit.IUITextDroppable */
		@protocol (UITextDropRequest), /* UIKit.IUITextDropRequest */
		@protocol (UITextFieldDelegate), /* UIKit.IUITextFieldDelegate */
		@protocol (UITextFormattingCoordinatorDelegate), /* UIKit.IUITextFormattingCoordinatorDelegate */
		@protocol (UITextInput), /* UIKit.IUITextInput */
		@protocol (UITextInputDelegate), /* UIKit.IUITextInputDelegate */
		@protocol (UITextInputTokenizer), /* UIKit.IUITextInputTokenizer */
		@protocol (UITextInputTraits), /* UIKit.IUITextInputTraits */
		@protocol (UITextInteractionDelegate), /* UIKit.IUITextInteractionDelegate */
		@protocol (UITextPasteConfigurationSupporting), /* UIKit.IUITextPasteConfigurationSupporting */
		@protocol (UITextPasteDelegate), /* UIKit.IUITextPasteDelegate */
		@protocol (UITextPasteItem), /* UIKit.IUITextPasteItem */
		@protocol (UITextSearchAggregator), /* UIKit.IUITextSearchAggregator */
		@protocol (UITextSearching), /* UIKit.IUITextSearching */
		@protocol (UITextViewDelegate), /* UIKit.IUITextViewDelegate */
		@protocol (UITimingCurveProvider), /* UIKit.IUITimingCurveProvider */
		@protocol (UIToolbarDelegate), /* UIKit.IUIToolbarDelegate */
		@protocol (UIToolTipInteractionDelegate), /* UIKit.IUIToolTipInteractionDelegate */
		@protocol (UITraitEnvironment), /* UIKit.IUITraitEnvironment */
		@protocol (UIUserActivityRestoring), /* UIKit.IUIUserActivityRestoring */
		@protocol (UIVideoEditorControllerDelegate), /* UIKit.IUIVideoEditorControllerDelegate */
		@protocol (UIViewAnimating), /* UIKit.IUIViewAnimating */
		@protocol (UIViewControllerAnimatedTransitioning), /* UIKit.IUIViewControllerAnimatedTransitioning */
		@protocol (UIViewControllerContextTransitioning), /* UIKit.IUIViewControllerContextTransitioning */
		@protocol (UIViewControllerInteractiveTransitioning), /* UIKit.IUIViewControllerInteractiveTransitioning */
		@protocol (UIViewControllerPreviewing), /* UIKit.IUIViewControllerPreviewing */
		@protocol (UIViewControllerPreviewingDelegate), /* UIKit.IUIViewControllerPreviewingDelegate */
		@protocol (UIViewControllerRestoration), /* UIKit.IUIViewControllerRestoration */
		@protocol (UIViewControllerTransitionCoordinator), /* UIKit.IUIViewControllerTransitionCoordinator */
		@protocol (UIViewControllerTransitionCoordinatorContext), /* UIKit.IUIViewControllerTransitionCoordinatorContext */
		@protocol (UIViewControllerTransitioningDelegate), /* UIKit.IUIViewControllerTransitioningDelegate */
		@protocol (UIViewImplicitlyAnimating), /* UIKit.IUIViewImplicitlyAnimating */
		@protocol (UIWebViewDelegate), /* UIKit.IUIWebViewDelegate */
		@protocol (UIWindowSceneDelegate), /* UIKit.IUIWindowSceneDelegate */
		@protocol (ABNewPersonViewControllerDelegate), /* AddressBookUI.IABNewPersonViewControllerDelegate */
		@protocol (ABPeoplePickerNavigationControllerDelegate), /* AddressBookUI.IABPeoplePickerNavigationControllerDelegate */
		@protocol (ABPersonViewControllerDelegate), /* AddressBookUI.IABPersonViewControllerDelegate */
		@protocol (ABUnknownPersonViewControllerDelegate), /* AddressBookUI.IABUnknownPersonViewControllerDelegate */
		@protocol (AXBrailleMapRenderer), /* Accessibility.IAXBrailleMapRenderer */
		@protocol (AXChart), /* Accessibility.IAXChart */
		@protocol (AXCustomContentProvider), /* Accessibility.IAXCustomContentProvider */
		@protocol (AXDataAxisDescriptor), /* Accessibility.IAXDataAxisDescriptor */
		@protocol (AVCustomRoutingControllerDelegate), /* AVKit.IAVCustomRoutingControllerDelegate */
		@protocol (AVPictureInPictureControllerDelegate), /* AVKit.IAVPictureInPictureControllerDelegate */
		@protocol (AVPictureInPictureSampleBufferPlaybackDelegate), /* AVKit.IAVPictureInPictureSampleBufferPlaybackDelegate */
		@protocol (AVPlayerViewControllerDelegate), /* AVKit.IAVPlayerViewControllerDelegate */
		@protocol (AVRoutePickerViewDelegate), /* AVKit.IAVRoutePickerViewDelegate */
		@protocol (AVAssetDownloadDelegate), /* AVFoundation.IAVAssetDownloadDelegate */
		@protocol (AVAssetResourceLoaderDelegate), /* AVFoundation.IAVAssetResourceLoaderDelegate */
		@protocol (AVAssetWriterDelegate), /* AVFoundation.IAVAssetWriterDelegate */
		@protocol (AVAsynchronousKeyValueLoading), /* AVFoundation.IAVAsynchronousKeyValueLoading */
		@protocol (AVAudio3DMixing), /* AVFoundation.IAVAudio3DMixing */
		@protocol (AVAudioMixing), /* AVFoundation.IAVAudioMixing */
		@protocol (AVAudioPlayerDelegate), /* AVFoundation.IAVAudioPlayerDelegate */
		@protocol (AVAudioRecorderDelegate), /* AVFoundation.IAVAudioRecorderDelegate */
		@protocol (AVAudioSessionDelegate), /* AVFoundation.IAVAudioSessionDelegate */
		@protocol (AVAudioStereoMixing), /* AVFoundation.IAVAudioStereoMixing */
		@protocol (AVCaptureAudioDataOutputSampleBufferDelegate), /* AVFoundation.IAVCaptureAudioDataOutputSampleBufferDelegate */
		@protocol (AVCaptureDataOutputSynchronizerDelegate), /* AVFoundation.IAVCaptureDataOutputSynchronizerDelegate */
		@protocol (AVCaptureDepthDataOutputDelegate), /* AVFoundation.IAVCaptureDepthDataOutputDelegate */
		@protocol (AVCaptureFileOutputRecordingDelegate), /* AVFoundation.IAVCaptureFileOutputRecordingDelegate */
		@protocol (AVCaptureMetadataOutputObjectsDelegate), /* AVFoundation.IAVCaptureMetadataOutputObjectsDelegate */
		@protocol (AVCapturePhotoCaptureDelegate), /* AVFoundation.IAVCapturePhotoCaptureDelegate */
		@protocol (AVCapturePhotoFileDataRepresentationCustomizer), /* AVFoundation.IAVCapturePhotoFileDataRepresentationCustomizer */
		@protocol (AVCaptureVideoDataOutputSampleBufferDelegate), /* AVFoundation.IAVCaptureVideoDataOutputSampleBufferDelegate */
		@protocol (AVContentKeyRecipient), /* AVFoundation.IAVContentKeyRecipient */
		@protocol (AVContentKeySessionDelegate), /* AVFoundation.IAVContentKeySessionDelegate */
		@protocol (AVFragmentMinding), /* AVFoundation.IAVFragmentMinding */
		@protocol (AVPlaybackCoordinatorPlaybackControlDelegate), /* AVFoundation.IAVPlaybackCoordinatorPlaybackControlDelegate */
		@protocol (AVPlayerItemLegibleOutputPushDelegate), /* AVFoundation.IAVPlayerItemLegibleOutputPushDelegate */
		@protocol (AVPlayerItemMetadataCollectorPushDelegate), /* AVFoundation.IAVPlayerItemMetadataCollectorPushDelegate */
		@protocol (AVPlayerItemMetadataOutputPushDelegate), /* AVFoundation.IAVPlayerItemMetadataOutputPushDelegate */
		@protocol (AVPlayerItemOutputPullDelegate), /* AVFoundation.IAVPlayerItemOutputPullDelegate */
		@protocol (AVPlayerItemOutputPushDelegate), /* AVFoundation.IAVPlayerItemOutputPushDelegate */
		@protocol (AVPlayerPlaybackCoordinatorDelegate), /* AVFoundation.IAVPlayerPlaybackCoordinatorDelegate */
		@protocol (AVQueuedSampleBufferRendering), /* AVFoundation.IAVQueuedSampleBufferRendering */
		@protocol (AVSpeechSynthesizerDelegate), /* AVFoundation.IAVSpeechSynthesizerDelegate */
		@protocol (AVVideoCompositing), /* AVFoundation.IAVVideoCompositing */
		@protocol (AVVideoCompositionValidationHandling), /* AVFoundation.IAVVideoCompositionValidationHandling */
		@protocol (ARAnchorCopying), /* ARKit.IARAnchorCopying */
		@protocol (ARCoachingOverlayViewDelegate), /* ARKit.IARCoachingOverlayViewDelegate */
		@protocol (ARSCNViewDelegate), /* ARKit.IARSCNViewDelegate */
		@protocol (ARSessionDelegate), /* ARKit.IARSessionDelegate */
		@protocol (ARSessionObserver), /* ARKit.IARSessionObserver */
		@protocol (ARSessionProviding), /* ARKit.IARSessionProviding */
		@protocol (ARSKViewDelegate), /* ARKit.IARSKViewDelegate */
		@protocol (ARTrackable), /* ARKit.IARTrackable */
	};
	static struct MTRegistrationMap __xamarin_registration_map = {
		__xamarin_registration_assemblies,
		__xamarin_class_map,
		NULL,
		__xamarin_skipped_map,
		__xamarin_protocol_wrapper_map,
		{ __xamarin_protocol_tokens, __xamarin_protocols },
		116,
		4512,
		0,
		51,
		875,
		875
	};

void xamarin_create_classes () {
	__xamarin_class_map [0].handle = objc_getClass ("NSObject");
	__xamarin_class_map [1].handle = objc_getClass ("UIResponder");
	__xamarin_class_map [2].handle = objc_getClass ("UIViewController");
	__xamarin_class_map [3].handle = objc_getClass ("UINavigationController");
	__xamarin_class_map [4].handle = [Xamarin_Forms_Platform_iOS_NavigationRenderer class];
	__xamarin_class_map [5].handle = [HrApp_iOS_CustomNaviPageRenderer class];
	__xamarin_class_map [6].handle = [Xamarin_Forms_Platform_iOS_PageRenderer class];
	__xamarin_class_map [7].handle = [HrApp_iOS_CustomPageRenderer class];
	__xamarin_class_map [8].handle = objc_getClass ("UIView");
	__xamarin_class_map [9].handle = objc_getClass ("WKWebView");
	__xamarin_class_map [10].handle = [Xamarin_Forms_Platform_iOS_WkWebViewRenderer class];
	__xamarin_class_map [11].handle = [HrApp_iOS_CustomWebViewRenderer class];
	__xamarin_class_map [12].handle = objc_getClass ("UIApplicationDelegate");
	__xamarin_class_map [13].handle = [Xamarin_Forms_Platform_iOS_FormsApplicationDelegate class];
	__xamarin_class_map [14].handle = [AppDelegate class];
	__xamarin_class_map [15].handle = [MyViewController class];
	__xamarin_class_map [16].handle = objc_getClass ("VNDocumentCameraScan");
	__xamarin_class_map [17].handle = objc_getClass ("VNDocumentCameraViewController");
	__xamarin_class_map [18].handle = objc_getClass ("Xamarin_iOS__VisionKit_VNDocumentCameraViewControllerDelegate");
	__xamarin_class_map [19].handle = objc_getClass ("UTType");
	__xamarin_class_map [20].handle = objc_getClass ("WCSession");
	__xamarin_class_map [21].handle = objc_getClass ("WCSessionDelegate");
	__xamarin_class_map [22].handle = objc_getClass ("WCSessionFile");
	__xamarin_class_map [23].handle = objc_getClass ("WCSessionFileTransfer");
	__xamarin_class_map [24].handle = objc_getClass ("WCSessionUserInfoTransfer");
	__xamarin_class_map [25].handle = objc_getClass ("SFAcousticFeature");
	__xamarin_class_map [26].handle = objc_getClass ("SFSpeechRecognitionRequest");
	__xamarin_class_map [27].handle = objc_getClass ("SFSpeechAudioBufferRecognitionRequest");
	__xamarin_class_map [28].handle = objc_getClass ("SFSpeechRecognitionMetadata");
	__xamarin_class_map [29].handle = objc_getClass ("SFSpeechRecognitionResult");
	__xamarin_class_map [30].handle = objc_getClass ("SFSpeechRecognitionTask");
	__xamarin_class_map [31].handle = objc_getClass ("SFSpeechRecognitionTaskDelegate");
	__xamarin_class_map [32].handle = objc_getClass ("SFSpeechRecognizer");
	__xamarin_class_map [33].handle = objc_getClass ("SFSpeechRecognizerDelegate");
	__xamarin_class_map [34].handle = objc_getClass ("SFSpeechURLRecognitionRequest");
	__xamarin_class_map [35].handle = objc_getClass ("SFTranscription");
	__xamarin_class_map [36].handle = objc_getClass ("SFTranscriptionSegment");
	__xamarin_class_map [37].handle = objc_getClass ("SFVoiceAnalytics");
	__xamarin_class_map [38].handle = objc_getClass ("SNAudioStreamAnalyzer");
	__xamarin_class_map [39].handle = objc_getClass ("SNClassification");
	__xamarin_class_map [40].handle = objc_getClass ("SNClassificationResult");
	__xamarin_class_map [41].handle = objc_getClass ("SNClassifySoundRequest");
	__xamarin_class_map [42].handle = objc_getClass ("SWHighlight");
	__xamarin_class_map [43].handle = objc_getClass ("SWCollaborationHighlight");
	__xamarin_class_map [44].handle = objc_getClass ("Xamarin_iOS__SharedWithYou_SWCollaborationViewDelegate");
	__xamarin_class_map [45].handle = objc_getClass ("Xamarin_iOS__SharedWithYou_SWHighlightCenterDelegate");
	__xamarin_class_map [46].handle = objc_getClass ("SWHighlightChangeEvent");
	__xamarin_class_map [47].handle = objc_getClass ("SWHighlightMembershipEvent");
	__xamarin_class_map [48].handle = objc_getClass ("SWHighlightMentionEvent");
	__xamarin_class_map [49].handle = objc_getClass ("SWHighlightPersistenceEvent");
	__xamarin_class_map [50].handle = objc_getClass ("SWRemoveParticipantAlertController");
	__xamarin_class_map [51].handle = objc_getClass ("STScreenTimeConfiguration");
	__xamarin_class_map [52].handle = objc_getClass ("STScreenTimeConfigurationObserver");
	__xamarin_class_map [53].handle = objc_getClass ("STWebHistory");
	__xamarin_class_map [54].handle = objc_getClass ("STWebpageController");
	__xamarin_class_map [55].handle = objc_getClass ("SFAuthenticationSession");
	__xamarin_class_map [56].handle = objc_getClass ("SFContentBlockerState");
	__xamarin_class_map [57].handle = objc_getClass ("SFSafariViewController");
	__xamarin_class_map [58].handle = objc_getClass ("SFSafariViewControllerActivityButton");
	__xamarin_class_map [59].handle = objc_getClass ("SFSafariViewControllerConfiguration");
	__xamarin_class_map [60].handle = objc_getClass ("SFSafariViewControllerDelegate");
	__xamarin_class_map [61].handle = objc_getClass ("SFSafariViewControllerPrewarmingToken");
	__xamarin_class_map [62].handle = objc_getClass ("SSReadingList");
	__xamarin_class_map [63].handle = objc_getClass ("QLThumbnailGenerationRequest");
	__xamarin_class_map [64].handle = objc_getClass ("QLThumbnailRepresentation");
	__xamarin_class_map [65].handle = objc_getClass ("QLFilePreviewRequest");
	__xamarin_class_map [66].handle = objc_getClass ("QLFileThumbnailRequest");
	__xamarin_class_map [67].handle = objc_getClass ("QLPreviewControllerDataSource");
	__xamarin_class_map [68].handle = objc_getClass ("QLPreviewControllerDelegate");
	__xamarin_class_map [69].handle = objc_getClass ("QLPreviewItem");
	__xamarin_class_map [70].handle = objc_getClass ("QLPreviewProvider");
	__xamarin_class_map [71].handle = objc_getClass ("QLPreviewReply");
	__xamarin_class_map [72].handle = objc_getClass ("QLPreviewReplyAttachment");
	__xamarin_class_map [73].handle = objc_getClass ("UIWindowSceneActivationConfiguration");
	__xamarin_class_map [74].handle = objc_getClass ("QLPreviewSceneActivationConfiguration");
	__xamarin_class_map [75].handle = objc_getClass ("QLPreviewSceneOptions");
	__xamarin_class_map [76].handle = objc_getClass ("QLThumbnailProvider");
	__xamarin_class_map [77].handle = objc_getClass ("QLThumbnailReply");
	__xamarin_class_map [78].handle = objc_getClass ("PKPushCredentials");
	__xamarin_class_map [79].handle = objc_getClass ("PKPushPayload");
	__xamarin_class_map [80].handle = objc_getClass ("PKPushRegistry");
	__xamarin_class_map [81].handle = objc_getClass ("PKPushRegistryDelegate");
	__xamarin_class_map [82].handle = objc_getClass ("PHContentEditingController");
	__xamarin_class_map [83].handle = objc_getClass ("NSExtensionContext");
	__xamarin_class_map [84].handle = objc_getClass ("PHEditingExtensionContext");
	__xamarin_class_map [85].handle = objc_getClass ("PHLivePhotoViewDelegate");
	__xamarin_class_map [86].handle = objc_getClass ("PHPickerConfiguration");
	__xamarin_class_map [87].handle = objc_getClass ("PHPickerFilter");
	__xamarin_class_map [88].handle = objc_getClass ("PHPickerResult");
	__xamarin_class_map [89].handle = objc_getClass ("PHPickerViewController");
	__xamarin_class_map [90].handle = objc_getClass ("Xamarin_iOS__PhotosUI_PHPickerViewControllerDelegate");
	__xamarin_class_map [91].handle = objc_getClass ("Xamarin_iOS__PencilKit_PKCanvasViewDelegate");
	__xamarin_class_map [92].handle = objc_getClass ("PKDrawing");
	__xamarin_class_map [93].handle = objc_getClass ("PKTool");
	__xamarin_class_map [94].handle = objc_getClass ("PKEraserTool");
	__xamarin_class_map [95].handle = objc_getClass ("PKFloatRange");
	__xamarin_class_map [96].handle = objc_getClass ("PKInk");
	__xamarin_class_map [97].handle = objc_getClass ("PKInkingTool");
	__xamarin_class_map [98].handle = objc_getClass ("PKLassoTool");
	__xamarin_class_map [99].handle = objc_getClass ("PKStroke");
	__xamarin_class_map [100].handle = objc_getClass ("PKStrokePath");
	__xamarin_class_map [101].handle = objc_getClass ("PKStrokePoint");
	__xamarin_class_map [102].handle = objc_getClass ("PKToolPicker");
	__xamarin_class_map [103].handle = objc_getClass ("OSLogEntry");
	__xamarin_class_map [104].handle = objc_getClass ("OSLogEntryActivity");
	__xamarin_class_map [105].handle = objc_getClass ("OSLogEntryBoundary");
	__xamarin_class_map [106].handle = objc_getClass ("OSLogEntryLog");
	__xamarin_class_map [107].handle = objc_getClass ("OSLogEntrySignpost");
	__xamarin_class_map [108].handle = objc_getClass ("NSEnumerator");
	__xamarin_class_map [109].handle = objc_getClass ("OSLogEnumerator");
	__xamarin_class_map [110].handle = objc_getClass ("OSLogMessageComponent");
	__xamarin_class_map [111].handle = objc_getClass ("OSLogPosition");
	__xamarin_class_map [112].handle = objc_getClass ("OSLogStore");
	__xamarin_class_map [113].handle = objc_getClass ("NCWidgetController");
	__xamarin_class_map [114].handle = objc_getClass ("NCWidgetProviding");
	__xamarin_class_map [115].handle = objc_getClass ("NKAssetDownload");
	__xamarin_class_map [116].handle = objc_getClass ("NKLibrary");
	__xamarin_class_map [117].handle = objc_getClass ("MSMessage");
	__xamarin_class_map [118].handle = objc_getClass ("MSMessageLayout");
	__xamarin_class_map [119].handle = objc_getClass ("MSMessageLiveLayout");
	__xamarin_class_map [120].handle = objc_getClass ("MSMessagesAppViewController");
	__xamarin_class_map [121].handle = objc_getClass ("MSMessageTemplateLayout");
	__xamarin_class_map [122].handle = objc_getClass ("MSSession");
	__xamarin_class_map [123].handle = objc_getClass ("MSSticker");
	__xamarin_class_map [124].handle = objc_getClass ("MSStickerBrowserViewController");
	__xamarin_class_map [125].handle = objc_getClass ("MSStickerBrowserViewDataSource");
	__xamarin_class_map [126].handle = objc_getClass ("LAAuthenticationRequirement");
	__xamarin_class_map [127].handle = objc_getClass ("LABiometryFallbackRequirement");
	__xamarin_class_map [128].handle = objc_getClass ("LARight");
	__xamarin_class_map [129].handle = objc_getClass ("LAPersistedRight");
	__xamarin_class_map [130].handle = objc_getClass ("LPLinkMetadata");
	__xamarin_class_map [131].handle = objc_getClass ("Xamarin_iOS__IntentsUI_INUIAddVoiceShortcutButtonDelegate");
	__xamarin_class_map [132].handle = objc_getClass ("INUIAddVoiceShortcutViewController");
	__xamarin_class_map [133].handle = objc_getClass ("Xamarin_iOS__IntentsUI_INUIAddVoiceShortcutViewControllerDelegate");
	__xamarin_class_map [134].handle = objc_getClass ("INUIEditVoiceShortcutViewController");
	__xamarin_class_map [135].handle = objc_getClass ("Xamarin_iOS__IntentsUI_INUIEditVoiceShortcutViewControllerDelegate");
	__xamarin_class_map [136].handle = objc_getClass ("ILClassificationUIExtensionContext");
	__xamarin_class_map [137].handle = objc_getClass ("ILClassificationUIExtensionViewController");
	__xamarin_class_map [138].handle = objc_getClass ("ILClassificationRequest");
	__xamarin_class_map [139].handle = objc_getClass ("ILCallClassificationRequest");
	__xamarin_class_map [140].handle = objc_getClass ("ILCommunication");
	__xamarin_class_map [141].handle = objc_getClass ("ILCallCommunication");
	__xamarin_class_map [142].handle = objc_getClass ("ILClassificationResponse");
	__xamarin_class_map [143].handle = objc_getClass ("ILMessageClassificationRequest");
	__xamarin_class_map [144].handle = objc_getClass ("ILMessageCommunication");
	__xamarin_class_map [145].handle = objc_getClass ("ILMessageFilterCapabilitiesQueryRequest");
	__xamarin_class_map [146].handle = objc_getClass ("ILMessageFilterExtension");
	__xamarin_class_map [147].handle = objc_getClass ("ILMessageFilterQueryRequest");
	__xamarin_class_map [148].handle = objc_getClass ("ILMessageFilterQueryResponse");
	__xamarin_class_map [149].handle = objc_getClass ("ILNetworkResponse");
	__xamarin_class_map [150].handle = objc_getClass ("FPUIActionExtensionContext");
	__xamarin_class_map [151].handle = objc_getClass ("FPUIActionExtensionViewController");
	__xamarin_class_map [152].handle = objc_getClass ("EAAccessoryDelegate");
	__xamarin_class_map [153].handle = objc_getClass ("EASession");
	__xamarin_class_map [154].handle = objc_getClass ("EAWiFiUnconfiguredAccessory");
	__xamarin_class_map [155].handle = objc_getClass ("EAWiFiUnconfiguredAccessoryBrowserDelegate");
	__xamarin_class_map [156].handle = objc_getClass ("CHHapticDynamicParameter");
	__xamarin_class_map [157].handle = objc_getClass ("CHHapticEvent");
	__xamarin_class_map [158].handle = objc_getClass ("CHHapticEventParameter");
	__xamarin_class_map [159].handle = objc_getClass ("CHHapticParameterCurve");
	__xamarin_class_map [160].handle = objc_getClass ("CHHapticParameterCurveControlPoint");
	__xamarin_class_map [161].handle = objc_getClass ("CHHapticPattern");
	__xamarin_class_map [162].handle = objc_getClass ("AUAudioUnitViewConfiguration");
	__xamarin_class_map [163].handle = objc_getClass ("AUGenericViewController");
	__xamarin_class_map [164].handle = objc_getClass ("AUViewController");
	__xamarin_class_map [165].handle = objc_getClass ("UITableViewController");
	__xamarin_class_map [166].handle = objc_getClass ("CABTMIDICentralViewController");
	__xamarin_class_map [167].handle = objc_getClass ("CABTMIDILocalPeripheralViewController");
	__xamarin_class_map [168].handle = objc_getClass ("CNContactPickerDelegate");
	__xamarin_class_map [169].handle = objc_getClass ("CNContactPickerViewController");
	__xamarin_class_map [170].handle = objc_getClass ("CNContactViewController");
	__xamarin_class_map [171].handle = objc_getClass ("CNContactViewControllerDelegate");
	__xamarin_class_map [172].handle = objc_getClass ("BGTask");
	__xamarin_class_map [173].handle = objc_getClass ("BGAppRefreshTask");
	__xamarin_class_map [174].handle = objc_getClass ("BGTaskRequest");
	__xamarin_class_map [175].handle = objc_getClass ("BGAppRefreshTaskRequest");
	__xamarin_class_map [176].handle = objc_getClass ("BGProcessingTask");
	__xamarin_class_map [177].handle = objc_getClass ("BGProcessingTaskRequest");
	__xamarin_class_map [178].handle = objc_getClass ("AEAssessmentApplication");
	__xamarin_class_map [179].handle = objc_getClass ("AEAssessmentConfiguration");
	__xamarin_class_map [180].handle = objc_getClass ("AEAssessmentParticipantConfiguration");
	__xamarin_class_map [181].handle = objc_getClass ("AEAssessmentSession");
	__xamarin_class_map [182].handle = objc_getClass ("Xamarin_iOS__AutomaticAssessmentConfiguration_AEAssessmentSessionDelegate");
	__xamarin_class_map [183].handle = objc_getClass ("AAAttribution");
	__xamarin_class_map [184].handle = objc_getClass ("iAd_ADBannerViewDelegate");
	__xamarin_class_map [185].handle = objc_getClass ("iAd_ADInterstitialAd");
	__xamarin_class_map [186].handle = objc_getClass ("iAd_ADInterstitialAdDelegate");
	__xamarin_class_map [187].handle = objc_getClass ("iAd_ADInterstitialAdPresentationViewController");
	__xamarin_class_map [188].handle = objc_getClass ("VNCircle");
	__xamarin_class_map [189].handle = objc_getClass ("VNRequest");
	__xamarin_class_map [190].handle = objc_getClass ("VNImageBasedRequest");
	__xamarin_class_map [191].handle = objc_getClass ("VNDetectBarcodesRequest");
	__xamarin_class_map [192].handle = objc_getClass ("VNObservation");
	__xamarin_class_map [193].handle = objc_getClass ("VNFeaturePrintObservation");
	__xamarin_class_map [194].handle = objc_getClass ("VNGeometryUtils");
	__xamarin_class_map [195].handle = objc_getClass ("VNVector");
	__xamarin_class_map [196].handle = objc_getClass ("VNDetectedObjectObservation");
	__xamarin_class_map [197].handle = objc_getClass ("VNRectangleObservation");
	__xamarin_class_map [198].handle = objc_getClass ("VNBarcodeObservation");
	__xamarin_class_map [199].handle = objc_getClass ("VNClassificationObservation");
	__xamarin_class_map [200].handle = objc_getClass ("VNClassifyImageRequest");
	__xamarin_class_map [201].handle = objc_getClass ("VNContour");
	__xamarin_class_map [202].handle = objc_getClass ("VNContoursObservation");
	__xamarin_class_map [203].handle = objc_getClass ("VNCoreMLFeatureValueObservation");
	__xamarin_class_map [204].handle = objc_getClass ("VNCoreMLModel");
	__xamarin_class_map [205].handle = objc_getClass ("VNCoreMLRequest");
	__xamarin_class_map [206].handle = objc_getClass ("VNDetectContoursRequest");
	__xamarin_class_map [207].handle = objc_getClass ("VNDetectDocumentSegmentationRequest");
	__xamarin_class_map [208].handle = objc_getClass ("VNPoint");
	__xamarin_class_map [209].handle = objc_getClass ("VNDetectedPoint");
	__xamarin_class_map [210].handle = objc_getClass ("VNDetectFaceCaptureQualityRequest");
	__xamarin_class_map [211].handle = objc_getClass ("VNDetectFaceLandmarksRequest");
	__xamarin_class_map [212].handle = objc_getClass ("VNDetectFaceRectanglesRequest");
	__xamarin_class_map [213].handle = objc_getClass ("VNDetectHorizonRequest");
	__xamarin_class_map [214].handle = objc_getClass ("VNDetectHumanRectanglesRequest");
	__xamarin_class_map [215].handle = objc_getClass ("VNDetectRectanglesRequest");
	__xamarin_class_map [216].handle = objc_getClass ("VNDetectTextRectanglesRequest");
	__xamarin_class_map [217].handle = objc_getClass ("VNStatefulRequest");
	__xamarin_class_map [218].handle = objc_getClass ("VNDetectTrajectoriesRequest");
	__xamarin_class_map [219].handle = objc_getClass ("VNFaceLandmarkRegion");
	__xamarin_class_map [220].handle = objc_getClass ("VNFaceLandmarks");
	__xamarin_class_map [221].handle = objc_getClass ("VNFaceLandmarks2D");
	__xamarin_class_map [222].handle = objc_getClass ("VNFaceObservation");
	__xamarin_class_map [223].handle = objc_getClass ("VNGenerateAttentionBasedSaliencyImageRequest");
	__xamarin_class_map [224].handle = objc_getClass ("VNGenerateImageFeaturePrintRequest");
	__xamarin_class_map [225].handle = objc_getClass ("VNGenerateObjectnessBasedSaliencyImageRequest");
	__xamarin_class_map [226].handle = objc_getClass ("VNTargetedImageRequest");
	__xamarin_class_map [227].handle = objc_getClass ("VNGenerateOpticalFlowRequest");
	__xamarin_class_map [228].handle = objc_getClass ("VNGeneratePersonSegmentationRequest");
	__xamarin_class_map [229].handle = objc_getClass ("VNImageRegistrationRequest");
	__xamarin_class_map [230].handle = objc_getClass ("VNHomographicImageRegistrationRequest");
	__xamarin_class_map [231].handle = objc_getClass ("VNHorizonObservation");
	__xamarin_class_map [232].handle = objc_getClass ("VNHumanObservation");
	__xamarin_class_map [233].handle = objc_getClass ("VNImageAlignmentObservation");
	__xamarin_class_map [234].handle = objc_getClass ("VNImageHomographicAlignmentObservation");
	__xamarin_class_map [235].handle = objc_getClass ("VNImageRequestHandler");
	__xamarin_class_map [236].handle = objc_getClass ("VNImageTranslationAlignmentObservation");
	__xamarin_class_map [237].handle = objc_getClass ("VNPixelBufferObservation");
	__xamarin_class_map [238].handle = objc_getClass ("VNRecognizedObjectObservation");
	__xamarin_class_map [239].handle = objc_getClass ("VNRecognizedPoint");
	__xamarin_class_map [240].handle = objc_getClass ("VNRecognizedText");
	__xamarin_class_map [241].handle = objc_getClass ("VNRecognizedTextObservation");
	__xamarin_class_map [242].handle = objc_getClass ("VNRecognizeTextRequest");
	__xamarin_class_map [243].handle = objc_getClass ("VNSaliencyImageObservation");
	__xamarin_class_map [244].handle = objc_getClass ("VNSequenceRequestHandler");
	__xamarin_class_map [245].handle = objc_getClass ("VNTextObservation");
	__xamarin_class_map [246].handle = objc_getClass ("VNTrackingRequest");
	__xamarin_class_map [247].handle = objc_getClass ("VNTrackObjectRequest");
	__xamarin_class_map [248].handle = objc_getClass ("VNTrackRectangleRequest");
	__xamarin_class_map [249].handle = objc_getClass ("VNTrajectoryObservation");
	__xamarin_class_map [250].handle = objc_getClass ("VNTranslationalImageRegistrationRequest");
	__xamarin_class_map [251].handle = objc_getClass ("VNVideoProcessor");
	__xamarin_class_map [252].handle = objc_getClass ("VNVideoProcessorCadence");
	__xamarin_class_map [253].handle = objc_getClass ("VNVideoProcessorFrameRateCadence");
	__xamarin_class_map [254].handle = objc_getClass ("VNVideoProcessorRequestProcessingOptions");
	__xamarin_class_map [255].handle = objc_getClass ("VNVideoProcessorTimeIntervalCadence");
	__xamarin_class_map [256].handle = objc_getClass ("VSAccountMetadataRequest");
	__xamarin_class_map [257].handle = objc_getClass ("VSAccountApplicationProvider");
	__xamarin_class_map [258].handle = objc_getClass ("VSAccountManagerDelegate");
	__xamarin_class_map [259].handle = objc_getClass ("VSAccountManagerResult");
	__xamarin_class_map [260].handle = objc_getClass ("VSAccountMetadata");
	__xamarin_class_map [261].handle = objc_getClass ("VSAccountProviderResponse");
	__xamarin_class_map [262].handle = objc_getClass ("VSSubscription");
	__xamarin_class_map [263].handle = objc_getClass ("VSSubscriptionRegistrationCenter");
	__xamarin_class_map [264].handle = objc_getClass ("VSUserAccount");
	__xamarin_class_map [265].handle = objc_getClass ("UNNotificationAttachment");
	__xamarin_class_map [266].handle = objc_getClass ("UNNotificationTrigger");
	__xamarin_class_map [267].handle = objc_getClass ("UNCalendarNotificationTrigger");
	__xamarin_class_map [268].handle = objc_getClass ("UNLocationNotificationTrigger");
	__xamarin_class_map [269].handle = objc_getClass ("UNNotificationContent");
	__xamarin_class_map [270].handle = objc_getClass ("UNMutableNotificationContent");
	__xamarin_class_map [271].handle = objc_getClass ("UNNotification");
	__xamarin_class_map [272].handle = objc_getClass ("UNNotificationAction");
	__xamarin_class_map [273].handle = objc_getClass ("UNNotificationActionIcon");
	__xamarin_class_map [274].handle = objc_getClass ("UNNotificationCategory");
	__xamarin_class_map [275].handle = objc_getClass ("UNNotificationRequest");
	__xamarin_class_map [276].handle = objc_getClass ("UNNotificationResponse");
	__xamarin_class_map [277].handle = objc_getClass ("UNNotificationServiceExtension");
	__xamarin_class_map [278].handle = objc_getClass ("UNNotificationSettings");
	__xamarin_class_map [279].handle = objc_getClass ("UNNotificationSound");
	__xamarin_class_map [280].handle = objc_getClass ("UNPushNotificationTrigger");
	__xamarin_class_map [281].handle = objc_getClass ("UNTextInputNotificationAction");
	__xamarin_class_map [282].handle = objc_getClass ("UNTextInputNotificationResponse");
	__xamarin_class_map [283].handle = objc_getClass ("UNTimeIntervalNotificationTrigger");
	__xamarin_class_map [284].handle = objc_getClass ("UNUserNotificationCenterDelegate");
	__xamarin_class_map [285].handle = objc_getClass ("TWTweetComposeViewController");
	__xamarin_class_map [286].handle = objc_getClass ("SKRequest");
	__xamarin_class_map [287].handle = objc_getClass ("SKReceiptRefreshRequest");
	__xamarin_class_map [288].handle = objc_getClass ("SKOverlayConfiguration");
	__xamarin_class_map [289].handle = objc_getClass ("SKOverlayAppClipConfiguration");
	__xamarin_class_map [290].handle = objc_getClass ("SKOverlayAppConfiguration");
	__xamarin_class_map [291].handle = objc_getClass ("SKPayment");
	__xamarin_class_map [292].handle = objc_getClass ("SKPaymentTransactionObserver");
	__xamarin_class_map [293].handle = objc_getClass ("SKAdImpression");
	__xamarin_class_map [294].handle = objc_getClass ("SKArcadeService");
	__xamarin_class_map [295].handle = objc_getClass ("SKCloudServiceSetupViewControllerDelegate");
	__xamarin_class_map [296].handle = objc_getClass ("SKDownload");
	__xamarin_class_map [297].handle = objc_getClass ("SKMutablePayment");
	__xamarin_class_map [298].handle = objc_getClass ("SKOverlay");
	__xamarin_class_map [299].handle = objc_getClass ("Xamarin_iOS__StoreKit_SKOverlayDelegate");
	__xamarin_class_map [300].handle = objc_getClass ("SKOverlayTransitionContext");
	__xamarin_class_map [301].handle = objc_getClass ("SKPaymentDiscount");
	__xamarin_class_map [302].handle = objc_getClass ("SKPaymentQueue");
	__xamarin_class_map [303].handle = objc_getClass ("Xamarin_iOS__StoreKit_SKPaymentQueueDelegate");
	__xamarin_class_map [304].handle = objc_getClass ("SKPaymentTransaction");
	__xamarin_class_map [305].handle = objc_getClass ("SKProduct");
	__xamarin_class_map [306].handle = objc_getClass ("SKProductDiscount");
	__xamarin_class_map [307].handle = objc_getClass ("SKRequestDelegate");
	__xamarin_class_map [308].handle = objc_getClass ("SKProductsRequestDelegate");
	__xamarin_class_map [309].handle = objc_getClass ("SKProductsResponse");
	__xamarin_class_map [310].handle = objc_getClass ("SKProductSubscriptionPeriod");
	__xamarin_class_map [311].handle = objc_getClass ("SKStorefront");
	__xamarin_class_map [312].handle = objc_getClass ("SKStoreProductViewControllerDelegate");
	__xamarin_class_map [313].handle = objc_getClass ("SKStoreReviewController");
	__xamarin_class_map [314].handle = objc_getClass ("SKAction");
	__xamarin_class_map [315].handle = objc_getClass ("SKNode");
	__xamarin_class_map [316].handle = objc_getClass ("SKFieldNode");
	__xamarin_class_map [317].handle = objc_getClass ("SKKeyframeSequence");
	__xamarin_class_map [318].handle = objc_getClass ("SKShapeNode");
	__xamarin_class_map [319].handle = objc_getClass ("SKUniform");
	__xamarin_class_map [320].handle = objc_getClass ("SKVideoNode");
	__xamarin_class_map [321].handle = objc_getClass ("SKWarpGeometry");
	__xamarin_class_map [322].handle = objc_getClass ("SKWarpGeometryGrid");
	__xamarin_class_map [323].handle = objc_getClass ("SK3DNode");
	__xamarin_class_map [324].handle = objc_getClass ("SKAttribute");
	__xamarin_class_map [325].handle = objc_getClass ("SKAttributeValue");
	__xamarin_class_map [326].handle = objc_getClass ("SKAudioNode");
	__xamarin_class_map [327].handle = objc_getClass ("SKCameraNode");
	__xamarin_class_map [328].handle = objc_getClass ("SKConstraint");
	__xamarin_class_map [329].handle = objc_getClass ("SKCropNode");
	__xamarin_class_map [330].handle = objc_getClass ("SKEffectNode");
	__xamarin_class_map [331].handle = objc_getClass ("SKEmitterNode");
	__xamarin_class_map [332].handle = objc_getClass ("SKLabelNode");
	__xamarin_class_map [333].handle = objc_getClass ("SKLightNode");
	__xamarin_class_map [334].handle = objc_getClass ("SKTexture");
	__xamarin_class_map [335].handle = objc_getClass ("SKMutableTexture");
	__xamarin_class_map [336].handle = objc_getClass ("SKPhysicsBody");
	__xamarin_class_map [337].handle = objc_getClass ("SKPhysicsContact");
	__xamarin_class_map [338].handle = objc_getClass ("SKPhysicsContactDelegate");
	__xamarin_class_map [339].handle = objc_getClass ("SKPhysicsJoint");
	__xamarin_class_map [340].handle = objc_getClass ("SKPhysicsJointFixed");
	__xamarin_class_map [341].handle = objc_getClass ("SKPhysicsJointLimit");
	__xamarin_class_map [342].handle = objc_getClass ("SKPhysicsJointPin");
	__xamarin_class_map [343].handle = objc_getClass ("SKPhysicsJointSliding");
	__xamarin_class_map [344].handle = objc_getClass ("SKPhysicsJointSpring");
	__xamarin_class_map [345].handle = objc_getClass ("SKRange");
	__xamarin_class_map [346].handle = objc_getClass ("SKReachConstraints");
	__xamarin_class_map [347].handle = objc_getClass ("SKReferenceNode");
	__xamarin_class_map [348].handle = objc_getClass ("SKRegion");
	__xamarin_class_map [349].handle = objc_getClass ("SKRenderer");
	__xamarin_class_map [350].handle = objc_getClass ("SKScene");
	__xamarin_class_map [351].handle = objc_getClass ("SKSceneDelegate");
	__xamarin_class_map [352].handle = objc_getClass ("SKShader");
	__xamarin_class_map [353].handle = objc_getClass ("SKSpriteNode");
	__xamarin_class_map [354].handle = objc_getClass ("SKTileDefinition");
	__xamarin_class_map [355].handle = objc_getClass ("SKTileGroup");
	__xamarin_class_map [356].handle = objc_getClass ("SKTileGroupRule");
	__xamarin_class_map [357].handle = objc_getClass ("SKTileMapNode");
	__xamarin_class_map [358].handle = objc_getClass ("SKTileSet");
	__xamarin_class_map [359].handle = objc_getClass ("SKTransformNode");
	__xamarin_class_map [360].handle = objc_getClass ("SKTransition");
	__xamarin_class_map [361].handle = objc_getClass ("SKViewDelegate");
	__xamarin_class_map [362].handle = objc_getClass ("SLComposeSheetConfigurationItem");
	__xamarin_class_map [363].handle = objc_getClass ("SLComposeViewController");
	__xamarin_class_map [364].handle = objc_getClass ("SLComposeServiceViewController");
	__xamarin_class_map [365].handle = objc_getClass ("SWAction");
	__xamarin_class_map [366].handle = objc_getClass ("SWCollaborationCoordinator");
	__xamarin_class_map [367].handle = objc_getClass ("SWCollaborationOption");
	__xamarin_class_map [368].handle = objc_getClass ("SWCollaborationOptionsGroup");
	__xamarin_class_map [369].handle = objc_getClass ("SWCollaborationOptionsPickerGroup");
	__xamarin_class_map [370].handle = objc_getClass ("SWCollaborationShareOptions");
	__xamarin_class_map [371].handle = objc_getClass ("SWPerson");
	__xamarin_class_map [372].handle = objc_getClass ("SWPersonIdentity");
	__xamarin_class_map [373].handle = objc_getClass ("SWPersonIdentityProof");
	__xamarin_class_map [374].handle = objc_getClass ("SWSignedPersonIdentityProof");
	__xamarin_class_map [375].handle = objc_getClass ("SWStartCollaborationAction");
	__xamarin_class_map [376].handle = objc_getClass ("SWUpdateCollaborationParticipantsAction");
	__xamarin_class_map [377].handle = objc_getClass ("SRAmbientLightSample");
	__xamarin_class_map [378].handle = objc_getClass ("SRApplicationUsage");
	__xamarin_class_map [379].handle = objc_getClass ("SRDeletionRecord");
	__xamarin_class_map [380].handle = objc_getClass ("SRDevice");
	__xamarin_class_map [381].handle = objc_getClass ("SRDeviceUsageReport");
	__xamarin_class_map [382].handle = objc_getClass ("SRFetchRequest");
	__xamarin_class_map [383].handle = objc_getClass ("SRFetchResult");
	__xamarin_class_map [384].handle = objc_getClass ("SRKeyboardMetrics");
	__xamarin_class_map [385].handle = objc_getClass ("SRKeyboardProbabilityMetric");
	__xamarin_class_map [386].handle = objc_getClass ("SRMessagesUsageReport");
	__xamarin_class_map [387].handle = objc_getClass ("SRNotificationUsage");
	__xamarin_class_map [388].handle = objc_getClass ("SRPhoneUsageReport");
	__xamarin_class_map [389].handle = objc_getClass ("Xamarin_iOS__SensorKit_SRSensorReaderDelegate");
	__xamarin_class_map [390].handle = objc_getClass ("SRTextInputSession");
	__xamarin_class_map [391].handle = objc_getClass ("SRVisit");
	__xamarin_class_map [392].handle = objc_getClass ("SRWebUsage");
	__xamarin_class_map [393].handle = objc_getClass ("SRWristDetection");
	__xamarin_class_map [394].handle = objc_getClass ("SCNGeometry");
	__xamarin_class_map [395].handle = objc_getClass ("SCNText");
	__xamarin_class_map [396].handle = objc_getClass ("SCNAnimatable");
	__xamarin_class_map [397].handle = objc_getClass ("SCNSceneRenderer");
	__xamarin_class_map [398].handle = objc_getClass ("SCNGeometrySource");
	__xamarin_class_map [399].handle = objc_getClass ("SCNParticleSystem");
	__xamarin_class_map [400].handle = objc_getClass ("SCNPhysicsShape");
	__xamarin_class_map [401].handle = objc_getClass ("SCNScene");
	__xamarin_class_map [402].handle = objc_getClass ("SCNSceneSource");
	__xamarin_class_map [403].handle = objc_getClass ("SCNSkinner");
	__xamarin_class_map [404].handle = objc_getClass ("SCNTechnique");
	__xamarin_class_map [405].handle = objc_getClass ("SCNConstraint");
	__xamarin_class_map [406].handle = objc_getClass ("SCNAccelerationConstraint");
	__xamarin_class_map [407].handle = objc_getClass ("SCNActionable");
	__xamarin_class_map [408].handle = objc_getClass ("SCNAnimation");
	__xamarin_class_map [409].handle = objc_getClass ("SCNAnimationPlayer");
	__xamarin_class_map [410].handle = objc_getClass ("SCNAudioPlayer");
	__xamarin_class_map [411].handle = objc_getClass ("SCNAudioSource");
	__xamarin_class_map [412].handle = objc_getClass ("SCNAvoidOccluderConstraint");
	__xamarin_class_map [413].handle = objc_getClass ("SCNAvoidOccluderConstraintDelegate");
	__xamarin_class_map [414].handle = objc_getClass ("SCNBillboardConstraint");
	__xamarin_class_map [415].handle = objc_getClass ("SCNBoundingVolume");
	__xamarin_class_map [416].handle = objc_getClass ("SCNBox");
	__xamarin_class_map [417].handle = objc_getClass ("SCNCamera");
	__xamarin_class_map [418].handle = objc_getClass ("SCNCameraController");
	__xamarin_class_map [419].handle = objc_getClass ("SCNCameraControllerDelegate");
	__xamarin_class_map [420].handle = objc_getClass ("SCNCapsule");
	__xamarin_class_map [421].handle = objc_getClass ("SCNCone");
	__xamarin_class_map [422].handle = objc_getClass ("SCNCylinder");
	__xamarin_class_map [423].handle = objc_getClass ("SCNDistanceConstraint");
	__xamarin_class_map [424].handle = objc_getClass ("SCNFloor");
	__xamarin_class_map [425].handle = objc_getClass ("SCNGeometryElement");
	__xamarin_class_map [426].handle = objc_getClass ("SCNGeometryTessellator");
	__xamarin_class_map [427].handle = objc_getClass ("SCNHitTestResult");
	__xamarin_class_map [428].handle = objc_getClass ("SCNIKConstraint");
	__xamarin_class_map [429].handle = objc_getClass ("SCNLevelOfDetail");
	__xamarin_class_map [430].handle = objc_getClass ("SCNLight");
	__xamarin_class_map [431].handle = objc_getClass ("SCNLookAtConstraint");
	__xamarin_class_map [432].handle = objc_getClass ("SCNMaterial");
	__xamarin_class_map [433].handle = objc_getClass ("SCNMaterialProperty");
	__xamarin_class_map [434].handle = objc_getClass ("SCNMorpher");
	__xamarin_class_map [435].handle = objc_getClass ("SCNNodeRendererDelegate");
	__xamarin_class_map [436].handle = objc_getClass ("SCNParticlePropertyController");
	__xamarin_class_map [437].handle = objc_getClass ("SCNPhysicsBehavior");
	__xamarin_class_map [438].handle = objc_getClass ("SCNPhysicsBallSocketJoint");
	__xamarin_class_map [439].handle = objc_getClass ("SCNPhysicsBody");
	__xamarin_class_map [440].handle = objc_getClass ("SCNPhysicsConeTwistJoint");
	__xamarin_class_map [441].handle = objc_getClass ("SCNPhysicsContact");
	__xamarin_class_map [442].handle = objc_getClass ("SCNPhysicsContactDelegate");
	__xamarin_class_map [443].handle = objc_getClass ("SCNPhysicsField");
	__xamarin_class_map [444].handle = objc_getClass ("SCNPhysicsHingeJoint");
	__xamarin_class_map [445].handle = objc_getClass ("SCNPhysicsSliderJoint");
	__xamarin_class_map [446].handle = objc_getClass ("SCNPhysicsVehicle");
	__xamarin_class_map [447].handle = objc_getClass ("SCNPhysicsVehicleWheel");
	__xamarin_class_map [448].handle = objc_getClass ("SCNPlane");
	__xamarin_class_map [449].handle = objc_getClass ("SCNProgram");
	__xamarin_class_map [450].handle = objc_getClass ("SCNProgramDelegate");
	__xamarin_class_map [451].handle = objc_getClass ("SCNPyramid");
	__xamarin_class_map [452].handle = objc_getClass ("SCNNode");
	__xamarin_class_map [453].handle = objc_getClass ("SCNReferenceNode");
	__xamarin_class_map [454].handle = objc_getClass ("SCNReplicatorConstraint");
	__xamarin_class_map [455].handle = objc_getClass ("SCNSceneExportDelegate");
	__xamarin_class_map [456].handle = objc_getClass ("SCNSceneRendererDelegate");
	__xamarin_class_map [457].handle = objc_getClass ("SCNShadable");
	__xamarin_class_map [458].handle = objc_getClass ("SCNShape");
	__xamarin_class_map [459].handle = objc_getClass ("SCNSliderConstraint");
	__xamarin_class_map [460].handle = objc_getClass ("SCNSphere");
	__xamarin_class_map [461].handle = objc_getClass ("SCNTechniqueSupport");
	__xamarin_class_map [462].handle = objc_getClass ("SCNTimingFunction");
	__xamarin_class_map [463].handle = objc_getClass ("SCNTorus");
	__xamarin_class_map [464].handle = objc_getClass ("SCNTransaction");
	__xamarin_class_map [465].handle = objc_getClass ("SCNTransformConstraint");
	__xamarin_class_map [466].handle = objc_getClass ("SCNTube");
	__xamarin_class_map [467].handle = objc_getClass ("RPBroadcastConfiguration");
	__xamarin_class_map [468].handle = objc_getClass ("RPBroadcastActivityViewControllerDelegate");
	__xamarin_class_map [469].handle = objc_getClass ("RPBroadcastControllerDelegate");
	__xamarin_class_map [470].handle = objc_getClass ("RPBroadcastHandler");
	__xamarin_class_map [471].handle = objc_getClass ("RPBroadcastMP4ClipHandler");
	__xamarin_class_map [472].handle = objc_getClass ("RPBroadcastSampleHandler");
	__xamarin_class_map [473].handle = objc_getClass ("RPPreviewViewController");
	__xamarin_class_map [474].handle = objc_getClass ("RPPreviewViewControllerDelegate");
	__xamarin_class_map [475].handle = objc_getClass ("RPScreenRecorderDelegate");
	__xamarin_class_map [476].handle = objc_getClass ("PHChangeRequest");
	__xamarin_class_map [477].handle = objc_getClass ("PHAssetChangeRequest");
	__xamarin_class_map [478].handle = objc_getClass ("PHAssetCreationRequest");
	__xamarin_class_map [479].handle = objc_getClass ("PHContentEditingInputRequestOptions");
	__xamarin_class_map [480].handle = objc_getClass ("PHLivePhoto");
	__xamarin_class_map [481].handle = objc_getClass ("PHAdjustmentData");
	__xamarin_class_map [482].handle = objc_getClass ("PHObject");
	__xamarin_class_map [483].handle = objc_getClass ("PHAsset");
	__xamarin_class_map [484].handle = objc_getClass ("PHCollection");
	__xamarin_class_map [485].handle = objc_getClass ("PHAssetCollection");
	__xamarin_class_map [486].handle = objc_getClass ("PHAssetCollectionChangeRequest");
	__xamarin_class_map [487].handle = objc_getClass ("PHAssetResource");
	__xamarin_class_map [488].handle = objc_getClass ("PHAssetResourceCreationOptions");
	__xamarin_class_map [489].handle = objc_getClass ("PHAssetResourceRequestOptions");
	__xamarin_class_map [490].handle = objc_getClass ("PHImageManager");
	__xamarin_class_map [491].handle = objc_getClass ("PHCachingImageManager");
	__xamarin_class_map [492].handle = objc_getClass ("PHChange");
	__xamarin_class_map [493].handle = objc_getClass ("PHCloudIdentifier");
	__xamarin_class_map [494].handle = objc_getClass ("PHCloudIdentifierMapping");
	__xamarin_class_map [495].handle = objc_getClass ("PHCollectionList");
	__xamarin_class_map [496].handle = objc_getClass ("PHCollectionListChangeRequest");
	__xamarin_class_map [497].handle = objc_getClass ("PHContentEditingInput");
	__xamarin_class_map [498].handle = objc_getClass ("PHContentEditingOutput");
	__xamarin_class_map [499].handle = objc_getClass ("PHFetchOptions");
	__xamarin_class_map [500].handle = objc_getClass ("PHFetchResultChangeDetails");
	__xamarin_class_map [501].handle = objc_getClass ("PHImageRequestOptions");
	__xamarin_class_map [502].handle = objc_getClass ("PHLivePhotoRequestOptions");
	__xamarin_class_map [503].handle = objc_getClass ("PHLocalIdentifierMapping");
	__xamarin_class_map [504].handle = objc_getClass ("PHObjectChangeDetails");
	__xamarin_class_map [505].handle = objc_getClass ("PHObjectPlaceholder");
	__xamarin_class_map [506].handle = objc_getClass ("PHPersistentChange");
	__xamarin_class_map [507].handle = objc_getClass ("PHPersistentChangeFetchResult");
	__xamarin_class_map [508].handle = objc_getClass ("PHPersistentChangeToken");
	__xamarin_class_map [509].handle = objc_getClass ("PHPersistentObjectChangeDetails");
	__xamarin_class_map [510].handle = objc_getClass ("PHPhotoLibraryChangeObserver");
	__xamarin_class_map [511].handle = objc_getClass ("PHVideoRequestOptions");
	__xamarin_class_map [512].handle = objc_getClass ("PDFBorder");
	__xamarin_class_map [513].handle = objc_getClass ("PDFAction");
	__xamarin_class_map [514].handle = objc_getClass ("PDFActionGoTo");
	__xamarin_class_map [515].handle = objc_getClass ("PDFActionNamed");
	__xamarin_class_map [516].handle = objc_getClass ("PDFActionRemoteGoTo");
	__xamarin_class_map [517].handle = objc_getClass ("PDFActionResetForm");
	__xamarin_class_map [518].handle = objc_getClass ("PDFActionURL");
	__xamarin_class_map [519].handle = objc_getClass ("PDFAppearanceCharacteristics");
	__xamarin_class_map [520].handle = objc_getClass ("PDFDestination");
	__xamarin_class_map [521].handle = objc_getClass ("PDFDocumentDelegate");
	__xamarin_class_map [522].handle = objc_getClass ("PDFOutline");
	__xamarin_class_map [523].handle = objc_getClass ("PDFPage");
	__xamarin_class_map [524].handle = objc_getClass ("PDFSelection");
	__xamarin_class_map [525].handle = objc_getClass ("PDFViewDelegate");
	__xamarin_class_map [526].handle = objc_getClass ("PKPaymentRequest");
	__xamarin_class_map [527].handle = objc_getClass ("PKAddSecureElementPassConfiguration");
	__xamarin_class_map [528].handle = objc_getClass ("PKAddCarKeyPassConfiguration");
	__xamarin_class_map [529].handle = objc_getClass ("PKAddPassesViewControllerDelegate");
	__xamarin_class_map [530].handle = objc_getClass ("PKAddPaymentPassRequest");
	__xamarin_class_map [531].handle = objc_getClass ("PKAddPaymentPassRequestConfiguration");
	__xamarin_class_map [532].handle = objc_getClass ("PKAddPaymentPassViewController");
	__xamarin_class_map [533].handle = objc_getClass ("PKAddPaymentPassViewControllerDelegate");
	__xamarin_class_map [534].handle = objc_getClass ("PKAddSecureElementPassViewController");
	__xamarin_class_map [535].handle = objc_getClass ("Xamarin_iOS__PassKit_PKAddSecureElementPassViewControllerDelegate");
	__xamarin_class_map [536].handle = objc_getClass ("PKAutomaticReloadPaymentRequest");
	__xamarin_class_map [537].handle = objc_getClass ("PKPaymentSummaryItem");
	__xamarin_class_map [538].handle = objc_getClass ("PKAutomaticReloadPaymentSummaryItem");
	__xamarin_class_map [539].handle = objc_getClass ("PKBarcodeEventConfigurationRequest");
	__xamarin_class_map [540].handle = objc_getClass ("PKBarcodeEventMetadataRequest");
	__xamarin_class_map [541].handle = objc_getClass ("PKBarcodeEventMetadataResponse");
	__xamarin_class_map [542].handle = objc_getClass ("PKBarcodeEventSignatureRequest");
	__xamarin_class_map [543].handle = objc_getClass ("PKBarcodeEventSignatureResponse");
	__xamarin_class_map [544].handle = objc_getClass ("PKContact");
	__xamarin_class_map [545].handle = objc_getClass ("PKDateComponentsRange");
	__xamarin_class_map [546].handle = objc_getClass ("PKDeferredPaymentSummaryItem");
	__xamarin_class_map [547].handle = objc_getClass ("PKDisbursementAuthorizationControllerDelegate");
	__xamarin_class_map [548].handle = objc_getClass ("PKDisbursementRequest");
	__xamarin_class_map [549].handle = objc_getClass ("PKDisbursementVoucher");
	__xamarin_class_map [550].handle = objc_getClass ("PKIdentityDocument");
	__xamarin_class_map [551].handle = objc_getClass ("PKIdentityDriversLicenseDescriptor");
	__xamarin_class_map [552].handle = objc_getClass ("PKIdentityElement");
	__xamarin_class_map [553].handle = objc_getClass ("PKIdentityIntentToStore");
	__xamarin_class_map [554].handle = objc_getClass ("PKIdentityRequest");
	__xamarin_class_map [555].handle = objc_getClass ("PKIssuerProvisioningExtensionPassEntry");
	__xamarin_class_map [556].handle = objc_getClass ("PKIssuerProvisioningExtensionPaymentPassEntry");
	__xamarin_class_map [557].handle = objc_getClass ("PKIssuerProvisioningExtensionStatus");
	__xamarin_class_map [558].handle = objc_getClass ("PKLabeledValue");
	__xamarin_class_map [559].handle = objc_getClass ("PKObject");
	__xamarin_class_map [560].handle = objc_getClass ("PKPass");
	__xamarin_class_map [561].handle = objc_getClass ("PKPayment");
	__xamarin_class_map [562].handle = objc_getClass ("PKPaymentAuthorizationControllerDelegate");
	__xamarin_class_map [563].handle = objc_getClass ("PKPaymentAuthorizationResult");
	__xamarin_class_map [564].handle = objc_getClass ("PKPaymentAuthorizationViewControllerDelegate");
	__xamarin_class_map [565].handle = objc_getClass ("PKPaymentInformationEventExtension");
	__xamarin_class_map [566].handle = objc_getClass ("PKPaymentMerchantSession");
	__xamarin_class_map [567].handle = objc_getClass ("PKPaymentMethod");
	__xamarin_class_map [568].handle = objc_getClass ("PKPaymentOrderDetails");
	__xamarin_class_map [569].handle = objc_getClass ("PKSecureElementPass");
	__xamarin_class_map [570].handle = objc_getClass ("PKPaymentPass");
	__xamarin_class_map [571].handle = objc_getClass ("PKPaymentRequestUpdate");
	__xamarin_class_map [572].handle = objc_getClass ("PKPaymentRequestCouponCodeUpdate");
	__xamarin_class_map [573].handle = objc_getClass ("PKPaymentRequestMerchantSessionUpdate");
	__xamarin_class_map [574].handle = objc_getClass ("PKPaymentRequestPaymentMethodUpdate");
	__xamarin_class_map [575].handle = objc_getClass ("PKPaymentRequestShippingContactUpdate");
	__xamarin_class_map [576].handle = objc_getClass ("PKPaymentRequestShippingMethodUpdate");
	__xamarin_class_map [577].handle = objc_getClass ("PKPaymentToken");
	__xamarin_class_map [578].handle = objc_getClass ("PKPaymentTokenContext");
	__xamarin_class_map [579].handle = objc_getClass ("PKRecurringPaymentRequest");
	__xamarin_class_map [580].handle = objc_getClass ("PKRecurringPaymentSummaryItem");
	__xamarin_class_map [581].handle = objc_getClass ("PKShareablePassMetadataPreview");
	__xamarin_class_map [582].handle = objc_getClass ("PKShareSecureElementPassViewController");
	__xamarin_class_map [583].handle = objc_getClass ("Xamarin_iOS__PassKit_PKShareSecureElementPassViewControllerDelegate");
	__xamarin_class_map [584].handle = objc_getClass ("PKShippingMethod");
	__xamarin_class_map [585].handle = objc_getClass ("PKStoredValuePassBalance");
	__xamarin_class_map [586].handle = objc_getClass ("PKStoredValuePassProperties");
	__xamarin_class_map [587].handle = objc_getClass ("PKTransitPassProperties");
	__xamarin_class_map [588].handle = objc_getClass ("PKSuicaPassProperties");
	__xamarin_class_map [589].handle = objc_getClass ("Xamarin_iOS__PassKit_PKVehicleConnectionDelegate");
	__xamarin_class_map [590].handle = objc_getClass ("EAGLSharegroup");
	__xamarin_class_map [591].handle = objc_getClass ("NETunnelNetworkSettings");
	__xamarin_class_map [592].handle = objc_getClass ("NEPacketTunnelNetworkSettings");
	__xamarin_class_map [593].handle = objc_getClass ("NWPath");
	__xamarin_class_map [594].handle = objc_getClass ("NWEndpoint");
	__xamarin_class_map [595].handle = objc_getClass ("NWHostEndpoint");
	__xamarin_class_map [596].handle = objc_getClass ("NWTCPConnectionAuthenticationDelegate");
	__xamarin_class_map [597].handle = objc_getClass ("NEFilterFlow");
	__xamarin_class_map [598].handle = objc_getClass ("NEHotspotConfiguration");
	__xamarin_class_map [599].handle = objc_getClass ("NEHotspotEAPSettings");
	__xamarin_class_map [600].handle = objc_getClass ("Xamarin_iOS__NetworkExtension_NEAppPushDelegate");
	__xamarin_class_map [601].handle = objc_getClass ("NEAppRule");
	__xamarin_class_map [602].handle = objc_getClass ("NEDNSSettings");
	__xamarin_class_map [603].handle = objc_getClass ("NEDNSOverHTTPSSettings");
	__xamarin_class_map [604].handle = objc_getClass ("NEDNSOverTLSSettings");
	__xamarin_class_map [605].handle = objc_getClass ("NEVPNProtocol");
	__xamarin_class_map [606].handle = objc_getClass ("NEDNSProxyProviderProtocol");
	__xamarin_class_map [607].handle = objc_getClass ("NEEvaluateConnectionRule");
	__xamarin_class_map [608].handle = objc_getClass ("NEFilterBrowserFlow");
	__xamarin_class_map [609].handle = objc_getClass ("NEFilterVerdict");
	__xamarin_class_map [610].handle = objc_getClass ("NEFilterNewFlowVerdict");
	__xamarin_class_map [611].handle = objc_getClass ("NEFilterControlVerdict");
	__xamarin_class_map [612].handle = objc_getClass ("NEProvider");
	__xamarin_class_map [613].handle = objc_getClass ("NEFilterProvider");
	__xamarin_class_map [614].handle = objc_getClass ("NEFilterDataProvider");
	__xamarin_class_map [615].handle = objc_getClass ("NEFilterDataVerdict");
	__xamarin_class_map [616].handle = objc_getClass ("NEFilterProviderConfiguration");
	__xamarin_class_map [617].handle = objc_getClass ("NEFilterRemediationVerdict");
	__xamarin_class_map [618].handle = objc_getClass ("NEFilterReport");
	__xamarin_class_map [619].handle = objc_getClass ("NEFilterSocketFlow");
	__xamarin_class_map [620].handle = objc_getClass ("NEFlowMetaData");
	__xamarin_class_map [621].handle = objc_getClass ("NEHotspotHelper");
	__xamarin_class_map [622].handle = objc_getClass ("NEHotspotHelperCommand");
	__xamarin_class_map [623].handle = objc_getClass ("NEHotspotHelperResponse");
	__xamarin_class_map [624].handle = objc_getClass ("NEHotspotHS20Settings");
	__xamarin_class_map [625].handle = objc_getClass ("NEIPv4Route");
	__xamarin_class_map [626].handle = objc_getClass ("NEIPv4Settings");
	__xamarin_class_map [627].handle = objc_getClass ("NEIPv6Route");
	__xamarin_class_map [628].handle = objc_getClass ("NEIPv6Settings");
	__xamarin_class_map [629].handle = objc_getClass ("NEOnDemandRule");
	__xamarin_class_map [630].handle = objc_getClass ("NEOnDemandRuleConnect");
	__xamarin_class_map [631].handle = objc_getClass ("NEOnDemandRuleDisconnect");
	__xamarin_class_map [632].handle = objc_getClass ("NEOnDemandRuleEvaluateConnection");
	__xamarin_class_map [633].handle = objc_getClass ("NEOnDemandRuleIgnore");
	__xamarin_class_map [634].handle = objc_getClass ("NEPacket");
	__xamarin_class_map [635].handle = objc_getClass ("NEPrivateLTENetwork");
	__xamarin_class_map [636].handle = objc_getClass ("NEProxyServer");
	__xamarin_class_map [637].handle = objc_getClass ("NEProxySettings");
	__xamarin_class_map [638].handle = objc_getClass ("NETunnelProviderProtocol");
	__xamarin_class_map [639].handle = objc_getClass ("NEVPNConnection");
	__xamarin_class_map [640].handle = objc_getClass ("NETunnelProviderSession");
	__xamarin_class_map [641].handle = objc_getClass ("NEVPNIKEv2SecurityAssociationParameters");
	__xamarin_class_map [642].handle = objc_getClass ("NEVPNProtocolIPSec");
	__xamarin_class_map [643].handle = objc_getClass ("NEVPNProtocolIKEv2");
	__xamarin_class_map [644].handle = objc_getClass ("NWBonjourServiceEndpoint");
	__xamarin_class_map [645].handle = objc_getClass ("NWTLSParameters");
	__xamarin_class_map [646].handle = objc_getClass ("NINearbyObject");
	__xamarin_class_map [647].handle = objc_getClass ("NIAlgorithmConvergence");
	__xamarin_class_map [648].handle = objc_getClass ("NIConfiguration");
	__xamarin_class_map [649].handle = objc_getClass ("NIDiscoveryToken");
	__xamarin_class_map [650].handle = objc_getClass ("NINearbyAccessoryConfiguration");
	__xamarin_class_map [651].handle = objc_getClass ("NINearbyPeerConfiguration");
	__xamarin_class_map [652].handle = objc_getClass ("NISession");
	__xamarin_class_map [653].handle = objc_getClass ("Xamarin_iOS__NearbyInteraction_NISessionDelegate");
	__xamarin_class_map [654].handle = objc_getClass ("NLModel");
	__xamarin_class_map [655].handle = objc_getClass ("NLGazetteer");
	__xamarin_class_map [656].handle = objc_getClass ("NLModelConfiguration");
	__xamarin_class_map [657].handle = objc_getClass ("NLTokenizer");
	__xamarin_class_map [658].handle = objc_getClass ("MCPeerID");
	__xamarin_class_map [659].handle = objc_getClass ("MCAdvertiserAssistant");
	__xamarin_class_map [660].handle = objc_getClass ("MCAdvertiserAssistantDelegate");
	__xamarin_class_map [661].handle = objc_getClass ("MCBrowserViewController");
	__xamarin_class_map [662].handle = objc_getClass ("MCBrowserViewControllerDelegate");
	__xamarin_class_map [663].handle = objc_getClass ("MCNearbyServiceAdvertiser");
	__xamarin_class_map [664].handle = objc_getClass ("MCNearbyServiceAdvertiserDelegate");
	__xamarin_class_map [665].handle = objc_getClass ("MCNearbyServiceBrowser");
	__xamarin_class_map [666].handle = objc_getClass ("MCNearbyServiceBrowserDelegate");
	__xamarin_class_map [667].handle = objc_getClass ("MCSessionDelegate");
	__xamarin_class_map [668].handle = objc_getClass ("MDLAnimatedValue");
	__xamarin_class_map [669].handle = objc_getClass ("MDLAnimatedQuaternion");
	__xamarin_class_map [670].handle = objc_getClass ("MDLAnimatedScalarArray");
	__xamarin_class_map [671].handle = objc_getClass ("MDLAnimatedVector3Array");
	__xamarin_class_map [672].handle = objc_getClass ("MDLAnimatedQuaternionArray");
	__xamarin_class_map [673].handle = objc_getClass ("MDLAnimatedScalar");
	__xamarin_class_map [674].handle = objc_getClass ("MDLAnimatedVector2");
	__xamarin_class_map [675].handle = objc_getClass ("MDLAnimatedVector3");
	__xamarin_class_map [676].handle = objc_getClass ("MDLAnimatedVector4");
	__xamarin_class_map [677].handle = objc_getClass ("MDLAnimatedMatrix4x4");
	__xamarin_class_map [678].handle = objc_getClass ("MDLMatrix4x4Array");
	__xamarin_class_map [679].handle = objc_getClass ("MDLAsset");
	__xamarin_class_map [680].handle = objc_getClass ("MDLTexture");
	__xamarin_class_map [681].handle = objc_getClass ("MDLNoiseTexture");
	__xamarin_class_map [682].handle = objc_getClass ("MDLTransform");
	__xamarin_class_map [683].handle = objc_getClass ("MDLVertexDescriptor");
	__xamarin_class_map [684].handle = objc_getClass ("MDLAnimationBindComponent");
	__xamarin_class_map [685].handle = objc_getClass ("MDLObject");
	__xamarin_class_map [686].handle = objc_getClass ("MDLLight");
	__xamarin_class_map [687].handle = objc_getClass ("MDLPhysicallyPlausibleLight");
	__xamarin_class_map [688].handle = objc_getClass ("MDLAreaLight");
	__xamarin_class_map [689].handle = objc_getClass ("MDLBundleAssetResolver");
	__xamarin_class_map [690].handle = objc_getClass ("MDLCamera");
	__xamarin_class_map [691].handle = objc_getClass ("MDLCheckerboardTexture");
	__xamarin_class_map [692].handle = objc_getClass ("MDLColorSwatchTexture");
	__xamarin_class_map [693].handle = objc_getClass ("MDLLightProbe");
	__xamarin_class_map [694].handle = objc_getClass ("MDLLightProbeIrradianceDataSource");
	__xamarin_class_map [695].handle = objc_getClass ("MDLMaterial");
	__xamarin_class_map [696].handle = objc_getClass ("MDLMaterialProperty");
	__xamarin_class_map [697].handle = objc_getClass ("MDLMaterialPropertyConnection");
	__xamarin_class_map [698].handle = objc_getClass ("MDLMaterialPropertyNode");
	__xamarin_class_map [699].handle = objc_getClass ("MDLMaterialPropertyGraph");
	__xamarin_class_map [700].handle = objc_getClass ("MDLMeshBufferData");
	__xamarin_class_map [701].handle = objc_getClass ("MDLMeshBufferDataAllocator");
	__xamarin_class_map [702].handle = objc_getClass ("MDLMeshBufferMap");
	__xamarin_class_map [703].handle = objc_getClass ("MDLMeshBufferZoneDefault");
	__xamarin_class_map [704].handle = objc_getClass ("MDLNormalMapTexture");
	__xamarin_class_map [705].handle = objc_getClass ("MDLObjectContainer");
	__xamarin_class_map [706].handle = objc_getClass ("MDLPackedJointAnimation");
	__xamarin_class_map [707].handle = objc_getClass ("MDLPathAssetResolver");
	__xamarin_class_map [708].handle = objc_getClass ("MDLPhotometricLight");
	__xamarin_class_map [709].handle = objc_getClass ("MDLScatteringFunction");
	__xamarin_class_map [710].handle = objc_getClass ("MDLPhysicallyPlausibleScatteringFunction");
	__xamarin_class_map [711].handle = objc_getClass ("MDLRelativeAssetResolver");
	__xamarin_class_map [712].handle = objc_getClass ("MDLSkeleton");
	__xamarin_class_map [713].handle = objc_getClass ("MDLSkyCubeTexture");
	__xamarin_class_map [714].handle = objc_getClass ("MDLStereoscopicCamera");
	__xamarin_class_map [715].handle = objc_getClass ("MDLSubmesh");
	__xamarin_class_map [716].handle = objc_getClass ("MDLSubmeshTopology");
	__xamarin_class_map [717].handle = objc_getClass ("MDLTextureFilter");
	__xamarin_class_map [718].handle = objc_getClass ("MDLTextureSampler");
	__xamarin_class_map [719].handle = objc_getClass ("MDLTransformMatrixOp");
	__xamarin_class_map [720].handle = objc_getClass ("MDLTransformOrientOp");
	__xamarin_class_map [721].handle = objc_getClass ("MDLTransformRotateOp");
	__xamarin_class_map [722].handle = objc_getClass ("MDLTransformRotateXOp");
	__xamarin_class_map [723].handle = objc_getClass ("MDLTransformRotateYOp");
	__xamarin_class_map [724].handle = objc_getClass ("MDLTransformRotateZOp");
	__xamarin_class_map [725].handle = objc_getClass ("MDLTransformScaleOp");
	__xamarin_class_map [726].handle = objc_getClass ("MDLTransformStack");
	__xamarin_class_map [727].handle = objc_getClass ("MDLTransformTranslateOp");
	__xamarin_class_map [728].handle = objc_getClass ("MDLURLTexture");
	__xamarin_class_map [729].handle = objc_getClass ("MDLVertexAttribute");
	__xamarin_class_map [730].handle = objc_getClass ("MDLVertexAttributeData");
	__xamarin_class_map [731].handle = objc_getClass ("MDLVertexBufferLayout");
	__xamarin_class_map [732].handle = objc_getClass ("MDLVoxelArray");
	__xamarin_class_map [733].handle = objc_getClass ("MXMetaData");
	__xamarin_class_map [734].handle = objc_getClass ("MXMetric");
	__xamarin_class_map [735].handle = objc_getClass ("MXMetricManager");
	__xamarin_class_map [736].handle = objc_getClass ("MXMetricPayload");
	__xamarin_class_map [737].handle = objc_getClass ("MXAnimationMetric");
	__xamarin_class_map [738].handle = objc_getClass ("MXAppExitMetric");
	__xamarin_class_map [739].handle = objc_getClass ("MXDiagnostic");
	__xamarin_class_map [740].handle = objc_getClass ("MXAppLaunchDiagnostic");
	__xamarin_class_map [741].handle = objc_getClass ("MXAppLaunchMetric");
	__xamarin_class_map [742].handle = objc_getClass ("MXAppResponsivenessMetric");
	__xamarin_class_map [743].handle = objc_getClass ("MXAppRunTimeMetric");
	__xamarin_class_map [744].handle = objc_getClass ("MXAverage");
	__xamarin_class_map [745].handle = objc_getClass ("MXBackgroundExitData");
	__xamarin_class_map [746].handle = objc_getClass ("MXCallStackTree");
	__xamarin_class_map [747].handle = objc_getClass ("MXCellularConditionMetric");
	__xamarin_class_map [748].handle = objc_getClass ("MXCPUExceptionDiagnostic");
	__xamarin_class_map [749].handle = objc_getClass ("MXCPUMetric");
	__xamarin_class_map [750].handle = objc_getClass ("MXCrashDiagnostic");
	__xamarin_class_map [751].handle = objc_getClass ("MXDiagnosticPayload");
	__xamarin_class_map [752].handle = objc_getClass ("MXDiskIOMetric");
	__xamarin_class_map [753].handle = objc_getClass ("MXDiskWriteExceptionDiagnostic");
	__xamarin_class_map [754].handle = objc_getClass ("MXDisplayMetric");
	__xamarin_class_map [755].handle = objc_getClass ("MXForegroundExitData");
	__xamarin_class_map [756].handle = objc_getClass ("MXGPUMetric");
	__xamarin_class_map [757].handle = objc_getClass ("MXHangDiagnostic");
	__xamarin_class_map [758].handle = objc_getClass ("MXHistogram");
	__xamarin_class_map [759].handle = objc_getClass ("MXHistogramBucket");
	__xamarin_class_map [760].handle = objc_getClass ("MXLocationActivityMetric");
	__xamarin_class_map [761].handle = objc_getClass ("MXMemoryMetric");
	__xamarin_class_map [762].handle = objc_getClass ("MXNetworkTransferMetric");
	__xamarin_class_map [763].handle = objc_getClass ("MXSignpostIntervalData");
	__xamarin_class_map [764].handle = objc_getClass ("MXSignpostMetric");
	__xamarin_class_map [765].handle = objc_getClass ("NSUnit");
	__xamarin_class_map [766].handle = objc_getClass ("NSDimension");
	__xamarin_class_map [767].handle = objc_getClass ("MXUnitAveragePixelLuminance");
	__xamarin_class_map [768].handle = objc_getClass ("MXUnitSignalBars");
	__xamarin_class_map [769].handle = objc_getClass ("MPSGraph");
	__xamarin_class_map [770].handle = objc_getClass ("MPSGraphCompilationDescriptor");
	__xamarin_class_map [771].handle = objc_getClass ("MPSGraphConvolution2DOpDescriptor");
	__xamarin_class_map [772].handle = objc_getClass ("MPSGraphCreateSparseOpDescriptor");
	__xamarin_class_map [773].handle = objc_getClass ("MPSGraphDepthwiseConvolution2DOpDescriptor");
	__xamarin_class_map [774].handle = objc_getClass ("MPSGraphDevice");
	__xamarin_class_map [775].handle = objc_getClass ("MPSGraphExecutable");
	__xamarin_class_map [776].handle = objc_getClass ("MPSGraphExecutableExecutionDescriptor");
	__xamarin_class_map [777].handle = objc_getClass ("MPSGraphExecutionDescriptor");
	__xamarin_class_map [778].handle = objc_getClass ("MPSGraphOperation");
	__xamarin_class_map [779].handle = objc_getClass ("MPSGraphPooling2DOpDescriptor");
	__xamarin_class_map [780].handle = objc_getClass ("MPSGraphRandomOpDescriptor");
	__xamarin_class_map [781].handle = objc_getClass ("MPSGraphType");
	__xamarin_class_map [782].handle = objc_getClass ("MPSCNNConvolutionDescriptor");
	__xamarin_class_map [783].handle = objc_getClass ("MPSKernel");
	__xamarin_class_map [784].handle = objc_getClass ("MPSCNNKernel");
	__xamarin_class_map [785].handle = objc_getClass ("MPSCNNBinaryConvolution");
	__xamarin_class_map [786].handle = objc_getClass ("MPSCNNBinaryFullyConnected");
	__xamarin_class_map [787].handle = objc_getClass ("MPSCNNNeuron");
	__xamarin_class_map [788].handle = objc_getClass ("MPSCNNNeuronPReLU");
	__xamarin_class_map [789].handle = objc_getClass ("MPSNNFilterNode");
	__xamarin_class_map [790].handle = objc_getClass ("MPSCNNConvolutionNode");
	__xamarin_class_map [791].handle = objc_getClass ("MPSCNNConvolutionTransposeNode");
	__xamarin_class_map [792].handle = objc_getClass ("MPSCNNConvolutionTranspose");
	__xamarin_class_map [793].handle = objc_getClass ("MPSCNNConvolution");
	__xamarin_class_map [794].handle = objc_getClass ("MPSState");
	__xamarin_class_map [795].handle = objc_getClass ("MetalPerformanceShaders_MPSCnnConvolutionState");
	__xamarin_class_map [796].handle = objc_getClass ("MPSImageHistogram");
	__xamarin_class_map [797].handle = objc_getClass ("MPSUnaryImageKernel");
	__xamarin_class_map [798].handle = objc_getClass ("MPSImageScale");
	__xamarin_class_map [799].handle = objc_getClass ("MPSImage");
	__xamarin_class_map [800].handle = objc_getClass ("MPSImageDilate");
	__xamarin_class_map [801].handle = objc_getClass ("MPSImageErode");
	__xamarin_class_map [802].handle = objc_getClass ("MPSImageThresholdBinary");
	__xamarin_class_map [803].handle = objc_getClass ("MPSImageThresholdBinaryInverse");
	__xamarin_class_map [804].handle = objc_getClass ("MPSImageThresholdTruncate");
	__xamarin_class_map [805].handle = objc_getClass ("MPSImageThresholdToZero");
	__xamarin_class_map [806].handle = objc_getClass ("MPSImageThresholdToZeroInverse");
	__xamarin_class_map [807].handle = objc_getClass ("MPSImageSobel");
	__xamarin_class_map [808].handle = objc_getClass ("MPSCNNFullyConnected");
	__xamarin_class_map [809].handle = objc_getClass ("MPSImageConversion");
	__xamarin_class_map [810].handle = objc_getClass ("MPSImagePyramid");
	__xamarin_class_map [811].handle = objc_getClass ("MPSImageGaussianPyramid");
	__xamarin_class_map [812].handle = objc_getClass ("MPSImageLaplacianPyramid");
	__xamarin_class_map [813].handle = objc_getClass ("MPSImageLaplacianPyramidSubtract");
	__xamarin_class_map [814].handle = objc_getClass ("MPSImageLaplacianPyramidAdd");
	__xamarin_class_map [815].handle = objc_getClass ("MPSCNNBinaryConvolutionNode");
	__xamarin_class_map [816].handle = objc_getClass ("MPSCNNBinaryFullyConnectedNode");
	__xamarin_class_map [817].handle = objc_getClass ("MPSMatrixDescriptor");
	__xamarin_class_map [818].handle = objc_getClass ("MPSNDArray");
	__xamarin_class_map [819].handle = objc_getClass ("MPSStateResourceList");
	__xamarin_class_map [820].handle = objc_getClass ("MPSAccelerationStructureGroup");
	__xamarin_class_map [821].handle = objc_getClass ("MPSBinaryImageKernel");
	__xamarin_class_map [822].handle = objc_getClass ("MPSCNNBinaryKernel");
	__xamarin_class_map [823].handle = objc_getClass ("MPSCNNArithmetic");
	__xamarin_class_map [824].handle = objc_getClass ("MPSCNNAdd");
	__xamarin_class_map [825].handle = objc_getClass ("MPSCNNGradientKernel");
	__xamarin_class_map [826].handle = objc_getClass ("MPSCNNArithmeticGradient");
	__xamarin_class_map [827].handle = objc_getClass ("MPSCNNAddGradient");
	__xamarin_class_map [828].handle = objc_getClass ("MPSNNBinaryGradientState");
	__xamarin_class_map [829].handle = objc_getClass ("MPSCNNArithmeticGradientState");
	__xamarin_class_map [830].handle = objc_getClass ("MPSCNNBatchNormalization");
	__xamarin_class_map [831].handle = objc_getClass ("Xamarin_iOS__MetalPerformanceShaders_MPSCnnBatchNormalizationDataSource");
	__xamarin_class_map [832].handle = objc_getClass ("MPSCNNBatchNormalizationGradient");
	__xamarin_class_map [833].handle = objc_getClass ("MPSNNGradientFilterNode");
	__xamarin_class_map [834].handle = objc_getClass ("MPSCNNBatchNormalizationGradientNode");
	__xamarin_class_map [835].handle = objc_getClass ("MPSCNNBatchNormalizationNode");
	__xamarin_class_map [836].handle = objc_getClass ("MPSNNGradientState");
	__xamarin_class_map [837].handle = objc_getClass ("MPSCNNBatchNormalizationState");
	__xamarin_class_map [838].handle = objc_getClass ("MPSCNNBatchNormalizationStatistics");
	__xamarin_class_map [839].handle = objc_getClass ("MPSCNNBatchNormalizationStatisticsGradient");
	__xamarin_class_map [840].handle = objc_getClass ("MPSCNNConvolutionDataSource");
	__xamarin_class_map [841].handle = objc_getClass ("MPSCNNConvolutionGradient");
	__xamarin_class_map [842].handle = objc_getClass ("MPSCNNConvolutionGradientNode");
	__xamarin_class_map [843].handle = objc_getClass ("MPSCNNConvolutionGradientState");
	__xamarin_class_map [844].handle = objc_getClass ("MPSNNStateNode");
	__xamarin_class_map [845].handle = objc_getClass ("MPSNNGradientStateNode");
	__xamarin_class_map [846].handle = objc_getClass ("MPSCNNConvolutionGradientStateNode");
	__xamarin_class_map [847].handle = objc_getClass ("MPSCNNConvolutionStateNode");
	__xamarin_class_map [848].handle = objc_getClass ("MPSCNNConvolutionWeightsAndBiasesState");
	__xamarin_class_map [849].handle = objc_getClass ("MPSCNNCrossChannelNormalization");
	__xamarin_class_map [850].handle = objc_getClass ("MPSCNNCrossChannelNormalizationGradient");
	__xamarin_class_map [851].handle = objc_getClass ("MPSCNNCrossChannelNormalizationGradientNode");
	__xamarin_class_map [852].handle = objc_getClass ("MPSCNNNormalizationNode");
	__xamarin_class_map [853].handle = objc_getClass ("MPSCNNCrossChannelNormalizationNode");
	__xamarin_class_map [854].handle = objc_getClass ("MPSCNNDepthWiseConvolutionDescriptor");
	__xamarin_class_map [855].handle = objc_getClass ("MPSCNNPooling");
	__xamarin_class_map [856].handle = objc_getClass ("MPSCNNDilatedPoolingMax");
	__xamarin_class_map [857].handle = objc_getClass ("MPSCNNPoolingGradient");
	__xamarin_class_map [858].handle = objc_getClass ("MPSCNNDilatedPoolingMaxGradient");
	__xamarin_class_map [859].handle = objc_getClass ("MPSCNNPoolingGradientNode");
	__xamarin_class_map [860].handle = objc_getClass ("MPSCNNDilatedPoolingMaxGradientNode");
	__xamarin_class_map [861].handle = objc_getClass ("MPSCNNDilatedPoolingMaxNode");
	__xamarin_class_map [862].handle = objc_getClass ("MPSCNNDivide");
	__xamarin_class_map [863].handle = objc_getClass ("MPSCNNDropout");
	__xamarin_class_map [864].handle = objc_getClass ("MPSCNNDropoutGradient");
	__xamarin_class_map [865].handle = objc_getClass ("MPSCNNDropoutGradientNode");
	__xamarin_class_map [866].handle = objc_getClass ("MPSCNNDropoutGradientState");
	__xamarin_class_map [867].handle = objc_getClass ("MPSCNNDropoutNode");
	__xamarin_class_map [868].handle = objc_getClass ("MPSCNNFullyConnectedGradient");
	__xamarin_class_map [869].handle = objc_getClass ("MPSCNNFullyConnectedNode");
	__xamarin_class_map [870].handle = objc_getClass ("MPSCNNInstanceNormalization");
	__xamarin_class_map [871].handle = objc_getClass ("Xamarin_iOS__MetalPerformanceShaders_MPSCnnInstanceNormalizationDataSource");
	__xamarin_class_map [872].handle = objc_getClass ("MPSCNNInstanceNormalizationGradient");
	__xamarin_class_map [873].handle = objc_getClass ("MPSCNNInstanceNormalizationGradientNode");
	__xamarin_class_map [874].handle = objc_getClass ("MPSCNNInstanceNormalizationGradientState");
	__xamarin_class_map [875].handle = objc_getClass ("MPSCNNInstanceNormalizationNode");
	__xamarin_class_map [876].handle = objc_getClass ("MPSCNNLocalContrastNormalization");
	__xamarin_class_map [877].handle = objc_getClass ("MPSCNNLocalContrastNormalizationGradient");
	__xamarin_class_map [878].handle = objc_getClass ("MPSCNNLocalContrastNormalizationGradientNode");
	__xamarin_class_map [879].handle = objc_getClass ("MPSCNNLocalContrastNormalizationNode");
	__xamarin_class_map [880].handle = objc_getClass ("MPSCNNLogSoftMax");
	__xamarin_class_map [881].handle = objc_getClass ("MPSCNNLogSoftMaxGradient");
	__xamarin_class_map [882].handle = objc_getClass ("MPSCNNLogSoftMaxGradientNode");
	__xamarin_class_map [883].handle = objc_getClass ("MPSCNNLogSoftMaxNode");
	__xamarin_class_map [884].handle = objc_getClass ("MPSCNNLoss");
	__xamarin_class_map [885].handle = objc_getClass ("MPSCNNLossDataDescriptor");
	__xamarin_class_map [886].handle = objc_getClass ("MPSCNNLossDescriptor");
	__xamarin_class_map [887].handle = objc_getClass ("MPSCNNLossLabels");
	__xamarin_class_map [888].handle = objc_getClass ("MPSCNNLossNode");
	__xamarin_class_map [889].handle = objc_getClass ("MPSCNNMultiply");
	__xamarin_class_map [890].handle = objc_getClass ("MPSCNNMultiplyGradient");
	__xamarin_class_map [891].handle = objc_getClass ("MPSCNNNeuronAbsolute");
	__xamarin_class_map [892].handle = objc_getClass ("MPSCNNNeuronNode");
	__xamarin_class_map [893].handle = objc_getClass ("MPSCNNNeuronAbsoluteNode");
	__xamarin_class_map [894].handle = objc_getClass ("MPSCNNNeuronELU");
	__xamarin_class_map [895].handle = objc_getClass ("MPSCNNNeuronELUNode");
	__xamarin_class_map [896].handle = objc_getClass ("MPSCNNNeuronExponential");
	__xamarin_class_map [897].handle = objc_getClass ("MPSCNNNeuronExponentialNode");
	__xamarin_class_map [898].handle = objc_getClass ("MPSCNNNeuronGradient");
	__xamarin_class_map [899].handle = objc_getClass ("MPSCNNNeuronGradientNode");
	__xamarin_class_map [900].handle = objc_getClass ("MPSCNNNeuronHardSigmoid");
	__xamarin_class_map [901].handle = objc_getClass ("MPSCNNNeuronHardSigmoidNode");
	__xamarin_class_map [902].handle = objc_getClass ("MPSCNNNeuronLinear");
	__xamarin_class_map [903].handle = objc_getClass ("MPSCNNNeuronLinearNode");
	__xamarin_class_map [904].handle = objc_getClass ("MPSCNNNeuronLogarithm");
	__xamarin_class_map [905].handle = objc_getClass ("MPSCNNNeuronLogarithmNode");
	__xamarin_class_map [906].handle = objc_getClass ("MPSCNNNeuronPower");
	__xamarin_class_map [907].handle = objc_getClass ("MPSCNNNeuronPowerNode");
	__xamarin_class_map [908].handle = objc_getClass ("MPSCNNNeuronPReLUNode");
	__xamarin_class_map [909].handle = objc_getClass ("MPSCNNNeuronReLU");
	__xamarin_class_map [910].handle = objc_getClass ("MPSCNNNeuronReLUN");
	__xamarin_class_map [911].handle = objc_getClass ("MPSCNNNeuronReLUNNode");
	__xamarin_class_map [912].handle = objc_getClass ("MPSCNNNeuronReLUNode");
	__xamarin_class_map [913].handle = objc_getClass ("MPSCNNNeuronSigmoid");
	__xamarin_class_map [914].handle = objc_getClass ("MPSCNNNeuronSigmoidNode");
	__xamarin_class_map [915].handle = objc_getClass ("MPSCNNNeuronSoftPlus");
	__xamarin_class_map [916].handle = objc_getClass ("MPSCNNNeuronSoftPlusNode");
	__xamarin_class_map [917].handle = objc_getClass ("MPSCNNNeuronSoftSign");
	__xamarin_class_map [918].handle = objc_getClass ("MPSCNNNeuronSoftSignNode");
	__xamarin_class_map [919].handle = objc_getClass ("MPSCNNNeuronTanH");
	__xamarin_class_map [920].handle = objc_getClass ("MPSCNNNeuronTanHNode");
	__xamarin_class_map [921].handle = objc_getClass ("MPSCNNNormalizationGammaAndBetaState");
	__xamarin_class_map [922].handle = objc_getClass ("MPSCNNNormalizationMeanAndVarianceState");
	__xamarin_class_map [923].handle = objc_getClass ("MPSCNNPoolingAverage");
	__xamarin_class_map [924].handle = objc_getClass ("MPSCNNPoolingAverageGradient");
	__xamarin_class_map [925].handle = objc_getClass ("MPSCNNPoolingAverageGradientNode");
	__xamarin_class_map [926].handle = objc_getClass ("MPSCNNPoolingNode");
	__xamarin_class_map [927].handle = objc_getClass ("MPSCNNPoolingAverageNode");
	__xamarin_class_map [928].handle = objc_getClass ("MPSCNNPoolingL2Norm");
	__xamarin_class_map [929].handle = objc_getClass ("MPSCNNPoolingL2NormGradient");
	__xamarin_class_map [930].handle = objc_getClass ("MPSCNNPoolingL2NormGradientNode");
	__xamarin_class_map [931].handle = objc_getClass ("MPSCNNPoolingL2NormNode");
	__xamarin_class_map [932].handle = objc_getClass ("MPSCNNPoolingMax");
	__xamarin_class_map [933].handle = objc_getClass ("MPSCNNPoolingMaxGradient");
	__xamarin_class_map [934].handle = objc_getClass ("MPSCNNPoolingMaxGradientNode");
	__xamarin_class_map [935].handle = objc_getClass ("MPSCNNPoolingMaxNode");
	__xamarin_class_map [936].handle = objc_getClass ("MPSCNNSoftMax");
	__xamarin_class_map [937].handle = objc_getClass ("MPSCNNSoftMaxGradient");
	__xamarin_class_map [938].handle = objc_getClass ("MPSCNNSoftMaxGradientNode");
	__xamarin_class_map [939].handle = objc_getClass ("MPSCNNSoftMaxNode");
	__xamarin_class_map [940].handle = objc_getClass ("MPSCNNSpatialNormalization");
	__xamarin_class_map [941].handle = objc_getClass ("MPSCNNSpatialNormalizationGradient");
	__xamarin_class_map [942].handle = objc_getClass ("MPSCNNSpatialNormalizationGradientNode");
	__xamarin_class_map [943].handle = objc_getClass ("MPSCNNSpatialNormalizationNode");
	__xamarin_class_map [944].handle = objc_getClass ("MPSCNNSubPixelConvolutionDescriptor");
	__xamarin_class_map [945].handle = objc_getClass ("MPSCNNSubtract");
	__xamarin_class_map [946].handle = objc_getClass ("MPSCNNSubtractGradient");
	__xamarin_class_map [947].handle = objc_getClass ("MPSCNNUpsampling");
	__xamarin_class_map [948].handle = objc_getClass ("MPSCNNUpsamplingBilinear");
	__xamarin_class_map [949].handle = objc_getClass ("MPSCNNUpsamplingGradient");
	__xamarin_class_map [950].handle = objc_getClass ("MPSCNNUpsamplingBilinearGradient");
	__xamarin_class_map [951].handle = objc_getClass ("MPSCNNUpsamplingBilinearGradientNode");
	__xamarin_class_map [952].handle = objc_getClass ("MPSCNNUpsamplingBilinearNode");
	__xamarin_class_map [953].handle = objc_getClass ("MPSCNNUpsamplingNearest");
	__xamarin_class_map [954].handle = objc_getClass ("MPSCNNUpsamplingNearestGradient");
	__xamarin_class_map [955].handle = objc_getClass ("MPSCNNUpsamplingNearestGradientNode");
	__xamarin_class_map [956].handle = objc_getClass ("MPSCNNUpsamplingNearestNode");
	__xamarin_class_map [957].handle = objc_getClass ("MPSCNNYOLOLoss");
	__xamarin_class_map [958].handle = objc_getClass ("MPSCNNYOLOLossDescriptor");
	__xamarin_class_map [959].handle = objc_getClass ("MPSCNNYOLOLossNode");
	__xamarin_class_map [960].handle = objc_getClass ("MPSCommandBuffer");
	__xamarin_class_map [961].handle = objc_getClass ("MPSRNNDescriptor");
	__xamarin_class_map [962].handle = objc_getClass ("MPSGRUDescriptor");
	__xamarin_class_map [963].handle = objc_getClass ("MPSImageArithmetic");
	__xamarin_class_map [964].handle = objc_getClass ("MPSImageAdd");
	__xamarin_class_map [965].handle = objc_getClass ("MPSImageAreaMax");
	__xamarin_class_map [966].handle = objc_getClass ("MPSImageAreaMin");
	__xamarin_class_map [967].handle = objc_getClass ("MPSImageBilinearScale");
	__xamarin_class_map [968].handle = objc_getClass ("MPSImageBox");
	__xamarin_class_map [969].handle = objc_getClass ("MPSImageConvolution");
	__xamarin_class_map [970].handle = objc_getClass ("MPSImageCopyToMatrix");
	__xamarin_class_map [971].handle = objc_getClass ("MPSImageDescriptor");
	__xamarin_class_map [972].handle = objc_getClass ("MPSImageDivide");
	__xamarin_class_map [973].handle = objc_getClass ("MPSImageEuclideanDistanceTransform");
	__xamarin_class_map [974].handle = objc_getClass ("MPSImageFindKeypoints");
	__xamarin_class_map [975].handle = objc_getClass ("MPSImageGaussianBlur");
	__xamarin_class_map [976].handle = objc_getClass ("MPSImageGuidedFilter");
	__xamarin_class_map [977].handle = objc_getClass ("MPSImageHistogramEqualization");
	__xamarin_class_map [978].handle = objc_getClass ("MPSImageHistogramSpecification");
	__xamarin_class_map [979].handle = objc_getClass ("MPSImageIntegral");
	__xamarin_class_map [980].handle = objc_getClass ("MPSImageIntegralOfSquares");
	__xamarin_class_map [981].handle = objc_getClass ("MPSImageLanczosScale");
	__xamarin_class_map [982].handle = objc_getClass ("MPSImageLaplacian");
	__xamarin_class_map [983].handle = objc_getClass ("MPSImageMedian");
	__xamarin_class_map [984].handle = objc_getClass ("MPSImageMultiply");
	__xamarin_class_map [985].handle = objc_getClass ("MPSImageNormalizedHistogram");
	__xamarin_class_map [986].handle = objc_getClass ("MPSImageReduceUnary");
	__xamarin_class_map [987].handle = objc_getClass ("MPSImageReduceColumnMax");
	__xamarin_class_map [988].handle = objc_getClass ("MPSImageReduceColumnMean");
	__xamarin_class_map [989].handle = objc_getClass ("MPSImageReduceColumnMin");
	__xamarin_class_map [990].handle = objc_getClass ("MPSImageReduceColumnSum");
	__xamarin_class_map [991].handle = objc_getClass ("MPSImageReduceRowMax");
	__xamarin_class_map [992].handle = objc_getClass ("MPSImageReduceRowMean");
	__xamarin_class_map [993].handle = objc_getClass ("MPSImageReduceRowMin");
	__xamarin_class_map [994].handle = objc_getClass ("MPSImageReduceRowSum");
	__xamarin_class_map [995].handle = objc_getClass ("MPSImageStatisticsMean");
	__xamarin_class_map [996].handle = objc_getClass ("MPSImageStatisticsMeanAndVariance");
	__xamarin_class_map [997].handle = objc_getClass ("MPSImageStatisticsMinAndMax");
	__xamarin_class_map [998].handle = objc_getClass ("MPSImageSubtract");
	__xamarin_class_map [999].handle = objc_getClass ("MPSImageTent");
	__xamarin_class_map [1000].handle = objc_getClass ("MPSImageTranspose");
	__xamarin_class_map [1001].handle = objc_getClass ("MPSAccelerationStructure");
	__xamarin_class_map [1002].handle = objc_getClass ("MPSInstanceAccelerationStructure");
	__xamarin_class_map [1003].handle = objc_getClass ("NSCoder");
	__xamarin_class_map [1004].handle = objc_getClass ("NSKeyedUnarchiver");
	__xamarin_class_map [1005].handle = objc_getClass ("MPSKeyedUnarchiver");
	__xamarin_class_map [1006].handle = objc_getClass ("MPSLSTMDescriptor");
	__xamarin_class_map [1007].handle = objc_getClass ("MPSMatrix");
	__xamarin_class_map [1008].handle = objc_getClass ("MPSMatrixUnaryKernel");
	__xamarin_class_map [1009].handle = objc_getClass ("MPSMatrixBatchNormalization");
	__xamarin_class_map [1010].handle = objc_getClass ("MPSMatrixBinaryKernel");
	__xamarin_class_map [1011].handle = objc_getClass ("MPSMatrixBatchNormalizationGradient");
	__xamarin_class_map [1012].handle = objc_getClass ("MPSMatrixCopy");
	__xamarin_class_map [1013].handle = objc_getClass ("MPSMatrixCopyDescriptor");
	__xamarin_class_map [1014].handle = objc_getClass ("MPSMatrixCopyToImage");
	__xamarin_class_map [1015].handle = objc_getClass ("MPSMatrixDecompositionCholesky");
	__xamarin_class_map [1016].handle = objc_getClass ("MPSMatrixDecompositionLU");
	__xamarin_class_map [1017].handle = objc_getClass ("MPSMatrixFindTopK");
	__xamarin_class_map [1018].handle = objc_getClass ("MPSMatrixFullyConnected");
	__xamarin_class_map [1019].handle = objc_getClass ("MPSMatrixFullyConnectedGradient");
	__xamarin_class_map [1020].handle = objc_getClass ("MPSMatrixSoftMax");
	__xamarin_class_map [1021].handle = objc_getClass ("MPSMatrixLogSoftMax");
	__xamarin_class_map [1022].handle = objc_getClass ("MPSMatrixSoftMaxGradient");
	__xamarin_class_map [1023].handle = objc_getClass ("MPSMatrixLogSoftMaxGradient");
	__xamarin_class_map [1024].handle = objc_getClass ("MPSMatrixMultiplication");
	__xamarin_class_map [1025].handle = objc_getClass ("MPSMatrixNeuron");
	__xamarin_class_map [1026].handle = objc_getClass ("MPSMatrixNeuronGradient");
	__xamarin_class_map [1027].handle = objc_getClass ("MPSMatrixRandom");
	__xamarin_class_map [1028].handle = objc_getClass ("MPSMatrixRandomDistributionDescriptor");
	__xamarin_class_map [1029].handle = objc_getClass ("MPSMatrixRandomMTGP32");
	__xamarin_class_map [1030].handle = objc_getClass ("MPSMatrixRandomPhilox");
	__xamarin_class_map [1031].handle = objc_getClass ("MPSMatrixSolveCholesky");
	__xamarin_class_map [1032].handle = objc_getClass ("MPSMatrixSolveLU");
	__xamarin_class_map [1033].handle = objc_getClass ("MPSMatrixSolveTriangular");
	__xamarin_class_map [1034].handle = objc_getClass ("MPSMatrixSum");
	__xamarin_class_map [1035].handle = objc_getClass ("MPSMatrixVectorMultiplication");
	__xamarin_class_map [1036].handle = objc_getClass ("MPSNNArithmeticGradientNode");
	__xamarin_class_map [1037].handle = objc_getClass ("MPSNNAdditionGradientNode");
	__xamarin_class_map [1038].handle = objc_getClass ("MPSNNBinaryArithmeticNode");
	__xamarin_class_map [1039].handle = objc_getClass ("MPSNNAdditionNode");
	__xamarin_class_map [1040].handle = objc_getClass ("MPSNNBinaryGradientStateNode");
	__xamarin_class_map [1041].handle = objc_getClass ("MPSNNArithmeticGradientStateNode");
	__xamarin_class_map [1042].handle = objc_getClass ("MPSNNScaleNode");
	__xamarin_class_map [1043].handle = objc_getClass ("MPSNNBilinearScaleNode");
	__xamarin_class_map [1044].handle = objc_getClass ("MPSNNCompare");
	__xamarin_class_map [1045].handle = objc_getClass ("MPSNNComparisonNode");
	__xamarin_class_map [1046].handle = objc_getClass ("MPSNNConcatenationGradientNode");
	__xamarin_class_map [1047].handle = objc_getClass ("MPSNNConcatenationNode");
	__xamarin_class_map [1048].handle = objc_getClass ("MPSNNCropAndResizeBilinear");
	__xamarin_class_map [1049].handle = objc_getClass ("MPSNNDefaultPadding");
	__xamarin_class_map [1050].handle = objc_getClass ("MPSNNDivisionNode");
	__xamarin_class_map [1051].handle = objc_getClass ("MPSNNForwardLossNode");
	__xamarin_class_map [1052].handle = objc_getClass ("MPSNNImageNode");
	__xamarin_class_map [1053].handle = objc_getClass ("MPSNNInitialGradientNode");
	__xamarin_class_map [1054].handle = objc_getClass ("MPSNNLabelsNode");
	__xamarin_class_map [1055].handle = objc_getClass ("MPSNNLanczosScaleNode");
	__xamarin_class_map [1056].handle = objc_getClass ("MPSNNLossGradientNode");
	__xamarin_class_map [1057].handle = objc_getClass ("MPSNNMultiplicationGradientNode");
	__xamarin_class_map [1058].handle = objc_getClass ("MPSNNMultiplicationNode");
	__xamarin_class_map [1059].handle = objc_getClass ("MPSNNNeuronDescriptor");
	__xamarin_class_map [1060].handle = objc_getClass ("MPSNNOptimizer");
	__xamarin_class_map [1061].handle = objc_getClass ("MPSNNOptimizerAdam");
	__xamarin_class_map [1062].handle = objc_getClass ("MPSNNOptimizerDescriptor");
	__xamarin_class_map [1063].handle = objc_getClass ("MPSNNOptimizerRMSProp");
	__xamarin_class_map [1064].handle = objc_getClass ("MPSNNOptimizerStochasticGradientDescent");
	__xamarin_class_map [1065].handle = objc_getClass ("MPSNNPad");
	__xamarin_class_map [1066].handle = objc_getClass ("MPSNNPadGradient");
	__xamarin_class_map [1067].handle = objc_getClass ("MPSNNPadGradientNode");
	__xamarin_class_map [1068].handle = objc_getClass ("MPSNNPadNode");
	__xamarin_class_map [1069].handle = objc_getClass ("MPSNNReduceBinary");
	__xamarin_class_map [1070].handle = objc_getClass ("MPSNNReduceUnary");
	__xamarin_class_map [1071].handle = objc_getClass ("MPSNNReduceColumnMax");
	__xamarin_class_map [1072].handle = objc_getClass ("MPSNNReduceColumnMean");
	__xamarin_class_map [1073].handle = objc_getClass ("MPSNNReduceColumnMin");
	__xamarin_class_map [1074].handle = objc_getClass ("MPSNNReduceColumnSum");
	__xamarin_class_map [1075].handle = objc_getClass ("MPSNNReduceFeatureChannelsAndWeightsMean");
	__xamarin_class_map [1076].handle = objc_getClass ("MPSNNReduceFeatureChannelsAndWeightsSum");
	__xamarin_class_map [1077].handle = objc_getClass ("MPSNNReduceFeatureChannelsArgumentMax");
	__xamarin_class_map [1078].handle = objc_getClass ("MPSNNReduceFeatureChannelsArgumentMin");
	__xamarin_class_map [1079].handle = objc_getClass ("MPSNNReduceFeatureChannelsMax");
	__xamarin_class_map [1080].handle = objc_getClass ("MPSNNReduceFeatureChannelsMean");
	__xamarin_class_map [1081].handle = objc_getClass ("MPSNNReduceFeatureChannelsMin");
	__xamarin_class_map [1082].handle = objc_getClass ("MPSNNReduceFeatureChannelsSum");
	__xamarin_class_map [1083].handle = objc_getClass ("MPSNNReduceRowMax");
	__xamarin_class_map [1084].handle = objc_getClass ("MPSNNReduceRowMean");
	__xamarin_class_map [1085].handle = objc_getClass ("MPSNNReduceRowMin");
	__xamarin_class_map [1086].handle = objc_getClass ("MPSNNReduceRowSum");
	__xamarin_class_map [1087].handle = objc_getClass ("MPSNNUnaryReductionNode");
	__xamarin_class_map [1088].handle = objc_getClass ("MPSNNReductionColumnMaxNode");
	__xamarin_class_map [1089].handle = objc_getClass ("MPSNNReductionColumnMeanNode");
	__xamarin_class_map [1090].handle = objc_getClass ("MPSNNReductionColumnMinNode");
	__xamarin_class_map [1091].handle = objc_getClass ("MPSNNReductionColumnSumNode");
	__xamarin_class_map [1092].handle = objc_getClass ("MPSNNReductionFeatureChannelsArgumentMaxNode");
	__xamarin_class_map [1093].handle = objc_getClass ("MPSNNReductionFeatureChannelsArgumentMinNode");
	__xamarin_class_map [1094].handle = objc_getClass ("MPSNNReductionFeatureChannelsMaxNode");
	__xamarin_class_map [1095].handle = objc_getClass ("MPSNNReductionFeatureChannelsMeanNode");
	__xamarin_class_map [1096].handle = objc_getClass ("MPSNNReductionFeatureChannelsMinNode");
	__xamarin_class_map [1097].handle = objc_getClass ("MPSNNReductionFeatureChannelsSumNode");
	__xamarin_class_map [1098].handle = objc_getClass ("MPSNNReductionRowMaxNode");
	__xamarin_class_map [1099].handle = objc_getClass ("MPSNNReductionRowMeanNode");
	__xamarin_class_map [1100].handle = objc_getClass ("MPSNNReductionRowMinNode");
	__xamarin_class_map [1101].handle = objc_getClass ("MPSNNReductionRowSumNode");
	__xamarin_class_map [1102].handle = objc_getClass ("MPSNNReductionSpatialMeanGradientNode");
	__xamarin_class_map [1103].handle = objc_getClass ("MPSNNReductionSpatialMeanNode");
	__xamarin_class_map [1104].handle = objc_getClass ("MPSNNReshape");
	__xamarin_class_map [1105].handle = objc_getClass ("MPSNNReshapeGradient");
	__xamarin_class_map [1106].handle = objc_getClass ("MPSNNReshapeGradientNode");
	__xamarin_class_map [1107].handle = objc_getClass ("MPSNNReshapeNode");
	__xamarin_class_map [1108].handle = objc_getClass ("MPSNNResizeBilinear");
	__xamarin_class_map [1109].handle = objc_getClass ("MPSNNSlice");
	__xamarin_class_map [1110].handle = objc_getClass ("MPSNNSubtractionGradientNode");
	__xamarin_class_map [1111].handle = objc_getClass ("MPSNNSubtractionNode");
	__xamarin_class_map [1112].handle = objc_getClass ("MPSPredicate");
	__xamarin_class_map [1113].handle = objc_getClass ("MPSRayIntersector");
	__xamarin_class_map [1114].handle = objc_getClass ("MPSRNNImageInferenceLayer");
	__xamarin_class_map [1115].handle = objc_getClass ("MPSRNNMatrixInferenceLayer");
	__xamarin_class_map [1116].handle = objc_getClass ("MPSRNNMatrixTrainingLayer");
	__xamarin_class_map [1117].handle = objc_getClass ("MPSRNNMatrixTrainingState");
	__xamarin_class_map [1118].handle = objc_getClass ("MPSRNNRecurrentImageState");
	__xamarin_class_map [1119].handle = objc_getClass ("MPSRNNRecurrentMatrixState");
	__xamarin_class_map [1120].handle = objc_getClass ("MPSRNNSingleGateDescriptor");
	__xamarin_class_map [1121].handle = objc_getClass ("MPSTemporaryImage");
	__xamarin_class_map [1122].handle = objc_getClass ("MPSTemporaryMatrix");
	__xamarin_class_map [1123].handle = objc_getClass ("MPSTemporaryNDArray");
	__xamarin_class_map [1124].handle = objc_getClass ("MPSVector");
	__xamarin_class_map [1125].handle = objc_getClass ("MPSTemporaryVector");
	__xamarin_class_map [1126].handle = objc_getClass ("MPSTriangleAccelerationStructure");
	__xamarin_class_map [1127].handle = objc_getClass ("MPSVectorDescriptor");
	__xamarin_class_map [1128].handle = objc_getClass ("MTKMesh");
	__xamarin_class_map [1129].handle = objc_getClass ("MTKMeshBufferAllocator");
	__xamarin_class_map [1130].handle = objc_getClass ("MTKMeshBuffer");
	__xamarin_class_map [1131].handle = objc_getClass ("MTKSubmesh");
	__xamarin_class_map [1132].handle = objc_getClass ("MTKViewDelegate");
	__xamarin_class_map [1133].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptorArray");
	__xamarin_class_map [1134].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptorArray");
	__xamarin_class_map [1135].handle = objc_getClass ("MTLVertexAttributeDescriptorArray");
	__xamarin_class_map [1136].handle = objc_getClass ("MTLVertexBufferLayoutDescriptorArray");
	__xamarin_class_map [1137].handle = objc_getClass ("MTLBufferLayoutDescriptorArray");
	__xamarin_class_map [1138].handle = objc_getClass ("MTLAttributeDescriptorArray");
	__xamarin_class_map [1139].handle = objc_getClass ("MTLPipelineBufferDescriptorArray");
	__xamarin_class_map [1140].handle = objc_getClass ("MTLTileRenderPipelineColorAttachmentDescriptorArray");
	__xamarin_class_map [1141].handle = objc_getClass ("MTLBlitPassSampleBufferAttachmentDescriptorArray");
	__xamarin_class_map [1142].handle = objc_getClass ("MTLSharedTextureHandle");
	__xamarin_class_map [1143].handle = objc_getClass ("MTLComputePassSampleBufferAttachmentDescriptorArray");
	__xamarin_class_map [1144].handle = objc_getClass ("MTLRasterizationRateLayerDescriptor");
	__xamarin_class_map [1145].handle = objc_getClass ("MTLRenderPassDescriptor");
	__xamarin_class_map [1146].handle = objc_getClass ("MTLRenderPassSampleBufferAttachmentDescriptorArray");
	__xamarin_class_map [1147].handle = objc_getClass ("MTLResourceStatePassSampleBufferAttachmentDescriptorArray");
	__xamarin_class_map [1148].handle = objc_getClass ("MTLVertexDescriptor");
	__xamarin_class_map [1149].handle = objc_getClass ("MTLAccelerationStructureGeometryDescriptor");
	__xamarin_class_map [1150].handle = objc_getClass ("MTLAccelerationStructureBoundingBoxGeometryDescriptor");
	__xamarin_class_map [1151].handle = objc_getClass ("MTLAccelerationStructureDescriptor");
	__xamarin_class_map [1152].handle = objc_getClass ("MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor");
	__xamarin_class_map [1153].handle = objc_getClass ("MTLAccelerationStructureMotionTriangleGeometryDescriptor");
	__xamarin_class_map [1154].handle = objc_getClass ("MTLAccelerationStructureTriangleGeometryDescriptor");
	__xamarin_class_map [1155].handle = objc_getClass ("MTLArgument");
	__xamarin_class_map [1156].handle = objc_getClass ("MTLArgumentDescriptor");
	__xamarin_class_map [1157].handle = objc_getClass ("MTLType");
	__xamarin_class_map [1158].handle = objc_getClass ("MTLArrayType");
	__xamarin_class_map [1159].handle = objc_getClass ("MTLAttribute");
	__xamarin_class_map [1160].handle = objc_getClass ("MTLAttributeDescriptor");
	__xamarin_class_map [1161].handle = objc_getClass ("MTLBinaryArchiveDescriptor");
	__xamarin_class_map [1162].handle = objc_getClass ("MTLBlitPassDescriptor");
	__xamarin_class_map [1163].handle = objc_getClass ("MTLBlitPassSampleBufferAttachmentDescriptor");
	__xamarin_class_map [1164].handle = objc_getClass ("MTLBufferLayoutDescriptor");
	__xamarin_class_map [1165].handle = objc_getClass ("MTLCaptureDescriptor");
	__xamarin_class_map [1166].handle = objc_getClass ("MTLCaptureManager");
	__xamarin_class_map [1167].handle = objc_getClass ("Xamarin_iOS__Metal_MTLCaptureScope");
	__xamarin_class_map [1168].handle = objc_getClass ("MTLCommandBufferDescriptor");
	__xamarin_class_map [1169].handle = objc_getClass ("MTLCompileOptions");
	__xamarin_class_map [1170].handle = objc_getClass ("MTLComputePassDescriptor");
	__xamarin_class_map [1171].handle = objc_getClass ("MTLComputePassSampleBufferAttachmentDescriptor");
	__xamarin_class_map [1172].handle = objc_getClass ("MTLComputePipelineDescriptor");
	__xamarin_class_map [1173].handle = objc_getClass ("MTLComputePipelineReflection");
	__xamarin_class_map [1174].handle = objc_getClass ("MTLCounterSampleBufferDescriptor");
	__xamarin_class_map [1175].handle = objc_getClass ("MTLDepthStencilDescriptor");
	__xamarin_class_map [1176].handle = objc_getClass ("MTLDrawable");
	__xamarin_class_map [1177].handle = objc_getClass ("MTLFunctionConstant");
	__xamarin_class_map [1178].handle = objc_getClass ("MTLFunctionConstantValues");
	__xamarin_class_map [1179].handle = objc_getClass ("MTLFunctionDescriptor");
	__xamarin_class_map [1180].handle = objc_getClass ("MTLFunctionStitchingFunctionNode");
	__xamarin_class_map [1181].handle = objc_getClass ("MTLFunctionStitchingGraph");
	__xamarin_class_map [1182].handle = objc_getClass ("MTLFunctionStitchingInputNode");
	__xamarin_class_map [1183].handle = objc_getClass ("MTLHeapDescriptor");
	__xamarin_class_map [1184].handle = objc_getClass ("MTLIndirectCommandBufferDescriptor");
	__xamarin_class_map [1185].handle = objc_getClass ("MTLInstanceAccelerationStructureDescriptor");
	__xamarin_class_map [1186].handle = objc_getClass ("MTLIntersectionFunctionDescriptor");
	__xamarin_class_map [1187].handle = objc_getClass ("MTLIntersectionFunctionTableDescriptor");
	__xamarin_class_map [1188].handle = objc_getClass ("MTLLinkedFunctions");
	__xamarin_class_map [1189].handle = objc_getClass ("MTLMotionKeyframeData");
	__xamarin_class_map [1190].handle = objc_getClass ("MTLPipelineBufferDescriptor");
	__xamarin_class_map [1191].handle = objc_getClass ("MTLPointerType");
	__xamarin_class_map [1192].handle = objc_getClass ("MTLPrimitiveAccelerationStructureDescriptor");
	__xamarin_class_map [1193].handle = objc_getClass ("MTLRasterizationRateLayerArray");
	__xamarin_class_map [1194].handle = objc_getClass ("MTLRasterizationRateMapDescriptor");
	__xamarin_class_map [1195].handle = objc_getClass ("MTLRasterizationRateSampleArray");
	__xamarin_class_map [1196].handle = objc_getClass ("MTLRenderPassAttachmentDescriptor");
	__xamarin_class_map [1197].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptor");
	__xamarin_class_map [1198].handle = objc_getClass ("MTLRenderPassDepthAttachmentDescriptor");
	__xamarin_class_map [1199].handle = objc_getClass ("MTLRenderPassSampleBufferAttachmentDescriptor");
	__xamarin_class_map [1200].handle = objc_getClass ("MTLRenderPassStencilAttachmentDescriptor");
	__xamarin_class_map [1201].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptor");
	__xamarin_class_map [1202].handle = objc_getClass ("MTLRenderPipelineDescriptor");
	__xamarin_class_map [1203].handle = objc_getClass ("MTLRenderPipelineFunctionsDescriptor");
	__xamarin_class_map [1204].handle = objc_getClass ("MTLRenderPipelineReflection");
	__xamarin_class_map [1205].handle = objc_getClass ("MTLResourceStatePassDescriptor");
	__xamarin_class_map [1206].handle = objc_getClass ("MTLResourceStatePassSampleBufferAttachmentDescriptor");
	__xamarin_class_map [1207].handle = objc_getClass ("MTLSamplerDescriptor");
	__xamarin_class_map [1208].handle = objc_getClass ("MTLSharedEventHandle");
	__xamarin_class_map [1209].handle = objc_getClass ("MTLSharedEventListener");
	__xamarin_class_map [1210].handle = objc_getClass ("MTLStageInputOutputDescriptor");
	__xamarin_class_map [1211].handle = objc_getClass ("MTLStencilDescriptor");
	__xamarin_class_map [1212].handle = objc_getClass ("MTLStitchedLibraryDescriptor");
	__xamarin_class_map [1213].handle = objc_getClass ("MTLStructMember");
	__xamarin_class_map [1214].handle = objc_getClass ("MTLStructType");
	__xamarin_class_map [1215].handle = objc_getClass ("MTLTextureDescriptor");
	__xamarin_class_map [1216].handle = objc_getClass ("MTLTextureReferenceType");
	__xamarin_class_map [1217].handle = objc_getClass ("MTLTileRenderPipelineColorAttachmentDescriptor");
	__xamarin_class_map [1218].handle = objc_getClass ("MTLTileRenderPipelineDescriptor");
	__xamarin_class_map [1219].handle = objc_getClass ("MTLVertexAttribute");
	__xamarin_class_map [1220].handle = objc_getClass ("MTLVertexAttributeDescriptor");
	__xamarin_class_map [1221].handle = objc_getClass ("MTLVertexBufferLayoutDescriptor");
	__xamarin_class_map [1222].handle = objc_getClass ("MTLVisibleFunctionTableDescriptor");
	__xamarin_class_map [1223].handle = objc_getClass ("UINavigationControllerDelegate");
	__xamarin_class_map [1224].handle = objc_getClass ("MFMailComposeViewControllerDelegate");
	__xamarin_class_map [1225].handle = objc_getClass ("MessageUI_Mono_MFMailComposeViewControllerDelegate");
	__xamarin_class_map [1226].handle = objc_getClass ("MFMessageComposeViewControllerDelegate");
	__xamarin_class_map [1227].handle = objc_getClass ("MessageUI_Mono_MFMessageComposeViewControllerDelegate");
	__xamarin_class_map [1228].handle = objc_getClass ("MPMediaEntity");
	__xamarin_class_map [1229].handle = objc_getClass ("MPMediaItem");
	__xamarin_class_map [1230].handle = objc_getClass ("MPMediaItemArtwork");
	__xamarin_class_map [1231].handle = objc_getClass ("MPMediaQuery");
	__xamarin_class_map [1232].handle = objc_getClass ("MPNowPlayingInfoCenter");
	__xamarin_class_map [1233].handle = objc_getClass ("MPPlayableContentDelegate");
	__xamarin_class_map [1234].handle = objc_getClass ("MPPlayableContentDataSource");
	__xamarin_class_map [1235].handle = objc_getClass ("MPRemoteCommandCenter");
	__xamarin_class_map [1236].handle = objc_getClass ("MPAdTimeRange");
	__xamarin_class_map [1237].handle = objc_getClass ("MPRemoteCommandEvent");
	__xamarin_class_map [1238].handle = objc_getClass ("MPChangeLanguageOptionCommandEvent");
	__xamarin_class_map [1239].handle = objc_getClass ("MPRemoteCommand");
	__xamarin_class_map [1240].handle = objc_getClass ("MPChangePlaybackPositionCommand");
	__xamarin_class_map [1241].handle = objc_getClass ("MPChangePlaybackPositionCommandEvent");
	__xamarin_class_map [1242].handle = objc_getClass ("MPChangePlaybackRateCommand");
	__xamarin_class_map [1243].handle = objc_getClass ("MPChangePlaybackRateCommandEvent");
	__xamarin_class_map [1244].handle = objc_getClass ("MPChangeRepeatModeCommand");
	__xamarin_class_map [1245].handle = objc_getClass ("MPChangeRepeatModeCommandEvent");
	__xamarin_class_map [1246].handle = objc_getClass ("MPChangeShuffleModeCommand");
	__xamarin_class_map [1247].handle = objc_getClass ("MPChangeShuffleModeCommandEvent");
	__xamarin_class_map [1248].handle = objc_getClass ("MPContentItem");
	__xamarin_class_map [1249].handle = objc_getClass ("MPFeedbackCommand");
	__xamarin_class_map [1250].handle = objc_getClass ("MPFeedbackCommandEvent");
	__xamarin_class_map [1251].handle = objc_getClass ("MPMediaItemCollection");
	__xamarin_class_map [1252].handle = objc_getClass ("MPMediaPickerControllerDelegate");
	__xamarin_class_map [1253].handle = objc_getClass ("MPMediaPlaylistCreationMetadata");
	__xamarin_class_map [1254].handle = objc_getClass ("MPMediaPredicate");
	__xamarin_class_map [1255].handle = objc_getClass ("MPMediaPropertyPredicate");
	__xamarin_class_map [1256].handle = objc_getClass ("MPMediaQuerySection");
	__xamarin_class_map [1257].handle = objc_getClass ("MPMovieAccessLog");
	__xamarin_class_map [1258].handle = objc_getClass ("MPMovieAccessLogEvent");
	__xamarin_class_map [1259].handle = objc_getClass ("MPMovieErrorLog");
	__xamarin_class_map [1260].handle = objc_getClass ("MPMovieErrorLogEvent");
	__xamarin_class_map [1261].handle = objc_getClass ("MPMoviePlayerViewController");
	__xamarin_class_map [1262].handle = objc_getClass ("MPMusicPlayerControllerQueue");
	__xamarin_class_map [1263].handle = objc_getClass ("MPMusicPlayerControllerMutableQueue");
	__xamarin_class_map [1264].handle = objc_getClass ("MPMusicPlayerQueueDescriptor");
	__xamarin_class_map [1265].handle = objc_getClass ("MPMusicPlayerMediaItemQueueDescriptor");
	__xamarin_class_map [1266].handle = objc_getClass ("MPMusicPlayerPlayParameters");
	__xamarin_class_map [1267].handle = objc_getClass ("MPMusicPlayerPlayParametersQueueDescriptor");
	__xamarin_class_map [1268].handle = objc_getClass ("MPMusicPlayerStoreQueueDescriptor");
	__xamarin_class_map [1269].handle = objc_getClass ("MPNowPlayingInfoLanguageOption");
	__xamarin_class_map [1270].handle = objc_getClass ("MPNowPlayingInfoLanguageOptionGroup");
	__xamarin_class_map [1271].handle = objc_getClass ("Xamarin_iOS__MediaPlayer_MPNowPlayingSessionDelegate");
	__xamarin_class_map [1272].handle = objc_getClass ("MPPlayableContentManager");
	__xamarin_class_map [1273].handle = objc_getClass ("MPPlayableContentManagerContext");
	__xamarin_class_map [1274].handle = objc_getClass ("MPRatingCommand");
	__xamarin_class_map [1275].handle = objc_getClass ("MPRatingCommandEvent");
	__xamarin_class_map [1276].handle = objc_getClass ("MPSeekCommandEvent");
	__xamarin_class_map [1277].handle = objc_getClass ("MPSkipIntervalCommandEvent");
	__xamarin_class_map [1278].handle = objc_getClass ("MPTimedMetadata");
	__xamarin_class_map [1279].handle = objc_getClass ("MKShape");
	__xamarin_class_map [1280].handle = objc_getClass ("MKMultiPoint");
	__xamarin_class_map [1281].handle = objc_getClass ("MKPolyline");
	__xamarin_class_map [1282].handle = objc_getClass ("MKGeodesicPolyline");
	__xamarin_class_map [1283].handle = objc_getClass ("MKMapCameraZoomRange");
	__xamarin_class_map [1284].handle = objc_getClass ("MKPolygon");
	__xamarin_class_map [1285].handle = objc_getClass ("MKAnnotation");
	__xamarin_class_map [1286].handle = objc_getClass ("MKCircle");
	__xamarin_class_map [1287].handle = objc_getClass ("MKOverlayRenderer");
	__xamarin_class_map [1288].handle = objc_getClass ("MKOverlayPathRenderer");
	__xamarin_class_map [1289].handle = objc_getClass ("MKCircleRenderer");
	__xamarin_class_map [1290].handle = objc_getClass ("MKClusterAnnotation");
	__xamarin_class_map [1291].handle = objc_getClass ("MKDirectionsRequest");
	__xamarin_class_map [1292].handle = objc_getClass ("MKDirectionsResponse");
	__xamarin_class_map [1293].handle = objc_getClass ("NSFormatter");
	__xamarin_class_map [1294].handle = objc_getClass ("MKDistanceFormatter");
	__xamarin_class_map [1295].handle = objc_getClass ("MKETAResponse");
	__xamarin_class_map [1296].handle = objc_getClass ("MKGeoJSONDecoder");
	__xamarin_class_map [1297].handle = objc_getClass ("MKGeoJSONFeature");
	__xamarin_class_map [1298].handle = objc_getClass ("MKMapConfiguration");
	__xamarin_class_map [1299].handle = objc_getClass ("MKHybridMapConfiguration");
	__xamarin_class_map [1300].handle = objc_getClass ("MKIconStyle");
	__xamarin_class_map [1301].handle = objc_getClass ("MKImageryMapConfiguration");
	__xamarin_class_map [1302].handle = objc_getClass ("MKLocalPointsOfInterestRequest");
	__xamarin_class_map [1303].handle = objc_getClass ("MKLocalSearchCompleter");
	__xamarin_class_map [1304].handle = objc_getClass ("MKLocalSearchCompleterDelegate");
	__xamarin_class_map [1305].handle = objc_getClass ("MKLocalSearchCompletion");
	__xamarin_class_map [1306].handle = objc_getClass ("MKLocalSearchRequest");
	__xamarin_class_map [1307].handle = objc_getClass ("MKLocalSearchResponse");
	__xamarin_class_map [1308].handle = objc_getClass ("MKLookAroundScene");
	__xamarin_class_map [1309].handle = objc_getClass ("MKLookAroundSnapshot");
	__xamarin_class_map [1310].handle = objc_getClass ("MKLookAroundSnapshotOptions");
	__xamarin_class_map [1311].handle = objc_getClass ("MKLookAroundViewController");
	__xamarin_class_map [1312].handle = objc_getClass ("Xamarin_iOS__MapKit_MKLookAroundViewControllerDelegate");
	__xamarin_class_map [1313].handle = objc_getClass ("MKMapCamera");
	__xamarin_class_map [1314].handle = objc_getClass ("MKMapCameraBoundary");
	__xamarin_class_map [1315].handle = objc_getClass ("MKMapFeatureAnnotation");
	__xamarin_class_map [1316].handle = objc_getClass ("MKMapSnapshot");
	__xamarin_class_map [1317].handle = objc_getClass ("MKMapSnapshotOptions");
	__xamarin_class_map [1318].handle = objc_getClass ("MKMapViewDelegate");
	__xamarin_class_map [1319].handle = objc_getClass ("MKMultiPolygon");
	__xamarin_class_map [1320].handle = objc_getClass ("MKMultiPolygonRenderer");
	__xamarin_class_map [1321].handle = objc_getClass ("MKMultiPolyline");
	__xamarin_class_map [1322].handle = objc_getClass ("MKMultiPolylineRenderer");
	__xamarin_class_map [1323].handle = objc_getClass ("MKOverlay");
	__xamarin_class_map [1324].handle = objc_getClass ("CLPlacemark");
	__xamarin_class_map [1325].handle = objc_getClass ("MKPlacemark");
	__xamarin_class_map [1326].handle = objc_getClass ("MKPointAnnotation");
	__xamarin_class_map [1327].handle = objc_getClass ("MKPolygonRenderer");
	__xamarin_class_map [1328].handle = objc_getClass ("MKPolylineRenderer");
	__xamarin_class_map [1329].handle = objc_getClass ("MKReverseGeocoder");
	__xamarin_class_map [1330].handle = objc_getClass ("MKReverseGeocoderDelegate");
	__xamarin_class_map [1331].handle = objc_getClass ("MKRoute");
	__xamarin_class_map [1332].handle = objc_getClass ("MKRouteStep");
	__xamarin_class_map [1333].handle = objc_getClass ("MKStandardMapConfiguration");
	__xamarin_class_map [1334].handle = objc_getClass ("MKTileOverlay");
	__xamarin_class_map [1335].handle = objc_getClass ("MKTileOverlayRenderer");
	__xamarin_class_map [1336].handle = objc_getClass ("MKUserLocation");
	__xamarin_class_map [1337].handle = objc_getClass ("JSContext");
	__xamarin_class_map [1338].handle = objc_getClass ("JSValue");
	__xamarin_class_map [1339].handle = objc_getClass ("Xamarin_iOS__JavaScriptCore_JSExport");
	__xamarin_class_map [1340].handle = objc_getClass ("JSManagedValue");
	__xamarin_class_map [1341].handle = objc_getClass ("JSVirtualMachine");
	__xamarin_class_map [1342].handle = objc_getClass ("INIntentResolutionResult");
	__xamarin_class_map [1343].handle = objc_getClass ("INBillTypeResolutionResult");
	__xamarin_class_map [1344].handle = objc_getClass ("INCallRecord");
	__xamarin_class_map [1345].handle = objc_getClass ("INCallRecordTypeResolutionResult");
	__xamarin_class_map [1346].handle = objc_getClass ("INCarAirCirculationModeResolutionResult");
	__xamarin_class_map [1347].handle = objc_getClass ("INCarAudioSourceResolutionResult");
	__xamarin_class_map [1348].handle = objc_getClass ("INCarDefrosterResolutionResult");
	__xamarin_class_map [1349].handle = objc_getClass ("INCarSeatResolutionResult");
	__xamarin_class_map [1350].handle = objc_getClass ("INCarSignalOptionsResolutionResult");
	__xamarin_class_map [1351].handle = objc_getClass ("INPerson");
	__xamarin_class_map [1352].handle = objc_getClass ("INRideDriver");
	__xamarin_class_map [1353].handle = objc_getClass ("INRideStatus");
	__xamarin_class_map [1354].handle = objc_getClass ("INRestaurantGuest");
	__xamarin_class_map [1355].handle = objc_getClass ("INIntentResponse");
	__xamarin_class_map [1356].handle = objc_getClass ("INGetCarLockStatusIntentResponse");
	__xamarin_class_map [1357].handle = objc_getClass ("INGetCarPowerLevelStatusIntentResponse");
	__xamarin_class_map [1358].handle = objc_getClass ("INMessageAttributeOptionsResolutionResult");
	__xamarin_class_map [1359].handle = objc_getClass ("INMessageAttributeResolutionResult");
	__xamarin_class_map [1360].handle = objc_getClass ("INPaymentStatusResolutionResult");
	__xamarin_class_map [1361].handle = objc_getClass ("INPlayMediaIntentResponse");
	__xamarin_class_map [1362].handle = objc_getClass ("INPriceRange");
	__xamarin_class_map [1363].handle = objc_getClass ("INRadioTypeResolutionResult");
	__xamarin_class_map [1364].handle = objc_getClass ("INRelativeReferenceResolutionResult");
	__xamarin_class_map [1365].handle = objc_getClass ("INRelativeSettingResolutionResult");
	__xamarin_class_map [1366].handle = objc_getClass ("INRideOption");
	__xamarin_class_map [1367].handle = objc_getClass ("INIntent");
	__xamarin_class_map [1368].handle = objc_getClass ("INSaveProfileInCarIntent");
	__xamarin_class_map [1369].handle = objc_getClass ("INSearchCallHistoryIntent");
	__xamarin_class_map [1370].handle = objc_getClass ("INSetCarLockStatusIntent");
	__xamarin_class_map [1371].handle = objc_getClass ("INSetClimateSettingsInCarIntent");
	__xamarin_class_map [1372].handle = objc_getClass ("INSetDefrosterSettingsInCarIntent");
	__xamarin_class_map [1373].handle = objc_getClass ("INSetProfileInCarIntent");
	__xamarin_class_map [1374].handle = objc_getClass ("INSetSeatSettingsInCarIntent");
	__xamarin_class_map [1375].handle = objc_getClass ("INSpeakableString");
	__xamarin_class_map [1376].handle = objc_getClass ("INStartWorkoutIntent");
	__xamarin_class_map [1377].handle = objc_getClass ("INWorkoutGoalUnitTypeResolutionResult");
	__xamarin_class_map [1378].handle = objc_getClass ("INWorkoutLocationTypeResolutionResult");
	__xamarin_class_map [1379].handle = objc_getClass ("INAccountTypeResolutionResult");
	__xamarin_class_map [1380].handle = objc_getClass ("INActivateCarSignalIntent");
	__xamarin_class_map [1381].handle = objc_getClass ("INActivateCarSignalIntentResponse");
	__xamarin_class_map [1382].handle = objc_getClass ("INAddMediaIntent");
	__xamarin_class_map [1383].handle = objc_getClass ("INAddMediaIntentResponse");
	__xamarin_class_map [1384].handle = objc_getClass ("INMediaDestinationResolutionResult");
	__xamarin_class_map [1385].handle = objc_getClass ("INAddMediaMediaDestinationResolutionResult");
	__xamarin_class_map [1386].handle = objc_getClass ("INMediaItemResolutionResult");
	__xamarin_class_map [1387].handle = objc_getClass ("INAddMediaMediaItemResolutionResult");
	__xamarin_class_map [1388].handle = objc_getClass ("INAddTasksIntent");
	__xamarin_class_map [1389].handle = objc_getClass ("INAddTasksIntentResponse");
	__xamarin_class_map [1390].handle = objc_getClass ("INTaskListResolutionResult");
	__xamarin_class_map [1391].handle = objc_getClass ("INAddTasksTargetTaskListResolutionResult");
	__xamarin_class_map [1392].handle = objc_getClass ("INTemporalEventTriggerResolutionResult");
	__xamarin_class_map [1393].handle = objc_getClass ("INAddTasksTemporalEventTriggerResolutionResult");
	__xamarin_class_map [1394].handle = objc_getClass ("INAirline");
	__xamarin_class_map [1395].handle = objc_getClass ("INAirport");
	__xamarin_class_map [1396].handle = objc_getClass ("INAirportGate");
	__xamarin_class_map [1397].handle = objc_getClass ("INAnswerCallIntent");
	__xamarin_class_map [1398].handle = objc_getClass ("INAnswerCallIntentResponse");
	__xamarin_class_map [1399].handle = objc_getClass ("INAppendToNoteIntent");
	__xamarin_class_map [1400].handle = objc_getClass ("INAppendToNoteIntentResponse");
	__xamarin_class_map [1401].handle = objc_getClass ("INBalanceAmount");
	__xamarin_class_map [1402].handle = objc_getClass ("INBalanceTypeResolutionResult");
	__xamarin_class_map [1403].handle = objc_getClass ("INBillDetails");
	__xamarin_class_map [1404].handle = objc_getClass ("INBillPayee");
	__xamarin_class_map [1405].handle = objc_getClass ("INBillPayeeResolutionResult");
	__xamarin_class_map [1406].handle = objc_getClass ("INReservation");
	__xamarin_class_map [1407].handle = objc_getClass ("INBoatReservation");
	__xamarin_class_map [1408].handle = objc_getClass ("INBoatTrip");
	__xamarin_class_map [1409].handle = objc_getClass ("INBookRestaurantReservationIntent");
	__xamarin_class_map [1410].handle = objc_getClass ("INBookRestaurantReservationIntentResponse");
	__xamarin_class_map [1411].handle = objc_getClass ("INBooleanResolutionResult");
	__xamarin_class_map [1412].handle = objc_getClass ("INBusReservation");
	__xamarin_class_map [1413].handle = objc_getClass ("INBusTrip");
	__xamarin_class_map [1414].handle = objc_getClass ("INCallCapabilityResolutionResult");
	__xamarin_class_map [1415].handle = objc_getClass ("INCallDestinationTypeResolutionResult");
	__xamarin_class_map [1416].handle = objc_getClass ("INCallGroup");
	__xamarin_class_map [1417].handle = objc_getClass ("INCallRecordFilter");
	__xamarin_class_map [1418].handle = objc_getClass ("INCallRecordResolutionResult");
	__xamarin_class_map [1419].handle = objc_getClass ("INCallRecordTypeOptionsResolutionResult");
	__xamarin_class_map [1420].handle = objc_getClass ("INCancelRideIntent");
	__xamarin_class_map [1421].handle = objc_getClass ("INCancelRideIntentResponse");
	__xamarin_class_map [1422].handle = objc_getClass ("INCancelWorkoutIntent");
	__xamarin_class_map [1423].handle = objc_getClass ("INCancelWorkoutIntentResponse");
	__xamarin_class_map [1424].handle = objc_getClass ("INCarHeadUnit");
	__xamarin_class_map [1425].handle = objc_getClass ("INCreateNoteIntent");
	__xamarin_class_map [1426].handle = objc_getClass ("INCreateNoteIntentResponse");
	__xamarin_class_map [1427].handle = objc_getClass ("INCreateTaskListIntent");
	__xamarin_class_map [1428].handle = objc_getClass ("INCreateTaskListIntentResponse");
	__xamarin_class_map [1429].handle = objc_getClass ("INCurrencyAmount");
	__xamarin_class_map [1430].handle = objc_getClass ("INCurrencyAmountResolutionResult");
	__xamarin_class_map [1431].handle = objc_getClass ("INRelevanceProvider");
	__xamarin_class_map [1432].handle = objc_getClass ("INDailyRoutineRelevanceProvider");
	__xamarin_class_map [1433].handle = objc_getClass ("INDateComponentsRange");
	__xamarin_class_map [1434].handle = objc_getClass ("INDateComponentsRangeResolutionResult");
	__xamarin_class_map [1435].handle = objc_getClass ("INDateComponentsResolutionResult");
	__xamarin_class_map [1436].handle = objc_getClass ("INDateRelevanceProvider");
	__xamarin_class_map [1437].handle = objc_getClass ("INDateSearchTypeResolutionResult");
	__xamarin_class_map [1438].handle = objc_getClass ("INDefaultCardTemplate");
	__xamarin_class_map [1439].handle = objc_getClass ("INDeleteTasksIntent");
	__xamarin_class_map [1440].handle = objc_getClass ("INDeleteTasksIntentResponse");
	__xamarin_class_map [1441].handle = objc_getClass ("INDeleteTasksTaskListResolutionResult");
	__xamarin_class_map [1442].handle = objc_getClass ("INTaskResolutionResult");
	__xamarin_class_map [1443].handle = objc_getClass ("INDeleteTasksTaskResolutionResult");
	__xamarin_class_map [1444].handle = objc_getClass ("INDoubleResolutionResult");
	__xamarin_class_map [1445].handle = objc_getClass ("INEndWorkoutIntent");
	__xamarin_class_map [1446].handle = objc_getClass ("INEndWorkoutIntentResponse");
	__xamarin_class_map [1447].handle = objc_getClass ("INEnergyResolutionResult");
	__xamarin_class_map [1448].handle = objc_getClass ("INEnumResolutionResult");
	__xamarin_class_map [1449].handle = objc_getClass ("INExtension");
	__xamarin_class_map [1450].handle = objc_getClass ("INFile");
	__xamarin_class_map [1451].handle = objc_getClass ("INFileResolutionResult");
	__xamarin_class_map [1452].handle = objc_getClass ("INFlight");
	__xamarin_class_map [1453].handle = objc_getClass ("INFlightReservation");
	__xamarin_class_map [1454].handle = objc_getClass ("INFocusStatus");
	__xamarin_class_map [1455].handle = objc_getClass ("INGetAvailableRestaurantReservationBookingDefaultsIntent");
	__xamarin_class_map [1456].handle = objc_getClass ("INGetAvailableRestaurantReservationBookingDefaultsIntentResponse");
	__xamarin_class_map [1457].handle = objc_getClass ("INGetAvailableRestaurantReservationBookingsIntent");
	__xamarin_class_map [1458].handle = objc_getClass ("INGetAvailableRestaurantReservationBookingsIntentResponse");
	__xamarin_class_map [1459].handle = objc_getClass ("INGetCarLockStatusIntent");
	__xamarin_class_map [1460].handle = objc_getClass ("INGetCarPowerLevelStatusIntent");
	__xamarin_class_map [1461].handle = objc_getClass ("INGetReservationDetailsIntent");
	__xamarin_class_map [1462].handle = objc_getClass ("INGetReservationDetailsIntentResponse");
	__xamarin_class_map [1463].handle = objc_getClass ("INGetRestaurantGuestIntent");
	__xamarin_class_map [1464].handle = objc_getClass ("INGetRestaurantGuestIntentResponse");
	__xamarin_class_map [1465].handle = objc_getClass ("INGetRideStatusIntent");
	__xamarin_class_map [1466].handle = objc_getClass ("INGetRideStatusIntentResponse");
	__xamarin_class_map [1467].handle = objc_getClass ("INGetUserCurrentRestaurantReservationBookingsIntent");
	__xamarin_class_map [1468].handle = objc_getClass ("INGetUserCurrentRestaurantReservationBookingsIntentResponse");
	__xamarin_class_map [1469].handle = objc_getClass ("INGetVisualCodeIntent");
	__xamarin_class_map [1470].handle = objc_getClass ("INGetVisualCodeIntentResponse");
	__xamarin_class_map [1471].handle = objc_getClass ("INHangUpCallIntent");
	__xamarin_class_map [1472].handle = objc_getClass ("INHangUpCallIntentResponse");
	__xamarin_class_map [1473].handle = objc_getClass ("INNoteContent");
	__xamarin_class_map [1474].handle = objc_getClass ("INImageNoteContent");
	__xamarin_class_map [1475].handle = objc_getClass ("INIntegerResolutionResult");
	__xamarin_class_map [1476].handle = objc_getClass ("INIntentDonationMetadata");
	__xamarin_class_map [1477].handle = objc_getClass ("INLengthResolutionResult");
	__xamarin_class_map [1478].handle = objc_getClass ("INListCarsIntent");
	__xamarin_class_map [1479].handle = objc_getClass ("INListCarsIntentResponse");
	__xamarin_class_map [1480].handle = objc_getClass ("INListRideOptionsIntent");
	__xamarin_class_map [1481].handle = objc_getClass ("INListRideOptionsIntentResponse");
	__xamarin_class_map [1482].handle = objc_getClass ("INLocationRelevanceProvider");
	__xamarin_class_map [1483].handle = objc_getClass ("INLocationSearchTypeResolutionResult");
	__xamarin_class_map [1484].handle = objc_getClass ("INLodgingReservation");
	__xamarin_class_map [1485].handle = objc_getClass ("INMassResolutionResult");
	__xamarin_class_map [1486].handle = objc_getClass ("INMediaAffinityTypeResolutionResult");
	__xamarin_class_map [1487].handle = objc_getClass ("INMediaDestination");
	__xamarin_class_map [1488].handle = objc_getClass ("INMediaItem");
	__xamarin_class_map [1489].handle = objc_getClass ("INMediaSearch");
	__xamarin_class_map [1490].handle = objc_getClass ("INUserContext");
	__xamarin_class_map [1491].handle = objc_getClass ("INMediaUserContext");
	__xamarin_class_map [1492].handle = objc_getClass ("INMessage");
	__xamarin_class_map [1493].handle = objc_getClass ("INNote");
	__xamarin_class_map [1494].handle = objc_getClass ("INNotebookItemTypeResolutionResult");
	__xamarin_class_map [1495].handle = objc_getClass ("INNoteContentResolutionResult");
	__xamarin_class_map [1496].handle = objc_getClass ("INNoteContentTypeResolutionResult");
	__xamarin_class_map [1497].handle = objc_getClass ("INNoteResolutionResult");
	__xamarin_class_map [1498].handle = objc_getClass ("INObject");
	__xamarin_class_map [1499].handle = objc_getClass ("INObjectCollection");
	__xamarin_class_map [1500].handle = objc_getClass ("INObjectResolutionResult");
	__xamarin_class_map [1501].handle = objc_getClass ("INObjectSection");
	__xamarin_class_map [1502].handle = objc_getClass ("INOutgoingMessageTypeResolutionResult");
	__xamarin_class_map [1503].handle = objc_getClass ("INParameter");
	__xamarin_class_map [1504].handle = objc_getClass ("INPauseWorkoutIntent");
	__xamarin_class_map [1505].handle = objc_getClass ("INPauseWorkoutIntentResponse");
	__xamarin_class_map [1506].handle = objc_getClass ("INPayBillIntent");
	__xamarin_class_map [1507].handle = objc_getClass ("INPayBillIntentResponse");
	__xamarin_class_map [1508].handle = objc_getClass ("INPaymentAccount");
	__xamarin_class_map [1509].handle = objc_getClass ("INPaymentAccountResolutionResult");
	__xamarin_class_map [1510].handle = objc_getClass ("INPaymentAmount");
	__xamarin_class_map [1511].handle = objc_getClass ("INPaymentAmountResolutionResult");
	__xamarin_class_map [1512].handle = objc_getClass ("INPaymentMethod");
	__xamarin_class_map [1513].handle = objc_getClass ("INPaymentMethodResolutionResult");
	__xamarin_class_map [1514].handle = objc_getClass ("INPaymentRecord");
	__xamarin_class_map [1515].handle = objc_getClass ("INPersonHandle");
	__xamarin_class_map [1516].handle = objc_getClass ("INPersonResolutionResult");
	__xamarin_class_map [1517].handle = objc_getClass ("INPlacemarkResolutionResult");
	__xamarin_class_map [1518].handle = objc_getClass ("INPlaybackQueueLocationResolutionResult");
	__xamarin_class_map [1519].handle = objc_getClass ("INPlaybackRepeatModeResolutionResult");
	__xamarin_class_map [1520].handle = objc_getClass ("INPlayMediaIntent");
	__xamarin_class_map [1521].handle = objc_getClass ("INPlayMediaMediaItemResolutionResult");
	__xamarin_class_map [1522].handle = objc_getClass ("INPlayMediaPlaybackSpeedResolutionResult");
	__xamarin_class_map [1523].handle = objc_getClass ("INRecurrenceRule");
	__xamarin_class_map [1524].handle = objc_getClass ("INRelevantShortcut");
	__xamarin_class_map [1525].handle = objc_getClass ("INRentalCar");
	__xamarin_class_map [1526].handle = objc_getClass ("INRentalCarReservation");
	__xamarin_class_map [1527].handle = objc_getClass ("INRequestPaymentCurrencyAmountResolutionResult");
	__xamarin_class_map [1528].handle = objc_getClass ("INRequestPaymentIntent");
	__xamarin_class_map [1529].handle = objc_getClass ("INRequestPaymentIntentResponse");
	__xamarin_class_map [1530].handle = objc_getClass ("INRequestPaymentPayerResolutionResult");
	__xamarin_class_map [1531].handle = objc_getClass ("INRequestRideIntent");
	__xamarin_class_map [1532].handle = objc_getClass ("INRequestRideIntentResponse");
	__xamarin_class_map [1533].handle = objc_getClass ("INReservationAction");
	__xamarin_class_map [1534].handle = objc_getClass ("INRestaurant");
	__xamarin_class_map [1535].handle = objc_getClass ("INRestaurantGuestDisplayPreferences");
	__xamarin_class_map [1536].handle = objc_getClass ("INRestaurantGuestResolutionResult");
	__xamarin_class_map [1537].handle = objc_getClass ("INRestaurantOffer");
	__xamarin_class_map [1538].handle = objc_getClass ("INRestaurantReservation");
	__xamarin_class_map [1539].handle = objc_getClass ("INRestaurantReservationBooking");
	__xamarin_class_map [1540].handle = objc_getClass ("INRestaurantReservationUserBooking");
	__xamarin_class_map [1541].handle = objc_getClass ("INRestaurantResolutionResult");
	__xamarin_class_map [1542].handle = objc_getClass ("INResumeWorkoutIntent");
	__xamarin_class_map [1543].handle = objc_getClass ("INResumeWorkoutIntentResponse");
	__xamarin_class_map [1544].handle = objc_getClass ("INRideCompletionStatus");
	__xamarin_class_map [1545].handle = objc_getClass ("INRideFareLineItem");
	__xamarin_class_map [1546].handle = objc_getClass ("INRidePartySizeOption");
	__xamarin_class_map [1547].handle = objc_getClass ("INRideVehicle");
	__xamarin_class_map [1548].handle = objc_getClass ("INSaveProfileInCarIntentResponse");
	__xamarin_class_map [1549].handle = objc_getClass ("INSearchCallHistoryIntentResponse");
	__xamarin_class_map [1550].handle = objc_getClass ("INSearchForAccountsIntent");
	__xamarin_class_map [1551].handle = objc_getClass ("INSearchForAccountsIntentResponse");
	__xamarin_class_map [1552].handle = objc_getClass ("INSearchForBillsIntent");
	__xamarin_class_map [1553].handle = objc_getClass ("INSearchForBillsIntentResponse");
	__xamarin_class_map [1554].handle = objc_getClass ("INSearchForMediaIntent");
	__xamarin_class_map [1555].handle = objc_getClass ("INSearchForMediaIntentResponse");
	__xamarin_class_map [1556].handle = objc_getClass ("INSearchForMediaMediaItemResolutionResult");
	__xamarin_class_map [1557].handle = objc_getClass ("INSearchForMessagesIntent");
	__xamarin_class_map [1558].handle = objc_getClass ("INSearchForMessagesIntentResponse");
	__xamarin_class_map [1559].handle = objc_getClass ("INSearchForNotebookItemsIntent");
	__xamarin_class_map [1560].handle = objc_getClass ("INSearchForNotebookItemsIntentResponse");
	__xamarin_class_map [1561].handle = objc_getClass ("INSearchForPhotosIntent");
	__xamarin_class_map [1562].handle = objc_getClass ("INSearchForPhotosIntentResponse");
	__xamarin_class_map [1563].handle = objc_getClass ("INSeat");
	__xamarin_class_map [1564].handle = objc_getClass ("INSendMessageAttachment");
	__xamarin_class_map [1565].handle = objc_getClass ("INSendMessageIntent");
	__xamarin_class_map [1566].handle = objc_getClass ("INSendMessageIntentDonationMetadata");
	__xamarin_class_map [1567].handle = objc_getClass ("INSendMessageIntentResponse");
	__xamarin_class_map [1568].handle = objc_getClass ("INSendMessageRecipientResolutionResult");
	__xamarin_class_map [1569].handle = objc_getClass ("INSendPaymentCurrencyAmountResolutionResult");
	__xamarin_class_map [1570].handle = objc_getClass ("INSendPaymentIntent");
	__xamarin_class_map [1571].handle = objc_getClass ("INSendPaymentIntentResponse");
	__xamarin_class_map [1572].handle = objc_getClass ("INSendPaymentPayeeResolutionResult");
	__xamarin_class_map [1573].handle = objc_getClass ("INSendRideFeedbackIntent");
	__xamarin_class_map [1574].handle = objc_getClass ("INSendRideFeedbackIntentResponse");
	__xamarin_class_map [1575].handle = objc_getClass ("INSetAudioSourceInCarIntent");
	__xamarin_class_map [1576].handle = objc_getClass ("INSetAudioSourceInCarIntentResponse");
	__xamarin_class_map [1577].handle = objc_getClass ("INSetCarLockStatusIntentResponse");
	__xamarin_class_map [1578].handle = objc_getClass ("INSetClimateSettingsInCarIntentResponse");
	__xamarin_class_map [1579].handle = objc_getClass ("INSetDefrosterSettingsInCarIntentResponse");
	__xamarin_class_map [1580].handle = objc_getClass ("INSetMessageAttributeIntent");
	__xamarin_class_map [1581].handle = objc_getClass ("INSetMessageAttributeIntentResponse");
	__xamarin_class_map [1582].handle = objc_getClass ("INSetProfileInCarIntentResponse");
	__xamarin_class_map [1583].handle = objc_getClass ("INSetRadioStationIntent");
	__xamarin_class_map [1584].handle = objc_getClass ("INSetRadioStationIntentResponse");
	__xamarin_class_map [1585].handle = objc_getClass ("INSetSeatSettingsInCarIntentResponse");
	__xamarin_class_map [1586].handle = objc_getClass ("INSetTaskAttributeIntent");
	__xamarin_class_map [1587].handle = objc_getClass ("INSetTaskAttributeIntentResponse");
	__xamarin_class_map [1588].handle = objc_getClass ("INSetTaskAttributeTemporalEventTriggerResolutionResult");
	__xamarin_class_map [1589].handle = objc_getClass ("INShareFocusStatusIntent");
	__xamarin_class_map [1590].handle = objc_getClass ("INShareFocusStatusIntentResponse");
	__xamarin_class_map [1591].handle = objc_getClass ("INShortcut");
	__xamarin_class_map [1592].handle = objc_getClass ("INSnoozeTasksIntent");
	__xamarin_class_map [1593].handle = objc_getClass ("INSnoozeTasksIntentResponse");
	__xamarin_class_map [1594].handle = objc_getClass ("INSnoozeTasksTaskResolutionResult");
	__xamarin_class_map [1595].handle = objc_getClass ("INSpatialEventTrigger");
	__xamarin_class_map [1596].handle = objc_getClass ("INSpatialEventTriggerResolutionResult");
	__xamarin_class_map [1597].handle = objc_getClass ("INSpeakableStringResolutionResult");
	__xamarin_class_map [1598].handle = objc_getClass ("INSpeedResolutionResult");
	__xamarin_class_map [1599].handle = objc_getClass ("INStartAudioCallIntent");
	__xamarin_class_map [1600].handle = objc_getClass ("INStartAudioCallIntentResponse");
	__xamarin_class_map [1601].handle = objc_getClass ("INStartCallCallCapabilityResolutionResult");
	__xamarin_class_map [1602].handle = objc_getClass ("INStartCallCallRecordToCallBackResolutionResult");
	__xamarin_class_map [1603].handle = objc_getClass ("INStartCallContactResolutionResult");
	__xamarin_class_map [1604].handle = objc_getClass ("INStartCallIntent");
	__xamarin_class_map [1605].handle = objc_getClass ("INStartCallIntentResponse");
	__xamarin_class_map [1606].handle = objc_getClass ("INStartPhotoPlaybackIntent");
	__xamarin_class_map [1607].handle = objc_getClass ("INStartPhotoPlaybackIntentResponse");
	__xamarin_class_map [1608].handle = objc_getClass ("INStartVideoCallIntent");
	__xamarin_class_map [1609].handle = objc_getClass ("INStartVideoCallIntentResponse");
	__xamarin_class_map [1610].handle = objc_getClass ("INStartWorkoutIntentResponse");
	__xamarin_class_map [1611].handle = objc_getClass ("INStringResolutionResult");
	__xamarin_class_map [1612].handle = objc_getClass ("INTask");
	__xamarin_class_map [1613].handle = objc_getClass ("INTaskList");
	__xamarin_class_map [1614].handle = objc_getClass ("INTaskPriorityResolutionResult");
	__xamarin_class_map [1615].handle = objc_getClass ("INTaskStatusResolutionResult");
	__xamarin_class_map [1616].handle = objc_getClass ("INTemperatureResolutionResult");
	__xamarin_class_map [1617].handle = objc_getClass ("INTemporalEventTrigger");
	__xamarin_class_map [1618].handle = objc_getClass ("INTemporalEventTriggerTypeOptionsResolutionResult");
	__xamarin_class_map [1619].handle = objc_getClass ("INTermsAndConditions");
	__xamarin_class_map [1620].handle = objc_getClass ("INTextNoteContent");
	__xamarin_class_map [1621].handle = objc_getClass ("INTicketedEvent");
	__xamarin_class_map [1622].handle = objc_getClass ("INTicketedEventReservation");
	__xamarin_class_map [1623].handle = objc_getClass ("INTimeIntervalResolutionResult");
	__xamarin_class_map [1624].handle = objc_getClass ("INTrainReservation");
	__xamarin_class_map [1625].handle = objc_getClass ("INTrainTrip");
	__xamarin_class_map [1626].handle = objc_getClass ("INTransferMoneyIntent");
	__xamarin_class_map [1627].handle = objc_getClass ("INTransferMoneyIntentResponse");
	__xamarin_class_map [1628].handle = objc_getClass ("INUpcomingMediaManager");
	__xamarin_class_map [1629].handle = objc_getClass ("INUpdateMediaAffinityIntent");
	__xamarin_class_map [1630].handle = objc_getClass ("INUpdateMediaAffinityIntentResponse");
	__xamarin_class_map [1631].handle = objc_getClass ("INUpdateMediaAffinityMediaItemResolutionResult");
	__xamarin_class_map [1632].handle = objc_getClass ("INURLResolutionResult");
	__xamarin_class_map [1633].handle = objc_getClass ("INVisualCodeTypeResolutionResult");
	__xamarin_class_map [1634].handle = objc_getClass ("INVocabulary");
	__xamarin_class_map [1635].handle = objc_getClass ("INVoiceShortcut");
	__xamarin_class_map [1636].handle = objc_getClass ("INVolumeResolutionResult");
	__xamarin_class_map [1637].handle = objc_getClass ("HMCharacteristicMetadata");
	__xamarin_class_map [1638].handle = objc_getClass ("HMAccessControl");
	__xamarin_class_map [1639].handle = objc_getClass ("HMAccessoryBrowserDelegate");
	__xamarin_class_map [1640].handle = objc_getClass ("HMAccessoryCategory");
	__xamarin_class_map [1641].handle = objc_getClass ("HMAccessoryDelegate");
	__xamarin_class_map [1642].handle = objc_getClass ("HMAccessoryOwnershipToken");
	__xamarin_class_map [1643].handle = objc_getClass ("HMAccessoryProfile");
	__xamarin_class_map [1644].handle = objc_getClass ("HMAccessorySetupPayload");
	__xamarin_class_map [1645].handle = objc_getClass ("HMAccessorySetupRequest");
	__xamarin_class_map [1646].handle = objc_getClass ("HMAccessorySetupResult");
	__xamarin_class_map [1647].handle = objc_getClass ("HMAction");
	__xamarin_class_map [1648].handle = objc_getClass ("HMAddAccessoryRequest");
	__xamarin_class_map [1649].handle = objc_getClass ("HMEvent");
	__xamarin_class_map [1650].handle = objc_getClass ("HMTimeEvent");
	__xamarin_class_map [1651].handle = objc_getClass ("HMCalendarEvent");
	__xamarin_class_map [1652].handle = objc_getClass ("HMCameraControl");
	__xamarin_class_map [1653].handle = objc_getClass ("HMCameraAudioControl");
	__xamarin_class_map [1654].handle = objc_getClass ("HMCameraProfile");
	__xamarin_class_map [1655].handle = objc_getClass ("HMCameraSettingsControl");
	__xamarin_class_map [1656].handle = objc_getClass ("HMCameraSource");
	__xamarin_class_map [1657].handle = objc_getClass ("HMCameraSnapshot");
	__xamarin_class_map [1658].handle = objc_getClass ("HMCameraSnapshotControl");
	__xamarin_class_map [1659].handle = objc_getClass ("HMCameraSnapshotControlDelegate");
	__xamarin_class_map [1660].handle = objc_getClass ("HMCameraStreamControl");
	__xamarin_class_map [1661].handle = objc_getClass ("HMCameraStreamControlDelegate");
	__xamarin_class_map [1662].handle = objc_getClass ("HMCharacteristicThresholdRangeEvent");
	__xamarin_class_map [1663].handle = objc_getClass ("HMDurationEvent");
	__xamarin_class_map [1664].handle = objc_getClass ("HMHomeAccessControl");
	__xamarin_class_map [1665].handle = objc_getClass ("HMHomeDelegate");
	__xamarin_class_map [1666].handle = objc_getClass ("HMHomeManagerDelegate");
	__xamarin_class_map [1667].handle = objc_getClass ("HMMutableCalendarEvent");
	__xamarin_class_map [1668].handle = objc_getClass ("HMCharacteristicEvent");
	__xamarin_class_map [1669].handle = objc_getClass ("HMMutableCharacteristicEvent");
	__xamarin_class_map [1670].handle = objc_getClass ("HMMutableCharacteristicThresholdRangeEvent");
	__xamarin_class_map [1671].handle = objc_getClass ("HMMutableDurationEvent");
	__xamarin_class_map [1672].handle = objc_getClass ("HMLocationEvent");
	__xamarin_class_map [1673].handle = objc_getClass ("HMMutableLocationEvent");
	__xamarin_class_map [1674].handle = objc_getClass ("HMPresenceEvent");
	__xamarin_class_map [1675].handle = objc_getClass ("HMMutablePresenceEvent");
	__xamarin_class_map [1676].handle = objc_getClass ("HMSignificantTimeEvent");
	__xamarin_class_map [1677].handle = objc_getClass ("HMMutableSignificantTimeEvent");
	__xamarin_class_map [1678].handle = objc_getClass ("HMNetworkConfigurationProfile");
	__xamarin_class_map [1679].handle = objc_getClass ("Xamarin_iOS__HomeKit_HMNetworkConfigurationProfileDelegate");
	__xamarin_class_map [1680].handle = objc_getClass ("HMNumberRange");
	__xamarin_class_map [1681].handle = objc_getClass ("HMUser");
	__xamarin_class_map [1682].handle = objc_getClass ("HKQuery");
	__xamarin_class_map [1683].handle = objc_getClass ("HKAnchoredObjectQuery");
	__xamarin_class_map [1684].handle = objc_getClass ("HKObjectType");
	__xamarin_class_map [1685].handle = objc_getClass ("HKSampleType");
	__xamarin_class_map [1686].handle = objc_getClass ("HKQuantityType");
	__xamarin_class_map [1687].handle = objc_getClass ("HKCategoryType");
	__xamarin_class_map [1688].handle = objc_getClass ("HKCharacteristicType");
	__xamarin_class_map [1689].handle = objc_getClass ("HKCorrelationType");
	__xamarin_class_map [1690].handle = objc_getClass ("HKDocumentType");
	__xamarin_class_map [1691].handle = objc_getClass ("HKStatisticsCollectionQuery");
	__xamarin_class_map [1692].handle = objc_getClass ("HKSampleQuery");
	__xamarin_class_map [1693].handle = objc_getClass ("HKUnit");
	__xamarin_class_map [1694].handle = objc_getClass ("HKActivityMoveModeObject");
	__xamarin_class_map [1695].handle = objc_getClass ("HKActivitySummary");
	__xamarin_class_map [1696].handle = objc_getClass ("HKActivitySummaryQuery");
	__xamarin_class_map [1697].handle = objc_getClass ("HKActivitySummaryType");
	__xamarin_class_map [1698].handle = objc_getClass ("HKAttachment");
	__xamarin_class_map [1699].handle = objc_getClass ("HKObject");
	__xamarin_class_map [1700].handle = objc_getClass ("HKSample");
	__xamarin_class_map [1701].handle = objc_getClass ("HKAudiogramSample");
	__xamarin_class_map [1702].handle = objc_getClass ("HKAudiogramSampleType");
	__xamarin_class_map [1703].handle = objc_getClass ("HKAudiogramSensitivityPoint");
	__xamarin_class_map [1704].handle = objc_getClass ("HKBiologicalSexObject");
	__xamarin_class_map [1705].handle = objc_getClass ("HKBloodTypeObject");
	__xamarin_class_map [1706].handle = objc_getClass ("HKCategorySample");
	__xamarin_class_map [1707].handle = objc_getClass ("HKCDADocument");
	__xamarin_class_map [1708].handle = objc_getClass ("HKDocumentSample");
	__xamarin_class_map [1709].handle = objc_getClass ("HKCDADocumentSample");
	__xamarin_class_map [1710].handle = objc_getClass ("HKClinicalRecord");
	__xamarin_class_map [1711].handle = objc_getClass ("HKClinicalType");
	__xamarin_class_map [1712].handle = objc_getClass ("HKLensSpecification");
	__xamarin_class_map [1713].handle = objc_getClass ("HKContactsLensSpecification");
	__xamarin_class_map [1714].handle = objc_getClass ("HKVisionPrescription");
	__xamarin_class_map [1715].handle = objc_getClass ("HKContactsPrescription");
	__xamarin_class_map [1716].handle = objc_getClass ("HKCorrelation");
	__xamarin_class_map [1717].handle = objc_getClass ("HKCorrelationQuery");
	__xamarin_class_map [1718].handle = objc_getClass ("HKQuantitySample");
	__xamarin_class_map [1719].handle = objc_getClass ("HKCumulativeQuantitySample");
	__xamarin_class_map [1720].handle = objc_getClass ("HKCumulativeQuantitySeriesSample");
	__xamarin_class_map [1721].handle = objc_getClass ("HKDeletedObject");
	__xamarin_class_map [1722].handle = objc_getClass ("HKDevice");
	__xamarin_class_map [1723].handle = objc_getClass ("HKDiscreteQuantitySample");
	__xamarin_class_map [1724].handle = objc_getClass ("HKDocumentQuery");
	__xamarin_class_map [1725].handle = objc_getClass ("HKElectrocardiogram");
	__xamarin_class_map [1726].handle = objc_getClass ("HKElectrocardiogramQuery");
	__xamarin_class_map [1727].handle = objc_getClass ("HKElectrocardiogramType");
	__xamarin_class_map [1728].handle = objc_getClass ("HKElectrocardiogramVoltageMeasurement");
	__xamarin_class_map [1729].handle = objc_getClass ("HKFHIRResource");
	__xamarin_class_map [1730].handle = objc_getClass ("HKFHIRVersion");
	__xamarin_class_map [1731].handle = objc_getClass ("HKFitzpatrickSkinTypeObject");
	__xamarin_class_map [1732].handle = objc_getClass ("HKGlassesLensSpecification");
	__xamarin_class_map [1733].handle = objc_getClass ("HKGlassesPrescription");
	__xamarin_class_map [1734].handle = objc_getClass ("HKHeartbeatSeriesQuery");
	__xamarin_class_map [1735].handle = objc_getClass ("HKSeriesSample");
	__xamarin_class_map [1736].handle = objc_getClass ("HKHeartbeatSeriesSample");
	__xamarin_class_map [1737].handle = objc_getClass ("HKObserverQuery");
	__xamarin_class_map [1738].handle = objc_getClass ("HKPrescriptionType");
	__xamarin_class_map [1739].handle = objc_getClass ("HKQuantity");
	__xamarin_class_map [1740].handle = objc_getClass ("HKQuantitySeriesSampleQuery");
	__xamarin_class_map [1741].handle = objc_getClass ("HKQueryAnchor");
	__xamarin_class_map [1742].handle = objc_getClass ("HKQueryDescriptor");
	__xamarin_class_map [1743].handle = objc_getClass ("HKSeriesBuilder");
	__xamarin_class_map [1744].handle = objc_getClass ("HKSeriesType");
	__xamarin_class_map [1745].handle = objc_getClass ("HKSource");
	__xamarin_class_map [1746].handle = objc_getClass ("HKSourceQuery");
	__xamarin_class_map [1747].handle = objc_getClass ("HKSourceRevision");
	__xamarin_class_map [1748].handle = objc_getClass ("HKStatistics");
	__xamarin_class_map [1749].handle = objc_getClass ("HKStatisticsCollection");
	__xamarin_class_map [1750].handle = objc_getClass ("HKStatisticsQuery");
	__xamarin_class_map [1751].handle = objc_getClass ("HKVerifiableClinicalRecord");
	__xamarin_class_map [1752].handle = objc_getClass ("HKVerifiableClinicalRecordSubject");
	__xamarin_class_map [1753].handle = objc_getClass ("HKVisionPrism");
	__xamarin_class_map [1754].handle = objc_getClass ("HKWheelchairUseObject");
	__xamarin_class_map [1755].handle = objc_getClass ("HKWorkout");
	__xamarin_class_map [1756].handle = objc_getClass ("HKWorkoutActivity");
	__xamarin_class_map [1757].handle = objc_getClass ("HKWorkoutConfiguration");
	__xamarin_class_map [1758].handle = objc_getClass ("HKWorkoutEvent");
	__xamarin_class_map [1759].handle = objc_getClass ("HKWorkoutRoute");
	__xamarin_class_map [1760].handle = objc_getClass ("HKWorkoutRouteQuery");
	__xamarin_class_map [1761].handle = objc_getClass ("HKWorkoutType");
	__xamarin_class_map [1762].handle = objc_getClass ("GKBehavior");
	__xamarin_class_map [1763].handle = objc_getClass ("GKQuadtree");
	__xamarin_class_map [1764].handle = objc_getClass ("GKQuadtreeNode");
	__xamarin_class_map [1765].handle = objc_getClass ("GKComponentSystem");
	__xamarin_class_map [1766].handle = objc_getClass ("GKCompositeBehavior");
	__xamarin_class_map [1767].handle = objc_getClass ("GKEntity");
	__xamarin_class_map [1768].handle = objc_getClass ("GKGraph");
	__xamarin_class_map [1769].handle = objc_getClass ("GKGridGraph");
	__xamarin_class_map [1770].handle = objc_getClass ("GKObstacleGraph");
	__xamarin_class_map [1771].handle = objc_getClass ("GKPath");
	__xamarin_class_map [1772].handle = objc_getClass ("GKObstacle");
	__xamarin_class_map [1773].handle = objc_getClass ("GKPolygonObstacle");
	__xamarin_class_map [1774].handle = objc_getClass ("GKState");
	__xamarin_class_map [1775].handle = objc_getClass ("GKStateMachine");
	__xamarin_class_map [1776].handle = objc_getClass ("GKComponent");
	__xamarin_class_map [1777].handle = objc_getClass ("GKAgent");
	__xamarin_class_map [1778].handle = objc_getClass ("GKAgent2D");
	__xamarin_class_map [1779].handle = objc_getClass ("GKAgent3D");
	__xamarin_class_map [1780].handle = objc_getClass ("GKAgentDelegate");
	__xamarin_class_map [1781].handle = objc_getClass ("GKRandomSource");
	__xamarin_class_map [1782].handle = objc_getClass ("GKARC4RandomSource");
	__xamarin_class_map [1783].handle = objc_getClass ("GKNoiseSource");
	__xamarin_class_map [1784].handle = objc_getClass ("GKCoherentNoiseSource");
	__xamarin_class_map [1785].handle = objc_getClass ("GKBillowNoiseSource");
	__xamarin_class_map [1786].handle = objc_getClass ("GKCheckerboardNoiseSource");
	__xamarin_class_map [1787].handle = objc_getClass ("GKCircleObstacle");
	__xamarin_class_map [1788].handle = objc_getClass ("GKConstantNoiseSource");
	__xamarin_class_map [1789].handle = objc_getClass ("GKCylindersNoiseSource");
	__xamarin_class_map [1790].handle = objc_getClass ("GKDecisionNode");
	__xamarin_class_map [1791].handle = objc_getClass ("GKDecisionTree");
	__xamarin_class_map [1792].handle = objc_getClass ("GKRandomDistribution");
	__xamarin_class_map [1793].handle = objc_getClass ("GKGaussianDistribution");
	__xamarin_class_map [1794].handle = objc_getClass ("GKGoal");
	__xamarin_class_map [1795].handle = objc_getClass ("GKGraphNode");
	__xamarin_class_map [1796].handle = objc_getClass ("GKGraphNode2D");
	__xamarin_class_map [1797].handle = objc_getClass ("GKGraphNode3D");
	__xamarin_class_map [1798].handle = objc_getClass ("GKGridGraphNode");
	__xamarin_class_map [1799].handle = objc_getClass ("GKHybridStrategist");
	__xamarin_class_map [1800].handle = objc_getClass ("GKLinearCongruentialRandomSource");
	__xamarin_class_map [1801].handle = objc_getClass ("GKMersenneTwisterRandomSource");
	__xamarin_class_map [1802].handle = objc_getClass ("GKMeshGraph");
	__xamarin_class_map [1803].handle = objc_getClass ("GKMinmaxStrategist");
	__xamarin_class_map [1804].handle = objc_getClass ("GKMonteCarloStrategist");
	__xamarin_class_map [1805].handle = objc_getClass ("GKNoise");
	__xamarin_class_map [1806].handle = objc_getClass ("GKNoiseMap");
	__xamarin_class_map [1807].handle = objc_getClass ("GKRule");
	__xamarin_class_map [1808].handle = objc_getClass ("GKNSPredicateRule");
	__xamarin_class_map [1809].handle = objc_getClass ("GKOctree");
	__xamarin_class_map [1810].handle = objc_getClass ("GKOctreeNode");
	__xamarin_class_map [1811].handle = objc_getClass ("GKPerlinNoiseSource");
	__xamarin_class_map [1812].handle = objc_getClass ("GKRidgedNoiseSource");
	__xamarin_class_map [1813].handle = objc_getClass ("GKRTree");
	__xamarin_class_map [1814].handle = objc_getClass ("GKRuleSystem");
	__xamarin_class_map [1815].handle = objc_getClass ("GKScene");
	__xamarin_class_map [1816].handle = objc_getClass ("GKSCNNodeComponent");
	__xamarin_class_map [1817].handle = objc_getClass ("GKShuffledDistribution");
	__xamarin_class_map [1818].handle = objc_getClass ("GKSKNodeComponent");
	__xamarin_class_map [1819].handle = objc_getClass ("GKSphereObstacle");
	__xamarin_class_map [1820].handle = objc_getClass ("GKSpheresNoiseSource");
	__xamarin_class_map [1821].handle = objc_getClass ("GKVoronoiNoiseSource");
	__xamarin_class_map [1822].handle = objc_getClass ("GKMatchRequest");
	__xamarin_class_map [1823].handle = objc_getClass ("GameKit_GKPeerPickerControllerDelegate");
	__xamarin_class_map [1824].handle = objc_getClass ("GameKit_GKPeerPickerController");
	__xamarin_class_map [1825].handle = objc_getClass ("GKLocalPlayerListener");
	__xamarin_class_map [1826].handle = objc_getClass ("GKSessionDelegate");
	__xamarin_class_map [1827].handle = objc_getClass ("GameKit_Mono_GKSessionDelegate");
	__xamarin_class_map [1828].handle = objc_getClass ("GKVoiceChat");
	__xamarin_class_map [1829].handle = objc_getClass ("GKTurnBasedExchangeReply");
	__xamarin_class_map [1830].handle = objc_getClass ("GKAccessPoint");
	__xamarin_class_map [1831].handle = objc_getClass ("GKChallenge");
	__xamarin_class_map [1832].handle = objc_getClass ("GKAchievementChallenge");
	__xamarin_class_map [1833].handle = objc_getClass ("GKAchievementViewControllerDelegate");
	__xamarin_class_map [1834].handle = objc_getClass ("GKBasePlayer");
	__xamarin_class_map [1835].handle = objc_getClass ("GKChallengeEventHandlerDelegate");
	__xamarin_class_map [1836].handle = objc_getClass ("GKChallengeListener");
	__xamarin_class_map [1837].handle = objc_getClass ("GKCloudPlayer");
	__xamarin_class_map [1838].handle = objc_getClass ("GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [1839].handle = objc_getClass ("GKGameCenterControllerDelegate");
	__xamarin_class_map [1840].handle = objc_getClass ("GKInvite");
	__xamarin_class_map [1841].handle = objc_getClass ("GKInviteEventListener");
	__xamarin_class_map [1842].handle = objc_getClass ("GKLeaderboardScore");
	__xamarin_class_map [1843].handle = objc_getClass ("GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [1844].handle = objc_getClass ("GKMatchDelegate");
	__xamarin_class_map [1845].handle = objc_getClass ("GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [1846].handle = objc_getClass ("GKSavedGameListener");
	__xamarin_class_map [1847].handle = objc_getClass ("GKScoreChallenge");
	__xamarin_class_map [1848].handle = objc_getClass ("GKTurnBasedEventHandler");
	__xamarin_class_map [1849].handle = objc_getClass ("GKTurnBasedEventHandlerDelegate");
	__xamarin_class_map [1850].handle = objc_getClass ("GKTurnBasedEventListener");
	__xamarin_class_map [1851].handle = objc_getClass ("GKTurnBasedMatchmakerViewControllerDelegate");
	__xamarin_class_map [1852].handle = objc_getClass ("GKTurnBasedParticipant");
	__xamarin_class_map [1853].handle = objc_getClass ("GKVoiceChatClient");
	__xamarin_class_map [1854].handle = objc_getClass ("GKVoiceChatService");
	__xamarin_class_map [1855].handle = objc_getClass ("GCPhysicalInputProfile");
	__xamarin_class_map [1856].handle = objc_getClass ("GCExtendedGamepad");
	__xamarin_class_map [1857].handle = objc_getClass ("GCExtendedGamepadSnapshot");
	__xamarin_class_map [1858].handle = objc_getClass ("GCGamepad");
	__xamarin_class_map [1859].handle = objc_getClass ("GCGamepadSnapshot");
	__xamarin_class_map [1860].handle = objc_getClass ("GCMicroGamepad");
	__xamarin_class_map [1861].handle = objc_getClass ("GCMicroGamepadSnapshot");
	__xamarin_class_map [1862].handle = objc_getClass ("GCColor");
	__xamarin_class_map [1863].handle = objc_getClass ("GCControllerElement");
	__xamarin_class_map [1864].handle = objc_getClass ("GCControllerAxisInput");
	__xamarin_class_map [1865].handle = objc_getClass ("GCControllerButtonInput");
	__xamarin_class_map [1866].handle = objc_getClass ("GCControllerDirectionPad");
	__xamarin_class_map [1867].handle = objc_getClass ("GCControllerTouchpad");
	__xamarin_class_map [1868].handle = objc_getClass ("GCDeviceBattery");
	__xamarin_class_map [1869].handle = objc_getClass ("GCDeviceCursor");
	__xamarin_class_map [1870].handle = objc_getClass ("GCDeviceHaptics");
	__xamarin_class_map [1871].handle = objc_getClass ("GCDeviceLight");
	__xamarin_class_map [1872].handle = objc_getClass ("GCDirectionalGamepad");
	__xamarin_class_map [1873].handle = objc_getClass ("GCDualSenseAdaptiveTrigger");
	__xamarin_class_map [1874].handle = objc_getClass ("GCDualSenseGamepad");
	__xamarin_class_map [1875].handle = objc_getClass ("GCDualShockGamepad");
	__xamarin_class_map [1876].handle = objc_getClass ("GCEventViewController");
	__xamarin_class_map [1877].handle = objc_getClass ("GCKeyboardInput");
	__xamarin_class_map [1878].handle = objc_getClass ("GCMotion");
	__xamarin_class_map [1879].handle = objc_getClass ("GCMouseInput");
	__xamarin_class_map [1880].handle = objc_getClass ("GCVirtualControllerConfiguration");
	__xamarin_class_map [1881].handle = objc_getClass ("GCVirtualControllerElementConfiguration");
	__xamarin_class_map [1882].handle = objc_getClass ("GCXboxGamepad");
	__xamarin_class_map [1883].handle = objc_getClass ("GLKMesh");
	__xamarin_class_map [1884].handle = objc_getClass ("GLKBaseEffect");
	__xamarin_class_map [1885].handle = objc_getClass ("GLKEffectProperty");
	__xamarin_class_map [1886].handle = objc_getClass ("GLKEffectPropertyFog");
	__xamarin_class_map [1887].handle = objc_getClass ("GLKEffectPropertyLight");
	__xamarin_class_map [1888].handle = objc_getClass ("GLKEffectPropertyMaterial");
	__xamarin_class_map [1889].handle = objc_getClass ("GLKEffectPropertyTexture");
	__xamarin_class_map [1890].handle = objc_getClass ("GLKEffectPropertyTransform");
	__xamarin_class_map [1891].handle = objc_getClass ("GLKMeshBuffer");
	__xamarin_class_map [1892].handle = objc_getClass ("GLKMeshBufferAllocator");
	__xamarin_class_map [1893].handle = objc_getClass ("GLKNamedEffect");
	__xamarin_class_map [1894].handle = objc_getClass ("GLKReflectionMapEffect");
	__xamarin_class_map [1895].handle = objc_getClass ("GLKSkyboxEffect");
	__xamarin_class_map [1896].handle = objc_getClass ("GLKSubmesh");
	__xamarin_class_map [1897].handle = objc_getClass ("GLKTextureInfo");
	__xamarin_class_map [1898].handle = objc_getClass ("GLKViewController");
	__xamarin_class_map [1899].handle = objc_getClass ("GLKViewControllerDelegate");
	__xamarin_class_map [1900].handle = objc_getClass ("GLKViewDelegate");
	__xamarin_class_map [1901].handle = objc_getClass ("WKPreferences");
	__xamarin_class_map [1902].handle = objc_getClass ("WKWindowFeatures");
	__xamarin_class_map [1903].handle = objc_getClass ("WKBackForwardList");
	__xamarin_class_map [1904].handle = objc_getClass ("WKBackForwardListItem");
	__xamarin_class_map [1905].handle = objc_getClass ("WKContentRuleList");
	__xamarin_class_map [1906].handle = objc_getClass ("WKContentWorld");
	__xamarin_class_map [1907].handle = objc_getClass ("WKContextMenuElementInfo");
	__xamarin_class_map [1908].handle = objc_getClass ("Xamarin_iOS__WebKit_WKDownloadDelegate");
	__xamarin_class_map [1909].handle = objc_getClass ("WKFindConfiguration");
	__xamarin_class_map [1910].handle = objc_getClass ("WKFindResult");
	__xamarin_class_map [1911].handle = objc_getClass ("WKFrameInfo");
	__xamarin_class_map [1912].handle = objc_getClass ("WKNavigation");
	__xamarin_class_map [1913].handle = objc_getClass ("WKNavigationAction");
	__xamarin_class_map [1914].handle = objc_getClass ("WKNavigationDelegate");
	__xamarin_class_map [1915].handle = objc_getClass ("WKNavigationResponse");
	__xamarin_class_map [1916].handle = objc_getClass ("WKPDFConfiguration");
	__xamarin_class_map [1917].handle = objc_getClass ("WKPreviewElementInfo");
	__xamarin_class_map [1918].handle = objc_getClass ("WKProcessPool");
	__xamarin_class_map [1919].handle = objc_getClass ("WKScriptMessage");
	__xamarin_class_map [1920].handle = objc_getClass ("WKScriptMessageHandler");
	__xamarin_class_map [1921].handle = objc_getClass ("WKSecurityOrigin");
	__xamarin_class_map [1922].handle = objc_getClass ("WKSnapshotConfiguration");
	__xamarin_class_map [1923].handle = objc_getClass ("WKUIDelegate");
	__xamarin_class_map [1924].handle = objc_getClass ("WKUserContentController");
	__xamarin_class_map [1925].handle = objc_getClass ("WKUserScript");
	__xamarin_class_map [1926].handle = objc_getClass ("WKWebpagePreferences");
	__xamarin_class_map [1927].handle = objc_getClass ("WKWebsiteDataRecord");
	__xamarin_class_map [1928].handle = objc_getClass ("WKWebViewConfiguration");
	__xamarin_class_map [1929].handle = objc_getClass ("NSOperation");
	__xamarin_class_map [1930].handle = objc_getClass ("Foundation_NSDispatcher");
	__xamarin_class_map [1931].handle = objc_getClass ("__MonoMac_NSActionDispatcher");
	__xamarin_class_map [1932].handle = objc_getClass ("__MonoMac_NSSynchronizationContextDispatcher");
	__xamarin_class_map [1933].handle = objc_getClass ("__Xamarin_NSTimerActionDispatcher");
	__xamarin_class_map [1934].handle = objc_getClass ("Foundation_NSAsyncDispatcher");
	__xamarin_class_map [1935].handle = objc_getClass ("__MonoMac_NSAsyncActionDispatcher");
	__xamarin_class_map [1936].handle = objc_getClass ("__MonoMac_NSAsyncSynchronizationContextDispatcher");
	__xamarin_class_map [1937].handle = objc_getClass ("NSArray");
	__xamarin_class_map [1938].handle = objc_getClass ("NSAutoreleasePool");
	__xamarin_class_map [1939].handle = objc_getClass ("NSBundle");
	__xamarin_class_map [1940].handle = objc_getClass ("NSDate");
	__xamarin_class_map [1941].handle = objc_getClass ("NSDateComponents");
	__xamarin_class_map [1942].handle = objc_getClass ("NSDirectoryEnumerator");
	__xamarin_class_map [1943].handle = objc_getClass ("NSError");
	__xamarin_class_map [1944].handle = objc_getClass ("NSExpression");
	__xamarin_class_map [1945].handle = objc_getClass ("NSFileManagerDelegate");
	__xamarin_class_map [1946].handle = objc_getClass ("NSHTTPCookie");
	__xamarin_class_map [1947].handle = objc_getClass ("NSStream");
	__xamarin_class_map [1948].handle = objc_getClass ("NSInputStream");
	__xamarin_class_map [1949].handle = objc_getClass ("NSMetadataItem");
	__xamarin_class_map [1950].handle = objc_getClass ("NSMutableArray");
	__xamarin_class_map [1951].handle = objc_getClass ("NSAttributedString");
	__xamarin_class_map [1952].handle = objc_getClass ("NSMutableAttributedString");
	__xamarin_class_map [1953].handle = objc_getClass ("NSOrderedSet");
	__xamarin_class_map [1954].handle = objc_getClass ("NSMutableOrderedSet");
	__xamarin_class_map [1955].handle = objc_getClass ("NSSet");
	__xamarin_class_map [1956].handle = objc_getClass ("NSMutableSet");
	__xamarin_class_map [1957].handle = objc_getClass ("NSString");
	__xamarin_class_map [1958].handle = objc_getClass ("NSMutableString");
	__xamarin_class_map [1959].handle = objc_getClass ("NSURLRequest");
	__xamarin_class_map [1960].handle = objc_getClass ("NSMutableURLRequest");
	__xamarin_class_map [1961].handle = objc_getClass ("Foundation_InternalNSNotificationHandler");
	__xamarin_class_map [1962].handle = objc_getClass ("NSNull");
	__xamarin_class_map [1963].handle = objc_getClass ("NSValue");
	__xamarin_class_map [1964].handle = objc_getClass ("NSNumber");
	__xamarin_class_map [1965].handle = objc_getClass ("NSOutputStream");
	__xamarin_class_map [1966].handle = objc_getClass ("NSPredicate");
	__xamarin_class_map [1967].handle = objc_getClass ("NSProxy");
	__xamarin_class_map [1968].handle = objc_getClass ("NSRunLoop");
	__xamarin_class_map [1969].handle = objc_getClass ("NSThread");
	__xamarin_class_map [1970].handle = objc_getClass ("NSTimeZone");
	__xamarin_class_map [1971].handle = objc_getClass ("NSTimer");
	__xamarin_class_map [1972].handle = objc_getClass ("NSUnitAcceleration");
	__xamarin_class_map [1973].handle = objc_getClass ("NSUnitAngle");
	__xamarin_class_map [1974].handle = objc_getClass ("NSUnitArea");
	__xamarin_class_map [1975].handle = objc_getClass ("NSUnitConcentrationMass");
	__xamarin_class_map [1976].handle = objc_getClass ("NSUnitDispersion");
	__xamarin_class_map [1977].handle = objc_getClass ("NSUnitDuration");
	__xamarin_class_map [1978].handle = objc_getClass ("NSUnitElectricCharge");
	__xamarin_class_map [1979].handle = objc_getClass ("NSUnitElectricCurrent");
	__xamarin_class_map [1980].handle = objc_getClass ("NSUnitElectricPotentialDifference");
	__xamarin_class_map [1981].handle = objc_getClass ("NSUnitElectricResistance");
	__xamarin_class_map [1982].handle = objc_getClass ("NSUnitEnergy");
	__xamarin_class_map [1983].handle = objc_getClass ("NSUnitFrequency");
	__xamarin_class_map [1984].handle = objc_getClass ("NSUnitFuelEfficiency");
	__xamarin_class_map [1985].handle = objc_getClass ("NSUnitLength");
	__xamarin_class_map [1986].handle = objc_getClass ("NSUnitIlluminance");
	__xamarin_class_map [1987].handle = objc_getClass ("NSUnitMass");
	__xamarin_class_map [1988].handle = objc_getClass ("NSUnitPower");
	__xamarin_class_map [1989].handle = objc_getClass ("NSUnitPressure");
	__xamarin_class_map [1990].handle = objc_getClass ("NSUnitSpeed");
	__xamarin_class_map [1991].handle = objc_getClass ("NSUnitVolume");
	__xamarin_class_map [1992].handle = objc_getClass ("NSURLComponents");
	__xamarin_class_map [1993].handle = objc_getClass ("NSURLCredential");
	__xamarin_class_map [1994].handle = objc_getClass ("NSURLProtectionSpace");
	__xamarin_class_map [1995].handle = objc_getClass ("NSURLProtocol");
	__xamarin_class_map [1996].handle = objc_getClass ("NSUUID");
	__xamarin_class_map [1997].handle = objc_getClass ("NSXPCConnection");
	__xamarin_class_map [1998].handle = objc_getClass ("NSXPCInterface");
	__xamarin_class_map [1999].handle = objc_getClass ("NSAttributedStringMarkdownParsingOptions");
	__xamarin_class_map [2000].handle = objc_getClass ("NSAttributedStringMarkdownSourcePosition");
	__xamarin_class_map [2001].handle = objc_getClass ("NSBlockOperation");
	__xamarin_class_map [2002].handle = objc_getClass ("NSByteCountFormatter");
	__xamarin_class_map [2003].handle = objc_getClass ("NSCacheDelegate");
	__xamarin_class_map [2004].handle = objc_getClass ("NSCachedURLResponse");
	__xamarin_class_map [2005].handle = objc_getClass ("NSCharacterSet");
	__xamarin_class_map [2006].handle = objc_getClass ("NSCoding");
	__xamarin_class_map [2007].handle = objc_getClass ("NSComparisonPredicate");
	__xamarin_class_map [2008].handle = objc_getClass ("NSCompoundPredicate");
	__xamarin_class_map [2009].handle = objc_getClass ("NSCondition");
	__xamarin_class_map [2010].handle = objc_getClass ("NSConditionLock");
	__xamarin_class_map [2011].handle = objc_getClass ("NSCopying");
	__xamarin_class_map [2012].handle = objc_getClass ("NSRegularExpression");
	__xamarin_class_map [2013].handle = objc_getClass ("NSDataDetector");
	__xamarin_class_map [2014].handle = objc_getClass ("NSDateComponentsFormatter");
	__xamarin_class_map [2015].handle = objc_getClass ("NSDateFormatter");
	__xamarin_class_map [2016].handle = objc_getClass ("NSDateInterval");
	__xamarin_class_map [2017].handle = objc_getClass ("NSDateIntervalFormatter");
	__xamarin_class_map [2018].handle = objc_getClass ("NSDecimalNumber");
	__xamarin_class_map [2019].handle = objc_getClass ("NSEnergyFormatter");
	__xamarin_class_map [2020].handle = objc_getClass ("NSException");
	__xamarin_class_map [2021].handle = objc_getClass ("NSExtensionItem");
	__xamarin_class_map [2022].handle = objc_getClass ("NSExtensionRequestHandling");
	__xamarin_class_map [2023].handle = objc_getClass ("NSFileAccessIntent");
	__xamarin_class_map [2024].handle = objc_getClass ("NSFileCoordinator");
	__xamarin_class_map [2025].handle = objc_getClass ("NSFilePresenter");
	__xamarin_class_map [2026].handle = objc_getClass ("NSFileProviderService");
	__xamarin_class_map [2027].handle = objc_getClass ("NSFileWrapper");
	__xamarin_class_map [2028].handle = objc_getClass ("NSURLResponse");
	__xamarin_class_map [2029].handle = objc_getClass ("NSHTTPURLResponse");
	__xamarin_class_map [2030].handle = objc_getClass ("NSIndexSet");
	__xamarin_class_map [2031].handle = objc_getClass ("NSInflectionRule");
	__xamarin_class_map [2032].handle = objc_getClass ("NSInflectionRuleExplicit");
	__xamarin_class_map [2033].handle = objc_getClass ("NSInvocation");
	__xamarin_class_map [2034].handle = objc_getClass ("NSISO8601DateFormatter");
	__xamarin_class_map [2035].handle = objc_getClass ("NSJSONSerialization");
	__xamarin_class_map [2036].handle = objc_getClass ("NSKeyedArchiverDelegate");
	__xamarin_class_map [2037].handle = objc_getClass ("NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2038].handle = objc_getClass ("NSLengthFormatter");
	__xamarin_class_map [2039].handle = objc_getClass ("NSLinguisticTagger");
	__xamarin_class_map [2040].handle = objc_getClass ("NSListFormatter");
	__xamarin_class_map [2041].handle = objc_getClass ("NSLock");
	__xamarin_class_map [2042].handle = objc_getClass ("NSPort");
	__xamarin_class_map [2043].handle = objc_getClass ("NSMachPort");
	__xamarin_class_map [2044].handle = objc_getClass ("NSPortDelegate");
	__xamarin_class_map [2045].handle = objc_getClass ("NSMachPortDelegate");
	__xamarin_class_map [2046].handle = objc_getClass ("NSMassFormatter");
	__xamarin_class_map [2047].handle = objc_getClass ("NSMeasurement");
	__xamarin_class_map [2048].handle = objc_getClass ("NSMeasurementFormatter");
	__xamarin_class_map [2049].handle = objc_getClass ("NSMetadataQueryAttributeValueTuple");
	__xamarin_class_map [2050].handle = objc_getClass ("NSMetadataQueryDelegate");
	__xamarin_class_map [2051].handle = objc_getClass ("NSMetadataQueryResultGroup");
	__xamarin_class_map [2052].handle = objc_getClass ("NSMethodSignature");
	__xamarin_class_map [2053].handle = objc_getClass ("NSMorphology");
	__xamarin_class_map [2054].handle = objc_getClass ("NSMorphologyCustomPronoun");
	__xamarin_class_map [2055].handle = objc_getClass ("NSMutableCharacterSet");
	__xamarin_class_map [2056].handle = objc_getClass ("NSMutableCopying");
	__xamarin_class_map [2057].handle = objc_getClass ("NSMutableIndexSet");
	__xamarin_class_map [2058].handle = objc_getClass ("NSNetServiceBrowserDelegate");
	__xamarin_class_map [2059].handle = objc_getClass ("NSNetServiceDelegate");
	__xamarin_class_map [2060].handle = objc_getClass ("NSNotification");
	__xamarin_class_map [2061].handle = objc_getClass ("NSNotificationQueue");
	__xamarin_class_map [2062].handle = objc_getClass ("NSNumberFormatter");
	__xamarin_class_map [2063].handle = objc_getClass ("NSOperationQueue");
	__xamarin_class_map [2064].handle = objc_getClass ("NSOrthography");
	__xamarin_class_map [2065].handle = objc_getClass ("NSPersonNameComponents");
	__xamarin_class_map [2066].handle = objc_getClass ("NSPersonNameComponentsFormatter");
	__xamarin_class_map [2067].handle = objc_getClass ("NSPipe");
	__xamarin_class_map [2068].handle = objc_getClass ("NSPortMessage");
	__xamarin_class_map [2069].handle = objc_getClass ("NSPresentationIntent");
	__xamarin_class_map [2070].handle = objc_getClass ("NSPropertyListSerialization");
	__xamarin_class_map [2071].handle = objc_getClass ("NSData");
	__xamarin_class_map [2072].handle = objc_getClass ("NSMutableData");
	__xamarin_class_map [2073].handle = objc_getClass ("NSPurgeableData");
	__xamarin_class_map [2074].handle = objc_getClass ("NSRecursiveLock");
	__xamarin_class_map [2075].handle = objc_getClass ("NSRelativeDateTimeFormatter");
	__xamarin_class_map [2076].handle = objc_getClass ("NSSortDescriptor");
	__xamarin_class_map [2077].handle = objc_getClass ("NSStreamDelegate");
	__xamarin_class_map [2078].handle = objc_getClass ("NSStringDrawingContext");
	__xamarin_class_map [2079].handle = objc_getClass ("NSTextCheckingResult");
	__xamarin_class_map [2080].handle = objc_getClass ("NSUnitConverter");
	__xamarin_class_map [2081].handle = objc_getClass ("NSUnitConverterLinear");
	__xamarin_class_map [2082].handle = objc_getClass ("NSUnitInformationStorage");
	__xamarin_class_map [2083].handle = objc_getClass ("NSUnitTemperature");
	__xamarin_class_map [2084].handle = objc_getClass ("NSURLAuthenticationChallenge");
	__xamarin_class_map [2085].handle = objc_getClass ("NSURLAuthenticationChallengeSender");
	__xamarin_class_map [2086].handle = objc_getClass ("NSURLConnectionDelegate");
	__xamarin_class_map [2087].handle = objc_getClass ("NSURLConnectionDataDelegate");
	__xamarin_class_map [2088].handle = objc_getClass ("NSURLConnectionDownloadDelegate");
	__xamarin_class_map [2089].handle = objc_getClass ("NSURLQueryItem");
	__xamarin_class_map [2090].handle = objc_getClass ("NSURLSessionDelegate");
	__xamarin_class_map [2091].handle = objc_getClass ("NSURLSessionTaskDelegate");
	__xamarin_class_map [2092].handle = objc_getClass ("NSURLSessionDataDelegate");
	__xamarin_class_map [2093].handle = objc_getClass ("NSURLSessionTask");
	__xamarin_class_map [2094].handle = objc_getClass ("NSURLSessionDataTask");
	__xamarin_class_map [2095].handle = objc_getClass ("NSURLSessionDownloadDelegate");
	__xamarin_class_map [2096].handle = objc_getClass ("NSURLSessionDownloadTask");
	__xamarin_class_map [2097].handle = objc_getClass ("NSURLSessionStreamDelegate");
	__xamarin_class_map [2098].handle = objc_getClass ("NSURLSessionTaskMetrics");
	__xamarin_class_map [2099].handle = objc_getClass ("NSURLSessionTaskTransactionMetrics");
	__xamarin_class_map [2100].handle = objc_getClass ("NSURLSessionUploadTask");
	__xamarin_class_map [2101].handle = objc_getClass ("Xamarin_iOS__Foundation_NSUrlSessionWebSocketDelegate");
	__xamarin_class_map [2102].handle = objc_getClass ("NSURLSessionWebSocketMessage");
	__xamarin_class_map [2103].handle = objc_getClass ("NSUserActivityDelegate");
	__xamarin_class_map [2104].handle = objc_getClass ("NSXPCListener");
	__xamarin_class_map [2105].handle = objc_getClass ("Xamarin_iOS__Foundation_NSXpcListenerDelegate");
	__xamarin_class_map [2106].handle = objc_getClass ("NSXPCListenerEndpoint");
	__xamarin_class_map [2107].handle = objc_getClass ("NSFileProviderDomainVersion");
	__xamarin_class_map [2108].handle = objc_getClass ("NSFileProviderItemVersion");
	__xamarin_class_map [2109].handle = objc_getClass ("NSFileProviderRequest");
	__xamarin_class_map [2110].handle = objc_getClass ("EKCalendarChooserDelegate");
	__xamarin_class_map [2111].handle = objc_getClass ("EKEventEditViewDelegate");
	__xamarin_class_map [2112].handle = objc_getClass ("EKEventViewDelegate");
	__xamarin_class_map [2113].handle = objc_getClass ("EKObject");
	__xamarin_class_map [2114].handle = objc_getClass ("EKRecurrenceRule");
	__xamarin_class_map [2115].handle = objc_getClass ("EKRecurrenceDayOfWeek");
	__xamarin_class_map [2116].handle = objc_getClass ("EKAlarm");
	__xamarin_class_map [2117].handle = objc_getClass ("EKCalendarItem");
	__xamarin_class_map [2118].handle = objc_getClass ("EKReminder");
	__xamarin_class_map [2119].handle = objc_getClass ("EKCalendar");
	__xamarin_class_map [2120].handle = objc_getClass ("EKEvent");
	__xamarin_class_map [2121].handle = objc_getClass ("EKParticipant");
	__xamarin_class_map [2122].handle = objc_getClass ("EKRecurrenceEnd");
	__xamarin_class_map [2123].handle = objc_getClass ("EKSource");
	__xamarin_class_map [2124].handle = objc_getClass ("EKStructuredLocation");
	__xamarin_class_map [2125].handle = objc_getClass ("EKVirtualConferenceDescriptor");
	__xamarin_class_map [2126].handle = objc_getClass ("EKVirtualConferenceRoomTypeDescriptor");
	__xamarin_class_map [2127].handle = objc_getClass ("EKVirtualConferenceURLDescriptor");
	__xamarin_class_map [2128].handle = objc_getClass ("CTCall");
	__xamarin_class_map [2129].handle = objc_getClass ("CTCallCenter");
	__xamarin_class_map [2130].handle = objc_getClass ("CTCarrier");
	__xamarin_class_map [2131].handle = objc_getClass ("CTCellularData");
	__xamarin_class_map [2132].handle = objc_getClass ("CTCellularPlanProvisioningRequest");
	__xamarin_class_map [2133].handle = objc_getClass ("CTSubscriber");
	__xamarin_class_map [2134].handle = objc_getClass ("CTSubscriberInfo");
	__xamarin_class_map [2135].handle = objc_getClass ("Xamarin_iOS__CoreTelephony_CTTelephonyNetworkInfoDelegate");
	__xamarin_class_map [2136].handle = objc_getClass ("CSCustomAttributeKey");
	__xamarin_class_map [2137].handle = objc_getClass ("CSSearchQueryContext");
	__xamarin_class_map [2138].handle = objc_getClass ("CSSearchableItemAttributeSet");
	__xamarin_class_map [2139].handle = objc_getClass ("CSImportExtension");
	__xamarin_class_map [2140].handle = objc_getClass ("CSIndexExtensionRequestHandler");
	__xamarin_class_map [2141].handle = objc_getClass ("CSLocalizedString");
	__xamarin_class_map [2142].handle = objc_getClass ("CSPerson");
	__xamarin_class_map [2143].handle = objc_getClass ("CSSearchableIndexDelegate");
	__xamarin_class_map [2144].handle = objc_getClass ("CSSearchableItem");
	__xamarin_class_map [2145].handle = objc_getClass ("CSSearchQuery");
	__xamarin_class_map [2146].handle = objc_getClass ("CSSuggestion");
	__xamarin_class_map [2147].handle = objc_getClass ("CSUserQuery");
	__xamarin_class_map [2148].handle = objc_getClass ("CSUserQueryContext");
	__xamarin_class_map [2149].handle = objc_getClass ("CMSensorRecorder");
	__xamarin_class_map [2150].handle = objc_getClass ("CMSensorDataList");
	__xamarin_class_map [2151].handle = objc_getClass ("CMLogItem");
	__xamarin_class_map [2152].handle = objc_getClass ("CMAccelerometerData");
	__xamarin_class_map [2153].handle = objc_getClass ("CMAbsoluteAltitudeData");
	__xamarin_class_map [2154].handle = objc_getClass ("CMAltitudeData");
	__xamarin_class_map [2155].handle = objc_getClass ("CMAmbientPressureData");
	__xamarin_class_map [2156].handle = objc_getClass ("CMAttitude");
	__xamarin_class_map [2157].handle = objc_getClass ("CMDeviceMotion");
	__xamarin_class_map [2158].handle = objc_getClass ("CMDyskineticSymptomResult");
	__xamarin_class_map [2159].handle = objc_getClass ("CMGyroData");
	__xamarin_class_map [2160].handle = objc_getClass ("CMHeadphoneMotionManager");
	__xamarin_class_map [2161].handle = objc_getClass ("Xamarin_iOS__CoreMotion_CMHeadphoneMotionManagerDelegate");
	__xamarin_class_map [2162].handle = objc_getClass ("CMMagnetometerData");
	__xamarin_class_map [2163].handle = objc_getClass ("CMMotionActivity");
	__xamarin_class_map [2164].handle = objc_getClass ("CMMotionManager");
	__xamarin_class_map [2165].handle = objc_getClass ("CMPedometerData");
	__xamarin_class_map [2166].handle = objc_getClass ("CMPedometerEvent");
	__xamarin_class_map [2167].handle = objc_getClass ("CMRecordedAccelerometerData");
	__xamarin_class_map [2168].handle = objc_getClass ("CMRecordedPressureData");
	__xamarin_class_map [2169].handle = objc_getClass ("CMRotationRateData");
	__xamarin_class_map [2170].handle = objc_getClass ("CMRecordedRotationRateData");
	__xamarin_class_map [2171].handle = objc_getClass ("CMTremorResult");
	__xamarin_class_map [2172].handle = objc_getClass ("MIDICISession");
	__xamarin_class_map [2173].handle = objc_getClass ("MIDINetworkConnection");
	__xamarin_class_map [2174].handle = objc_getClass ("MIDINetworkHost");
	__xamarin_class_map [2175].handle = objc_getClass ("MIDICIDeviceInfo");
	__xamarin_class_map [2176].handle = objc_getClass ("MIDICIDiscoveredNode");
	__xamarin_class_map [2177].handle = objc_getClass ("MIDICIDiscoveryManager");
	__xamarin_class_map [2178].handle = objc_getClass ("MIDICIProfile");
	__xamarin_class_map [2179].handle = objc_getClass ("Xamarin_iOS__CoreMidi_MidiCIProfileResponderDelegate");
	__xamarin_class_map [2180].handle = objc_getClass ("MIDICIProfileState");
	__xamarin_class_map [2181].handle = objc_getClass ("MIDINetworkSession");
	__xamarin_class_map [2182].handle = objc_getClass ("MLDictionaryFeatureProvider");
	__xamarin_class_map [2183].handle = objc_getClass ("MLMultiArrayConstraint");
	__xamarin_class_map [2184].handle = objc_getClass ("MLArrayBatchProvider");
	__xamarin_class_map [2185].handle = objc_getClass ("Xamarin_iOS__CoreML_MLCustomModel");
	__xamarin_class_map [2186].handle = objc_getClass ("MLDictionaryConstraint");
	__xamarin_class_map [2187].handle = objc_getClass ("MLFeatureDescription");
	__xamarin_class_map [2188].handle = objc_getClass ("MLFeatureValue");
	__xamarin_class_map [2189].handle = objc_getClass ("MLImageConstraint");
	__xamarin_class_map [2190].handle = objc_getClass ("MLImageSize");
	__xamarin_class_map [2191].handle = objc_getClass ("MLImageSizeConstraint");
	__xamarin_class_map [2192].handle = objc_getClass ("MLKey");
	__xamarin_class_map [2193].handle = objc_getClass ("MLMetricKey");
	__xamarin_class_map [2194].handle = objc_getClass ("MLModelAsset");
	__xamarin_class_map [2195].handle = objc_getClass ("MLModelCollectionEntry");
	__xamarin_class_map [2196].handle = objc_getClass ("MLModelConfiguration");
	__xamarin_class_map [2197].handle = objc_getClass ("MLModelDescription");
	__xamarin_class_map [2198].handle = objc_getClass ("MLMultiArrayShapeConstraint");
	__xamarin_class_map [2199].handle = objc_getClass ("MLNumericConstraint");
	__xamarin_class_map [2200].handle = objc_getClass ("MLParameterDescription");
	__xamarin_class_map [2201].handle = objc_getClass ("MLParameterKey");
	__xamarin_class_map [2202].handle = objc_getClass ("MLPredictionOptions");
	__xamarin_class_map [2203].handle = objc_getClass ("MLSequence");
	__xamarin_class_map [2204].handle = objc_getClass ("MLSequenceConstraint");
	__xamarin_class_map [2205].handle = objc_getClass ("MLTask");
	__xamarin_class_map [2206].handle = objc_getClass ("MLUpdateContext");
	__xamarin_class_map [2207].handle = objc_getClass ("MLUpdateProgressHandlers");
	__xamarin_class_map [2208].handle = objc_getClass ("MLUpdateTask");
	__xamarin_class_map [2209].handle = objc_getClass ("CLHeading");
	__xamarin_class_map [2210].handle = objc_getClass ("CLLocation");
	__xamarin_class_map [2211].handle = objc_getClass ("CLBeacon");
	__xamarin_class_map [2212].handle = objc_getClass ("CLBeaconIdentityConstraint");
	__xamarin_class_map [2213].handle = objc_getClass ("CLRegion");
	__xamarin_class_map [2214].handle = objc_getClass ("CLBeaconRegion");
	__xamarin_class_map [2215].handle = objc_getClass ("CLCircularRegion");
	__xamarin_class_map [2216].handle = objc_getClass ("CLFloor");
	__xamarin_class_map [2217].handle = objc_getClass ("CLLocationManagerDelegate");
	__xamarin_class_map [2218].handle = objc_getClass ("CLLocationSourceInformation");
	__xamarin_class_map [2219].handle = objc_getClass ("CLVisit");
	__xamarin_class_map [2220].handle = objc_getClass ("CIColor");
	__xamarin_class_map [2221].handle = objc_getClass ("CIContext");
	__xamarin_class_map [2222].handle = objc_getClass ("CIDetector");
	__xamarin_class_map [2223].handle = objc_getClass ("CIFilter");
	__xamarin_class_map [2224].handle = objc_getClass ("CIImage");
	__xamarin_class_map [2225].handle = objc_getClass ("CISampler");
	__xamarin_class_map [2226].handle = objc_getClass ("CIVector");
	__xamarin_class_map [2227].handle = objc_getClass ("CoreImage_CIAccordionFoldTransition");
	__xamarin_class_map [2228].handle = objc_getClass ("CoreImage_CICompositingFilter");
	__xamarin_class_map [2229].handle = objc_getClass ("CoreImage_CIAdditionCompositing");
	__xamarin_class_map [2230].handle = objc_getClass ("CoreImage_CIAffineFilter");
	__xamarin_class_map [2231].handle = objc_getClass ("CoreImage_CIAffineClamp");
	__xamarin_class_map [2232].handle = objc_getClass ("CoreImage_CIAffineTile");
	__xamarin_class_map [2233].handle = objc_getClass ("CoreImage_CIAffineTransform");
	__xamarin_class_map [2234].handle = objc_getClass ("CoreImage_CIReductionFilter");
	__xamarin_class_map [2235].handle = objc_getClass ("CoreImage_CIAreaAverage");
	__xamarin_class_map [2236].handle = objc_getClass ("CoreImage_CIAreaHistogram");
	__xamarin_class_map [2237].handle = objc_getClass ("CoreImage_CIAreaLogarithmicHistogram");
	__xamarin_class_map [2238].handle = objc_getClass ("CoreImage_CIAreaMaximum");
	__xamarin_class_map [2239].handle = objc_getClass ("CoreImage_CIAreaMaximumAlpha");
	__xamarin_class_map [2240].handle = objc_getClass ("CoreImage_CIAreaMinimum");
	__xamarin_class_map [2241].handle = objc_getClass ("CoreImage_CIAreaMinimumAlpha");
	__xamarin_class_map [2242].handle = objc_getClass ("CoreImage_CIAreaMinMax");
	__xamarin_class_map [2243].handle = objc_getClass ("CoreImage_CIAreaMinMaxRed");
	__xamarin_class_map [2244].handle = objc_getClass ("CoreImage_CIImageGenerator");
	__xamarin_class_map [2245].handle = objc_getClass ("CoreImage_CIAttributedTextImageGenerator");
	__xamarin_class_map [2246].handle = objc_getClass ("CIBarcodeDescriptor");
	__xamarin_class_map [2247].handle = objc_getClass ("CIAztecCodeDescriptor");
	__xamarin_class_map [2248].handle = objc_getClass ("CoreImage_CICodeGenerator");
	__xamarin_class_map [2249].handle = objc_getClass ("CoreImage_CIAztecCodeGenerator");
	__xamarin_class_map [2250].handle = objc_getClass ("CoreImage_CIBarcodeGenerator");
	__xamarin_class_map [2251].handle = objc_getClass ("CoreImage_CITransitionFilter");
	__xamarin_class_map [2252].handle = objc_getClass ("CoreImage_CIBarsSwipeTransition");
	__xamarin_class_map [2253].handle = objc_getClass ("CoreImage_CIBicubicScaleTransform");
	__xamarin_class_map [2254].handle = objc_getClass ("CoreImage_CIBlendFilter");
	__xamarin_class_map [2255].handle = objc_getClass ("CIKernel");
	__xamarin_class_map [2256].handle = objc_getClass ("CIColorKernel");
	__xamarin_class_map [2257].handle = objc_getClass ("CIBlendKernel");
	__xamarin_class_map [2258].handle = objc_getClass ("CoreImage_CIBlendWithMask");
	__xamarin_class_map [2259].handle = objc_getClass ("CoreImage_CIBlendWithAlphaMask");
	__xamarin_class_map [2260].handle = objc_getClass ("CoreImage_CIBlendWithBlueMask");
	__xamarin_class_map [2261].handle = objc_getClass ("CoreImage_CIBlendWithRedMask");
	__xamarin_class_map [2262].handle = objc_getClass ("CoreImage_CIBloom");
	__xamarin_class_map [2263].handle = objc_getClass ("CoreImage_CILinearBlur");
	__xamarin_class_map [2264].handle = objc_getClass ("CoreImage_CIBokehBlur");
	__xamarin_class_map [2265].handle = objc_getClass ("CoreImage_CIBoxBlur");
	__xamarin_class_map [2266].handle = objc_getClass ("CoreImage_CIDistortionFilter");
	__xamarin_class_map [2267].handle = objc_getClass ("CoreImage_CIBumpDistortion");
	__xamarin_class_map [2268].handle = objc_getClass ("CoreImage_CIBumpDistortionLinear");
	__xamarin_class_map [2269].handle = objc_getClass ("CoreImage_CICameraCalibrationLensCorrection");
	__xamarin_class_map [2270].handle = objc_getClass ("CoreImage_CICheckerboardGenerator");
	__xamarin_class_map [2271].handle = objc_getClass ("CoreImage_CICircleSplashDistortion");
	__xamarin_class_map [2272].handle = objc_getClass ("CoreImage_CIScreenFilter");
	__xamarin_class_map [2273].handle = objc_getClass ("CoreImage_CICircularScreen");
	__xamarin_class_map [2274].handle = objc_getClass ("CoreImage_CICircularWrap");
	__xamarin_class_map [2275].handle = objc_getClass ("CoreImage_CIClamp");
	__xamarin_class_map [2276].handle = objc_getClass ("CoreImage_CICmykHalftone");
	__xamarin_class_map [2277].handle = objc_getClass ("CoreImage_CICode128BarcodeGenerator");
	__xamarin_class_map [2278].handle = objc_getClass ("CoreImage_CIColorAbsoluteDifference");
	__xamarin_class_map [2279].handle = objc_getClass ("CoreImage_CIColorBlendMode");
	__xamarin_class_map [2280].handle = objc_getClass ("CoreImage_CIColorBurnBlendMode");
	__xamarin_class_map [2281].handle = objc_getClass ("CoreImage_CIColorClamp");
	__xamarin_class_map [2282].handle = objc_getClass ("CoreImage_CIColorControls");
	__xamarin_class_map [2283].handle = objc_getClass ("CoreImage_CIColorCrossPolynomial");
	__xamarin_class_map [2284].handle = objc_getClass ("CoreImage_CIColorCube");
	__xamarin_class_map [2285].handle = objc_getClass ("CoreImage_CIColorCubesMixedWithMask");
	__xamarin_class_map [2286].handle = objc_getClass ("CoreImage_CIColorCubeWithColorSpace");
	__xamarin_class_map [2287].handle = objc_getClass ("CoreImage_CIColorCurves");
	__xamarin_class_map [2288].handle = objc_getClass ("CoreImage_CIColorDodgeBlendMode");
	__xamarin_class_map [2289].handle = objc_getClass ("CoreImage_CIColorInvert");
	__xamarin_class_map [2290].handle = objc_getClass ("CoreImage_CIColorMap");
	__xamarin_class_map [2291].handle = objc_getClass ("CoreImage_CIColorMatrix");
	__xamarin_class_map [2292].handle = objc_getClass ("CoreImage_CIColorMonochrome");
	__xamarin_class_map [2293].handle = objc_getClass ("CoreImage_CIColorPolynomial");
	__xamarin_class_map [2294].handle = objc_getClass ("CoreImage_CIColorPosterize");
	__xamarin_class_map [2295].handle = objc_getClass ("CoreImage_CIColorThreshold");
	__xamarin_class_map [2296].handle = objc_getClass ("CoreImage_CIColorThresholdOtsu");
	__xamarin_class_map [2297].handle = objc_getClass ("CoreImage_CIColumnAverage");
	__xamarin_class_map [2298].handle = objc_getClass ("CoreImage_CIComicEffect");
	__xamarin_class_map [2299].handle = objc_getClass ("CoreImage_CIConstantColorGenerator");
	__xamarin_class_map [2300].handle = objc_getClass ("CoreImage_CIConvolutionCore");
	__xamarin_class_map [2301].handle = objc_getClass ("CoreImage_CIConvolution3X3");
	__xamarin_class_map [2302].handle = objc_getClass ("CoreImage_CIConvolution5X5");
	__xamarin_class_map [2303].handle = objc_getClass ("CoreImage_CIConvolution7X7");
	__xamarin_class_map [2304].handle = objc_getClass ("CoreImage_CIConvolution9Horizontal");
	__xamarin_class_map [2305].handle = objc_getClass ("CoreImage_CIConvolution9Vertical");
	__xamarin_class_map [2306].handle = objc_getClass ("CoreImage_CIConvolutionRGB3X3");
	__xamarin_class_map [2307].handle = objc_getClass ("CoreImage_CIConvolutionRGB5X5");
	__xamarin_class_map [2308].handle = objc_getClass ("CoreImage_CIConvolutionRGB7X7");
	__xamarin_class_map [2309].handle = objc_getClass ("CoreImage_CIConvolutionRGB9Horizontal");
	__xamarin_class_map [2310].handle = objc_getClass ("CoreImage_CIConvolutionRGB9Vertical");
	__xamarin_class_map [2311].handle = objc_getClass ("CoreImage_CICopyMachineTransition");
	__xamarin_class_map [2312].handle = objc_getClass ("CoreImage_CICoreMLModelFilter");
	__xamarin_class_map [2313].handle = objc_getClass ("CoreImage_CICrop");
	__xamarin_class_map [2314].handle = objc_getClass ("CoreImage_CICrystallize");
	__xamarin_class_map [2315].handle = objc_getClass ("CoreImage_CIDarkenBlendMode");
	__xamarin_class_map [2316].handle = objc_getClass ("CIDataMatrixCodeDescriptor");
	__xamarin_class_map [2317].handle = objc_getClass ("CoreImage_CIDepthBlurEffect");
	__xamarin_class_map [2318].handle = objc_getClass ("CoreImage_CIDepthDisparityConverter");
	__xamarin_class_map [2319].handle = objc_getClass ("CoreImage_CIDepthOfField");
	__xamarin_class_map [2320].handle = objc_getClass ("CoreImage_CIDepthToDisparity");
	__xamarin_class_map [2321].handle = objc_getClass ("CoreImage_CIDifferenceBlendMode");
	__xamarin_class_map [2322].handle = objc_getClass ("CoreImage_CIDiscBlur");
	__xamarin_class_map [2323].handle = objc_getClass ("CoreImage_CIDisintegrateWithMaskTransition");
	__xamarin_class_map [2324].handle = objc_getClass ("CoreImage_CIDisparityToDepth");
	__xamarin_class_map [2325].handle = objc_getClass ("CoreImage_CIDisplacementDistortion");
	__xamarin_class_map [2326].handle = objc_getClass ("CoreImage_CIDissolveTransition");
	__xamarin_class_map [2327].handle = objc_getClass ("CoreImage_CIDither");
	__xamarin_class_map [2328].handle = objc_getClass ("CoreImage_CIDivideBlendMode");
	__xamarin_class_map [2329].handle = objc_getClass ("CoreImage_CIDocumentEnhancer");
	__xamarin_class_map [2330].handle = objc_getClass ("CoreImage_CIDotScreen");
	__xamarin_class_map [2331].handle = objc_getClass ("CoreImage_CIDroste");
	__xamarin_class_map [2332].handle = objc_getClass ("CoreImage_CIEdgePreserveUpsampleFilter");
	__xamarin_class_map [2333].handle = objc_getClass ("CoreImage_CIEdges");
	__xamarin_class_map [2334].handle = objc_getClass ("CoreImage_CIEdgeWork");
	__xamarin_class_map [2335].handle = objc_getClass ("CoreImage_CITileFilter");
	__xamarin_class_map [2336].handle = objc_getClass ("CoreImage_CIEightfoldReflectedTile");
	__xamarin_class_map [2337].handle = objc_getClass ("CoreImage_CIExclusionBlendMode");
	__xamarin_class_map [2338].handle = objc_getClass ("CoreImage_CIExposureAdjust");
	__xamarin_class_map [2339].handle = objc_getClass ("CoreImage_CIFaceBalance");
	__xamarin_class_map [2340].handle = objc_getClass ("CIFeature");
	__xamarin_class_map [2341].handle = objc_getClass ("CIFaceFeature");
	__xamarin_class_map [2342].handle = objc_getClass ("CoreImage_CIFalseColor");
	__xamarin_class_map [2343].handle = objc_getClass ("CIFilterShape");
	__xamarin_class_map [2344].handle = objc_getClass ("CoreImage_CIFlashTransition");
	__xamarin_class_map [2345].handle = objc_getClass ("CoreImage_CIFourfoldReflectedTile");
	__xamarin_class_map [2346].handle = objc_getClass ("CoreImage_CIFourfoldRotatedTile");
	__xamarin_class_map [2347].handle = objc_getClass ("CoreImage_CIFourfoldTranslatedTile");
	__xamarin_class_map [2348].handle = objc_getClass ("CoreImage_CIGaborGradients");
	__xamarin_class_map [2349].handle = objc_getClass ("CoreImage_CIGammaAdjust");
	__xamarin_class_map [2350].handle = objc_getClass ("CoreImage_CIGaussianBlur");
	__xamarin_class_map [2351].handle = objc_getClass ("CoreImage_CIGaussianGradient");
	__xamarin_class_map [2352].handle = objc_getClass ("CoreImage_CIGlassDistortion");
	__xamarin_class_map [2353].handle = objc_getClass ("CoreImage_CIGlassLozenge");
	__xamarin_class_map [2354].handle = objc_getClass ("CoreImage_CIGlideReflectedTile");
	__xamarin_class_map [2355].handle = objc_getClass ("CoreImage_CIGloom");
	__xamarin_class_map [2356].handle = objc_getClass ("CoreImage_CIGuidedFilter");
	__xamarin_class_map [2357].handle = objc_getClass ("CoreImage_CIHardLightBlendMode");
	__xamarin_class_map [2358].handle = objc_getClass ("CoreImage_CIHatchedScreen");
	__xamarin_class_map [2359].handle = objc_getClass ("CoreImage_CIHeightFieldFromMask");
	__xamarin_class_map [2360].handle = objc_getClass ("CoreImage_CIHexagonalPixellate");
	__xamarin_class_map [2361].handle = objc_getClass ("CoreImage_CIHighlightShadowAdjust");
	__xamarin_class_map [2362].handle = objc_getClass ("CoreImage_CIHistogramDisplayFilter");
	__xamarin_class_map [2363].handle = objc_getClass ("CoreImage_CIHoleDistortion");
	__xamarin_class_map [2364].handle = objc_getClass ("CoreImage_CIHueAdjust");
	__xamarin_class_map [2365].handle = objc_getClass ("CoreImage_CIHueBlendMode");
	__xamarin_class_map [2366].handle = objc_getClass ("CoreImage_CIHueSaturationValueGradient");
	__xamarin_class_map [2367].handle = objc_getClass ("CIImageAccumulator");
	__xamarin_class_map [2368].handle = objc_getClass ("CIImageProcessorKernel");
	__xamarin_class_map [2369].handle = objc_getClass ("CoreImage_CIKaleidoscope");
	__xamarin_class_map [2370].handle = objc_getClass ("CoreImage_CIKeystoneCorrection");
	__xamarin_class_map [2371].handle = objc_getClass ("CoreImage_CIKeystoneCorrectionCombined");
	__xamarin_class_map [2372].handle = objc_getClass ("CoreImage_CIKeystoneCorrectionHorizontal");
	__xamarin_class_map [2373].handle = objc_getClass ("CoreImage_CIKeystoneCorrectionVertical");
	__xamarin_class_map [2374].handle = objc_getClass ("CoreImage_CIKMeans");
	__xamarin_class_map [2375].handle = objc_getClass ("CoreImage_CILabDeltaE");
	__xamarin_class_map [2376].handle = objc_getClass ("CoreImage_CILanczosScaleTransform");
	__xamarin_class_map [2377].handle = objc_getClass ("CoreImage_CILenticularHaloGenerator");
	__xamarin_class_map [2378].handle = objc_getClass ("CoreImage_CILightenBlendMode");
	__xamarin_class_map [2379].handle = objc_getClass ("CoreImage_CILightTunnel");
	__xamarin_class_map [2380].handle = objc_getClass ("CoreImage_CILinearBurnBlendMode");
	__xamarin_class_map [2381].handle = objc_getClass ("CoreImage_CILinearDodgeBlendMode");
	__xamarin_class_map [2382].handle = objc_getClass ("CoreImage_CILinearGradient");
	__xamarin_class_map [2383].handle = objc_getClass ("CoreImage_CILinearLightBlendMode");
	__xamarin_class_map [2384].handle = objc_getClass ("CoreImage_CILinearToSRGBToneCurve");
	__xamarin_class_map [2385].handle = objc_getClass ("CoreImage_CILineOverlay");
	__xamarin_class_map [2386].handle = objc_getClass ("CoreImage_CILineScreen");
	__xamarin_class_map [2387].handle = objc_getClass ("CoreImage_CILuminosityBlendMode");
	__xamarin_class_map [2388].handle = objc_getClass ("CoreImage_CIMaskedVariableBlur");
	__xamarin_class_map [2389].handle = objc_getClass ("CoreImage_CIMaskToAlpha");
	__xamarin_class_map [2390].handle = objc_getClass ("CoreImage_CIMaximumComponent");
	__xamarin_class_map [2391].handle = objc_getClass ("CoreImage_CIMaximumCompositing");
	__xamarin_class_map [2392].handle = objc_getClass ("CoreImage_CIMedianFilter");
	__xamarin_class_map [2393].handle = objc_getClass ("CoreImage_CIMeshGenerator");
	__xamarin_class_map [2394].handle = objc_getClass ("CoreImage_CIMinimumComponent");
	__xamarin_class_map [2395].handle = objc_getClass ("CoreImage_CIMinimumCompositing");
	__xamarin_class_map [2396].handle = objc_getClass ("CoreImage_CIMix");
	__xamarin_class_map [2397].handle = objc_getClass ("CoreImage_CIModTransition");
	__xamarin_class_map [2398].handle = objc_getClass ("CoreImage_CIMorphology");
	__xamarin_class_map [2399].handle = objc_getClass ("CoreImage_CIMorphologyGradient");
	__xamarin_class_map [2400].handle = objc_getClass ("CoreImage_CIMorphologyMaximum");
	__xamarin_class_map [2401].handle = objc_getClass ("CoreImage_CIMorphologyMinimum");
	__xamarin_class_map [2402].handle = objc_getClass ("CoreImage_CIMorphologyRectangle");
	__xamarin_class_map [2403].handle = objc_getClass ("CoreImage_CIMorphologyRectangleMaximum");
	__xamarin_class_map [2404].handle = objc_getClass ("CoreImage_CIMorphologyRectangleMinimum");
	__xamarin_class_map [2405].handle = objc_getClass ("CoreImage_CIMotionBlur");
	__xamarin_class_map [2406].handle = objc_getClass ("CoreImage_CIMultiplyBlendMode");
	__xamarin_class_map [2407].handle = objc_getClass ("CoreImage_CIMultiplyCompositing");
	__xamarin_class_map [2408].handle = objc_getClass ("CoreImage_CINinePartStretched");
	__xamarin_class_map [2409].handle = objc_getClass ("CoreImage_CINinePartTiled");
	__xamarin_class_map [2410].handle = objc_getClass ("CoreImage_CINoiseReduction");
	__xamarin_class_map [2411].handle = objc_getClass ("CoreImage_CIOpTile");
	__xamarin_class_map [2412].handle = objc_getClass ("CoreImage_CIOverlayBlendMode");
	__xamarin_class_map [2413].handle = objc_getClass ("CoreImage_CIPageCurlTransition");
	__xamarin_class_map [2414].handle = objc_getClass ("CoreImage_CIPageCurlWithShadowTransition");
	__xamarin_class_map [2415].handle = objc_getClass ("CoreImage_CIPaletteCentroid");
	__xamarin_class_map [2416].handle = objc_getClass ("CoreImage_CIPalettize");
	__xamarin_class_map [2417].handle = objc_getClass ("CoreImage_CIParallelogramTile");
	__xamarin_class_map [2418].handle = objc_getClass ("CoreImage_CIPdf417BarcodeGenerator");
	__xamarin_class_map [2419].handle = objc_getClass ("CIPDF417CodeDescriptor");
	__xamarin_class_map [2420].handle = objc_getClass ("CoreImage_CIPersonSegmentation");
	__xamarin_class_map [2421].handle = objc_getClass ("CoreImage_CIPerspectiveTransform");
	__xamarin_class_map [2422].handle = objc_getClass ("CoreImage_CIPerspectiveCorrection");
	__xamarin_class_map [2423].handle = objc_getClass ("CoreImage_CIPerspectiveRotate");
	__xamarin_class_map [2424].handle = objc_getClass ("CoreImage_CIPerspectiveTile");
	__xamarin_class_map [2425].handle = objc_getClass ("CoreImage_CIPerspectiveTransformWithExtent");
	__xamarin_class_map [2426].handle = objc_getClass ("CoreImage_CIPhotoEffect");
	__xamarin_class_map [2427].handle = objc_getClass ("CoreImage_CIPhotoEffectChrome");
	__xamarin_class_map [2428].handle = objc_getClass ("CoreImage_CIPhotoEffectFade");
	__xamarin_class_map [2429].handle = objc_getClass ("CoreImage_CIPhotoEffectInstant");
	__xamarin_class_map [2430].handle = objc_getClass ("CoreImage_CIPhotoEffectMono");
	__xamarin_class_map [2431].handle = objc_getClass ("CoreImage_CIPhotoEffectNoir");
	__xamarin_class_map [2432].handle = objc_getClass ("CoreImage_CIPhotoEffectProcess");
	__xamarin_class_map [2433].handle = objc_getClass ("CoreImage_CIPhotoEffectTonal");
	__xamarin_class_map [2434].handle = objc_getClass ("CoreImage_CIPhotoEffectTransfer");
	__xamarin_class_map [2435].handle = objc_getClass ("CoreImage_CIPinchDistortion");
	__xamarin_class_map [2436].handle = objc_getClass ("CoreImage_CIPinLightBlendMode");
	__xamarin_class_map [2437].handle = objc_getClass ("CoreImage_CIPixellate");
	__xamarin_class_map [2438].handle = objc_getClass ("CoreImage_CIPointillize");
	__xamarin_class_map [2439].handle = objc_getClass ("CIQRCodeDescriptor");
	__xamarin_class_map [2440].handle = objc_getClass ("CIQRCodeFeature");
	__xamarin_class_map [2441].handle = objc_getClass ("CoreImage_CIQRCodeGenerator");
	__xamarin_class_map [2442].handle = objc_getClass ("CoreImage_CIRadialGradient");
	__xamarin_class_map [2443].handle = objc_getClass ("CoreImage_CIRandomGenerator");
	__xamarin_class_map [2444].handle = objc_getClass ("CIRAWFilter");
	__xamarin_class_map [2445].handle = objc_getClass ("CIRectangleFeature");
	__xamarin_class_map [2446].handle = objc_getClass ("CIRenderDestination");
	__xamarin_class_map [2447].handle = objc_getClass ("CIRenderInfo");
	__xamarin_class_map [2448].handle = objc_getClass ("CIRenderTask");
	__xamarin_class_map [2449].handle = objc_getClass ("CoreImage_CIRippleTransition");
	__xamarin_class_map [2450].handle = objc_getClass ("CoreImage_CIRoundedRectangleGenerator");
	__xamarin_class_map [2451].handle = objc_getClass ("CoreImage_CIRowAverage");
	__xamarin_class_map [2452].handle = objc_getClass ("CoreImage_CISaliencyMapFilter");
	__xamarin_class_map [2453].handle = objc_getClass ("CoreImage_CISampleNearest");
	__xamarin_class_map [2454].handle = objc_getClass ("CoreImage_CISaturationBlendMode");
	__xamarin_class_map [2455].handle = objc_getClass ("CoreImage_CIScreenBlendMode");
	__xamarin_class_map [2456].handle = objc_getClass ("CoreImage_CISepiaTone");
	__xamarin_class_map [2457].handle = objc_getClass ("CoreImage_CIShadedMaterial");
	__xamarin_class_map [2458].handle = objc_getClass ("CoreImage_CISharpenLuminance");
	__xamarin_class_map [2459].handle = objc_getClass ("CoreImage_CISixfoldReflectedTile");
	__xamarin_class_map [2460].handle = objc_getClass ("CoreImage_CISixfoldRotatedTile");
	__xamarin_class_map [2461].handle = objc_getClass ("CoreImage_CISmoothLinearGradient");
	__xamarin_class_map [2462].handle = objc_getClass ("CoreImage_CISoftLightBlendMode");
	__xamarin_class_map [2463].handle = objc_getClass ("CoreImage_CISourceAtopCompositing");
	__xamarin_class_map [2464].handle = objc_getClass ("CoreImage_CISourceInCompositing");
	__xamarin_class_map [2465].handle = objc_getClass ("CoreImage_CISourceOutCompositing");
	__xamarin_class_map [2466].handle = objc_getClass ("CoreImage_CISourceOverCompositing");
	__xamarin_class_map [2467].handle = objc_getClass ("CoreImage_CISpotColor");
	__xamarin_class_map [2468].handle = objc_getClass ("CoreImage_CISpotLight");
	__xamarin_class_map [2469].handle = objc_getClass ("CoreImage_CISRGBToneCurveToLinear");
	__xamarin_class_map [2470].handle = objc_getClass ("CoreImage_CIStarShineGenerator");
	__xamarin_class_map [2471].handle = objc_getClass ("CoreImage_CIStraightenFilter");
	__xamarin_class_map [2472].handle = objc_getClass ("CoreImage_CIStretchCrop");
	__xamarin_class_map [2473].handle = objc_getClass ("CoreImage_CIStripesGenerator");
	__xamarin_class_map [2474].handle = objc_getClass ("CoreImage_CISubtractBlendMode");
	__xamarin_class_map [2475].handle = objc_getClass ("CoreImage_CISunbeamsGenerator");
	__xamarin_class_map [2476].handle = objc_getClass ("CoreImage_CISwipeTransition");
	__xamarin_class_map [2477].handle = objc_getClass ("CoreImage_CITemperatureAndTint");
	__xamarin_class_map [2478].handle = objc_getClass ("CITextFeature");
	__xamarin_class_map [2479].handle = objc_getClass ("CoreImage_CITextImageGenerator");
	__xamarin_class_map [2480].handle = objc_getClass ("CoreImage_CIThermal");
	__xamarin_class_map [2481].handle = objc_getClass ("CoreImage_CIToneCurve");
	__xamarin_class_map [2482].handle = objc_getClass ("CoreImage_CITorusLensDistortion");
	__xamarin_class_map [2483].handle = objc_getClass ("CoreImage_CITriangleKaleidoscope");
	__xamarin_class_map [2484].handle = objc_getClass ("CoreImage_CITriangleTile");
	__xamarin_class_map [2485].handle = objc_getClass ("CoreImage_CITwelvefoldReflectedTile");
	__xamarin_class_map [2486].handle = objc_getClass ("CoreImage_CITwirlDistortion");
	__xamarin_class_map [2487].handle = objc_getClass ("CoreImage_CIUnsharpMask");
	__xamarin_class_map [2488].handle = objc_getClass ("CoreImage_CIVibrance");
	__xamarin_class_map [2489].handle = objc_getClass ("CoreImage_CIVignette");
	__xamarin_class_map [2490].handle = objc_getClass ("CoreImage_CIVignetteEffect");
	__xamarin_class_map [2491].handle = objc_getClass ("CoreImage_CIVividLightBlendMode");
	__xamarin_class_map [2492].handle = objc_getClass ("CoreImage_CIVortexDistortion");
	__xamarin_class_map [2493].handle = objc_getClass ("CIWarpKernel");
	__xamarin_class_map [2494].handle = objc_getClass ("CoreImage_CIWhitePointAdjust");
	__xamarin_class_map [2495].handle = objc_getClass ("CoreImage_CIXRay");
	__xamarin_class_map [2496].handle = objc_getClass ("CoreImage_CIZoomBlur");
	__xamarin_class_map [2497].handle = objc_getClass ("NSEntityDescription");
	__xamarin_class_map [2498].handle = objc_getClass ("NSMergeConflict");
	__xamarin_class_map [2499].handle = objc_getClass ("NSMergePolicy");
	__xamarin_class_map [2500].handle = objc_getClass ("NSPersistentStoreRequest");
	__xamarin_class_map [2501].handle = objc_getClass ("NSAsynchronousFetchRequest");
	__xamarin_class_map [2502].handle = objc_getClass ("NSPersistentStoreResult");
	__xamarin_class_map [2503].handle = objc_getClass ("NSPersistentStoreAsynchronousResult");
	__xamarin_class_map [2504].handle = objc_getClass ("NSAsynchronousFetchResult");
	__xamarin_class_map [2505].handle = objc_getClass ("NSPersistentStore");
	__xamarin_class_map [2506].handle = objc_getClass ("NSAtomicStore");
	__xamarin_class_map [2507].handle = objc_getClass ("NSAtomicStoreCacheNode");
	__xamarin_class_map [2508].handle = objc_getClass ("NSPropertyDescription");
	__xamarin_class_map [2509].handle = objc_getClass ("NSAttributeDescription");
	__xamarin_class_map [2510].handle = objc_getClass ("NSBatchDeleteRequest");
	__xamarin_class_map [2511].handle = objc_getClass ("NSBatchDeleteResult");
	__xamarin_class_map [2512].handle = objc_getClass ("NSBatchInsertRequest");
	__xamarin_class_map [2513].handle = objc_getClass ("NSBatchInsertResult");
	__xamarin_class_map [2514].handle = objc_getClass ("NSBatchUpdateRequest");
	__xamarin_class_map [2515].handle = objc_getClass ("NSBatchUpdateResult");
	__xamarin_class_map [2516].handle = objc_getClass ("NSConstraintConflict");
	__xamarin_class_map [2517].handle = objc_getClass ("NSDerivedAttributeDescription");
	__xamarin_class_map [2518].handle = objc_getClass ("NSEntityMapping");
	__xamarin_class_map [2519].handle = objc_getClass ("NSEntityMigrationPolicy");
	__xamarin_class_map [2520].handle = objc_getClass ("NSExpressionDescription");
	__xamarin_class_map [2521].handle = objc_getClass ("NSFetchedPropertyDescription");
	__xamarin_class_map [2522].handle = objc_getClass ("NSFetchedResultsController");
	__xamarin_class_map [2523].handle = objc_getClass ("NSFetchedResultsControllerDelegate");
	__xamarin_class_map [2524].handle = objc_getClass ("NSFetchedResultsSectionInfo");
	__xamarin_class_map [2525].handle = objc_getClass ("NSFetchIndexDescription");
	__xamarin_class_map [2526].handle = objc_getClass ("NSFetchIndexElementDescription");
	__xamarin_class_map [2527].handle = objc_getClass ("NSFetchRequest");
	__xamarin_class_map [2528].handle = objc_getClass ("NSFetchRequestExpression");
	__xamarin_class_map [2529].handle = objc_getClass ("NSIncrementalStore");
	__xamarin_class_map [2530].handle = objc_getClass ("NSIncrementalStoreNode");
	__xamarin_class_map [2531].handle = objc_getClass ("NSManagedObject");
	__xamarin_class_map [2532].handle = objc_getClass ("NSManagedObjectID");
	__xamarin_class_map [2533].handle = objc_getClass ("NSManagedObjectModel");
	__xamarin_class_map [2534].handle = objc_getClass ("NSMappingModel");
	__xamarin_class_map [2535].handle = objc_getClass ("NSMigrationManager");
	__xamarin_class_map [2536].handle = objc_getClass ("NSPersistentCloudKitContainerEventRequest");
	__xamarin_class_map [2537].handle = objc_getClass ("NSPersistentCloudKitContainerEventResult");
	__xamarin_class_map [2538].handle = objc_getClass ("NSPersistentCloudKitContainerOptions");
	__xamarin_class_map [2539].handle = objc_getClass ("NSPersistentHistoryChange");
	__xamarin_class_map [2540].handle = objc_getClass ("NSPersistentHistoryChangeRequest");
	__xamarin_class_map [2541].handle = objc_getClass ("NSPersistentHistoryResult");
	__xamarin_class_map [2542].handle = objc_getClass ("NSPersistentHistoryToken");
	__xamarin_class_map [2543].handle = objc_getClass ("NSPersistentHistoryTransaction");
	__xamarin_class_map [2544].handle = objc_getClass ("NSPersistentStoreDescription");
	__xamarin_class_map [2545].handle = objc_getClass ("NSPropertyMapping");
	__xamarin_class_map [2546].handle = objc_getClass ("NSQueryGenerationToken");
	__xamarin_class_map [2547].handle = objc_getClass ("NSRelationshipDescription");
	__xamarin_class_map [2548].handle = objc_getClass ("NSSaveChangesRequest");
	__xamarin_class_map [2549].handle = objc_getClass ("CBAttribute");
	__xamarin_class_map [2550].handle = objc_getClass ("CBCharacteristic");
	__xamarin_class_map [2551].handle = objc_getClass ("CBMutableCharacteristic");
	__xamarin_class_map [2552].handle = objc_getClass ("CBService");
	__xamarin_class_map [2553].handle = objc_getClass ("CBMutableService");
	__xamarin_class_map [2554].handle = objc_getClass ("CBManager");
	__xamarin_class_map [2555].handle = objc_getClass ("CBPeer");
	__xamarin_class_map [2556].handle = objc_getClass ("CBUUID");
	__xamarin_class_map [2557].handle = objc_getClass ("CBATTRequest");
	__xamarin_class_map [2558].handle = objc_getClass ("CBCentral");
	__xamarin_class_map [2559].handle = objc_getClass ("CBCentralManagerDelegate");
	__xamarin_class_map [2560].handle = objc_getClass ("CBDescriptor");
	__xamarin_class_map [2561].handle = objc_getClass ("CBL2CAPChannel");
	__xamarin_class_map [2562].handle = objc_getClass ("CBMutableDescriptor");
	__xamarin_class_map [2563].handle = objc_getClass ("CBPeripheralDelegate");
	__xamarin_class_map [2564].handle = objc_getClass ("CBPeripheralManagerDelegate");
	__xamarin_class_map [2565].handle = objc_getClass ("CAAnimation");
	__xamarin_class_map [2566].handle = objc_getClass ("CAPropertyAnimation");
	__xamarin_class_map [2567].handle = objc_getClass ("CABasicAnimation");
	__xamarin_class_map [2568].handle = objc_getClass ("CALayer");
	__xamarin_class_map [2569].handle = objc_getClass ("CAScrollLayer");
	__xamarin_class_map [2570].handle = objc_getClass ("CAEmitterBehavior");
	__xamarin_class_map [2571].handle = objc_getClass ("CAMetalLayer");
	__xamarin_class_map [2572].handle = objc_getClass ("CAGradientLayer");
	__xamarin_class_map [2573].handle = objc_getClass ("CAKeyframeAnimation");
	__xamarin_class_map [2574].handle = objc_getClass ("CADisplayLink");
	__xamarin_class_map [2575].handle = objc_getClass ("CALayerDelegate");
	__xamarin_class_map [2576].handle = objc_getClass ("CAMediaTimingFunction");
	__xamarin_class_map [2577].handle = objc_getClass ("CATextLayer");
	__xamarin_class_map [2578].handle = objc_getClass ("CAAction");
	__xamarin_class_map [2579].handle = objc_getClass ("CAAnimationDelegate");
	__xamarin_class_map [2580].handle = objc_getClass ("CAAnimationGroup");
	__xamarin_class_map [2581].handle = objc_getClass ("CAEAGLLayer");
	__xamarin_class_map [2582].handle = objc_getClass ("CAEmitterCell");
	__xamarin_class_map [2583].handle = objc_getClass ("CAEmitterLayer");
	__xamarin_class_map [2584].handle = objc_getClass ("CAMediaTiming");
	__xamarin_class_map [2585].handle = objc_getClass ("CAReplicatorLayer");
	__xamarin_class_map [2586].handle = objc_getClass ("CAShapeLayer");
	__xamarin_class_map [2587].handle = objc_getClass ("CASpringAnimation");
	__xamarin_class_map [2588].handle = objc_getClass ("CATiledLayer");
	__xamarin_class_map [2589].handle = objc_getClass ("CATransaction");
	__xamarin_class_map [2590].handle = objc_getClass ("CATransformLayer");
	__xamarin_class_map [2591].handle = objc_getClass ("CATransition");
	__xamarin_class_map [2592].handle = objc_getClass ("CAValueFunction");
	__xamarin_class_map [2593].handle = objc_getClass ("CNFetchRequest");
	__xamarin_class_map [2594].handle = objc_getClass ("CNContactFetchRequest");
	__xamarin_class_map [2595].handle = objc_getClass ("CNInstantMessageAddress");
	__xamarin_class_map [2596].handle = objc_getClass ("CNSocialProfile");
	__xamarin_class_map [2597].handle = objc_getClass ("CNChangeHistoryEvent");
	__xamarin_class_map [2598].handle = objc_getClass ("CNChangeHistoryAddContactEvent");
	__xamarin_class_map [2599].handle = objc_getClass ("CNChangeHistoryAddGroupEvent");
	__xamarin_class_map [2600].handle = objc_getClass ("CNChangeHistoryAddMemberToGroupEvent");
	__xamarin_class_map [2601].handle = objc_getClass ("CNChangeHistoryAddSubgroupToGroupEvent");
	__xamarin_class_map [2602].handle = objc_getClass ("CNChangeHistoryDeleteContactEvent");
	__xamarin_class_map [2603].handle = objc_getClass ("CNChangeHistoryDeleteGroupEvent");
	__xamarin_class_map [2604].handle = objc_getClass ("CNChangeHistoryDropEverythingEvent");
	__xamarin_class_map [2605].handle = objc_getClass ("CNChangeHistoryFetchRequest");
	__xamarin_class_map [2606].handle = objc_getClass ("CNChangeHistoryRemoveMemberFromGroupEvent");
	__xamarin_class_map [2607].handle = objc_getClass ("CNChangeHistoryRemoveSubgroupFromGroupEvent");
	__xamarin_class_map [2608].handle = objc_getClass ("CNChangeHistoryUpdateContactEvent");
	__xamarin_class_map [2609].handle = objc_getClass ("CNChangeHistoryUpdateGroupEvent");
	__xamarin_class_map [2610].handle = objc_getClass ("CNContactFormatter");
	__xamarin_class_map [2611].handle = objc_getClass ("CNContactProperty");
	__xamarin_class_map [2612].handle = objc_getClass ("CNContactRelation");
	__xamarin_class_map [2613].handle = objc_getClass ("CNContactsUserDefaults");
	__xamarin_class_map [2614].handle = objc_getClass ("CNContactVCardSerialization");
	__xamarin_class_map [2615].handle = objc_getClass ("CNContainer");
	__xamarin_class_map [2616].handle = objc_getClass ("CNFetchResult");
	__xamarin_class_map [2617].handle = objc_getClass ("CNGroup");
	__xamarin_class_map [2618].handle = objc_getClass ("CNLabeledValue");
	__xamarin_class_map [2619].handle = objc_getClass ("CNContact");
	__xamarin_class_map [2620].handle = objc_getClass ("CNMutableContact");
	__xamarin_class_map [2621].handle = objc_getClass ("CNMutableGroup");
	__xamarin_class_map [2622].handle = objc_getClass ("CNPostalAddress");
	__xamarin_class_map [2623].handle = objc_getClass ("CNMutablePostalAddress");
	__xamarin_class_map [2624].handle = objc_getClass ("CNPhoneNumber");
	__xamarin_class_map [2625].handle = objc_getClass ("CNPostalAddressFormatter");
	__xamarin_class_map [2626].handle = objc_getClass ("CNSaveRequest");
	__xamarin_class_map [2627].handle = objc_getClass ("CKNotification");
	__xamarin_class_map [2628].handle = objc_getClass ("CKQueryNotification");
	__xamarin_class_map [2629].handle = objc_getClass ("CKOperation");
	__xamarin_class_map [2630].handle = objc_getClass ("CKNotificationID");
	__xamarin_class_map [2631].handle = objc_getClass ("CKDiscoverAllContactsOperation");
	__xamarin_class_map [2632].handle = objc_getClass ("CloudKit_CKDiscoverUserInfosOperation");
	__xamarin_class_map [2633].handle = objc_getClass ("CKSubscription");
	__xamarin_class_map [2634].handle = objc_getClass ("CKDiscoveredUserInfo");
	__xamarin_class_map [2635].handle = objc_getClass ("CKRecord");
	__xamarin_class_map [2636].handle = objc_getClass ("CKRecordID");
	__xamarin_class_map [2637].handle = objc_getClass ("CKRecordZoneID");
	__xamarin_class_map [2638].handle = objc_getClass ("CKUserIdentityLookupInfo");
	__xamarin_class_map [2639].handle = objc_getClass ("CKAcceptSharesOperation");
	__xamarin_class_map [2640].handle = objc_getClass ("CKAllowedSharingOptions");
	__xamarin_class_map [2641].handle = objc_getClass ("CKAsset");
	__xamarin_class_map [2642].handle = objc_getClass ("CKDatabaseNotification");
	__xamarin_class_map [2643].handle = objc_getClass ("CKDatabaseOperation");
	__xamarin_class_map [2644].handle = objc_getClass ("CKDatabaseSubscription");
	__xamarin_class_map [2645].handle = objc_getClass ("CKDiscoverAllUserIdentitiesOperation");
	__xamarin_class_map [2646].handle = objc_getClass ("CKDiscoverUserIdentitiesOperation");
	__xamarin_class_map [2647].handle = objc_getClass ("CKFetchDatabaseChangesOperation");
	__xamarin_class_map [2648].handle = objc_getClass ("CKFetchNotificationChangesOperation");
	__xamarin_class_map [2649].handle = objc_getClass ("CKFetchRecordChangesOperation");
	__xamarin_class_map [2650].handle = objc_getClass ("CKFetchRecordsOperation");
	__xamarin_class_map [2651].handle = objc_getClass ("CKFetchRecordZoneChangesConfiguration");
	__xamarin_class_map [2652].handle = objc_getClass ("CKFetchRecordZoneChangesOperation");
	__xamarin_class_map [2653].handle = objc_getClass ("CKFetchRecordZoneChangesOptions");
	__xamarin_class_map [2654].handle = objc_getClass ("CKFetchRecordZonesOperation");
	__xamarin_class_map [2655].handle = objc_getClass ("CKFetchShareMetadataOperation");
	__xamarin_class_map [2656].handle = objc_getClass ("CKFetchShareParticipantsOperation");
	__xamarin_class_map [2657].handle = objc_getClass ("CKFetchSubscriptionsOperation");
	__xamarin_class_map [2658].handle = objc_getClass ("CKFetchWebAuthTokenOperation");
	__xamarin_class_map [2659].handle = objc_getClass ("CKLocationSortDescriptor");
	__xamarin_class_map [2660].handle = objc_getClass ("CKMarkNotificationsReadOperation");
	__xamarin_class_map [2661].handle = objc_getClass ("CKModifyBadgeOperation");
	__xamarin_class_map [2662].handle = objc_getClass ("CKModifyRecordsOperation");
	__xamarin_class_map [2663].handle = objc_getClass ("CKModifyRecordZonesOperation");
	__xamarin_class_map [2664].handle = objc_getClass ("CKModifySubscriptionsOperation");
	__xamarin_class_map [2665].handle = objc_getClass ("CKNotificationInfo");
	__xamarin_class_map [2666].handle = objc_getClass ("CKOperationConfiguration");
	__xamarin_class_map [2667].handle = objc_getClass ("CKOperationGroup");
	__xamarin_class_map [2668].handle = objc_getClass ("CKQuery");
	__xamarin_class_map [2669].handle = objc_getClass ("CKQueryCursor");
	__xamarin_class_map [2670].handle = objc_getClass ("CKQueryOperation");
	__xamarin_class_map [2671].handle = objc_getClass ("CKQuerySubscription");
	__xamarin_class_map [2672].handle = objc_getClass ("CKRecordValue");
	__xamarin_class_map [2673].handle = objc_getClass ("CKRecordZone");
	__xamarin_class_map [2674].handle = objc_getClass ("CKRecordZoneNotification");
	__xamarin_class_map [2675].handle = objc_getClass ("CKRecordZoneSubscription");
	__xamarin_class_map [2676].handle = objc_getClass ("CKReference");
	__xamarin_class_map [2677].handle = objc_getClass ("CKServerChangeToken");
	__xamarin_class_map [2678].handle = objc_getClass ("CKShare");
	__xamarin_class_map [2679].handle = objc_getClass ("CKShareMetadata");
	__xamarin_class_map [2680].handle = objc_getClass ("CKShareParticipant");
	__xamarin_class_map [2681].handle = objc_getClass ("CKSystemSharingUIObserver");
	__xamarin_class_map [2682].handle = objc_getClass ("CKUserIdentity");
	__xamarin_class_map [2683].handle = objc_getClass ("CLSObject");
	__xamarin_class_map [2684].handle = objc_getClass ("CLSActivity");
	__xamarin_class_map [2685].handle = objc_getClass ("CLSActivityItem");
	__xamarin_class_map [2686].handle = objc_getClass ("CLSBinaryItem");
	__xamarin_class_map [2687].handle = objc_getClass ("CLSDataStoreDelegate");
	__xamarin_class_map [2688].handle = objc_getClass ("CLSProgressReportingCapability");
	__xamarin_class_map [2689].handle = objc_getClass ("CLSQuantityItem");
	__xamarin_class_map [2690].handle = objc_getClass ("CLSScoreItem");
	__xamarin_class_map [2691].handle = objc_getClass ("CPMessageListItem");
	__xamarin_class_map [2692].handle = objc_getClass ("CPNavigationAlert");
	__xamarin_class_map [2693].handle = objc_getClass ("CPTemplate");
	__xamarin_class_map [2694].handle = objc_getClass ("CPActionSheetTemplate");
	__xamarin_class_map [2695].handle = objc_getClass ("CPAlertAction");
	__xamarin_class_map [2696].handle = objc_getClass ("CPAlertTemplate");
	__xamarin_class_map [2697].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPApplicationDelegate");
	__xamarin_class_map [2698].handle = objc_getClass ("CPAssistantCellConfiguration");
	__xamarin_class_map [2699].handle = objc_getClass ("CPBarButton");
	__xamarin_class_map [2700].handle = objc_getClass ("CPButton");
	__xamarin_class_map [2701].handle = objc_getClass ("CPContact");
	__xamarin_class_map [2702].handle = objc_getClass ("CPContactCallButton");
	__xamarin_class_map [2703].handle = objc_getClass ("CPContactDirectionsButton");
	__xamarin_class_map [2704].handle = objc_getClass ("CPContactMessageButton");
	__xamarin_class_map [2705].handle = objc_getClass ("CPContactTemplate");
	__xamarin_class_map [2706].handle = objc_getClass ("CPDashboardButton");
	__xamarin_class_map [2707].handle = objc_getClass ("CPDashboardController");
	__xamarin_class_map [2708].handle = objc_getClass ("CPGridButton");
	__xamarin_class_map [2709].handle = objc_getClass ("CPGridTemplate");
	__xamarin_class_map [2710].handle = objc_getClass ("CPImageSet");
	__xamarin_class_map [2711].handle = objc_getClass ("CPInformationItem");
	__xamarin_class_map [2712].handle = objc_getClass ("CPInformationRatingItem");
	__xamarin_class_map [2713].handle = objc_getClass ("CPInformationTemplate");
	__xamarin_class_map [2714].handle = objc_getClass ("CPInstrumentClusterController");
	__xamarin_class_map [2715].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPInstrumentClusterControllerDelegate");
	__xamarin_class_map [2716].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPInterfaceControllerDelegate");
	__xamarin_class_map [2717].handle = objc_getClass ("CPListImageRowItem");
	__xamarin_class_map [2718].handle = objc_getClass ("CPListItem");
	__xamarin_class_map [2719].handle = objc_getClass ("CPListSection");
	__xamarin_class_map [2720].handle = objc_getClass ("CPListTemplate");
	__xamarin_class_map [2721].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPListTemplateDelegate");
	__xamarin_class_map [2722].handle = objc_getClass ("CPManeuver");
	__xamarin_class_map [2723].handle = objc_getClass ("CPMapButton");
	__xamarin_class_map [2724].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPMapTemplateDelegate");
	__xamarin_class_map [2725].handle = objc_getClass ("CPMessageComposeBarButton");
	__xamarin_class_map [2726].handle = objc_getClass ("CPMessageListItemLeadingConfiguration");
	__xamarin_class_map [2727].handle = objc_getClass ("CPMessageListItemTrailingConfiguration");
	__xamarin_class_map [2728].handle = objc_getClass ("CPNavigationSession");
	__xamarin_class_map [2729].handle = objc_getClass ("CPNowPlayingButton");
	__xamarin_class_map [2730].handle = objc_getClass ("CPNowPlayingAddToLibraryButton");
	__xamarin_class_map [2731].handle = objc_getClass ("CPNowPlayingImageButton");
	__xamarin_class_map [2732].handle = objc_getClass ("CPNowPlayingMoreButton");
	__xamarin_class_map [2733].handle = objc_getClass ("CPNowPlayingPlaybackRateButton");
	__xamarin_class_map [2734].handle = objc_getClass ("CPNowPlayingRepeatButton");
	__xamarin_class_map [2735].handle = objc_getClass ("CPNowPlayingShuffleButton");
	__xamarin_class_map [2736].handle = objc_getClass ("CPNowPlayingTemplate");
	__xamarin_class_map [2737].handle = objc_getClass ("CPPointOfInterest");
	__xamarin_class_map [2738].handle = objc_getClass ("CPPointOfInterestTemplate");
	__xamarin_class_map [2739].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPPointOfInterestTemplateDelegate");
	__xamarin_class_map [2740].handle = objc_getClass ("CPRouteChoice");
	__xamarin_class_map [2741].handle = objc_getClass ("CPSearchTemplate");
	__xamarin_class_map [2742].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPSearchTemplateDelegate");
	__xamarin_class_map [2743].handle = objc_getClass ("CPSessionConfiguration");
	__xamarin_class_map [2744].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPSessionConfigurationDelegate");
	__xamarin_class_map [2745].handle = objc_getClass ("CPTabBarTemplate");
	__xamarin_class_map [2746].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPTabBarTemplateDelegate");
	__xamarin_class_map [2747].handle = objc_getClass ("UIScene");
	__xamarin_class_map [2748].handle = objc_getClass ("CPTemplateApplicationDashboardScene");
	__xamarin_class_map [2749].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPTemplateApplicationDashboardSceneDelegate");
	__xamarin_class_map [2750].handle = objc_getClass ("CPTemplateApplicationInstrumentClusterScene");
	__xamarin_class_map [2751].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPTemplateApplicationInstrumentClusterSceneDelegate");
	__xamarin_class_map [2752].handle = objc_getClass ("CPTemplateApplicationScene");
	__xamarin_class_map [2753].handle = objc_getClass ("Xamarin_iOS__CarPlay_CPTemplateApplicationSceneDelegate");
	__xamarin_class_map [2754].handle = objc_getClass ("CPTextButton");
	__xamarin_class_map [2755].handle = objc_getClass ("CPTravelEstimates");
	__xamarin_class_map [2756].handle = objc_getClass ("CPTrip");
	__xamarin_class_map [2757].handle = objc_getClass ("CPTripPreviewTextConfiguration");
	__xamarin_class_map [2758].handle = objc_getClass ("CPVoiceControlState");
	__xamarin_class_map [2759].handle = objc_getClass ("CPVoiceControlTemplate");
	__xamarin_class_map [2760].handle = objc_getClass ("CXAction");
	__xamarin_class_map [2761].handle = objc_getClass ("CXCallAction");
	__xamarin_class_map [2762].handle = objc_getClass ("CXAnswerCallAction");
	__xamarin_class_map [2763].handle = objc_getClass ("CXCall");
	__xamarin_class_map [2764].handle = objc_getClass ("CXCallDirectoryExtensionContextDelegate");
	__xamarin_class_map [2765].handle = objc_getClass ("CXCallDirectoryProvider");
	__xamarin_class_map [2766].handle = objc_getClass ("CXCallObserver");
	__xamarin_class_map [2767].handle = objc_getClass ("CXCallObserverDelegate");
	__xamarin_class_map [2768].handle = objc_getClass ("CXCallUpdate");
	__xamarin_class_map [2769].handle = objc_getClass ("CXEndCallAction");
	__xamarin_class_map [2770].handle = objc_getClass ("CXHandle");
	__xamarin_class_map [2771].handle = objc_getClass ("CXPlayDTMFCallAction");
	__xamarin_class_map [2772].handle = objc_getClass ("CXProviderConfiguration");
	__xamarin_class_map [2773].handle = objc_getClass ("CXProviderDelegate");
	__xamarin_class_map [2774].handle = objc_getClass ("CXSetGroupCallAction");
	__xamarin_class_map [2775].handle = objc_getClass ("CXSetHeldCallAction");
	__xamarin_class_map [2776].handle = objc_getClass ("CXSetMutedCallAction");
	__xamarin_class_map [2777].handle = objc_getClass ("CXStartCallAction");
	__xamarin_class_map [2778].handle = objc_getClass ("CXTransaction");
	__xamarin_class_map [2779].handle = objc_getClass ("BCChatAction");
	__xamarin_class_map [2780].handle = objc_getClass ("BAAppExtensionInfo");
	__xamarin_class_map [2781].handle = objc_getClass ("BADownload");
	__xamarin_class_map [2782].handle = objc_getClass ("Xamarin_iOS__BackgroundAssets_BADownloadManagerDelegate");
	__xamarin_class_map [2783].handle = objc_getClass ("BAURLDownload");
	__xamarin_class_map [2784].handle = objc_getClass ("ASAuthorization");
	__xamarin_class_map [2785].handle = objc_getClass ("ASAuthorizationRequest");
	__xamarin_class_map [2786].handle = objc_getClass ("ASAccountAuthenticationModificationController");
	__xamarin_class_map [2787].handle = objc_getClass ("Xamarin_iOS__AuthenticationServices_ASAccountAuthenticationModificationControllerDelegate");
	__xamarin_class_map [2788].handle = objc_getClass ("ASAccountAuthenticationModificationRequest");
	__xamarin_class_map [2789].handle = objc_getClass ("ASAccountAuthenticationModificationReplacePasswordWithSignInWithAppleRequest");
	__xamarin_class_map [2790].handle = objc_getClass ("ASAccountAuthenticationModificationUpgradePasswordToStrongPasswordRequest");
	__xamarin_class_map [2791].handle = objc_getClass ("ASAccountAuthenticationModificationViewController");
	__xamarin_class_map [2792].handle = objc_getClass ("ASAuthorizationOpenIDRequest");
	__xamarin_class_map [2793].handle = objc_getClass ("ASAuthorizationAppleIDRequest");
	__xamarin_class_map [2794].handle = objc_getClass ("ASAuthorizationController");
	__xamarin_class_map [2795].handle = objc_getClass ("Xamarin_iOS__AuthenticationServices_ASAuthorizationControllerDelegate");
	__xamarin_class_map [2796].handle = objc_getClass ("ASAuthorizationPasswordProvider");
	__xamarin_class_map [2797].handle = objc_getClass ("ASAuthorizationPasswordRequest");
	__xamarin_class_map [2798].handle = objc_getClass ("ASAuthorizationPlatformPublicKeyCredentialAssertion");
	__xamarin_class_map [2799].handle = objc_getClass ("ASAuthorizationPlatformPublicKeyCredentialAssertionRequest");
	__xamarin_class_map [2800].handle = objc_getClass ("ASAuthorizationPlatformPublicKeyCredentialDescriptor");
	__xamarin_class_map [2801].handle = objc_getClass ("ASAuthorizationPlatformPublicKeyCredentialProvider");
	__xamarin_class_map [2802].handle = objc_getClass ("ASAuthorizationPlatformPublicKeyCredentialRegistration");
	__xamarin_class_map [2803].handle = objc_getClass ("ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest");
	__xamarin_class_map [2804].handle = objc_getClass ("ASAuthorizationProviderExtensionAuthorizationResult");
	__xamarin_class_map [2805].handle = objc_getClass ("ASAuthorizationPublicKeyCredentialParameters");
	__xamarin_class_map [2806].handle = objc_getClass ("ASAuthorizationSecurityKeyPublicKeyCredentialAssertion");
	__xamarin_class_map [2807].handle = objc_getClass ("ASAuthorizationSecurityKeyPublicKeyCredentialAssertionRequest");
	__xamarin_class_map [2808].handle = objc_getClass ("ASAuthorizationSecurityKeyPublicKeyCredentialProvider");
	__xamarin_class_map [2809].handle = objc_getClass ("ASAuthorizationSecurityKeyPublicKeyCredentialRegistration");
	__xamarin_class_map [2810].handle = objc_getClass ("ASAuthorizationSecurityKeyPublicKeyCredentialRegistrationRequest");
	__xamarin_class_map [2811].handle = objc_getClass ("ASAuthorizationSingleSignOnProvider");
	__xamarin_class_map [2812].handle = objc_getClass ("ASAuthorizationSingleSignOnRequest");
	__xamarin_class_map [2813].handle = objc_getClass ("ASCredentialIdentityStoreState");
	__xamarin_class_map [2814].handle = objc_getClass ("ASCredentialProviderExtensionContext");
	__xamarin_class_map [2815].handle = objc_getClass ("ASCredentialProviderViewController");
	__xamarin_class_map [2816].handle = objc_getClass ("ASCredentialServiceIdentifier");
	__xamarin_class_map [2817].handle = objc_getClass ("ASPasswordCredential");
	__xamarin_class_map [2818].handle = objc_getClass ("ASPasswordCredentialIdentity");
	__xamarin_class_map [2819].handle = objc_getClass ("ASWebAuthenticationSession");
	__xamarin_class_map [2820].handle = objc_getClass ("AUParameterNode");
	__xamarin_class_map [2821].handle = objc_getClass ("AUParameter");
	__xamarin_class_map [2822].handle = objc_getClass ("AUAudioUnitBus");
	__xamarin_class_map [2823].handle = objc_getClass ("AUAudioUnitBusArray");
	__xamarin_class_map [2824].handle = objc_getClass ("AUAudioUnitPreset");
	__xamarin_class_map [2825].handle = objc_getClass ("AUParameterGroup");
	__xamarin_class_map [2826].handle = objc_getClass ("AUParameterTree");
	__xamarin_class_map [2827].handle = objc_getClass ("ALAssetsGroup");
	__xamarin_class_map [2828].handle = objc_getClass ("ALAssetRepresentation");
	__xamarin_class_map [2829].handle = objc_getClass ("ALAssetsFilter");
	__xamarin_class_map [2830].handle = objc_getClass ("NSLayoutManager");
	__xamarin_class_map [2831].handle = objc_getClass ("NSLayoutConstraint");
	__xamarin_class_map [2832].handle = objc_getClass ("UIAdaptivePresentationControllerDelegate");
	__xamarin_class_map [2833].handle = objc_getClass ("UIPresentationController");
	__xamarin_class_map [2834].handle = objc_getClass ("UIPrintFormatter");
	__xamarin_class_map [2835].handle = objc_getClass ("UIMarkupTextPrintFormatter");
	__xamarin_class_map [2836].handle = objc_getClass ("UIFocusUpdateContext");
	__xamarin_class_map [2837].handle = objc_getClass ("UICollectionViewFocusUpdateContext");
	__xamarin_class_map [2838].handle = objc_getClass ("UIActivityItemProvider");
	__xamarin_class_map [2839].handle = objc_getClass ("UIActivityViewController");
	__xamarin_class_map [2840].handle = objc_getClass ("UIAppearance");
	__xamarin_class_map [2841].handle = objc_getClass ("UIBezierPath");
	__xamarin_class_map [2842].handle = objc_getClass ("UICellAccessory");
	__xamarin_class_map [2843].handle = objc_getClass ("UICollectionViewLayout");
	__xamarin_class_map [2844].handle = objc_getClass ("UICollectionViewLayoutAttributes");
	__xamarin_class_map [2845].handle = objc_getClass ("UICollectionViewTransitionLayout");
	__xamarin_class_map [2846].handle = objc_getClass ("UIKit_UIControlEventProxy");
	__xamarin_class_map [2847].handle = objc_getClass ("UIEvent");
	__xamarin_class_map [2848].handle = objc_getClass ("UIFont");
	__xamarin_class_map [2849].handle = objc_getClass ("UIFontDescriptor");
	__xamarin_class_map [2850].handle = objc_getClass ("UIGestureRecognizer");
	__xamarin_class_map [2851].handle = objc_getClass ("UIRotationGestureRecognizer");
	__xamarin_class_map [2852].handle = objc_getClass ("UILongPressGestureRecognizer");
	__xamarin_class_map [2853].handle = objc_getClass ("UITapGestureRecognizer");
	__xamarin_class_map [2854].handle = objc_getClass ("UIPanGestureRecognizer");
	__xamarin_class_map [2855].handle = objc_getClass ("UIPinchGestureRecognizer");
	__xamarin_class_map [2856].handle = objc_getClass ("UISwipeGestureRecognizer");
	__xamarin_class_map [2857].handle = objc_getClass ("UIScreenEdgePanGestureRecognizer");
	__xamarin_class_map [2858].handle = objc_getClass ("UIHoverGestureRecognizer");
	__xamarin_class_map [2859].handle = objc_getClass ("__MonoTouch_UIImageStatusDispatcher");
	__xamarin_class_map [2860].handle = objc_getClass ("UIListSeparatorConfiguration");
	__xamarin_class_map [2861].handle = objc_getClass ("UIPopoverPresentationControllerDelegate");
	__xamarin_class_map [2862].handle = objc_getClass ("UIDynamicBehavior");
	__xamarin_class_map [2863].handle = objc_getClass ("UIPushBehavior");
	__xamarin_class_map [2864].handle = objc_getClass ("UISearchDisplayController");
	__xamarin_class_map [2865].handle = objc_getClass ("UISimpleTextPrintFormatter");
	__xamarin_class_map [2866].handle = objc_getClass ("UIStoryboardSegue");
	__xamarin_class_map [2867].handle = objc_getClass ("UIStoryboardPopoverSegue");
	__xamarin_class_map [2868].handle = objc_getClass ("UITraitCollection");
	__xamarin_class_map [2869].handle = objc_getClass ("UIVisualEffect");
	__xamarin_class_map [2870].handle = objc_getClass ("UIVibrancyEffect");
	__xamarin_class_map [2871].handle = objc_getClass ("__MonoTouch_UIVideoStatusDispatcher");
	__xamarin_class_map [2872].handle = objc_getClass ("NSCollectionLayoutAnchor");
	__xamarin_class_map [2873].handle = objc_getClass ("NSCollectionLayoutItem");
	__xamarin_class_map [2874].handle = objc_getClass ("NSCollectionLayoutSupplementaryItem");
	__xamarin_class_map [2875].handle = objc_getClass ("NSCollectionLayoutBoundarySupplementaryItem");
	__xamarin_class_map [2876].handle = objc_getClass ("NSCollectionLayoutDecorationItem");
	__xamarin_class_map [2877].handle = objc_getClass ("NSCollectionLayoutDimension");
	__xamarin_class_map [2878].handle = objc_getClass ("NSCollectionLayoutEdgeSpacing");
	__xamarin_class_map [2879].handle = objc_getClass ("NSCollectionLayoutGroup");
	__xamarin_class_map [2880].handle = objc_getClass ("NSCollectionLayoutGroupCustomItem");
	__xamarin_class_map [2881].handle = objc_getClass ("NSCollectionLayoutSection");
	__xamarin_class_map [2882].handle = objc_getClass ("NSCollectionLayoutSize");
	__xamarin_class_map [2883].handle = objc_getClass ("NSCollectionLayoutSpacing");
	__xamarin_class_map [2884].handle = objc_getClass ("NSDataAsset");
	__xamarin_class_map [2885].handle = objc_getClass ("NSDiffableDataSourceSectionSnapshot");
	__xamarin_class_map [2886].handle = objc_getClass ("NSDiffableDataSourceSectionTransaction");
	__xamarin_class_map [2887].handle = objc_getClass ("NSDiffableDataSourceSnapshot");
	__xamarin_class_map [2888].handle = objc_getClass ("NSDiffableDataSourceTransaction");
	__xamarin_class_map [2889].handle = objc_getClass ("NSLayoutAnchor");
	__xamarin_class_map [2890].handle = objc_getClass ("NSLayoutDimension");
	__xamarin_class_map [2891].handle = objc_getClass ("NSLayoutManagerDelegate");
	__xamarin_class_map [2892].handle = objc_getClass ("NSLayoutXAxisAnchor");
	__xamarin_class_map [2893].handle = objc_getClass ("NSLayoutYAxisAnchor");
	__xamarin_class_map [2894].handle = objc_getClass ("NSParagraphStyle");
	__xamarin_class_map [2895].handle = objc_getClass ("NSMutableParagraphStyle");
	__xamarin_class_map [2896].handle = objc_getClass ("NSShadow");
	__xamarin_class_map [2897].handle = objc_getClass ("NSTextAttachment");
	__xamarin_class_map [2898].handle = objc_getClass ("NSTextAttachmentContainer");
	__xamarin_class_map [2899].handle = objc_getClass ("NSTextAttachmentViewProvider");
	__xamarin_class_map [2900].handle = objc_getClass ("NSTextContainer");
	__xamarin_class_map [2901].handle = objc_getClass ("Xamarin_iOS__UIKit_NSTextContentManagerDelegate");
	__xamarin_class_map [2902].handle = objc_getClass ("NSTextContentManager");
	__xamarin_class_map [2903].handle = objc_getClass ("NSTextContentStorage");
	__xamarin_class_map [2904].handle = objc_getClass ("Xamarin_iOS__UIKit_NSTextContentStorageDelegate");
	__xamarin_class_map [2905].handle = objc_getClass ("NSTextElement");
	__xamarin_class_map [2906].handle = objc_getClass ("NSTextLayoutFragment");
	__xamarin_class_map [2907].handle = objc_getClass ("NSTextLayoutManager");
	__xamarin_class_map [2908].handle = objc_getClass ("Xamarin_iOS__UIKit_NSTextLayoutManagerDelegate");
	__xamarin_class_map [2909].handle = objc_getClass ("NSTextLineFragment");
	__xamarin_class_map [2910].handle = objc_getClass ("NSTextList");
	__xamarin_class_map [2911].handle = objc_getClass ("NSTextParagraph");
	__xamarin_class_map [2912].handle = objc_getClass ("NSTextListElement");
	__xamarin_class_map [2913].handle = objc_getClass ("NSTextRange");
	__xamarin_class_map [2914].handle = objc_getClass ("NSTextSelection");
	__xamarin_class_map [2915].handle = objc_getClass ("Xamarin_iOS__UIKit_NSTextSelectionDataSource");
	__xamarin_class_map [2916].handle = objc_getClass ("NSTextSelectionNavigation");
	__xamarin_class_map [2917].handle = objc_getClass ("NSTextStorageDelegate");
	__xamarin_class_map [2918].handle = objc_getClass ("NSTextTab");
	__xamarin_class_map [2919].handle = objc_getClass ("NSTextViewportLayoutController");
	__xamarin_class_map [2920].handle = objc_getClass ("Xamarin_iOS__UIKit_NSTextViewportLayoutControllerDelegate");
	__xamarin_class_map [2921].handle = objc_getClass ("UIAcceleration");
	__xamarin_class_map [2922].handle = objc_getClass ("UIAccelerometerDelegate");
	__xamarin_class_map [2923].handle = objc_getClass ("UIAccessibilityContainerDataTable");
	__xamarin_class_map [2924].handle = objc_getClass ("UIAccessibilityCustomRotor");
	__xamarin_class_map [2925].handle = objc_getClass ("UIAccessibilityCustomRotorItemResult");
	__xamarin_class_map [2926].handle = objc_getClass ("UIAccessibilityCustomRotorSearchPredicate");
	__xamarin_class_map [2927].handle = objc_getClass ("UIAccessibilityElement");
	__xamarin_class_map [2928].handle = objc_getClass ("UIAccessibilityLocationDescriptor");
	__xamarin_class_map [2929].handle = objc_getClass ("UIMenuElement");
	__xamarin_class_map [2930].handle = objc_getClass ("UIAction");
	__xamarin_class_map [2931].handle = objc_getClass ("UIActionSheetDelegate");
	__xamarin_class_map [2932].handle = objc_getClass ("UIActivity");
	__xamarin_class_map [2933].handle = objc_getClass ("UIActivityItemsConfiguration");
	__xamarin_class_map [2934].handle = objc_getClass ("UIActivityItemSource");
	__xamarin_class_map [2935].handle = objc_getClass ("UIAlertAction");
	__xamarin_class_map [2936].handle = objc_getClass ("UIAlertController");
	__xamarin_class_map [2937].handle = objc_getClass ("UIAlertViewDelegate");
	__xamarin_class_map [2938].handle = objc_getClass ("UIAppearanceContainer");
	__xamarin_class_map [2939].handle = objc_getClass ("UIApplicationShortcutIcon");
	__xamarin_class_map [2940].handle = objc_getClass ("UIApplicationShortcutItem");
	__xamarin_class_map [2941].handle = objc_getClass ("UIAttachmentBehavior");
	__xamarin_class_map [2942].handle = objc_getClass ("UIBackgroundConfiguration");
	__xamarin_class_map [2943].handle = objc_getClass ("UIBandSelectionInteraction");
	__xamarin_class_map [2944].handle = objc_getClass ("UIBarAppearance");
	__xamarin_class_map [2945].handle = objc_getClass ("UIBarButtonItemAppearance");
	__xamarin_class_map [2946].handle = objc_getClass ("UIBarButtonItemGroup");
	__xamarin_class_map [2947].handle = objc_getClass ("UIBarButtonItemStateAppearance");
	__xamarin_class_map [2948].handle = objc_getClass ("UIBarPositioning");
	__xamarin_class_map [2949].handle = objc_getClass ("UIBarPositioningDelegate");
	__xamarin_class_map [2950].handle = objc_getClass ("UIBlurEffect");
	__xamarin_class_map [2951].handle = objc_getClass ("UIButtonConfiguration");
	__xamarin_class_map [2952].handle = objc_getClass ("UICalendarSelection");
	__xamarin_class_map [2953].handle = objc_getClass ("UICalendarSelectionMultiDate");
	__xamarin_class_map [2954].handle = objc_getClass ("Xamarin_iOS__UIKit_UICalendarSelectionMultiDateDelegate");
	__xamarin_class_map [2955].handle = objc_getClass ("UICalendarSelectionSingleDate");
	__xamarin_class_map [2956].handle = objc_getClass ("Xamarin_iOS__UIKit_UICalendarSelectionSingleDateDelegate");
	__xamarin_class_map [2957].handle = objc_getClass ("UICalendarViewDecoration");
	__xamarin_class_map [2958].handle = objc_getClass ("Xamarin_iOS__UIKit_UICalendarViewDelegate");
	__xamarin_class_map [2959].handle = objc_getClass ("UICellAccessoryCheckmark");
	__xamarin_class_map [2960].handle = objc_getClass ("UICellAccessoryCustomView");
	__xamarin_class_map [2961].handle = objc_getClass ("UICellAccessoryDelete");
	__xamarin_class_map [2962].handle = objc_getClass ("UICellAccessoryDetail");
	__xamarin_class_map [2963].handle = objc_getClass ("UICellAccessoryDisclosureIndicator");
	__xamarin_class_map [2964].handle = objc_getClass ("UICellAccessoryInsert");
	__xamarin_class_map [2965].handle = objc_getClass ("UICellAccessoryLabel");
	__xamarin_class_map [2966].handle = objc_getClass ("UICellAccessoryMultiselect");
	__xamarin_class_map [2967].handle = objc_getClass ("UICellAccessoryOutlineDisclosure");
	__xamarin_class_map [2968].handle = objc_getClass ("UICellAccessoryPopUpMenu");
	__xamarin_class_map [2969].handle = objc_getClass ("UICellAccessoryReorder");
	__xamarin_class_map [2970].handle = objc_getClass ("UIViewConfigurationState");
	__xamarin_class_map [2971].handle = objc_getClass ("UICellConfigurationState");
	__xamarin_class_map [2972].handle = objc_getClass ("UICloudSharingController");
	__xamarin_class_map [2973].handle = objc_getClass ("UICloudSharingControllerDelegate");
	__xamarin_class_map [2974].handle = objc_getClass ("UICollectionLayoutListConfiguration");
	__xamarin_class_map [2975].handle = objc_getClass ("UICollectionViewCellRegistration");
	__xamarin_class_map [2976].handle = objc_getClass ("UICollectionViewCompositionalLayout");
	__xamarin_class_map [2977].handle = objc_getClass ("UICollectionViewCompositionalLayoutConfiguration");
	__xamarin_class_map [2978].handle = objc_getClass ("UICollectionViewController");
	__xamarin_class_map [2979].handle = objc_getClass ("UICollectionViewDataSource");
	__xamarin_class_map [2980].handle = objc_getClass ("UICollectionViewDelegate");
	__xamarin_class_map [2981].handle = objc_getClass ("UICollectionViewDelegateFlowLayout");
	__xamarin_class_map [2982].handle = objc_getClass ("UICollectionViewDiffableDataSourceReorderingHandlers");
	__xamarin_class_map [2983].handle = objc_getClass ("UICollectionViewDiffableDataSourceSectionSnapshotHandlers");
	__xamarin_class_map [2984].handle = objc_getClass ("UICollectionViewDragDelegate");
	__xamarin_class_map [2985].handle = objc_getClass ("UICollectionViewDropDelegate");
	__xamarin_class_map [2986].handle = objc_getClass ("UICollectionViewPlaceholder");
	__xamarin_class_map [2987].handle = objc_getClass ("UICollectionViewDropPlaceholder");
	__xamarin_class_map [2988].handle = objc_getClass ("UIDropProposal");
	__xamarin_class_map [2989].handle = objc_getClass ("UICollectionViewDropProposal");
	__xamarin_class_map [2990].handle = objc_getClass ("UICollectionViewFlowLayout");
	__xamarin_class_map [2991].handle = objc_getClass ("UICollectionViewLayoutInvalidationContext");
	__xamarin_class_map [2992].handle = objc_getClass ("UICollectionViewFlowLayoutInvalidationContext");
	__xamarin_class_map [2993].handle = objc_getClass ("UICollectionViewSource");
	__xamarin_class_map [2994].handle = objc_getClass ("UICollectionViewSupplementaryRegistration");
	__xamarin_class_map [2995].handle = objc_getClass ("UICollectionViewUpdateItem");
	__xamarin_class_map [2996].handle = objc_getClass ("UICollisionBehaviorDelegate");
	__xamarin_class_map [2997].handle = objc_getClass ("UIColorPickerViewController");
	__xamarin_class_map [2998].handle = objc_getClass ("Xamarin_iOS__UIKit_UIColorPickerViewControllerDelegate");
	__xamarin_class_map [2999].handle = objc_getClass ("UICommand");
	__xamarin_class_map [3000].handle = objc_getClass ("UICommandAlternate");
	__xamarin_class_map [3001].handle = objc_getClass ("UIContentContainer");
	__xamarin_class_map [3002].handle = objc_getClass ("UIContextMenuConfiguration");
	__xamarin_class_map [3003].handle = objc_getClass ("UIContextMenuInteraction");
	__xamarin_class_map [3004].handle = objc_getClass ("Xamarin_iOS__UIKit_UIContextMenuInteractionDelegate");
	__xamarin_class_map [3005].handle = objc_getClass ("UIContextualAction");
	__xamarin_class_map [3006].handle = objc_getClass ("UICoordinateSpace");
	__xamarin_class_map [3007].handle = objc_getClass ("UICubicTimingParameters");
	__xamarin_class_map [3008].handle = objc_getClass ("UIDeferredMenuElement");
	__xamarin_class_map [3009].handle = objc_getClass ("UIDictationPhrase");
	__xamarin_class_map [3010].handle = objc_getClass ("UIDocumentBrowserAction");
	__xamarin_class_map [3011].handle = objc_getClass ("UIDocumentBrowserTransitionController");
	__xamarin_class_map [3012].handle = objc_getClass ("UIDocumentBrowserViewControllerDelegate");
	__xamarin_class_map [3013].handle = objc_getClass ("UIDocumentInteractionControllerDelegate");
	__xamarin_class_map [3014].handle = objc_getClass ("UIDocumentMenuDelegate");
	__xamarin_class_map [3015].handle = objc_getClass ("UIDocumentPickerDelegate");
	__xamarin_class_map [3016].handle = objc_getClass ("UIDocumentPickerExtensionViewController");
	__xamarin_class_map [3017].handle = objc_getClass ("UIDocumentProperties");
	__xamarin_class_map [3018].handle = objc_getClass ("UIDragInteraction");
	__xamarin_class_map [3019].handle = objc_getClass ("UIDragInteractionDelegate");
	__xamarin_class_map [3020].handle = objc_getClass ("UIDragItem");
	__xamarin_class_map [3021].handle = objc_getClass ("UIDragPreview");
	__xamarin_class_map [3022].handle = objc_getClass ("UIPreviewParameters");
	__xamarin_class_map [3023].handle = objc_getClass ("UIDragPreviewParameters");
	__xamarin_class_map [3024].handle = objc_getClass ("UIPreviewTarget");
	__xamarin_class_map [3025].handle = objc_getClass ("UIDragPreviewTarget");
	__xamarin_class_map [3026].handle = objc_getClass ("UIDropInteraction");
	__xamarin_class_map [3027].handle = objc_getClass ("UIDropInteractionDelegate");
	__xamarin_class_map [3028].handle = objc_getClass ("UIDynamicAnimatorDelegate");
	__xamarin_class_map [3029].handle = objc_getClass ("UIDynamicItem");
	__xamarin_class_map [3030].handle = objc_getClass ("UIDynamicItemBehavior");
	__xamarin_class_map [3031].handle = objc_getClass ("UIDynamicItemGroup");
	__xamarin_class_map [3032].handle = objc_getClass ("UIEditMenuConfiguration");
	__xamarin_class_map [3033].handle = objc_getClass ("UIEditMenuInteraction");
	__xamarin_class_map [3034].handle = objc_getClass ("Xamarin_iOS__UIKit_UIEditMenuInteractionDelegate");
	__xamarin_class_map [3035].handle = objc_getClass ("UIEventAttribution");
	__xamarin_class_map [3036].handle = objc_getClass ("UIFeedbackGenerator");
	__xamarin_class_map [3037].handle = objc_getClass ("UIFieldBehavior");
	__xamarin_class_map [3038].handle = objc_getClass ("UIFindInteraction");
	__xamarin_class_map [3039].handle = objc_getClass ("Xamarin_iOS__UIKit_UIFindInteractionDelegate");
	__xamarin_class_map [3040].handle = objc_getClass ("UIFindSession");
	__xamarin_class_map [3041].handle = objc_getClass ("UIFocusDebugger");
	__xamarin_class_map [3042].handle = objc_getClass ("UIFocusEffect");
	__xamarin_class_map [3043].handle = objc_getClass ("UILayoutGuide");
	__xamarin_class_map [3044].handle = objc_getClass ("UIFocusGuide");
	__xamarin_class_map [3045].handle = objc_getClass ("UIFocusHaloEffect");
	__xamarin_class_map [3046].handle = objc_getClass ("UIFocusMovementHint");
	__xamarin_class_map [3047].handle = objc_getClass ("UIFocusSystem");
	__xamarin_class_map [3048].handle = objc_getClass ("UIFontMetrics");
	__xamarin_class_map [3049].handle = objc_getClass ("UIFontPickerViewController");
	__xamarin_class_map [3050].handle = objc_getClass ("UIFontPickerViewControllerConfiguration");
	__xamarin_class_map [3051].handle = objc_getClass ("Xamarin_iOS__UIKit_UIFontPickerViewControllerDelegate");
	__xamarin_class_map [3052].handle = objc_getClass ("UIGestureRecognizerDelegate");
	__xamarin_class_map [3053].handle = objc_getClass ("UIGraphicsRenderer");
	__xamarin_class_map [3054].handle = objc_getClass ("UIGraphicsImageRenderer");
	__xamarin_class_map [3055].handle = objc_getClass ("UIGraphicsRendererContext");
	__xamarin_class_map [3056].handle = objc_getClass ("UIGraphicsImageRendererContext");
	__xamarin_class_map [3057].handle = objc_getClass ("UIGraphicsRendererFormat");
	__xamarin_class_map [3058].handle = objc_getClass ("UIGraphicsImageRendererFormat");
	__xamarin_class_map [3059].handle = objc_getClass ("UIGraphicsPDFRenderer");
	__xamarin_class_map [3060].handle = objc_getClass ("UIGraphicsPDFRendererContext");
	__xamarin_class_map [3061].handle = objc_getClass ("UIGraphicsPDFRendererFormat");
	__xamarin_class_map [3062].handle = objc_getClass ("UIGravityBehavior");
	__xamarin_class_map [3063].handle = objc_getClass ("UIImageAsset");
	__xamarin_class_map [3064].handle = objc_getClass ("UIImageConfiguration");
	__xamarin_class_map [3065].handle = objc_getClass ("UIImagePickerControllerDelegate");
	__xamarin_class_map [3066].handle = objc_getClass ("UIImageSymbolConfiguration");
	__xamarin_class_map [3067].handle = objc_getClass ("UIImpactFeedbackGenerator");
	__xamarin_class_map [3068].handle = objc_getClass ("UIIndirectScribbleInteraction");
	__xamarin_class_map [3069].handle = objc_getClass ("Xamarin_iOS__UIKit_UIIndirectScribbleInteractionDelegate");
	__xamarin_class_map [3070].handle = objc_getClass ("UIMotionEffect");
	__xamarin_class_map [3071].handle = objc_getClass ("UIInterpolatingMotionEffect");
	__xamarin_class_map [3072].handle = objc_getClass ("UIKey");
	__xamarin_class_map [3073].handle = objc_getClass ("UITrackingLayoutGuide");
	__xamarin_class_map [3074].handle = objc_getClass ("UIKeyboardLayoutGuide");
	__xamarin_class_map [3075].handle = objc_getClass ("UIKeyCommand");
	__xamarin_class_map [3076].handle = objc_getClass ("Xamarin_iOS__UIKit_UILargeContentViewerInteractionDelegate");
	__xamarin_class_map [3077].handle = objc_getClass ("UILayoutSupport");
	__xamarin_class_map [3078].handle = objc_getClass ("UILexicon");
	__xamarin_class_map [3079].handle = objc_getClass ("UILexiconEntry");
	__xamarin_class_map [3080].handle = objc_getClass ("UIListContentConfiguration");
	__xamarin_class_map [3081].handle = objc_getClass ("UIListContentImageProperties");
	__xamarin_class_map [3082].handle = objc_getClass ("UIListContentTextProperties");
	__xamarin_class_map [3083].handle = objc_getClass ("UILocalizedIndexedCollation");
	__xamarin_class_map [3084].handle = objc_getClass ("UILocalNotification");
	__xamarin_class_map [3085].handle = objc_getClass ("UIDocument");
	__xamarin_class_map [3086].handle = objc_getClass ("UIManagedDocument");
	__xamarin_class_map [3087].handle = objc_getClass ("UIMenu");
	__xamarin_class_map [3088].handle = objc_getClass ("UIMenuItem");
	__xamarin_class_map [3089].handle = objc_getClass ("UIMenuSystem");
	__xamarin_class_map [3090].handle = objc_getClass ("UIMotionEffectGroup");
	__xamarin_class_map [3091].handle = objc_getClass ("UIMutableApplicationShortcutItem");
	__xamarin_class_map [3092].handle = objc_getClass ("UIUserNotificationAction");
	__xamarin_class_map [3093].handle = objc_getClass ("UIMutableUserNotificationAction");
	__xamarin_class_map [3094].handle = objc_getClass ("UIUserNotificationCategory");
	__xamarin_class_map [3095].handle = objc_getClass ("UIMutableUserNotificationCategory");
	__xamarin_class_map [3096].handle = objc_getClass ("UINavigationBarAppearance");
	__xamarin_class_map [3097].handle = objc_getClass ("UINavigationBarDelegate");
	__xamarin_class_map [3098].handle = objc_getClass ("UINavigationItem");
	__xamarin_class_map [3099].handle = objc_getClass ("Xamarin_iOS__UIKit_UINavigationItemRenameDelegate");
	__xamarin_class_map [3100].handle = objc_getClass ("UINib");
	__xamarin_class_map [3101].handle = objc_getClass ("UINotificationFeedbackGenerator");
	__xamarin_class_map [3102].handle = objc_getClass ("UIObjectRestoration");
	__xamarin_class_map [3103].handle = objc_getClass ("UIOpenURLContext");
	__xamarin_class_map [3104].handle = objc_getClass ("UIPageViewControllerDataSource");
	__xamarin_class_map [3105].handle = objc_getClass ("UIPageViewControllerDelegate");
	__xamarin_class_map [3106].handle = objc_getClass ("UIPasteConfiguration");
	__xamarin_class_map [3107].handle = objc_getClass ("UIPasteControlConfiguration");
	__xamarin_class_map [3108].handle = objc_getClass ("UIPencilInteraction");
	__xamarin_class_map [3109].handle = objc_getClass ("UIPencilInteractionDelegate");
	__xamarin_class_map [3110].handle = objc_getClass ("UIPercentDrivenInteractiveTransition");
	__xamarin_class_map [3111].handle = objc_getClass ("UIPickerViewDelegate");
	__xamarin_class_map [3112].handle = objc_getClass ("UIPickerViewAccessibilityDelegate");
	__xamarin_class_map [3113].handle = objc_getClass ("UIPickerViewDataSource");
	__xamarin_class_map [3114].handle = objc_getClass ("UIPickerViewModel");
	__xamarin_class_map [3115].handle = objc_getClass ("UIPointerAccessory");
	__xamarin_class_map [3116].handle = objc_getClass ("UIPointerEffect");
	__xamarin_class_map [3117].handle = objc_getClass ("UIPointerHighlightEffect");
	__xamarin_class_map [3118].handle = objc_getClass ("UIPointerHoverEffect");
	__xamarin_class_map [3119].handle = objc_getClass ("UIPointerInteraction");
	__xamarin_class_map [3120].handle = objc_getClass ("Xamarin_iOS__UIKit_UIPointerInteractionDelegate");
	__xamarin_class_map [3121].handle = objc_getClass ("UIPointerLiftEffect");
	__xamarin_class_map [3122].handle = objc_getClass ("UIPointerRegion");
	__xamarin_class_map [3123].handle = objc_getClass ("UIPointerRegionRequest");
	__xamarin_class_map [3124].handle = objc_getClass ("UIPointerShape");
	__xamarin_class_map [3125].handle = objc_getClass ("UIPointerStyle");
	__xamarin_class_map [3126].handle = objc_getClass ("UIPopoverControllerDelegate");
	__xamarin_class_map [3127].handle = objc_getClass ("UIPress");
	__xamarin_class_map [3128].handle = objc_getClass ("UIPressesEvent");
	__xamarin_class_map [3129].handle = objc_getClass ("UIPreviewAction");
	__xamarin_class_map [3130].handle = objc_getClass ("UIPreviewActionGroup");
	__xamarin_class_map [3131].handle = objc_getClass ("UIPreviewInteractionDelegate");
	__xamarin_class_map [3132].handle = objc_getClass ("UIPrinterDestination");
	__xamarin_class_map [3133].handle = objc_getClass ("UIPrinterPickerControllerDelegate");
	__xamarin_class_map [3134].handle = objc_getClass ("UIPrintInfo");
	__xamarin_class_map [3135].handle = objc_getClass ("UIPrintInteractionControllerDelegate");
	__xamarin_class_map [3136].handle = objc_getClass ("UIPrintPageRenderer");
	__xamarin_class_map [3137].handle = objc_getClass ("UIPrintPaper");
	__xamarin_class_map [3138].handle = objc_getClass ("UIPrintServiceExtension");
	__xamarin_class_map [3139].handle = objc_getClass ("UIReferenceLibraryViewController");
	__xamarin_class_map [3140].handle = objc_getClass ("UIRegion");
	__xamarin_class_map [3141].handle = objc_getClass ("UISceneActivationConditions");
	__xamarin_class_map [3142].handle = objc_getClass ("UISceneActivationRequestOptions");
	__xamarin_class_map [3143].handle = objc_getClass ("UISceneConfiguration");
	__xamarin_class_map [3144].handle = objc_getClass ("UISceneConnectionOptions");
	__xamarin_class_map [3145].handle = objc_getClass ("Xamarin_iOS__UIKit_UISceneDelegate");
	__xamarin_class_map [3146].handle = objc_getClass ("UISceneDestructionRequestOptions");
	__xamarin_class_map [3147].handle = objc_getClass ("UISceneOpenExternalURLOptions");
	__xamarin_class_map [3148].handle = objc_getClass ("UISceneOpenURLOptions");
	__xamarin_class_map [3149].handle = objc_getClass ("UISceneSession");
	__xamarin_class_map [3150].handle = objc_getClass ("UISceneSizeRestrictions");
	__xamarin_class_map [3151].handle = objc_getClass ("UISceneWindowingBehaviors");
	__xamarin_class_map [3152].handle = objc_getClass ("UIScreenMode");
	__xamarin_class_map [3153].handle = objc_getClass ("UIScreenshotService");
	__xamarin_class_map [3154].handle = objc_getClass ("Xamarin_iOS__UIKit_UIScreenshotServiceDelegate");
	__xamarin_class_map [3155].handle = objc_getClass ("UIScribbleInteraction");
	__xamarin_class_map [3156].handle = objc_getClass ("Xamarin_iOS__UIKit_UIScribbleInteractionDelegate");
	__xamarin_class_map [3157].handle = objc_getClass ("UIScrollViewDelegate");
	__xamarin_class_map [3158].handle = objc_getClass ("UIScrollViewAccessibilityDelegate");
	__xamarin_class_map [3159].handle = objc_getClass ("UISearchBarDelegate");
	__xamarin_class_map [3160].handle = objc_getClass ("UISearchContainerViewController");
	__xamarin_class_map [3161].handle = objc_getClass ("UISearchControllerDelegate");
	__xamarin_class_map [3162].handle = objc_getClass ("UISearchDisplayDelegate");
	__xamarin_class_map [3163].handle = objc_getClass ("UISearchResultsUpdating");
	__xamarin_class_map [3164].handle = objc_getClass ("UISearchSuggestionItem");
	__xamarin_class_map [3165].handle = objc_getClass ("Xamarin_iOS__UIKit_UISearchTextFieldDelegate");
	__xamarin_class_map [3166].handle = objc_getClass ("UISearchToken");
	__xamarin_class_map [3167].handle = objc_getClass ("UISelectionFeedbackGenerator");
	__xamarin_class_map [3168].handle = objc_getClass ("UISheetPresentationController");
	__xamarin_class_map [3169].handle = objc_getClass ("Xamarin_iOS__UIKit_UISheetPresentationControllerDelegate");
	__xamarin_class_map [3170].handle = objc_getClass ("UISheetPresentationControllerDetent");
	__xamarin_class_map [3171].handle = objc_getClass ("UISnapBehavior");
	__xamarin_class_map [3172].handle = objc_getClass ("UISplitViewControllerDelegate");
	__xamarin_class_map [3173].handle = objc_getClass ("UISpringLoadedInteraction");
	__xamarin_class_map [3174].handle = objc_getClass ("UISpringTimingParameters");
	__xamarin_class_map [3175].handle = objc_getClass ("UIStateRestoring");
	__xamarin_class_map [3176].handle = objc_getClass ("UIStatusBarManager");
	__xamarin_class_map [3177].handle = objc_getClass ("UIStoryboard");
	__xamarin_class_map [3178].handle = objc_getClass ("UIStoryboardUnwindSegueSource");
	__xamarin_class_map [3179].handle = objc_getClass ("UISwipeActionsConfiguration");
	__xamarin_class_map [3180].handle = objc_getClass ("UITabBarAppearance");
	__xamarin_class_map [3181].handle = objc_getClass ("UITabBarControllerDelegate");
	__xamarin_class_map [3182].handle = objc_getClass ("UITabBarDelegate");
	__xamarin_class_map [3183].handle = objc_getClass ("UITabBarItemAppearance");
	__xamarin_class_map [3184].handle = objc_getClass ("UITabBarItemStateAppearance");
	__xamarin_class_map [3185].handle = objc_getClass ("Xamarin_iOS__UIKit_UITableViewDataSource");
	__xamarin_class_map [3186].handle = objc_getClass ("UITableViewDelegate");
	__xamarin_class_map [3187].handle = objc_getClass ("UITableViewDragDelegate");
	__xamarin_class_map [3188].handle = objc_getClass ("UITableViewDropDelegate");
	__xamarin_class_map [3189].handle = objc_getClass ("UITableViewPlaceholder");
	__xamarin_class_map [3190].handle = objc_getClass ("UITableViewDropPlaceholder");
	__xamarin_class_map [3191].handle = objc_getClass ("UITableViewDropProposal");
	__xamarin_class_map [3192].handle = objc_getClass ("UITableViewFocusUpdateContext");
	__xamarin_class_map [3193].handle = objc_getClass ("UITableViewRowAction");
	__xamarin_class_map [3194].handle = objc_getClass ("UITableViewSource");
	__xamarin_class_map [3195].handle = objc_getClass ("UITargetedPreview");
	__xamarin_class_map [3196].handle = objc_getClass ("UITargetedDragPreview");
	__xamarin_class_map [3197].handle = objc_getClass ("UITextChecker");
	__xamarin_class_map [3198].handle = objc_getClass ("UITextDocumentProxy");
	__xamarin_class_map [3199].handle = objc_getClass ("UITextDragDelegate");
	__xamarin_class_map [3200].handle = objc_getClass ("UITextDragPreviewRenderer");
	__xamarin_class_map [3201].handle = objc_getClass ("UITextDropDelegate");
	__xamarin_class_map [3202].handle = objc_getClass ("UITextDropProposal");
	__xamarin_class_map [3203].handle = objc_getClass ("UITextFieldDelegate");
	__xamarin_class_map [3204].handle = objc_getClass ("UITextFormattingCoordinator");
	__xamarin_class_map [3205].handle = objc_getClass ("Xamarin_iOS__UIKit_UITextFormattingCoordinatorDelegate");
	__xamarin_class_map [3206].handle = objc_getClass ("UITextInputAssistantItem");
	__xamarin_class_map [3207].handle = objc_getClass ("UITextInputDelegate");
	__xamarin_class_map [3208].handle = objc_getClass ("UITextInputPasswordRules");
	__xamarin_class_map [3209].handle = objc_getClass ("UITextInputStringTokenizer");
	__xamarin_class_map [3210].handle = objc_getClass ("UITextInputTokenizer");
	__xamarin_class_map [3211].handle = objc_getClass ("UITextInteraction");
	__xamarin_class_map [3212].handle = objc_getClass ("Xamarin_iOS__UIKit_UITextInteractionDelegate");
	__xamarin_class_map [3213].handle = objc_getClass ("UITextPasteDelegate");
	__xamarin_class_map [3214].handle = objc_getClass ("UITextPlaceholder");
	__xamarin_class_map [3215].handle = objc_getClass ("UITextPosition");
	__xamarin_class_map [3216].handle = objc_getClass ("UITextRange");
	__xamarin_class_map [3217].handle = objc_getClass ("UITextSearchingFindSession");
	__xamarin_class_map [3218].handle = objc_getClass ("UITextSearchOptions");
	__xamarin_class_map [3219].handle = objc_getClass ("UITextSelectionRect");
	__xamarin_class_map [3220].handle = objc_getClass ("UITextViewDelegate");
	__xamarin_class_map [3221].handle = objc_getClass ("UIToolbarAppearance");
	__xamarin_class_map [3222].handle = objc_getClass ("UIToolbarDelegate");
	__xamarin_class_map [3223].handle = objc_getClass ("UIToolTipConfiguration");
	__xamarin_class_map [3224].handle = objc_getClass ("UIToolTipInteraction");
	__xamarin_class_map [3225].handle = objc_getClass ("Xamarin_iOS__UIKit_UIToolTipInteractionDelegate");
	__xamarin_class_map [3226].handle = objc_getClass ("UITouch");
	__xamarin_class_map [3227].handle = objc_getClass ("UITraitEnvironment");
	__xamarin_class_map [3228].handle = objc_getClass ("UIUserNotificationSettings");
	__xamarin_class_map [3229].handle = objc_getClass ("UIVideoEditorControllerDelegate");
	__xamarin_class_map [3230].handle = objc_getClass ("UIViewControllerAnimatedTransitioning");
	__xamarin_class_map [3231].handle = objc_getClass ("UIViewControllerContextTransitioning");
	__xamarin_class_map [3232].handle = objc_getClass ("UIViewControllerInteractiveTransitioning");
	__xamarin_class_map [3233].handle = objc_getClass ("UIViewControllerPreviewingDelegate");
	__xamarin_class_map [3234].handle = objc_getClass ("UIViewControllerTransitioningDelegate");
	__xamarin_class_map [3235].handle = objc_getClass ("UIViewPrintFormatter");
	__xamarin_class_map [3236].handle = objc_getClass ("UIViewPropertyAnimator");
	__xamarin_class_map [3237].handle = objc_getClass ("UIWebViewDelegate");
	__xamarin_class_map [3238].handle = objc_getClass ("UIWindowScene");
	__xamarin_class_map [3239].handle = objc_getClass ("UIWindowSceneActivationAction");
	__xamarin_class_map [3240].handle = objc_getClass ("UIWindowSceneActivationInteraction");
	__xamarin_class_map [3241].handle = objc_getClass ("UIWindowSceneActivationRequestOptions");
	__xamarin_class_map [3242].handle = objc_getClass ("Xamarin_iOS__UIKit_UIWindowSceneDelegate");
	__xamarin_class_map [3243].handle = objc_getClass ("UIWindowSceneDestructionRequestOptions");
	__xamarin_class_map [3244].handle = objc_getClass ("UIWindowSceneGeometry");
	__xamarin_class_map [3245].handle = objc_getClass ("UIWindowSceneGeometryPreferences");
	__xamarin_class_map [3246].handle = objc_getClass ("UIWindowSceneGeometryPreferencesIOS");
	__xamarin_class_map [3247].handle = objc_getClass ("UIWindowSceneGeometryPreferencesMac");
	__xamarin_class_map [3248].handle = objc_getClass ("ABNewPersonViewControllerDelegate");
	__xamarin_class_map [3249].handle = objc_getClass ("AddressBookUI_InternalABNewPersonViewControllerDelegate");
	__xamarin_class_map [3250].handle = objc_getClass ("ABPeoplePickerNavigationControllerDelegate");
	__xamarin_class_map [3251].handle = objc_getClass ("AddressBookUI_InternalABPeoplePickerNavigationControllerDelegate");
	__xamarin_class_map [3252].handle = objc_getClass ("ABPersonViewControllerDelegate");
	__xamarin_class_map [3253].handle = objc_getClass ("AddressBookUI_InternalABPersonViewControllerDelegate");
	__xamarin_class_map [3254].handle = objc_getClass ("ABUnknownPersonViewControllerDelegate");
	__xamarin_class_map [3255].handle = objc_getClass ("AddressBookUI_InternalABUnknownPersonViewControllerDelegate");
	__xamarin_class_map [3256].handle = objc_getClass ("ASIdentifierManager");
	__xamarin_class_map [3257].handle = objc_getClass ("ACAccount");
	__xamarin_class_map [3258].handle = objc_getClass ("ACAccountCredential");
	__xamarin_class_map [3259].handle = objc_getClass ("ACAccountType");
	__xamarin_class_map [3260].handle = objc_getClass ("AXBrailleMap");
	__xamarin_class_map [3261].handle = objc_getClass ("AXCategoricalDataAxisDescriptor");
	__xamarin_class_map [3262].handle = objc_getClass ("AXChartDescriptor");
	__xamarin_class_map [3263].handle = objc_getClass ("AXCustomContent");
	__xamarin_class_map [3264].handle = objc_getClass ("AXDataPoint");
	__xamarin_class_map [3265].handle = objc_getClass ("AXDataPointValue");
	__xamarin_class_map [3266].handle = objc_getClass ("AXDataSeriesDescriptor");
	__xamarin_class_map [3267].handle = objc_getClass ("AXLiveAudioGraph");
	__xamarin_class_map [3268].handle = objc_getClass ("AXNumericDataAxisDescriptor");
	__xamarin_class_map [3269].handle = objc_getClass ("AVCustomDeviceRoute");
	__xamarin_class_map [3270].handle = objc_getClass ("AVCustomRoutingActionItem");
	__xamarin_class_map [3271].handle = objc_getClass ("AVCustomRoutingEvent");
	__xamarin_class_map [3272].handle = objc_getClass ("AVPlayerViewController");
	__xamarin_class_map [3273].handle = objc_getClass ("Xamarin_iOS__AVKit_AVCustomRoutingControllerDelegate");
	__xamarin_class_map [3274].handle = objc_getClass ("AVInterstitialTimeRange");
	__xamarin_class_map [3275].handle = objc_getClass ("AVPictureInPictureController");
	__xamarin_class_map [3276].handle = objc_getClass ("AVPictureInPictureControllerContentSource");
	__xamarin_class_map [3277].handle = objc_getClass ("AVPictureInPictureControllerDelegate");
	__xamarin_class_map [3278].handle = objc_getClass ("Xamarin_iOS__AVKit_AVPictureInPictureSampleBufferPlaybackDelegate");
	__xamarin_class_map [3279].handle = objc_getClass ("AVPictureInPictureVideoCallViewController");
	__xamarin_class_map [3280].handle = objc_getClass ("AVPlaybackSpeed");
	__xamarin_class_map [3281].handle = objc_getClass ("AVPlayerViewControllerDelegate");
	__xamarin_class_map [3282].handle = objc_getClass ("AVRoutePickerViewDelegate");
	__xamarin_class_map [3283].handle = objc_getClass ("AVAssetDownloadStorageManagementPolicy");
	__xamarin_class_map [3284].handle = objc_getClass ("AVMutableAssetDownloadStorageManagementPolicy");
	__xamarin_class_map [3285].handle = objc_getClass ("AVAssetDownloadTask");
	__xamarin_class_map [3286].handle = objc_getClass ("NSURLSession");
	__xamarin_class_map [3287].handle = objc_getClass ("AVAssetDownloadURLSession");
	__xamarin_class_map [3288].handle = objc_getClass ("AVAssetResourceLoadingDataRequest");
	__xamarin_class_map [3289].handle = objc_getClass ("AVAudioBuffer");
	__xamarin_class_map [3290].handle = objc_getClass ("AVAudioChannelLayout");
	__xamarin_class_map [3291].handle = objc_getClass ("AVAudioFormat");
	__xamarin_class_map [3292].handle = objc_getClass ("AVAudioPlayer");
	__xamarin_class_map [3293].handle = objc_getClass ("AVAudioRecorder");
	__xamarin_class_map [3294].handle = objc_getClass ("AVAudioSessionDataSourceDescription");
	__xamarin_class_map [3295].handle = objc_getClass ("AVAudioSessionPortDescription");
	__xamarin_class_map [3296].handle = objc_getClass ("AVCaptureConnection");
	__xamarin_class_map [3297].handle = objc_getClass ("AVCaptureDeviceDiscoverySession");
	__xamarin_class_map [3298].handle = objc_getClass ("AVCaptureInput");
	__xamarin_class_map [3299].handle = objc_getClass ("AVCaptureDeviceInput");
	__xamarin_class_map [3300].handle = objc_getClass ("AVCaptureOutput");
	__xamarin_class_map [3301].handle = objc_getClass ("AVCaptureMetadataOutput");
	__xamarin_class_map [3302].handle = objc_getClass ("AVCaptureSynchronizedDataCollection");
	__xamarin_class_map [3303].handle = objc_getClass ("AVCaptureSynchronizedData");
	__xamarin_class_map [3304].handle = objc_getClass ("AVCaptureSynchronizedDepthData");
	__xamarin_class_map [3305].handle = objc_getClass ("AVAudioNode");
	__xamarin_class_map [3306].handle = objc_getClass ("AVAudioSourceNode");
	__xamarin_class_map [3307].handle = objc_getClass ("AVAssetTrack");
	__xamarin_class_map [3308].handle = objc_getClass ("AVCompositionTrack");
	__xamarin_class_map [3309].handle = objc_getClass ("AVMutableCompositionTrack");
	__xamarin_class_map [3310].handle = objc_getClass ("AVCaptureAudioDataOutputSampleBufferDelegate");
	__xamarin_class_map [3311].handle = objc_getClass ("AVCaptureInputPort");
	__xamarin_class_map [3312].handle = objc_getClass ("AVAudioConnectionPoint");
	__xamarin_class_map [3313].handle = objc_getClass ("AVCaptureBracketedStillImageSettings");
	__xamarin_class_map [3314].handle = objc_getClass ("AVCaptureManualExposureBracketedStillImageSettings");
	__xamarin_class_map [3315].handle = objc_getClass ("AVCaptureAutoExposureBracketedStillImageSettings");
	__xamarin_class_map [3316].handle = objc_getClass ("AVPlayerInterstitialEventMonitor");
	__xamarin_class_map [3317].handle = objc_getClass ("AVPlayerInterstitialEventController");
	__xamarin_class_map [3318].handle = objc_getClass ("AVPlayerInterstitialEvent");
	__xamarin_class_map [3319].handle = objc_getClass ("AVContentKeyResponse");
	__xamarin_class_map [3320].handle = objc_getClass ("AVDepthData");
	__xamarin_class_map [3321].handle = objc_getClass ("AVPlayerLayer");
	__xamarin_class_map [3322].handle = objc_getClass ("AVMetadataObject");
	__xamarin_class_map [3323].handle = objc_getClass ("AVMetadataMachineReadableCodeObject");
	__xamarin_class_map [3324].handle = objc_getClass ("AVOutputSettingsAssistant");
	__xamarin_class_map [3325].handle = objc_getClass ("AVPlayerLooper");
	__xamarin_class_map [3326].handle = objc_getClass ("AVTextStyleRule");
	__xamarin_class_map [3327].handle = objc_getClass ("AVAudioPlayerDelegate");
	__xamarin_class_map [3328].handle = objc_getClass ("AVFoundation_InternalAVAudioPlayerDelegate");
	__xamarin_class_map [3329].handle = objc_getClass ("AVAudioRecorderDelegate");
	__xamarin_class_map [3330].handle = objc_getClass ("AVFoundation_InternalAVAudioRecorderDelegate");
	__xamarin_class_map [3331].handle = objc_getClass ("AVAudioSessionDelegate");
	__xamarin_class_map [3332].handle = objc_getClass ("AVFoundation_InternalAVAudioSessionDelegate");
	__xamarin_class_map [3333].handle = objc_getClass ("AVAggregateAssetDownloadTask");
	__xamarin_class_map [3334].handle = objc_getClass ("AVAssetCache");
	__xamarin_class_map [3335].handle = objc_getClass ("AVAssetDownloadConfiguration");
	__xamarin_class_map [3336].handle = objc_getClass ("AVAssetDownloadContentConfiguration");
	__xamarin_class_map [3337].handle = objc_getClass ("AVAssetDownloadDelegate");
	__xamarin_class_map [3338].handle = objc_getClass ("AVAssetDownloadStorageManager");
	__xamarin_class_map [3339].handle = objc_getClass ("AVAssetImageGenerator");
	__xamarin_class_map [3340].handle = objc_getClass ("AVAssetReader");
	__xamarin_class_map [3341].handle = objc_getClass ("AVAssetReaderOutput");
	__xamarin_class_map [3342].handle = objc_getClass ("AVAssetReaderAudioMixOutput");
	__xamarin_class_map [3343].handle = objc_getClass ("AVAssetReaderOutputMetadataAdaptor");
	__xamarin_class_map [3344].handle = objc_getClass ("AVAssetReaderSampleReferenceOutput");
	__xamarin_class_map [3345].handle = objc_getClass ("AVAssetReaderTrackOutput");
	__xamarin_class_map [3346].handle = objc_getClass ("AVAssetReaderVideoCompositionOutput");
	__xamarin_class_map [3347].handle = objc_getClass ("AVAssetResourceLoader");
	__xamarin_class_map [3348].handle = objc_getClass ("AVAssetResourceLoaderDelegate");
	__xamarin_class_map [3349].handle = objc_getClass ("AVAssetResourceLoadingContentInformationRequest");
	__xamarin_class_map [3350].handle = objc_getClass ("AVAssetResourceLoadingRequest");
	__xamarin_class_map [3351].handle = objc_getClass ("AVAssetResourceLoadingRequestor");
	__xamarin_class_map [3352].handle = objc_getClass ("AVAssetResourceRenewalRequest");
	__xamarin_class_map [3353].handle = objc_getClass ("AVAssetSegmentReport");
	__xamarin_class_map [3354].handle = objc_getClass ("AVAssetSegmentReportSampleInformation");
	__xamarin_class_map [3355].handle = objc_getClass ("AVAssetSegmentTrackReport");
	__xamarin_class_map [3356].handle = objc_getClass ("AVAssetTrackGroup");
	__xamarin_class_map [3357].handle = objc_getClass ("AVAssetTrackSegment");
	__xamarin_class_map [3358].handle = objc_getClass ("AVAssetVariant");
	__xamarin_class_map [3359].handle = objc_getClass ("AVAssetVariantAudioAttributes");
	__xamarin_class_map [3360].handle = objc_getClass ("AVAssetVariantAudioRenditionSpecificAttributes");
	__xamarin_class_map [3361].handle = objc_getClass ("AVAssetVariantQualifier");
	__xamarin_class_map [3362].handle = objc_getClass ("AVAssetVariantVideoAttributes");
	__xamarin_class_map [3363].handle = objc_getClass ("Xamarin_iOS__AVFoundation_AVAssetWriterDelegate");
	__xamarin_class_map [3364].handle = objc_getClass ("AVAssetWriterInput");
	__xamarin_class_map [3365].handle = objc_getClass ("AVMediaSelectionGroup");
	__xamarin_class_map [3366].handle = objc_getClass ("AVAssetWriterInputGroup");
	__xamarin_class_map [3367].handle = objc_getClass ("AVAssetWriterInputMetadataAdaptor");
	__xamarin_class_map [3368].handle = objc_getClass ("AVAssetWriterInputPassDescription");
	__xamarin_class_map [3369].handle = objc_getClass ("AVAssetWriterInputPixelBufferAdaptor");
	__xamarin_class_map [3370].handle = objc_getClass ("AVAsynchronousCIImageFilteringRequest");
	__xamarin_class_map [3371].handle = objc_getClass ("AVAsynchronousKeyValueLoading");
	__xamarin_class_map [3372].handle = objc_getClass ("AVAudio3DMixing");
	__xamarin_class_map [3373].handle = objc_getClass ("AVAudioCompressedBuffer");
	__xamarin_class_map [3374].handle = objc_getClass ("AVAudioConverter");
	__xamarin_class_map [3375].handle = objc_getClass ("AVAudioEnvironmentDistanceAttenuationParameters");
	__xamarin_class_map [3376].handle = objc_getClass ("AVAudioEnvironmentNode");
	__xamarin_class_map [3377].handle = objc_getClass ("AVAudioEnvironmentReverbParameters");
	__xamarin_class_map [3378].handle = objc_getClass ("AVAudioFile");
	__xamarin_class_map [3379].handle = objc_getClass ("AVAudioIONode");
	__xamarin_class_map [3380].handle = objc_getClass ("AVAudioInputNode");
	__xamarin_class_map [3381].handle = objc_getClass ("AVAudioMix");
	__xamarin_class_map [3382].handle = objc_getClass ("AVAudioMixerNode");
	__xamarin_class_map [3383].handle = objc_getClass ("AVAudioMixingDestination");
	__xamarin_class_map [3384].handle = objc_getClass ("AVAudioMixInputParameters");
	__xamarin_class_map [3385].handle = objc_getClass ("AVAudioOutputNode");
	__xamarin_class_map [3386].handle = objc_getClass ("AVAudioPCMBuffer");
	__xamarin_class_map [3387].handle = objc_getClass ("AVAudioSequencer");
	__xamarin_class_map [3388].handle = objc_getClass ("AVAudioSessionChannelDescription");
	__xamarin_class_map [3389].handle = objc_getClass ("AVAudioSessionRouteDescription");
	__xamarin_class_map [3390].handle = objc_getClass ("AVAudioSinkNode");
	__xamarin_class_map [3391].handle = objc_getClass ("AVAudioStereoMixing");
	__xamarin_class_map [3392].handle = objc_getClass ("AVAudioTime");
	__xamarin_class_map [3393].handle = objc_getClass ("AVAudioUnit");
	__xamarin_class_map [3394].handle = objc_getClass ("AVAudioUnitEffect");
	__xamarin_class_map [3395].handle = objc_getClass ("AVAudioUnitDelay");
	__xamarin_class_map [3396].handle = objc_getClass ("AVAudioUnitDistortion");
	__xamarin_class_map [3397].handle = objc_getClass ("AVAudioUnitEQ");
	__xamarin_class_map [3398].handle = objc_getClass ("AVAudioUnitEQFilterParameters");
	__xamarin_class_map [3399].handle = objc_getClass ("AVAudioUnitGenerator");
	__xamarin_class_map [3400].handle = objc_getClass ("AVAudioUnitMIDIInstrument");
	__xamarin_class_map [3401].handle = objc_getClass ("AVAudioUnitReverb");
	__xamarin_class_map [3402].handle = objc_getClass ("AVAudioUnitSampler");
	__xamarin_class_map [3403].handle = objc_getClass ("AVAudioUnitTimeEffect");
	__xamarin_class_map [3404].handle = objc_getClass ("AVAudioUnitTimePitch");
	__xamarin_class_map [3405].handle = objc_getClass ("AVAudioUnitVarispeed");
	__xamarin_class_map [3406].handle = objc_getClass ("AVCameraCalibrationData");
	__xamarin_class_map [3407].handle = objc_getClass ("AVCaptureAudioChannel");
	__xamarin_class_map [3408].handle = objc_getClass ("AVCaptureAudioDataOutput");
	__xamarin_class_map [3409].handle = objc_getClass ("AVCaptureDataOutputSynchronizer");
	__xamarin_class_map [3410].handle = objc_getClass ("AVCaptureDataOutputSynchronizerDelegate");
	__xamarin_class_map [3411].handle = objc_getClass ("AVCaptureDepthDataOutput");
	__xamarin_class_map [3412].handle = objc_getClass ("AVCaptureDepthDataOutputDelegate");
	__xamarin_class_map [3413].handle = objc_getClass ("AVCaptureDeviceFormat");
	__xamarin_class_map [3414].handle = objc_getClass ("AVCaptureFileOutputRecordingDelegate");
	__xamarin_class_map [3415].handle = objc_getClass ("AVCaptureMetadataInput");
	__xamarin_class_map [3416].handle = objc_getClass ("AVCaptureMetadataOutputObjectsDelegate");
	__xamarin_class_map [3417].handle = objc_getClass ("AVCaptureFileOutput");
	__xamarin_class_map [3418].handle = objc_getClass ("AVCaptureMovieFileOutput");
	__xamarin_class_map [3419].handle = objc_getClass ("AVCaptureSession");
	__xamarin_class_map [3420].handle = objc_getClass ("AVCaptureMultiCamSession");
	__xamarin_class_map [3421].handle = objc_getClass ("AVCapturePhoto");
	__xamarin_class_map [3422].handle = objc_getClass ("AVCapturePhotoSettings");
	__xamarin_class_map [3423].handle = objc_getClass ("AVCapturePhotoBracketSettings");
	__xamarin_class_map [3424].handle = objc_getClass ("AVCapturePhotoCaptureDelegate");
	__xamarin_class_map [3425].handle = objc_getClass ("AVCaptureResolvedPhotoSettings");
	__xamarin_class_map [3426].handle = objc_getClass ("AVCaptureSynchronizedMetadataObjectData");
	__xamarin_class_map [3427].handle = objc_getClass ("AVCaptureSynchronizedSampleBufferData");
	__xamarin_class_map [3428].handle = objc_getClass ("AVCaptureSystemPressureState");
	__xamarin_class_map [3429].handle = objc_getClass ("AVCaptureVideoDataOutput");
	__xamarin_class_map [3430].handle = objc_getClass ("AVCaptureVideoDataOutputSampleBufferDelegate");
	__xamarin_class_map [3431].handle = objc_getClass ("AVAsset");
	__xamarin_class_map [3432].handle = objc_getClass ("AVComposition");
	__xamarin_class_map [3433].handle = objc_getClass ("AVCompositionTrackFormatDescriptionReplacement");
	__xamarin_class_map [3434].handle = objc_getClass ("AVCompositionTrackSegment");
	__xamarin_class_map [3435].handle = objc_getClass ("AVContentKey");
	__xamarin_class_map [3436].handle = objc_getClass ("AVContentKeySessionDelegate");
	__xamarin_class_map [3437].handle = objc_getClass ("AVContentKeySpecifier");
	__xamarin_class_map [3438].handle = objc_getClass ("AVCoordinatedPlaybackParticipant");
	__xamarin_class_map [3439].handle = objc_getClass ("AVCoordinatedPlaybackSuspension");
	__xamarin_class_map [3440].handle = objc_getClass ("AVMetadataGroup");
	__xamarin_class_map [3441].handle = objc_getClass ("AVDateRangeMetadataGroup");
	__xamarin_class_map [3442].handle = objc_getClass ("AVPlaybackCoordinator");
	__xamarin_class_map [3443].handle = objc_getClass ("AVDelegatingPlaybackCoordinator");
	__xamarin_class_map [3444].handle = objc_getClass ("AVDelegatingPlaybackCoordinatorPlaybackControlCommand");
	__xamarin_class_map [3445].handle = objc_getClass ("AVDelegatingPlaybackCoordinatorBufferingCommand");
	__xamarin_class_map [3446].handle = objc_getClass ("AVDelegatingPlaybackCoordinatorPauseCommand");
	__xamarin_class_map [3447].handle = objc_getClass ("AVDelegatingPlaybackCoordinatorPlayCommand");
	__xamarin_class_map [3448].handle = objc_getClass ("AVDelegatingPlaybackCoordinatorSeekCommand");
	__xamarin_class_map [3449].handle = objc_getClass ("AVURLAsset");
	__xamarin_class_map [3450].handle = objc_getClass ("AVFragmentedAsset");
	__xamarin_class_map [3451].handle = objc_getClass ("AVFragmentedAssetMinder");
	__xamarin_class_map [3452].handle = objc_getClass ("AVFragmentedAssetTrack");
	__xamarin_class_map [3453].handle = objc_getClass ("AVFragmentedMovieMinder");
	__xamarin_class_map [3454].handle = objc_getClass ("AVFrameRateRange");
	__xamarin_class_map [3455].handle = objc_getClass ("AVMediaDataStorage");
	__xamarin_class_map [3456].handle = objc_getClass ("AVMediaSelection");
	__xamarin_class_map [3457].handle = objc_getClass ("AVMediaSelectionOption");
	__xamarin_class_map [3458].handle = objc_getClass ("AVMetadataBodyObject");
	__xamarin_class_map [3459].handle = objc_getClass ("AVMetadataCatBodyObject");
	__xamarin_class_map [3460].handle = objc_getClass ("AVMetadataDogBodyObject");
	__xamarin_class_map [3461].handle = objc_getClass ("AVMetadataFaceObject");
	__xamarin_class_map [3462].handle = objc_getClass ("AVMetadataHumanBodyObject");
	__xamarin_class_map [3463].handle = objc_getClass ("AVMetadataItemFilter");
	__xamarin_class_map [3464].handle = objc_getClass ("AVMetadataItemValueRequest");
	__xamarin_class_map [3465].handle = objc_getClass ("AVMetadataSalientObject");
	__xamarin_class_map [3466].handle = objc_getClass ("AVMovie");
	__xamarin_class_map [3467].handle = objc_getClass ("AVMovieTrack");
	__xamarin_class_map [3468].handle = objc_getClass ("AVMusicTrack");
	__xamarin_class_map [3469].handle = objc_getClass ("AVMutableAudioMix");
	__xamarin_class_map [3470].handle = objc_getClass ("AVMutableAudioMixInputParameters");
	__xamarin_class_map [3471].handle = objc_getClass ("AVMutableComposition");
	__xamarin_class_map [3472].handle = objc_getClass ("AVMutableDateRangeMetadataGroup");
	__xamarin_class_map [3473].handle = objc_getClass ("AVMutableMediaSelection");
	__xamarin_class_map [3474].handle = objc_getClass ("AVMetadataItem");
	__xamarin_class_map [3475].handle = objc_getClass ("AVMutableMetadataItem");
	__xamarin_class_map [3476].handle = objc_getClass ("AVMutableMovieTrack");
	__xamarin_class_map [3477].handle = objc_getClass ("AVTimedMetadataGroup");
	__xamarin_class_map [3478].handle = objc_getClass ("AVMutableTimedMetadataGroup");
	__xamarin_class_map [3479].handle = objc_getClass ("AVVideoCompositionLayerInstruction");
	__xamarin_class_map [3480].handle = objc_getClass ("AVMutableVideoCompositionLayerInstruction");
	__xamarin_class_map [3481].handle = objc_getClass ("AVContentKeyRequest");
	__xamarin_class_map [3482].handle = objc_getClass ("AVPersistableContentKeyRequest");
	__xamarin_class_map [3483].handle = objc_getClass ("Xamarin_iOS__AVFoundation_AVPlaybackCoordinatorPlaybackControlDelegate");
	__xamarin_class_map [3484].handle = objc_getClass ("AVPlayerItemAccessLog");
	__xamarin_class_map [3485].handle = objc_getClass ("AVPlayerItemAccessLogEvent");
	__xamarin_class_map [3486].handle = objc_getClass ("AVPlayerItemErrorLog");
	__xamarin_class_map [3487].handle = objc_getClass ("AVPlayerItemErrorLogEvent");
	__xamarin_class_map [3488].handle = objc_getClass ("AVPlayerItemOutput");
	__xamarin_class_map [3489].handle = objc_getClass ("AVPlayerItemLegibleOutput");
	__xamarin_class_map [3490].handle = objc_getClass ("AVPlayerItemOutputPushDelegate");
	__xamarin_class_map [3491].handle = objc_getClass ("AVPlayerItemLegibleOutputPushDelegate");
	__xamarin_class_map [3492].handle = objc_getClass ("AVPlayerItemMediaDataCollector");
	__xamarin_class_map [3493].handle = objc_getClass ("AVPlayerItemMetadataCollector");
	__xamarin_class_map [3494].handle = objc_getClass ("AVPlayerItemMetadataCollectorPushDelegate");
	__xamarin_class_map [3495].handle = objc_getClass ("AVPlayerItemMetadataOutput");
	__xamarin_class_map [3496].handle = objc_getClass ("AVPlayerItemMetadataOutputPushDelegate");
	__xamarin_class_map [3497].handle = objc_getClass ("AVPlayerItemOutputPullDelegate");
	__xamarin_class_map [3498].handle = objc_getClass ("AVPlayerItemTrack");
	__xamarin_class_map [3499].handle = objc_getClass ("AVPlayerPlaybackCoordinator");
	__xamarin_class_map [3500].handle = objc_getClass ("Xamarin_iOS__AVFoundation_AVPlayerPlaybackCoordinatorDelegate");
	__xamarin_class_map [3501].handle = objc_getClass ("AVPortraitEffectsMatte");
	__xamarin_class_map [3502].handle = objc_getClass ("AVPlayer");
	__xamarin_class_map [3503].handle = objc_getClass ("AVQueuePlayer");
	__xamarin_class_map [3504].handle = objc_getClass ("AVSemanticSegmentationMatte");
	__xamarin_class_map [3505].handle = objc_getClass ("AVSpeechSynthesisVoice");
	__xamarin_class_map [3506].handle = objc_getClass ("AVSpeechSynthesizerDelegate");
	__xamarin_class_map [3507].handle = objc_getClass ("AVSpeechUtterance");
	__xamarin_class_map [3508].handle = objc_getClass ("AVSynchronizedLayer");
	__xamarin_class_map [3509].handle = objc_getClass ("AVVideoCompositing");
	__xamarin_class_map [3510].handle = objc_getClass ("AVVideoCompositionCoreAnimationTool");
	__xamarin_class_map [3511].handle = objc_getClass ("AVVideoCompositionRenderContext");
	__xamarin_class_map [3512].handle = objc_getClass ("AVVideoCompositionRenderHint");
	__xamarin_class_map [3513].handle = objc_getClass ("AVVideoCompositionValidationHandling");
	__xamarin_class_map [3514].handle = objc_getClass ("ARFaceGeometry");
	__xamarin_class_map [3515].handle = objc_getClass ("ARPlaneGeometry");
	__xamarin_class_map [3516].handle = objc_getClass ("ARPointCloud");
	__xamarin_class_map [3517].handle = objc_getClass ("ARSkeleton");
	__xamarin_class_map [3518].handle = objc_getClass ("ARSkeleton2D");
	__xamarin_class_map [3519].handle = objc_getClass ("ARSkeleton3D");
	__xamarin_class_map [3520].handle = objc_getClass ("ARAnchor");
	__xamarin_class_map [3521].handle = objc_getClass ("ARAppClipCodeAnchor");
	__xamarin_class_map [3522].handle = objc_getClass ("ARBody2D");
	__xamarin_class_map [3523].handle = objc_getClass ("ARBodyAnchor");
	__xamarin_class_map [3524].handle = objc_getClass ("ARConfiguration");
	__xamarin_class_map [3525].handle = objc_getClass ("ARBodyTrackingConfiguration");
	__xamarin_class_map [3526].handle = objc_getClass ("ARCamera");
	__xamarin_class_map [3527].handle = objc_getClass ("Xamarin_iOS__ARKit_ARCoachingOverlayViewDelegate");
	__xamarin_class_map [3528].handle = objc_getClass ("ARCollaborationData");
	__xamarin_class_map [3529].handle = objc_getClass ("ARDepthData");
	__xamarin_class_map [3530].handle = objc_getClass ("ARLightEstimate");
	__xamarin_class_map [3531].handle = objc_getClass ("ARDirectionalLightEstimate");
	__xamarin_class_map [3532].handle = objc_getClass ("AREnvironmentProbeAnchor");
	__xamarin_class_map [3533].handle = objc_getClass ("ARFaceAnchor");
	__xamarin_class_map [3534].handle = objc_getClass ("ARFaceTrackingConfiguration");
	__xamarin_class_map [3535].handle = objc_getClass ("ARFrame");
	__xamarin_class_map [3536].handle = objc_getClass ("ARGeoAnchor");
	__xamarin_class_map [3537].handle = objc_getClass ("ARGeometryElement");
	__xamarin_class_map [3538].handle = objc_getClass ("ARGeometrySource");
	__xamarin_class_map [3539].handle = objc_getClass ("ARGeoTrackingStatus");
	__xamarin_class_map [3540].handle = objc_getClass ("ARHitTestResult");
	__xamarin_class_map [3541].handle = objc_getClass ("ARImageAnchor");
	__xamarin_class_map [3542].handle = objc_getClass ("ARImageTrackingConfiguration");
	__xamarin_class_map [3543].handle = objc_getClass ("ARMatteGenerator");
	__xamarin_class_map [3544].handle = objc_getClass ("ARMeshAnchor");
	__xamarin_class_map [3545].handle = objc_getClass ("ARMeshGeometry");
	__xamarin_class_map [3546].handle = objc_getClass ("ARObjectAnchor");
	__xamarin_class_map [3547].handle = objc_getClass ("ARObjectScanningConfiguration");
	__xamarin_class_map [3548].handle = objc_getClass ("AROrientationTrackingConfiguration");
	__xamarin_class_map [3549].handle = objc_getClass ("ARParticipantAnchor");
	__xamarin_class_map [3550].handle = objc_getClass ("ARPlaneAnchor");
	__xamarin_class_map [3551].handle = objc_getClass ("ARPlaneExtent");
	__xamarin_class_map [3552].handle = objc_getClass ("ARPositionalTrackingConfiguration");
	__xamarin_class_map [3553].handle = objc_getClass ("ARQuickLookPreviewItem");
	__xamarin_class_map [3554].handle = objc_getClass ("ARRaycastQuery");
	__xamarin_class_map [3555].handle = objc_getClass ("ARRaycastResult");
	__xamarin_class_map [3556].handle = objc_getClass ("ARReferenceObject");
	__xamarin_class_map [3557].handle = objc_getClass ("ARSCNFaceGeometry");
	__xamarin_class_map [3558].handle = objc_getClass ("ARSCNPlaneGeometry");
	__xamarin_class_map [3559].handle = objc_getClass ("ARSCNViewDelegate");
	__xamarin_class_map [3560].handle = objc_getClass ("ARSessionDelegate");
	__xamarin_class_map [3561].handle = objc_getClass ("ARSkeletonDefinition");
	__xamarin_class_map [3562].handle = objc_getClass ("ARSKViewDelegate");
	__xamarin_class_map [3563].handle = objc_getClass ("ARTrackedRaycast");
	__xamarin_class_map [3564].handle = objc_getClass ("ARVideoFormat");
	__xamarin_class_map [3565].handle = objc_getClass ("ARWorldMap");
	__xamarin_class_map [3566].handle = objc_getClass ("ARWorldTrackingConfiguration");
	__xamarin_class_map [3567].handle = objc_getClass ("SNAudioFileAnalyzer");
	__xamarin_class_map [3568].handle = objc_getClass ("SNTimeDurationConstraint");
	__xamarin_class_map [3569].handle = objc_getClass ("UIKit_UIView_UIViewAppearance");
	__xamarin_class_map [3570].handle = objc_getClass ("SharedWithYou_SWAttributionView_SWAttributionViewAppearance");
	__xamarin_class_map [3571].handle = objc_getClass ("SWAttributionView");
	__xamarin_class_map [3572].handle = objc_getClass ("SharedWithYou_SWCollaborationView_SWCollaborationViewAppearance");
	__xamarin_class_map [3573].handle = objc_getClass ("SWCollaborationView");
	__xamarin_class_map [3574].handle = objc_getClass ("SWHighlightCenter");
	__xamarin_class_map [3575].handle = objc_getClass ("SFContentBlockerManager");
	__xamarin_class_map [3576].handle = objc_getClass ("SFSafariViewControllerDataStore");
	__xamarin_class_map [3577].handle = objc_getClass ("QLThumbnailGenerator");
	__xamarin_class_map [3578].handle = objc_getClass ("QuickLook_QLPreviewController__QLPreviewControllerDelegate");
	__xamarin_class_map [3579].handle = objc_getClass ("QLPreviewController");
	__xamarin_class_map [3580].handle = objc_getClass ("PhotosUI_PHLivePhotoView_PHLivePhotoViewAppearance");
	__xamarin_class_map [3581].handle = objc_getClass ("PHLivePhotoView");
	__xamarin_class_map [3582].handle = objc_getClass ("UIKit_UIScrollView_UIScrollViewAppearance");
	__xamarin_class_map [3583].handle = objc_getClass ("PencilKit_PKCanvasView_PKCanvasViewAppearance");
	__xamarin_class_map [3584].handle = objc_getClass ("UIScrollView");
	__xamarin_class_map [3585].handle = objc_getClass ("PKCanvasView");
	__xamarin_class_map [3586].handle = objc_getClass ("NKIssue");
	__xamarin_class_map [3587].handle = objc_getClass ("MSConversation");
	__xamarin_class_map [3588].handle = objc_getClass ("Messages_MSStickerBrowserView_MSStickerBrowserViewAppearance");
	__xamarin_class_map [3589].handle = objc_getClass ("MSStickerBrowserView");
	__xamarin_class_map [3590].handle = objc_getClass ("Messages_MSStickerView_MSStickerViewAppearance");
	__xamarin_class_map [3591].handle = objc_getClass ("MSStickerView");
	__xamarin_class_map [3592].handle = objc_getClass ("LAContext");
	__xamarin_class_map [3593].handle = objc_getClass ("LAPrivateKey");
	__xamarin_class_map [3594].handle = objc_getClass ("LAPublicKey");
	__xamarin_class_map [3595].handle = objc_getClass ("LARightStore");
	__xamarin_class_map [3596].handle = objc_getClass ("LASecret");
	__xamarin_class_map [3597].handle = objc_getClass ("LinkPresentation_LPLinkView_LPLinkViewAppearance");
	__xamarin_class_map [3598].handle = objc_getClass ("LPLinkView");
	__xamarin_class_map [3599].handle = objc_getClass ("LPMetadataProvider");
	__xamarin_class_map [3600].handle = objc_getClass ("UIKit_UIControl_UIControlAppearance");
	__xamarin_class_map [3601].handle = objc_getClass ("UIKit_UIButton_UIButtonAppearance");
	__xamarin_class_map [3602].handle = objc_getClass ("IntentsUI_INUIAddVoiceShortcutButton_INUIAddVoiceShortcutButtonAppearance");
	__xamarin_class_map [3603].handle = objc_getClass ("UIControl");
	__xamarin_class_map [3604].handle = objc_getClass ("UIButton");
	__xamarin_class_map [3605].handle = objc_getClass ("INUIAddVoiceShortcutButton");
	__xamarin_class_map [3606].handle = objc_getClass ("ILMessageFilterCapabilitiesQueryResponse");
	__xamarin_class_map [3607].handle = objc_getClass ("ILMessageFilterExtensionContext");
	__xamarin_class_map [3608].handle = objc_getClass ("HealthKitUI_HKActivityRingView_HKActivityRingViewAppearance");
	__xamarin_class_map [3609].handle = objc_getClass ("HKActivityRingView");
	__xamarin_class_map [3610].handle = objc_getClass ("ExternalAccessory_EAAccessory__EAAccessoryDelegate");
	__xamarin_class_map [3611].handle = objc_getClass ("EAAccessory");
	__xamarin_class_map [3612].handle = objc_getClass ("EAAccessoryManager");
	__xamarin_class_map [3613].handle = objc_getClass ("ExternalAccessory_EAWiFiUnconfiguredAccessoryBrowser__EAWiFiUnconfiguredAccessoryBrowserDelegate");
	__xamarin_class_map [3614].handle = objc_getClass ("EAWiFiUnconfiguredAccessoryBrowser");
	__xamarin_class_map [3615].handle = objc_getClass ("DCAppAttestService");
	__xamarin_class_map [3616].handle = objc_getClass ("DCDevice");
	__xamarin_class_map [3617].handle = objc_getClass ("CoreLocationUI_CLLocationButton_CLLocationButtonAppearance");
	__xamarin_class_map [3618].handle = objc_getClass ("CLLocationButton");
	__xamarin_class_map [3619].handle = objc_getClass ("CHHapticEngine");
	__xamarin_class_map [3620].handle = objc_getClass ("CoreAudioKit_CAInterAppAudioSwitcherView_CAInterAppAudioSwitcherViewAppearance");
	__xamarin_class_map [3621].handle = objc_getClass ("CAInterAppAudioSwitcherView");
	__xamarin_class_map [3622].handle = objc_getClass ("CoreAudioKit_CAInterAppAudioTransportView_CAInterAppAudioTransportViewAppearance");
	__xamarin_class_map [3623].handle = objc_getClass ("CAInterAppAudioTransportView");
	__xamarin_class_map [3624].handle = objc_getClass ("BGTaskScheduler");
	__xamarin_class_map [3625].handle = objc_getClass ("ATTrackingManager");
	__xamarin_class_map [3626].handle = objc_getClass ("APActivationPayload");
	__xamarin_class_map [3627].handle = objc_getClass ("iAd_ADBannerView_ADBannerViewAppearance");
	__xamarin_class_map [3628].handle = objc_getClass ("iAd_ADBannerView");
	__xamarin_class_map [3629].handle = objc_getClass ("ADClient");
	__xamarin_class_map [3630].handle = objc_getClass ("VNFaceLandmarkRegion2D");
	__xamarin_class_map [3631].handle = objc_getClass ("VNRecognizedPointsObservation");
	__xamarin_class_map [3632].handle = objc_getClass ("VNDetectHumanBodyPoseRequest");
	__xamarin_class_map [3633].handle = objc_getClass ("VNDetectHumanHandPoseRequest");
	__xamarin_class_map [3634].handle = objc_getClass ("VNHumanBodyPoseObservation");
	__xamarin_class_map [3635].handle = objc_getClass ("VNHumanHandPoseObservation");
	__xamarin_class_map [3636].handle = objc_getClass ("VNRecognizeAnimalsRequest");
	__xamarin_class_map [3637].handle = objc_getClass ("VSAccountManager");
	__xamarin_class_map [3638].handle = objc_getClass ("VSUserAccountManager");
	__xamarin_class_map [3639].handle = objc_getClass ("UNUserNotificationCenter");
	__xamarin_class_map [3640].handle = objc_getClass ("TWRequest");
	__xamarin_class_map [3641].handle = objc_getClass ("SKAdNetwork");
	__xamarin_class_map [3642].handle = objc_getClass ("SKCloudServiceController");
	__xamarin_class_map [3643].handle = objc_getClass ("SKCloudServiceSetupViewController");
	__xamarin_class_map [3644].handle = objc_getClass ("StoreKit_SKRequest__SKRequestDelegate");
	__xamarin_class_map [3645].handle = objc_getClass ("StoreKit_SKProductsRequest__SKProductsRequestDelegate");
	__xamarin_class_map [3646].handle = objc_getClass ("SKProductsRequest");
	__xamarin_class_map [3647].handle = objc_getClass ("SKProductStorePromotionController");
	__xamarin_class_map [3648].handle = objc_getClass ("StoreKit_SKStoreProductViewController__SKStoreProductViewControllerDelegate");
	__xamarin_class_map [3649].handle = objc_getClass ("SKStoreProductViewController");
	__xamarin_class_map [3650].handle = objc_getClass ("SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate");
	__xamarin_class_map [3651].handle = objc_getClass ("SKPhysicsWorld");
	__xamarin_class_map [3652].handle = objc_getClass ("SKTextureAtlas");
	__xamarin_class_map [3653].handle = objc_getClass ("SpriteKit_SKView_SKViewAppearance");
	__xamarin_class_map [3654].handle = objc_getClass ("SKView");
	__xamarin_class_map [3655].handle = objc_getClass ("SLRequest");
	__xamarin_class_map [3656].handle = objc_getClass ("SWCollaborationMetadata");
	__xamarin_class_map [3657].handle = objc_getClass ("SRSensorReader");
	__xamarin_class_map [3658].handle = objc_getClass ("SCNAction");
	__xamarin_class_map [3659].handle = objc_getClass ("SCNAnimationEvent");
	__xamarin_class_map [3660].handle = objc_getClass ("SceneKit_SCNView_SCNViewAppearance");
	__xamarin_class_map [3661].handle = objc_getClass ("SCNView");
	__xamarin_class_map [3662].handle = objc_getClass ("SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate");
	__xamarin_class_map [3663].handle = objc_getClass ("SCNPhysicsWorld");
	__xamarin_class_map [3664].handle = objc_getClass ("SCNRenderer");
	__xamarin_class_map [3665].handle = objc_getClass ("RPBroadcastActivityViewController");
	__xamarin_class_map [3666].handle = objc_getClass ("RPBroadcastController");
	__xamarin_class_map [3667].handle = objc_getClass ("RPScreenRecorder");
	__xamarin_class_map [3668].handle = objc_getClass ("ReplayKit_RPSystemBroadcastPickerView_RPSystemBroadcastPickerViewAppearance");
	__xamarin_class_map [3669].handle = objc_getClass ("RPSystemBroadcastPickerView");
	__xamarin_class_map [3670].handle = objc_getClass ("PHLivePhotoEditingContext");
	__xamarin_class_map [3671].handle = objc_getClass ("PHFetchResult");
	__xamarin_class_map [3672].handle = objc_getClass ("Photos_PHPhotoLibrary___phlib_observer");
	__xamarin_class_map [3673].handle = objc_getClass ("PHPhotoLibrary");
	__xamarin_class_map [3674].handle = objc_getClass ("PHAssetResourceManager");
	__xamarin_class_map [3675].handle = objc_getClass ("PDFAnnotation");
	__xamarin_class_map [3676].handle = objc_getClass ("PdfKit_PdfView__PdfViewDelegate");
	__xamarin_class_map [3677].handle = objc_getClass ("PdfKit_PdfView_PdfViewAppearance");
	__xamarin_class_map [3678].handle = objc_getClass ("PDFView");
	__xamarin_class_map [3679].handle = objc_getClass ("PdfKit_PdfDocument__PdfDocumentDelegate");
	__xamarin_class_map [3680].handle = objc_getClass ("PDFDocument");
	__xamarin_class_map [3681].handle = objc_getClass ("PdfKit_PdfThumbnailView_PdfThumbnailViewAppearance");
	__xamarin_class_map [3682].handle = objc_getClass ("PDFThumbnailView");
	__xamarin_class_map [3683].handle = objc_getClass ("PassKit_PKPaymentAuthorizationViewController__PKPaymentAuthorizationViewControllerDelegate");
	__xamarin_class_map [3684].handle = objc_getClass ("PKPaymentAuthorizationViewController");
	__xamarin_class_map [3685].handle = objc_getClass ("PKShareablePassMetadata");
	__xamarin_class_map [3686].handle = objc_getClass ("PassKit_PKAddPassButton_PKAddPassButtonAppearance");
	__xamarin_class_map [3687].handle = objc_getClass ("PKAddPassButton");
	__xamarin_class_map [3688].handle = objc_getClass ("PassKit_PKAddPassesViewController__PKAddPassesViewControllerDelegate");
	__xamarin_class_map [3689].handle = objc_getClass ("PKAddPassesViewController");
	__xamarin_class_map [3690].handle = objc_getClass ("PKAddShareablePassConfiguration");
	__xamarin_class_map [3691].handle = objc_getClass ("PKDisbursementAuthorizationController");
	__xamarin_class_map [3692].handle = objc_getClass ("PKIdentityAuthorizationController");
	__xamarin_class_map [3693].handle = objc_getClass ("PassKit_PKIdentityButton_PKIdentityButtonAppearance");
	__xamarin_class_map [3694].handle = objc_getClass ("PKIdentityButton");
	__xamarin_class_map [3695].handle = objc_getClass ("PKIssuerProvisioningExtensionHandler");
	__xamarin_class_map [3696].handle = objc_getClass ("PKPassLibrary");
	__xamarin_class_map [3697].handle = objc_getClass ("PKPaymentAuthorizationController");
	__xamarin_class_map [3698].handle = objc_getClass ("PassKit_PKPaymentButton_PKPaymentButtonAppearance");
	__xamarin_class_map [3699].handle = objc_getClass ("PKPaymentButton");
	__xamarin_class_map [3700].handle = objc_getClass ("PKVehicleConnectionSession");
	__xamarin_class_map [3701].handle = objc_getClass ("EAGLContext");
	__xamarin_class_map [3702].handle = objc_getClass ("NETunnelProvider");
	__xamarin_class_map [3703].handle = objc_getClass ("NEPacketTunnelProvider");
	__xamarin_class_map [3704].handle = objc_getClass ("NEAppProxyFlow");
	__xamarin_class_map [3705].handle = objc_getClass ("NEAppProxyProvider");
	__xamarin_class_map [3706].handle = objc_getClass ("NEVPNManager");
	__xamarin_class_map [3707].handle = objc_getClass ("NETunnelProviderManager");
	__xamarin_class_map [3708].handle = objc_getClass ("NEAppProxyProviderManager");
	__xamarin_class_map [3709].handle = objc_getClass ("NEAppProxyTCPFlow");
	__xamarin_class_map [3710].handle = objc_getClass ("NEAppProxyUDPFlow");
	__xamarin_class_map [3711].handle = objc_getClass ("NEAppPushManager");
	__xamarin_class_map [3712].handle = objc_getClass ("NEAppPushProvider");
	__xamarin_class_map [3713].handle = objc_getClass ("NEDNSProxyManager");
	__xamarin_class_map [3714].handle = objc_getClass ("NEDNSProxyProvider");
	__xamarin_class_map [3715].handle = objc_getClass ("NEDNSSettingsManager");
	__xamarin_class_map [3716].handle = objc_getClass ("NEFilterControlProvider");
	__xamarin_class_map [3717].handle = objc_getClass ("NEFilterManager");
	__xamarin_class_map [3718].handle = objc_getClass ("NEHotspotConfigurationManager");
	__xamarin_class_map [3719].handle = objc_getClass ("NEHotspotNetwork");
	__xamarin_class_map [3720].handle = objc_getClass ("NEPacketTunnelFlow");
	__xamarin_class_map [3721].handle = objc_getClass ("NWTCPConnection");
	__xamarin_class_map [3722].handle = objc_getClass ("NWUDPSession");
	__xamarin_class_map [3723].handle = objc_getClass ("NLEmbedding");
	__xamarin_class_map [3724].handle = objc_getClass ("NLLanguageRecognizer");
	__xamarin_class_map [3725].handle = objc_getClass ("NLTagger");
	__xamarin_class_map [3726].handle = objc_getClass ("System_Net_Http_NSUrlSessionHandler_WrappedNSInputStream");
	__xamarin_class_map [3727].handle = objc_getClass ("MCSession");
	__xamarin_class_map [3728].handle = objc_getClass ("MDLMesh");
	__xamarin_class_map [3729].handle = objc_getClass ("MPSGraphTensorData");
	__xamarin_class_map [3730].handle = objc_getClass ("MPSGraphDepthwiseConvolution3DOpDescriptor");
	__xamarin_class_map [3731].handle = objc_getClass ("MPSGraphPooling4DOpDescriptor");
	__xamarin_class_map [3732].handle = objc_getClass ("MPSGraphShapedType");
	__xamarin_class_map [3733].handle = objc_getClass ("MPSGraphStencilOpDescriptor");
	__xamarin_class_map [3734].handle = objc_getClass ("MPSGraphTensor");
	__xamarin_class_map [3735].handle = objc_getClass ("MPSGraphVariableOp");
	__xamarin_class_map [3736].handle = objc_getClass ("MPSNNGraph");
	__xamarin_class_map [3737].handle = objc_getClass ("MPSNDArrayDescriptor");
	__xamarin_class_map [3738].handle = objc_getClass ("MTKTextureLoader");
	__xamarin_class_map [3739].handle = objc_getClass ("MetalKit_MTKView_MTKViewAppearance");
	__xamarin_class_map [3740].handle = objc_getClass ("MTKView");
	__xamarin_class_map [3741].handle = objc_getClass ("MessageUI_MFMailComposeViewController_MFMailComposeViewControllerAppearance");
	__xamarin_class_map [3742].handle = objc_getClass ("MFMailComposeViewController");
	__xamarin_class_map [3743].handle = objc_getClass ("MessageUI_MFMessageComposeViewController_MFMessageComposeViewControllerAppearance");
	__xamarin_class_map [3744].handle = objc_getClass ("MFMessageComposeViewController");
	__xamarin_class_map [3745].handle = objc_getClass ("MPMoviePlayerController");
	__xamarin_class_map [3746].handle = objc_getClass ("MPSkipIntervalCommand");
	__xamarin_class_map [3747].handle = objc_getClass ("MPMediaLibrary");
	__xamarin_class_map [3748].handle = objc_getClass ("MediaPlayer_MPMediaPickerController__MPMediaPickerControllerDelegate");
	__xamarin_class_map [3749].handle = objc_getClass ("MPMediaPickerController");
	__xamarin_class_map [3750].handle = objc_getClass ("MPMediaPlaylist");
	__xamarin_class_map [3751].handle = objc_getClass ("MPMusicPlayerController");
	__xamarin_class_map [3752].handle = objc_getClass ("MPMusicPlayerApplicationController");
	__xamarin_class_map [3753].handle = objc_getClass ("MPNowPlayingSession");
	__xamarin_class_map [3754].handle = objc_getClass ("MediaPlayer_MPVolumeView_MPVolumeViewAppearance");
	__xamarin_class_map [3755].handle = objc_getClass ("MPVolumeView");
	__xamarin_class_map [3756].handle = objc_getClass ("UIKit_UIBarItem_UIBarItemAppearance");
	__xamarin_class_map [3757].handle = objc_getClass ("UIKit_UIBarButtonItem_UIBarButtonItemAppearance");
	__xamarin_class_map [3758].handle = objc_getClass ("MapKit_MKUserTrackingBarButtonItem_MKUserTrackingBarButtonItemAppearance");
	__xamarin_class_map [3759].handle = objc_getClass ("UIBarItem");
	__xamarin_class_map [3760].handle = objc_getClass ("UIBarButtonItem");
	__xamarin_class_map [3761].handle = objc_getClass ("MKUserTrackingBarButtonItem");
	__xamarin_class_map [3762].handle = objc_getClass ("MKDirections");
	__xamarin_class_map [3763].handle = objc_getClass ("MKLocalSearch");
	__xamarin_class_map [3764].handle = objc_getClass ("MKMapItem");
	__xamarin_class_map [3765].handle = objc_getClass ("MapKit_MKOverlayView_MKOverlayViewAppearance");
	__xamarin_class_map [3766].handle = objc_getClass ("MKOverlayView");
	__xamarin_class_map [3767].handle = objc_getClass ("MKPointOfInterestFilter");
	__xamarin_class_map [3768].handle = objc_getClass ("MapKit_MKAnnotationView_MKAnnotationViewAppearance");
	__xamarin_class_map [3769].handle = objc_getClass ("MKAnnotationView");
	__xamarin_class_map [3770].handle = objc_getClass ("MapKit_MKOverlayPathView_MKOverlayPathViewAppearance");
	__xamarin_class_map [3771].handle = objc_getClass ("MapKit_MKCircleView_MKCircleViewAppearance");
	__xamarin_class_map [3772].handle = objc_getClass ("MKOverlayPathView");
	__xamarin_class_map [3773].handle = objc_getClass ("MKCircleView");
	__xamarin_class_map [3774].handle = objc_getClass ("MapKit_MKCompassButton_MKCompassButtonAppearance");
	__xamarin_class_map [3775].handle = objc_getClass ("MKCompassButton");
	__xamarin_class_map [3776].handle = objc_getClass ("MKGradientPolylineRenderer");
	__xamarin_class_map [3777].handle = objc_getClass ("MKLookAroundSceneRequest");
	__xamarin_class_map [3778].handle = objc_getClass ("MKLookAroundSnapshotter");
	__xamarin_class_map [3779].handle = objc_getClass ("MKMapItemRequest");
	__xamarin_class_map [3780].handle = objc_getClass ("MKMapSnapshotter");
	__xamarin_class_map [3781].handle = objc_getClass ("MapKit_MKMapView__MKMapViewDelegate");
	__xamarin_class_map [3782].handle = objc_getClass ("MapKit_MKMapView_MKMapViewAppearance");
	__xamarin_class_map [3783].handle = objc_getClass ("MKMapView");
	__xamarin_class_map [3784].handle = objc_getClass ("MapKit_MKMarkerAnnotationView_MKMarkerAnnotationViewAppearance");
	__xamarin_class_map [3785].handle = objc_getClass ("MKMarkerAnnotationView");
	__xamarin_class_map [3786].handle = objc_getClass ("MapKit_MKPinAnnotationView_MKPinAnnotationViewAppearance");
	__xamarin_class_map [3787].handle = objc_getClass ("MKPinAnnotationView");
	__xamarin_class_map [3788].handle = objc_getClass ("MapKit_MKPolygonView_MKPolygonViewAppearance");
	__xamarin_class_map [3789].handle = objc_getClass ("MKPolygonView");
	__xamarin_class_map [3790].handle = objc_getClass ("MapKit_MKPolylineView_MKPolylineViewAppearance");
	__xamarin_class_map [3791].handle = objc_getClass ("MKPolylineView");
	__xamarin_class_map [3792].handle = objc_getClass ("MapKit_MKScaleView_MKScaleViewAppearance");
	__xamarin_class_map [3793].handle = objc_getClass ("MKScaleView");
	__xamarin_class_map [3794].handle = objc_getClass ("MapKit_MKUserLocationView_MKUserLocationViewAppearance");
	__xamarin_class_map [3795].handle = objc_getClass ("MKUserLocationView");
	__xamarin_class_map [3796].handle = objc_getClass ("MapKit_MKUserTrackingButton_MKUserTrackingButtonAppearance");
	__xamarin_class_map [3797].handle = objc_getClass ("MKUserTrackingButton");
	__xamarin_class_map [3798].handle = objc_getClass ("INInteraction");
	__xamarin_class_map [3799].handle = objc_getClass ("INCar");
	__xamarin_class_map [3800].handle = objc_getClass ("INFocusStatusCenter");
	__xamarin_class_map [3801].handle = objc_getClass ("INImage");
	__xamarin_class_map [3802].handle = objc_getClass ("INPreferences");
	__xamarin_class_map [3803].handle = objc_getClass ("INRelevantShortcutStore");
	__xamarin_class_map [3804].handle = objc_getClass ("INVoiceShortcutCenter");
	__xamarin_class_map [3805].handle = objc_getClass ("HMActionSet");
	__xamarin_class_map [3806].handle = objc_getClass ("HMCharacteristic");
	__xamarin_class_map [3807].handle = objc_getClass ("HMAccessorySetupManager");
	__xamarin_class_map [3808].handle = objc_getClass ("HMTrigger");
	__xamarin_class_map [3809].handle = objc_getClass ("HMEventTrigger");
	__xamarin_class_map [3810].handle = objc_getClass ("HomeKit_HMHome__HMHomeDelegate");
	__xamarin_class_map [3811].handle = objc_getClass ("HMHome");
	__xamarin_class_map [3812].handle = objc_getClass ("HMService");
	__xamarin_class_map [3813].handle = objc_getClass ("HomeKit_HMAccessory__HMAccessoryDelegate");
	__xamarin_class_map [3814].handle = objc_getClass ("HMAccessory");
	__xamarin_class_map [3815].handle = objc_getClass ("HomeKit_HMAccessoryBrowser__HMAccessoryBrowserDelegate");
	__xamarin_class_map [3816].handle = objc_getClass ("HMAccessoryBrowser");
	__xamarin_class_map [3817].handle = objc_getClass ("HMCameraStream");
	__xamarin_class_map [3818].handle = objc_getClass ("HomeKit_HMCameraView_HMCameraViewAppearance");
	__xamarin_class_map [3819].handle = objc_getClass ("HMCameraView");
	__xamarin_class_map [3820].handle = objc_getClass ("HMCharacteristicWriteAction");
	__xamarin_class_map [3821].handle = objc_getClass ("HomeKit_HMHomeManager__HMHomeManagerDelegate");
	__xamarin_class_map [3822].handle = objc_getClass ("HMHomeManager");
	__xamarin_class_map [3823].handle = objc_getClass ("HMRoom");
	__xamarin_class_map [3824].handle = objc_getClass ("HMServiceGroup");
	__xamarin_class_map [3825].handle = objc_getClass ("HMTimerTrigger");
	__xamarin_class_map [3826].handle = objc_getClass ("HMZone");
	__xamarin_class_map [3827].handle = objc_getClass ("HKAttachmentStore");
	__xamarin_class_map [3828].handle = objc_getClass ("HKHealthStore");
	__xamarin_class_map [3829].handle = objc_getClass ("HKHeartbeatSeriesBuilder");
	__xamarin_class_map [3830].handle = objc_getClass ("HKQuantitySeriesSampleBuilder");
	__xamarin_class_map [3831].handle = objc_getClass ("HKVerifiableClinicalRecordQuery");
	__xamarin_class_map [3832].handle = objc_getClass ("HKWorkoutBuilder");
	__xamarin_class_map [3833].handle = objc_getClass ("HKWorkoutRouteBuilder");
	__xamarin_class_map [3834].handle = objc_getClass ("GKMatchmaker");
	__xamarin_class_map [3835].handle = objc_getClass ("GKGameSession");
	__xamarin_class_map [3836].handle = objc_getClass ("GKScore");
	__xamarin_class_map [3837].handle = objc_getClass ("MonoTouch_GKSession_ReceivedObject");
	__xamarin_class_map [3838].handle = objc_getClass ("GKSession");
	__xamarin_class_map [3839].handle = objc_getClass ("GKTurnBasedExchange");
	__xamarin_class_map [3840].handle = objc_getClass ("GameKit_GKMatch__GKMatchDelegate");
	__xamarin_class_map [3841].handle = objc_getClass ("GKMatch");
	__xamarin_class_map [3842].handle = objc_getClass ("GKAchievement");
	__xamarin_class_map [3843].handle = objc_getClass ("GKAchievementDescription");
	__xamarin_class_map [3844].handle = objc_getClass ("GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate");
	__xamarin_class_map [3845].handle = objc_getClass ("GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate");
	__xamarin_class_map [3846].handle = objc_getClass ("GameKit_GKAchievementViewController_GKAchievementViewControllerAppearance");
	__xamarin_class_map [3847].handle = objc_getClass ("GKGameCenterViewController");
	__xamarin_class_map [3848].handle = objc_getClass ("GKAchievementViewController");
	__xamarin_class_map [3849].handle = objc_getClass ("GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate");
	__xamarin_class_map [3850].handle = objc_getClass ("GKChallengeEventHandler");
	__xamarin_class_map [3851].handle = objc_getClass ("GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [3852].handle = objc_getClass ("GameKit_GKFriendRequestComposeViewController_GKFriendRequestComposeViewControllerAppearance");
	__xamarin_class_map [3853].handle = objc_getClass ("GKFriendRequestComposeViewController");
	__xamarin_class_map [3854].handle = objc_getClass ("GKLeaderboard");
	__xamarin_class_map [3855].handle = objc_getClass ("GKLeaderboardEntry");
	__xamarin_class_map [3856].handle = objc_getClass ("GKLeaderboardSet");
	__xamarin_class_map [3857].handle = objc_getClass ("GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [3858].handle = objc_getClass ("GameKit_GKLeaderboardViewController_GKLeaderboardViewControllerAppearance");
	__xamarin_class_map [3859].handle = objc_getClass ("GKLeaderboardViewController");
	__xamarin_class_map [3860].handle = objc_getClass ("GKPlayer");
	__xamarin_class_map [3861].handle = objc_getClass ("GKLocalPlayer");
	__xamarin_class_map [3862].handle = objc_getClass ("GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [3863].handle = objc_getClass ("GKMatchmakerViewController");
	__xamarin_class_map [3864].handle = objc_getClass ("GKNotificationBanner");
	__xamarin_class_map [3865].handle = objc_getClass ("GKSavedGame");
	__xamarin_class_map [3866].handle = objc_getClass ("GKTurnBasedMatch");
	__xamarin_class_map [3867].handle = objc_getClass ("GameKit_GKTurnBasedMatchmakerViewController_GKTurnBasedMatchmakerViewControllerAppearance");
	__xamarin_class_map [3868].handle = objc_getClass ("GKTurnBasedMatchmakerViewController");
	__xamarin_class_map [3869].handle = objc_getClass ("GCController");
	__xamarin_class_map [3870].handle = objc_getClass ("GCKeyboard");
	__xamarin_class_map [3871].handle = objc_getClass ("GCMouse");
	__xamarin_class_map [3872].handle = objc_getClass ("GCVirtualController");
	__xamarin_class_map [3873].handle = objc_getClass ("GLKTextureLoader");
	__xamarin_class_map [3874].handle = objc_getClass ("GLKit_GLKView__GLKViewDelegate");
	__xamarin_class_map [3875].handle = objc_getClass ("GLKit_GLKView_GLKViewAppearance");
	__xamarin_class_map [3876].handle = objc_getClass ("GLKView");
	__xamarin_class_map [3877].handle = objc_getClass ("WebKit_WKWebView_WKWebViewAppearance");
	__xamarin_class_map [3878].handle = objc_getClass ("WKWebsiteDataStore");
	__xamarin_class_map [3879].handle = objc_getClass ("WKContentRuleListStore");
	__xamarin_class_map [3880].handle = objc_getClass ("WKDownload");
	__xamarin_class_map [3881].handle = objc_getClass ("WKHTTPCookieStore");
	__xamarin_class_map [3882].handle = objc_getClass ("NSIndexPath");
	__xamarin_class_map [3883].handle = objc_getClass ("Foundation_NSNetService__NSNetServiceDelegate");
	__xamarin_class_map [3884].handle = objc_getClass ("NSNetService");
	__xamarin_class_map [3885].handle = objc_getClass ("NSUserActivity");
	__xamarin_class_map [3886].handle = objc_getClass ("NSBundleResourceRequest");
	__xamarin_class_map [3887].handle = objc_getClass ("NSCalendar");
	__xamarin_class_map [3888].handle = objc_getClass ("NSDictionary");
	__xamarin_class_map [3889].handle = objc_getClass ("NSFileManager");
	__xamarin_class_map [3890].handle = objc_getClass ("NSItemProvider");
	__xamarin_class_map [3891].handle = objc_getClass ("Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate");
	__xamarin_class_map [3892].handle = objc_getClass ("NSKeyedArchiver");
	__xamarin_class_map [3893].handle = objc_getClass ("Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate");
	__xamarin_class_map [3894].handle = objc_getClass ("NSLocale");
	__xamarin_class_map [3895].handle = objc_getClass ("NSMutableDictionary");
	__xamarin_class_map [3896].handle = objc_getClass ("NSNotificationCenter");
	__xamarin_class_map [3897].handle = objc_getClass ("__NSObject_Disposer");
	__xamarin_class_map [3898].handle = objc_getClass ("__XamarinObjectObserver");
	__xamarin_class_map [3899].handle = objc_getClass ("NSProgress");
	__xamarin_class_map [3900].handle = objc_getClass ("Foundation_NSStream__NSStreamDelegate");
	__xamarin_class_map [3901].handle = objc_getClass ("NSUbiquitousKeyValueStore");
	__xamarin_class_map [3902].handle = objc_getClass ("NSUndoManager");
	__xamarin_class_map [3903].handle = objc_getClass ("NSURL");
	__xamarin_class_map [3904].handle = objc_getClass ("NSURLConnection");
	__xamarin_class_map [3905].handle = objc_getClass ("NSURLSessionConfiguration");
	__xamarin_class_map [3906].handle = objc_getClass ("NSUserDefaults");
	__xamarin_class_map [3907].handle = objc_getClass ("Foundation_NSCache__NSCacheDelegate");
	__xamarin_class_map [3908].handle = objc_getClass ("NSCache");
	__xamarin_class_map [3909].handle = objc_getClass ("NSFileHandle");
	__xamarin_class_map [3910].handle = objc_getClass ("NSFileVersion");
	__xamarin_class_map [3911].handle = objc_getClass ("NSHTTPCookieStorage");
	__xamarin_class_map [3912].handle = objc_getClass ("Foundation_NSMetadataQuery__NSMetadataQueryDelegate");
	__xamarin_class_map [3913].handle = objc_getClass ("NSMetadataQuery");
	__xamarin_class_map [3914].handle = objc_getClass ("Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate");
	__xamarin_class_map [3915].handle = objc_getClass ("NSNetServiceBrowser");
	__xamarin_class_map [3916].handle = objc_getClass ("NSProcessInfo");
	__xamarin_class_map [3917].handle = objc_getClass ("NSValueTransformer");
	__xamarin_class_map [3918].handle = objc_getClass ("NSSecureUnarchiveFromDataTransformer");
	__xamarin_class_map [3919].handle = objc_getClass ("NSURLCache");
	__xamarin_class_map [3920].handle = objc_getClass ("NSURLCredentialStorage");
	__xamarin_class_map [3921].handle = objc_getClass ("NSURLSessionStreamTask");
	__xamarin_class_map [3922].handle = objc_getClass ("NSURLSessionWebSocketTask");
	__xamarin_class_map [3923].handle = objc_getClass ("NSFileProviderDomain");
	__xamarin_class_map [3924].handle = objc_getClass ("NSFileProviderManager");
	__xamarin_class_map [3925].handle = objc_getClass ("EventKitUI_EKCalendarChooser__EKCalendarChooserDelegate");
	__xamarin_class_map [3926].handle = objc_getClass ("EKCalendarChooser");
	__xamarin_class_map [3927].handle = objc_getClass ("EventKitUI_EKEventEditViewController__EKEventEditViewDelegate");
	__xamarin_class_map [3928].handle = objc_getClass ("EventKitUI_EKEventEditViewController_EKEventEditViewControllerAppearance");
	__xamarin_class_map [3929].handle = objc_getClass ("EKEventEditViewController");
	__xamarin_class_map [3930].handle = objc_getClass ("EventKitUI_EKEventViewController__EKEventViewDelegate");
	__xamarin_class_map [3931].handle = objc_getClass ("EKEventViewController");
	__xamarin_class_map [3932].handle = objc_getClass ("EKEventStore");
	__xamarin_class_map [3933].handle = objc_getClass ("EKVirtualConferenceProvider");
	__xamarin_class_map [3934].handle = objc_getClass ("CTCellularPlanProvisioning");
	__xamarin_class_map [3935].handle = objc_getClass ("CTTelephonyNetworkInfo");
	__xamarin_class_map [3936].handle = objc_getClass ("CSSearchableIndex");
	__xamarin_class_map [3937].handle = objc_getClass ("CMAltimeter");
	__xamarin_class_map [3938].handle = objc_getClass ("CMMotionActivityManager");
	__xamarin_class_map [3939].handle = objc_getClass ("CMPedometer");
	__xamarin_class_map [3940].handle = objc_getClass ("CMStepCounter");
	__xamarin_class_map [3941].handle = objc_getClass ("MIDICIResponder");
	__xamarin_class_map [3942].handle = objc_getClass ("MLMultiArray");
	__xamarin_class_map [3943].handle = objc_getClass ("MLModel");
	__xamarin_class_map [3944].handle = objc_getClass ("MLModelCollection");
	__xamarin_class_map [3945].handle = objc_getClass ("CoreLocation_CLLocationManager__CLLocationManagerDelegate");
	__xamarin_class_map [3946].handle = objc_getClass ("CLLocationManager");
	__xamarin_class_map [3947].handle = objc_getClass ("CLGeocoder");
	__xamarin_class_map [3948].handle = objc_getClass ("NSCoreDataCoreSpotlightDelegate");
	__xamarin_class_map [3949].handle = objc_getClass ("NSManagedObjectContext");
	__xamarin_class_map [3950].handle = objc_getClass ("NSPersistentContainer");
	__xamarin_class_map [3951].handle = objc_getClass ("NSPersistentCloudKitContainer");
	__xamarin_class_map [3952].handle = objc_getClass ("NSPersistentCloudKitContainerEvent");
	__xamarin_class_map [3953].handle = objc_getClass ("NSPersistentStoreCoordinator");
	__xamarin_class_map [3954].handle = objc_getClass ("CoreBluetooth_CBCentralManager__CBCentralManagerDelegate");
	__xamarin_class_map [3955].handle = objc_getClass ("CBCentralManager");
	__xamarin_class_map [3956].handle = objc_getClass ("CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate");
	__xamarin_class_map [3957].handle = objc_getClass ("CBPeripheralManager");
	__xamarin_class_map [3958].handle = objc_getClass ("CoreBluetooth_CBPeripheral__CBPeripheralDelegate");
	__xamarin_class_map [3959].handle = objc_getClass ("CBPeripheral");
	__xamarin_class_map [3960].handle = objc_getClass ("CoreAnimation_CAAnimation__CAAnimationDelegate");
	__xamarin_class_map [3961].handle = objc_getClass ("CNContactStore");
	__xamarin_class_map [3962].handle = objc_getClass ("CKContainer");
	__xamarin_class_map [3963].handle = objc_getClass ("CKDatabase");
	__xamarin_class_map [3964].handle = objc_getClass ("CLSContext");
	__xamarin_class_map [3965].handle = objc_getClass ("CLSDataStore");
	__xamarin_class_map [3966].handle = objc_getClass ("CPInterfaceController");
	__xamarin_class_map [3967].handle = objc_getClass ("CPMapTemplate");
	__xamarin_class_map [3968].handle = objc_getClass ("UIKit_UIWindow_UIWindowAppearance");
	__xamarin_class_map [3969].handle = objc_getClass ("CarPlay_CPWindow_CPWindowAppearance");
	__xamarin_class_map [3970].handle = objc_getClass ("UIWindow");
	__xamarin_class_map [3971].handle = objc_getClass ("CPWindow");
	__xamarin_class_map [3972].handle = objc_getClass ("CXProvider");
	__xamarin_class_map [3973].handle = objc_getClass ("CXCallController");
	__xamarin_class_map [3974].handle = objc_getClass ("CXCallDirectoryExtensionContext");
	__xamarin_class_map [3975].handle = objc_getClass ("CXCallDirectoryManager");
	__xamarin_class_map [3976].handle = objc_getClass ("BusinessChat_BCChatButton_BCChatButtonAppearance");
	__xamarin_class_map [3977].handle = objc_getClass ("BCChatButton");
	__xamarin_class_map [3978].handle = objc_getClass ("BADownloadManager");
	__xamarin_class_map [3979].handle = objc_getClass ("ASAccountAuthenticationModificationExtensionContext");
	__xamarin_class_map [3980].handle = objc_getClass ("AuthenticationServices_ASAuthorizationAppleIdButton_ASAuthorizationAppleIdButtonAppearance");
	__xamarin_class_map [3981].handle = objc_getClass ("ASAuthorizationAppleIDButton");
	__xamarin_class_map [3982].handle = objc_getClass ("ASAuthorizationAppleIDCredential");
	__xamarin_class_map [3983].handle = objc_getClass ("ASAuthorizationAppleIDProvider");
	__xamarin_class_map [3984].handle = objc_getClass ("ASAuthorizationProviderExtensionAuthorizationRequest");
	__xamarin_class_map [3985].handle = objc_getClass ("ASAuthorizationSecurityKeyPublicKeyCredentialDescriptor");
	__xamarin_class_map [3986].handle = objc_getClass ("ASAuthorizationSingleSignOnCredential");
	__xamarin_class_map [3987].handle = objc_getClass ("ASCredentialIdentityStore");
	__xamarin_class_map [3988].handle = objc_getClass ("AUAudioUnit");
	__xamarin_class_map [3989].handle = objc_getClass ("ALAsset");
	__xamarin_class_map [3990].handle = objc_getClass ("ALAssetsLibrary");
	__xamarin_class_map [3991].handle = objc_getClass ("UIKit_UIPreviewInteraction__UIPreviewInteractionDelegate");
	__xamarin_class_map [3992].handle = objc_getClass ("UIPreviewInteraction");
	__xamarin_class_map [3993].handle = objc_getClass ("__MonoMac_FuncBoolDispatcher");
	__xamarin_class_map [3994].handle = objc_getClass ("UIAccessibilityCustomAction");
	__xamarin_class_map [3995].handle = objc_getClass ("UIKit_UIActionSheet__UIActionSheetDelegate");
	__xamarin_class_map [3996].handle = objc_getClass ("UIKit_UIActionSheet_UIActionSheetAppearance");
	__xamarin_class_map [3997].handle = objc_getClass ("UIActionSheet");
	__xamarin_class_map [3998].handle = objc_getClass ("UIKit_UIAlertView__UIAlertViewDelegate");
	__xamarin_class_map [3999].handle = objc_getClass ("UIKit_UIAlertView_UIAlertViewAppearance");
	__xamarin_class_map [4000].handle = objc_getClass ("UIAlertView");
	__xamarin_class_map [4001].handle = objc_getClass ("UIApplication");
	__xamarin_class_map [4002].handle = objc_getClass ("UIKit_UIBarButtonItem_Callback");
	__xamarin_class_map [4003].handle = objc_getClass ("UIKit_UICollectionView_UICollectionViewAppearance");
	__xamarin_class_map [4004].handle = objc_getClass ("UICollectionView");
	__xamarin_class_map [4005].handle = objc_getClass ("UIColor");
	__xamarin_class_map [4006].handle = objc_getClass ("UIDevice");
	__xamarin_class_map [4007].handle = objc_getClass ("UIDocumentBrowserViewController");
	__xamarin_class_map [4008].handle = objc_getClass ("UIKit_UIDocumentMenuViewController__UIDocumentMenuDelegate");
	__xamarin_class_map [4009].handle = objc_getClass ("UIDocumentMenuViewController");
	__xamarin_class_map [4010].handle = objc_getClass ("UIKit_UIDocumentPickerViewController__UIDocumentPickerDelegate");
	__xamarin_class_map [4011].handle = objc_getClass ("UIDocumentPickerViewController");
	__xamarin_class_map [4012].handle = objc_getClass ("UIDynamicAnimator");
	__xamarin_class_map [4013].handle = objc_getClass ("__UIGestureRecognizerToken");
	__xamarin_class_map [4014].handle = objc_getClass ("__UIGestureRecognizerGenericCB");
	__xamarin_class_map [4015].handle = objc_getClass ("__UIGestureRecognizerParameterlessToken");
	__xamarin_class_map [4016].handle = objc_getClass ("__UIGestureRecognizerParametrizedToken");
	__xamarin_class_map [4017].handle = objc_getClass ("UIKit_UIGestureRecognizer__UIGestureRecognizerDelegate");
	__xamarin_class_map [4018].handle = objc_getClass ("UIImage");
	__xamarin_class_map [4019].handle = objc_getClass ("UIKit_UIImagePickerController__UIImagePickerControllerDelegate");
	__xamarin_class_map [4020].handle = objc_getClass ("UIImagePickerController");
	__xamarin_class_map [4021].handle = objc_getClass ("UIKit_UINavigationBar_UINavigationBarAppearance");
	__xamarin_class_map [4022].handle = objc_getClass ("UINavigationBar");
	__xamarin_class_map [4023].handle = objc_getClass ("UIKit_UIPageViewController__UIPageViewControllerDelegate");
	__xamarin_class_map [4024].handle = objc_getClass ("UIKit_UIPageViewController__UIPageViewControllerDataSource");
	__xamarin_class_map [4025].handle = objc_getClass ("UIPageViewController");
	__xamarin_class_map [4026].handle = objc_getClass ("UIPasteboard");
	__xamarin_class_map [4027].handle = objc_getClass ("UIKit_UIPickerView_UIPickerViewAppearance");
	__xamarin_class_map [4028].handle = objc_getClass ("UIPickerView");
	__xamarin_class_map [4029].handle = objc_getClass ("UIKit_UIPopoverController__UIPopoverControllerDelegate");
	__xamarin_class_map [4030].handle = objc_getClass ("UIPopoverController");
	__xamarin_class_map [4031].handle = objc_getClass ("UIKit_UIPopoverPresentationController__UIPopoverPresentationControllerDelegate");
	__xamarin_class_map [4032].handle = objc_getClass ("UIPopoverPresentationController");
	__xamarin_class_map [4033].handle = objc_getClass ("UIKit_UIPrintInteractionController__UIPrintInteractionControllerDelegate");
	__xamarin_class_map [4034].handle = objc_getClass ("UIPrintInteractionController");
	__xamarin_class_map [4035].handle = objc_getClass ("UIScreen");
	__xamarin_class_map [4036].handle = objc_getClass ("UIKit_UISearchBar_UISearchBarAppearance");
	__xamarin_class_map [4037].handle = objc_getClass ("UIKit_UISearchBar__UISearchBarDelegate");
	__xamarin_class_map [4038].handle = objc_getClass ("UISearchBar");
	__xamarin_class_map [4039].handle = objc_getClass ("UIKit_UISearchController___Xamarin_UISearchResultsUpdating");
	__xamarin_class_map [4040].handle = objc_getClass ("UISearchController");
	__xamarin_class_map [4041].handle = objc_getClass ("UIKit_UISegmentedControl_UISegmentedControlAppearance");
	__xamarin_class_map [4042].handle = objc_getClass ("UISegmentedControl");
	__xamarin_class_map [4043].handle = objc_getClass ("UIKit_UITableView_UITableViewAppearance");
	__xamarin_class_map [4044].handle = objc_getClass ("UITableView");
	__xamarin_class_map [4045].handle = objc_getClass ("UIKit_UITableViewCell_UITableViewCellAppearance");
	__xamarin_class_map [4046].handle = objc_getClass ("UITableViewCell");
	__xamarin_class_map [4047].handle = objc_getClass ("UIKit_UITextField__UITextFieldDelegate");
	__xamarin_class_map [4048].handle = objc_getClass ("UIKit_UITextField_UITextFieldAppearance");
	__xamarin_class_map [4049].handle = objc_getClass ("UITextField");
	__xamarin_class_map [4050].handle = objc_getClass ("UIKit_UIScrollView__UIScrollViewDelegate");
	__xamarin_class_map [4051].handle = objc_getClass ("UIKit_UITextView__UITextViewDelegate");
	__xamarin_class_map [4052].handle = objc_getClass ("UIKit_UITextView_UITextViewAppearance");
	__xamarin_class_map [4053].handle = objc_getClass ("UITextView");
	__xamarin_class_map [4054].handle = objc_getClass ("UIKit_UIToolbar_UIToolbarAppearance");
	__xamarin_class_map [4055].handle = objc_getClass ("UIToolbar");
	__xamarin_class_map [4056].handle = objc_getClass ("UIKit_UIView__UIViewStaticCallback");
	__xamarin_class_map [4057].handle = objc_getClass ("NSFileProviderExtension");
	__xamarin_class_map [4058].handle = objc_getClass ("UIKit_NSTextStorage__NSTextStorageDelegate");
	__xamarin_class_map [4059].handle = objc_getClass ("NSTextStorage");
	__xamarin_class_map [4060].handle = objc_getClass ("UIKit_UIAccelerometer__UIAccelerometerDelegate");
	__xamarin_class_map [4061].handle = objc_getClass ("UIAccelerometer");
	__xamarin_class_map [4062].handle = objc_getClass ("UIKit_UIActivityIndicatorView_UIActivityIndicatorViewAppearance");
	__xamarin_class_map [4063].handle = objc_getClass ("UIActivityIndicatorView");
	__xamarin_class_map [4064].handle = objc_getClass ("UIKit_UICalendarView_UICalendarViewAppearance");
	__xamarin_class_map [4065].handle = objc_getClass ("UICalendarView");
	__xamarin_class_map [4066].handle = objc_getClass ("UIKit_UICollectionReusableView_UICollectionReusableViewAppearance");
	__xamarin_class_map [4067].handle = objc_getClass ("UICollectionReusableView");
	__xamarin_class_map [4068].handle = objc_getClass ("UIKit_UICollectionViewCell_UICollectionViewCellAppearance");
	__xamarin_class_map [4069].handle = objc_getClass ("UICollectionViewCell");
	__xamarin_class_map [4070].handle = objc_getClass ("UICollectionViewDiffableDataSource");
	__xamarin_class_map [4071].handle = objc_getClass ("UIKit_UICollectionViewListCell_UICollectionViewListCellAppearance");
	__xamarin_class_map [4072].handle = objc_getClass ("UICollectionViewListCell");
	__xamarin_class_map [4073].handle = objc_getClass ("UIKit_UICollisionBehavior__UICollisionBehaviorDelegate");
	__xamarin_class_map [4074].handle = objc_getClass ("UICollisionBehavior");
	__xamarin_class_map [4075].handle = objc_getClass ("UIKit_UIColorWell_UIColorWellAppearance");
	__xamarin_class_map [4076].handle = objc_getClass ("UIColorWell");
	__xamarin_class_map [4077].handle = objc_getClass ("UIKit_UIDatePicker_UIDatePickerAppearance");
	__xamarin_class_map [4078].handle = objc_getClass ("UIDatePicker");
	__xamarin_class_map [4079].handle = objc_getClass ("UIKit_UIDocumentInteractionController__UIDocumentInteractionControllerDelegate");
	__xamarin_class_map [4080].handle = objc_getClass ("UIDocumentInteractionController");
	__xamarin_class_map [4081].handle = objc_getClass ("UIKit_UIEventAttributionView_UIEventAttributionViewAppearance");
	__xamarin_class_map [4082].handle = objc_getClass ("UIEventAttributionView");
	__xamarin_class_map [4083].handle = objc_getClass ("UIFocusAnimationCoordinator");
	__xamarin_class_map [4084].handle = objc_getClass ("UIKit_UIImageView_UIImageViewAppearance");
	__xamarin_class_map [4085].handle = objc_getClass ("UIImageView");
	__xamarin_class_map [4086].handle = objc_getClass ("UIKit_UIInputView_UIInputViewAppearance");
	__xamarin_class_map [4087].handle = objc_getClass ("UIInputView");
	__xamarin_class_map [4088].handle = objc_getClass ("UIInputViewController");
	__xamarin_class_map [4089].handle = objc_getClass ("UIKit_UILabel_UILabelAppearance");
	__xamarin_class_map [4090].handle = objc_getClass ("UILabel");
	__xamarin_class_map [4091].handle = objc_getClass ("UILargeContentViewerInteraction");
	__xamarin_class_map [4092].handle = objc_getClass ("UIKit_UIListContentView_UIListContentViewAppearance");
	__xamarin_class_map [4093].handle = objc_getClass ("UIListContentView");
	__xamarin_class_map [4094].handle = objc_getClass ("UIMenuController");
	__xamarin_class_map [4095].handle = objc_getClass ("UIKit_UIPageControl_UIPageControlAppearance");
	__xamarin_class_map [4096].handle = objc_getClass ("UIPageControl");
	__xamarin_class_map [4097].handle = objc_getClass ("UIKit_UIPasteControl_UIPasteControlAppearance");
	__xamarin_class_map [4098].handle = objc_getClass ("UIPasteControl");
	__xamarin_class_map [4099].handle = objc_getClass ("UIPointerLockState");
	__xamarin_class_map [4100].handle = objc_getClass ("UIKit_UIPopoverBackgroundView_UIPopoverBackgroundViewAppearance");
	__xamarin_class_map [4101].handle = objc_getClass ("UIPopoverBackgroundView");
	__xamarin_class_map [4102].handle = objc_getClass ("UIPrinter");
	__xamarin_class_map [4103].handle = objc_getClass ("UIPrinterPickerController");
	__xamarin_class_map [4104].handle = objc_getClass ("UIKit_UIProgressView_UIProgressViewAppearance");
	__xamarin_class_map [4105].handle = objc_getClass ("UIProgressView");
	__xamarin_class_map [4106].handle = objc_getClass ("UIKit_UIRefreshControl_UIRefreshControlAppearance");
	__xamarin_class_map [4107].handle = objc_getClass ("UIRefreshControl");
	__xamarin_class_map [4108].handle = objc_getClass ("UIKit_UISearchTextField_UISearchTextFieldAppearance");
	__xamarin_class_map [4109].handle = objc_getClass ("UISearchTextField");
	__xamarin_class_map [4110].handle = objc_getClass ("UIKit_UISlider_UISliderAppearance");
	__xamarin_class_map [4111].handle = objc_getClass ("UISlider");
	__xamarin_class_map [4112].handle = objc_getClass ("UIKit_UISplitViewController__UISplitViewControllerDelegate");
	__xamarin_class_map [4113].handle = objc_getClass ("UISplitViewController");
	__xamarin_class_map [4114].handle = objc_getClass ("UIKit_UIStackView_UIStackViewAppearance");
	__xamarin_class_map [4115].handle = objc_getClass ("UIStackView");
	__xamarin_class_map [4116].handle = objc_getClass ("UIKit_UIStepper_UIStepperAppearance");
	__xamarin_class_map [4117].handle = objc_getClass ("UIStepper");
	__xamarin_class_map [4118].handle = objc_getClass ("UIKit_UISwitch_UISwitchAppearance");
	__xamarin_class_map [4119].handle = objc_getClass ("UISwitch");
	__xamarin_class_map [4120].handle = objc_getClass ("UIKit_UITabBar__UITabBarDelegate");
	__xamarin_class_map [4121].handle = objc_getClass ("UIKit_UITabBar_UITabBarAppearance");
	__xamarin_class_map [4122].handle = objc_getClass ("UITabBar");
	__xamarin_class_map [4123].handle = objc_getClass ("UIKit_UITabBarController__UITabBarControllerDelegate");
	__xamarin_class_map [4124].handle = objc_getClass ("UITabBarController");
	__xamarin_class_map [4125].handle = objc_getClass ("UIKit_UITabBarItem_UITabBarItemAppearance");
	__xamarin_class_map [4126].handle = objc_getClass ("UITabBarItem");
	__xamarin_class_map [4127].handle = objc_getClass ("UITableViewDiffableDataSource");
	__xamarin_class_map [4128].handle = objc_getClass ("UIKit_UITableViewHeaderFooterView_UITableViewHeaderFooterViewAppearance");
	__xamarin_class_map [4129].handle = objc_getClass ("UITableViewHeaderFooterView");
	__xamarin_class_map [4130].handle = objc_getClass ("UITextInputMode");
	__xamarin_class_map [4131].handle = objc_getClass ("UIKit_UIVideoEditorController__UIVideoEditorControllerDelegate");
	__xamarin_class_map [4132].handle = objc_getClass ("UIVideoEditorController");
	__xamarin_class_map [4133].handle = objc_getClass ("UIKit_UIVisualEffectView_UIVisualEffectViewAppearance");
	__xamarin_class_map [4134].handle = objc_getClass ("UIVisualEffectView");
	__xamarin_class_map [4135].handle = objc_getClass ("UIKit_UIWebView__UIWebViewDelegate");
	__xamarin_class_map [4136].handle = objc_getClass ("UIKit_UIWebView_UIWebViewAppearance");
	__xamarin_class_map [4137].handle = objc_getClass ("UIWebView");
	__xamarin_class_map [4138].handle = objc_getClass ("ABNewPersonViewController");
	__xamarin_class_map [4139].handle = objc_getClass ("AddressBookUI_ABPeoplePickerNavigationController_ABPeoplePickerNavigationControllerAppearance");
	__xamarin_class_map [4140].handle = objc_getClass ("ABPeoplePickerNavigationController");
	__xamarin_class_map [4141].handle = objc_getClass ("ABPersonViewController");
	__xamarin_class_map [4142].handle = objc_getClass ("ABUnknownPersonViewController");
	__xamarin_class_map [4143].handle = objc_getClass ("ACAccountStore");
	__xamarin_class_map [4144].handle = objc_getClass ("AVCustomRoutingController");
	__xamarin_class_map [4145].handle = objc_getClass ("AVKit_AVRoutePickerView_AVRoutePickerViewAppearance");
	__xamarin_class_map [4146].handle = objc_getClass ("AVRoutePickerView");
	__xamarin_class_map [4147].handle = objc_getClass ("AVAudioSession");
	__xamarin_class_map [4148].handle = objc_getClass ("AVFoundation_AVCaptureFileOutput_recordingProxy");
	__xamarin_class_map [4149].handle = objc_getClass ("AVCaptureVideoPreviewLayer");
	__xamarin_class_map [4150].handle = objc_getClass ("AVAudioUnitComponentManager");
	__xamarin_class_map [4151].handle = objc_getClass ("AVSampleBufferAudioRenderer");
	__xamarin_class_map [4152].handle = objc_getClass ("AVFoundation_AVPlayerInterstitialEventObserver");
	__xamarin_class_map [4153].handle = objc_getClass ("AVPlayerItemVideoOutput");
	__xamarin_class_map [4154].handle = objc_getClass ("AVPlayerItem");
	__xamarin_class_map [4155].handle = objc_getClass ("AVAssetExportSession");
	__xamarin_class_map [4156].handle = objc_getClass ("AVAssetWriter");
	__xamarin_class_map [4157].handle = objc_getClass ("AVAsynchronousVideoCompositionRequest");
	__xamarin_class_map [4158].handle = objc_getClass ("AVAudioEngine");
	__xamarin_class_map [4159].handle = objc_getClass ("AVAudioPlayerNode");
	__xamarin_class_map [4160].handle = objc_getClass ("AVAudioUnitComponent");
	__xamarin_class_map [4161].handle = objc_getClass ("AVCaptureDevice");
	__xamarin_class_map [4162].handle = objc_getClass ("AVCapturePhotoOutput");
	__xamarin_class_map [4163].handle = objc_getClass ("AVCaptureStillImageOutput");
	__xamarin_class_map [4164].handle = objc_getClass ("AVContentKeySession");
	__xamarin_class_map [4165].handle = objc_getClass ("AVFragmentedMovie");
	__xamarin_class_map [4166].handle = objc_getClass ("AVFragmentedMovieTrack");
	__xamarin_class_map [4167].handle = objc_getClass ("AVMIDIPlayer");
	__xamarin_class_map [4168].handle = objc_getClass ("AVMutableMovie");
	__xamarin_class_map [4169].handle = objc_getClass ("AVVideoComposition");
	__xamarin_class_map [4170].handle = objc_getClass ("AVMutableVideoComposition");
	__xamarin_class_map [4171].handle = objc_getClass ("AVVideoCompositionInstruction");
	__xamarin_class_map [4172].handle = objc_getClass ("AVMutableVideoCompositionInstruction");
	__xamarin_class_map [4173].handle = objc_getClass ("AVPlayerMediaSelectionCriteria");
	__xamarin_class_map [4174].handle = objc_getClass ("AVRouteDetector");
	__xamarin_class_map [4175].handle = objc_getClass ("AVSampleBufferDisplayLayer");
	__xamarin_class_map [4176].handle = objc_getClass ("AVSampleBufferRenderSynchronizer");
	__xamarin_class_map [4177].handle = objc_getClass ("AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate");
	__xamarin_class_map [4178].handle = objc_getClass ("AVSpeechSynthesizer");
	__xamarin_class_map [4179].handle = objc_getClass ("ARKit_ARCoachingOverlayView_ARCoachingOverlayViewAppearance");
	__xamarin_class_map [4180].handle = objc_getClass ("ARCoachingOverlayView");
	__xamarin_class_map [4181].handle = objc_getClass ("ARGeoTrackingConfiguration");
	__xamarin_class_map [4182].handle = objc_getClass ("ARReferenceImage");
	__xamarin_class_map [4183].handle = objc_getClass ("ARKit_ARSCNView_ARSCNViewAppearance");
	__xamarin_class_map [4184].handle = objc_getClass ("ARSCNView");
	__xamarin_class_map [4185].handle = objc_getClass ("ARSession");
	__xamarin_class_map [4186].handle = objc_getClass ("ARKit_ARSKView_ARSKViewAppearance");
	__xamarin_class_map [4187].handle = objc_getClass ("ARSKView");
	__xamarin_class_map [4188].handle = objc_getClass ("System_Net_Http_NSUrlSessionHandler_NSUrlSessionHandlerDelegate");
	__xamarin_class_map [4189].handle = [Xamarin_Forms_Platform_iOS_iOS7ButtonContainer class];
	__xamarin_class_map [4190].handle = [Xamarin_Forms_Platform_iOS_GlobalCloseContextGestureRecognizer class];
	__xamarin_class_map [4191].handle = [Xamarin_Forms_Platform_iOS_PlatformRenderer class];
	__xamarin_class_map [4192].handle = [Xamarin_Forms_Platform_iOS_VisualElementRenderer_1 class];
	__xamarin_class_map [4193].handle = [Xamarin_Forms_Platform_iOS_ViewRenderer_2 class];
	__xamarin_class_map [4194].handle = [Xamarin_Forms_Platform_iOS_ViewRenderer class];
	__xamarin_class_map [4195].handle = [Xamarin_Forms_Platform_iOS_CellTableViewCell class];
	__xamarin_class_map [4196].handle = [Xamarin_Forms_Platform_iOS_ActivityIndicatorRenderer class];
	__xamarin_class_map [4197].handle = [Xamarin_Forms_Platform_iOS_BoxRenderer class];
	__xamarin_class_map [4198].handle = [Xamarin_Forms_Platform_iOS_ButtonRenderer class];
	__xamarin_class_map [4199].handle = [Xamarin_Forms_Platform_iOS_NoCaretField class];
	__xamarin_class_map [4200].handle = [Xamarin_Forms_Platform_iOS_DatePickerRendererBase_1 class];
	__xamarin_class_map [4201].handle = [Xamarin_Forms_Platform_iOS_DatePickerRenderer class];
	__xamarin_class_map [4202].handle = [Xamarin_Forms_Platform_iOS_EditorRendererBase_1 class];
	__xamarin_class_map [4203].handle = [Xamarin_Forms_Platform_iOS_EditorRenderer class];
	__xamarin_class_map [4204].handle = [Xamarin_Forms_Platform_iOS_EntryRendererBase_1 class];
	__xamarin_class_map [4205].handle = [Xamarin_Forms_Platform_iOS_EntryRenderer class];
	__xamarin_class_map [4206].handle = [Xamarin_Forms_Platform_iOS_HeaderWrapperView class];
	__xamarin_class_map [4207].handle = [Xamarin_Forms_Platform_iOS_FormsRefreshControl class];
	__xamarin_class_map [4208].handle = [Xamarin_Forms_Platform_iOS_ReadOnlyField class];
	__xamarin_class_map [4209].handle = [Xamarin_Forms_Platform_iOS_PickerRendererBase_1 class];
	__xamarin_class_map [4210].handle = [Xamarin_Forms_Platform_iOS_PickerRenderer class];
	__xamarin_class_map [4211].handle = [Xamarin_Forms_Platform_iOS_ProgressBarRenderer class];
	__xamarin_class_map [4212].handle = [Xamarin_Forms_Platform_iOS_ScrollViewRenderer class];
	__xamarin_class_map [4213].handle = [Xamarin_Forms_Platform_iOS_SearchBarRenderer class];
	__xamarin_class_map [4214].handle = [Xamarin_Forms_Platform_iOS_SliderRenderer class];
	__xamarin_class_map [4215].handle = [Xamarin_Forms_Platform_iOS_StepperRenderer class];
	__xamarin_class_map [4216].handle = [Xamarin_Forms_Platform_iOS_SwitchRenderer class];
	__xamarin_class_map [4217].handle = [Xamarin_Forms_Platform_iOS_TableViewModelRenderer class];
	__xamarin_class_map [4218].handle = [Xamarin_Forms_Platform_iOS_UnEvenTableViewModelRenderer class];
	__xamarin_class_map [4219].handle = [Xamarin_Forms_Platform_iOS_TableViewRenderer class];
	__xamarin_class_map [4220].handle = [Xamarin_Forms_Platform_iOS_TimePickerRendererBase_1 class];
	__xamarin_class_map [4221].handle = [Xamarin_Forms_Platform_iOS_TimePickerRenderer class];
	__xamarin_class_map [4222].handle = [Xamarin_Forms_Platform_iOS_ItemsViewDelegator_2 class];
	__xamarin_class_map [4223].handle = [Xamarin_Forms_Platform_iOS_CarouselViewDelegator class];
	__xamarin_class_map [4224].handle = [Xamarin_Forms_Platform_iOS_ItemsViewRenderer_2 class];
	__xamarin_class_map [4225].handle = [Xamarin_Forms_Platform_iOS_CarouselViewRenderer class];
	__xamarin_class_map [4226].handle = [Xamarin_Forms_Platform_iOS_StructuredItemsViewRenderer_2 class];
	__xamarin_class_map [4227].handle = [Xamarin_Forms_Platform_iOS_SelectableItemsViewRenderer_2 class];
	__xamarin_class_map [4228].handle = [Xamarin_Forms_Platform_iOS_GroupableItemsViewRenderer_2 class];
	__xamarin_class_map [4229].handle = [Xamarin_Forms_Platform_iOS_CollectionViewRenderer class];
	__xamarin_class_map [4230].handle = [Xamarin_Forms_Platform_iOS_ItemsViewController_1 class];
	__xamarin_class_map [4231].handle = [Xamarin_Forms_Platform_iOS_StructuredItemsViewController_1 class];
	__xamarin_class_map [4232].handle = [Xamarin_Forms_Platform_iOS_SelectableItemsViewController_1 class];
	__xamarin_class_map [4233].handle = [Xamarin_Forms_Platform_iOS_GroupableItemsViewController_1 class];
	__xamarin_class_map [4234].handle = [Xamarin_Forms_Platform_iOS_SelectableItemsViewDelegator_2 class];
	__xamarin_class_map [4235].handle = [Xamarin_Forms_Platform_iOS_GroupableItemsViewDelegator_2 class];
	__xamarin_class_map [4236].handle = [Xamarin_Forms_Platform_iOS_ItemsViewCell class];
	__xamarin_class_map [4237].handle = [Xamarin_Forms_Platform_iOS_TemplatedCell class];
	__xamarin_class_map [4238].handle = [Xamarin_Forms_Platform_iOS_HeightConstrainedTemplatedCell class];
	__xamarin_class_map [4239].handle = [Xamarin_Forms_Platform_iOS_HorizontalCell class];
	__xamarin_class_map [4240].handle = [Xamarin_Forms_Platform_iOS_DefaultCell class];
	__xamarin_class_map [4241].handle = [Xamarin_Forms_Platform_iOS_HorizontalDefaultSupplementalView class];
	__xamarin_class_map [4242].handle = [Xamarin_Forms_Platform_iOS_HorizontalSupplementaryView class];
	__xamarin_class_map [4243].handle = [Xamarin_Forms_Platform_iOS_HorizontalDefaultCell class];
	__xamarin_class_map [4244].handle = [Xamarin_Forms_Platform_iOS_WidthConstrainedTemplatedCell class];
	__xamarin_class_map [4245].handle = [Xamarin_Forms_Platform_iOS_VerticalCell class];
	__xamarin_class_map [4246].handle = [Xamarin_Forms_Platform_iOS_VerticalDefaultCell class];
	__xamarin_class_map [4247].handle = [Xamarin_Forms_Platform_iOS_ItemsViewLayout class];
	__xamarin_class_map [4248].handle = [Xamarin_Forms_Platform_iOS_GridViewLayout class];
	__xamarin_class_map [4249].handle = [Xamarin_Forms_Platform_iOS_ListViewLayout class];
	__xamarin_class_map [4250].handle = [Xamarin_Forms_Platform_iOS_VerticalDefaultSupplementalView class];
	__xamarin_class_map [4251].handle = [Xamarin_Forms_Platform_iOS_VerticalSupplementaryView class];
	__xamarin_class_map [4252].handle = [Xamarin_Forms_Platform_iOS_FormsCAKeyFrameAnimation class];
	__xamarin_class_map [4253].handle = [Xamarin_Forms_Platform_iOS_FormsCheckBox class];
	__xamarin_class_map [4254].handle = [Xamarin_Forms_Platform_iOS_FormsUIImageView class];
	__xamarin_class_map [4255].handle = [Xamarin_Forms_Platform_iOS_NativeViewWrapperRenderer class];
	__xamarin_class_map [4256].handle = [Xamarin_Forms_Platform_iOS_PageContainer class];
	__xamarin_class_map [4257].handle = [Xamarin_Forms_Platform_iOS_CheckBoxRendererBase_1 class];
	__xamarin_class_map [4258].handle = [Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer class];
	__xamarin_class_map [4259].handle = [Xamarin_Forms_Platform_iOS_PhoneMasterDetailRenderer class];
	__xamarin_class_map [4260].handle = [Xamarin_Forms_Platform_iOS_ChildViewController class];
	__xamarin_class_map [4261].handle = [Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer class];
	__xamarin_class_map [4262].handle = [Xamarin_Forms_Platform_iOS_TabletMasterDetailRenderer class];
	__xamarin_class_map [4263].handle = [Xamarin_Forms_Platform_iOS_ShellItemRenderer class];
	__xamarin_class_map [4264].handle = [Xamarin_Forms_Platform_iOS_ShellSearchResultsRenderer class];
	__xamarin_class_map [4265].handle = [Xamarin_Forms_Platform_iOS_ShellTableViewController class];
	__xamarin_class_map [4266].handle = [Xamarin_Forms_Platform_iOS_TabletShellFlyoutRenderer class];
	__xamarin_class_map [4267].handle = [Xamarin_Forms_Platform_iOS_UIContainerCell class];
	__xamarin_class_map [4268].handle = [Xamarin_Forms_Platform_iOS_UIContainerView class];
	__xamarin_class_map [4269].handle = [Xamarin_Forms_Platform_iOS_NativeViewPropertyListener class];
	__xamarin_class_map [4270].handle = [Xamarin_Forms_Platform_iOS_CheckBoxRenderer class];
	__xamarin_class_map [4271].handle = [Xamarin_Forms_Platform_iOS_CarouselViewLayout class];
	__xamarin_class_map [4272].handle = [Xamarin_Forms_Platform_iOS_CarouselViewController class];
	__xamarin_class_map [4273].handle = [Xamarin_Forms_Platform_iOS_CarouselTemplatedCell class];
	__xamarin_class_map [4274].handle = [Xamarin_Forms_Platform_iOS_RefreshViewRenderer class];
	__xamarin_class_map [4275].handle = [Xamarin_Forms_Platform_iOS_IndicatorViewRenderer class];
	__xamarin_class_map [4276].handle = [Xamarin_Forms_Platform_iOS_FormsPageControl class];
	__xamarin_class_map [4277].handle = [Xamarin_Forms_Platform_iOS_ShapeRenderer_2 class];
	__xamarin_class_map [4278].handle = [Xamarin_Forms_Platform_iOS_ShapeView class];
	__xamarin_class_map [4279].handle = [Xamarin_Forms_Platform_iOS_ShapeLayer class];
	__xamarin_class_map [4280].handle = [Xamarin_Forms_Platform_iOS_PathRenderer class];
	__xamarin_class_map [4281].handle = [Xamarin_Forms_Platform_iOS_PathView class];
	__xamarin_class_map [4282].handle = [Xamarin_Forms_Platform_iOS_EllipseRenderer class];
	__xamarin_class_map [4283].handle = [Xamarin_Forms_Platform_iOS_EllipseView class];
	__xamarin_class_map [4284].handle = [Xamarin_Forms_Platform_iOS_LineRenderer class];
	__xamarin_class_map [4285].handle = [Xamarin_Forms_Platform_iOS_LineView class];
	__xamarin_class_map [4286].handle = [Xamarin_Forms_Platform_iOS_PolygonRenderer class];
	__xamarin_class_map [4287].handle = [Xamarin_Forms_Platform_iOS_PolygonView class];
	__xamarin_class_map [4288].handle = [Xamarin_Forms_Platform_iOS_PolylineRenderer class];
	__xamarin_class_map [4289].handle = [Xamarin_Forms_Platform_iOS_PolylineView class];
	__xamarin_class_map [4290].handle = [Xamarin_Forms_Platform_iOS_RectangleRenderer class];
	__xamarin_class_map [4291].handle = [Xamarin_Forms_Platform_iOS_RectangleView class];
	__xamarin_class_map [4292].handle = [Xamarin_Forms_Platform_iOS_ShellFlyoutHeaderContainer class];
	__xamarin_class_map [4293].handle = [Xamarin_Forms_Platform_iOS_ContextActionsCell_SelectGestureRecognizer class];
	__xamarin_class_map [4294].handle = [Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetController class];
	__xamarin_class_map [4295].handle = [Xamarin_Forms_Platform_iOS_ContextActionsCell_MoreActionSheetDelegate class];
	__xamarin_class_map [4296].handle = [Xamarin_Forms_Platform_iOS_ContextActionsCell class];
	__xamarin_class_map [4297].handle = [Xamarin_Forms_Platform_iOS_ContextScrollViewDelegate class];
	__xamarin_class_map [4298].handle = [Xamarin_Forms_Platform_iOS_Platform_DefaultRenderer class];
	__xamarin_class_map [4299].handle = [Xamarin_Forms_Platform_iOS_EntryCellRenderer_EntryCellTableViewCell class];
	__xamarin_class_map [4300].handle = [Xamarin_Forms_Platform_iOS_ViewCellRenderer_ViewTableCell class];
	__xamarin_class_map [4301].handle = [Xamarin_Forms_Platform_iOS_CarouselPageRenderer_CarouselPageContainer class];
	__xamarin_class_map [4302].handle = [Xamarin_Forms_Platform_iOS_CarouselPageRenderer class];
	__xamarin_class_map [4303].handle = [Xamarin_Forms_Platform_iOS_EditorRendererBase_1_FormsUITextView class];
	__xamarin_class_map [4304].handle = [Xamarin_Forms_Platform_iOS_FrameRenderer_FrameView class];
	__xamarin_class_map [4305].handle = [Xamarin_Forms_Platform_iOS_FrameRenderer class];
	__xamarin_class_map [4306].handle = [Xamarin_Forms_Platform_iOS_ImageRenderer class];
	__xamarin_class_map [4307].handle = [Xamarin_Forms_Platform_iOS_LabelRenderer_FormsLabel class];
	__xamarin_class_map [4308].handle = [Xamarin_Forms_Platform_iOS_LabelRenderer class];
	__xamarin_class_map [4309].handle = [Xamarin_Forms_Platform_iOS_ListViewRenderer_ListViewDataSource class];
	__xamarin_class_map [4310].handle = [Xamarin_Forms_Platform_iOS_ListViewRenderer_UnevenListViewDataSource class];
	__xamarin_class_map [4311].handle = [Xamarin_Forms_Platform_iOS_ListViewRenderer class];
	__xamarin_class_map [4312].handle = [Xamarin_Forms_Platform_iOS_FormsUITableViewController class];
	__xamarin_class_map [4313].handle = [Xamarin_Forms_Platform_iOS_NavigationRenderer_FormsNavigationBar class];
	__xamarin_class_map [4314].handle = [Xamarin_Forms_Platform_iOS_NavigationRenderer_Container class];
	__xamarin_class_map [4315].handle = [Xamarin_Forms_Platform_iOS_OpenGLViewRenderer_Delegate class];
	__xamarin_class_map [4316].handle = [Xamarin_Forms_Platform_iOS_OpenGLViewRenderer class];
	__xamarin_class_map [4317].handle = [Xamarin_Forms_Platform_iOS_PickerRendererBase_1_PickerSource class];
	__xamarin_class_map [4318].handle = [Xamarin_Forms_Platform_iOS_TabbedRenderer class];
	__xamarin_class_map [4319].handle = [Xamarin_Forms_Platform_iOS_DragAndDropDelegate_CustomLocalStateData class];
	__xamarin_class_map [4320].handle = [Xamarin_Forms_Platform_iOS_DragAndDropDelegate class];
	__xamarin_class_map [4321].handle = [Xamarin_Forms_Platform_iOS_ModalWrapper class];
	__xamarin_class_map [4322].handle = [Xamarin_Forms_Platform_iOS_PhoneFlyoutPageRenderer_ChildViewController class];
	__xamarin_class_map [4323].handle = [Xamarin_Forms_Platform_iOS_EventedViewController_FlyoutView class];
	__xamarin_class_map [4324].handle = [Xamarin_Forms_Platform_iOS_EventedViewController class];
	__xamarin_class_map [4325].handle = [Xamarin_Forms_Platform_iOS_TabletFlyoutPageRenderer_InnerDelegate class];
	__xamarin_class_map [4326].handle = [Xamarin_Forms_Platform_iOS_ShellFlyoutContentRenderer class];
	__xamarin_class_map [4327].handle = [Xamarin_Forms_Platform_iOS_ShellFlyoutRenderer class];
	__xamarin_class_map [4328].handle = [Xamarin_Forms_Platform_iOS_ShellPageRendererTracker_TitleViewContainer class];
	__xamarin_class_map [4329].handle = [Xamarin_Forms_Platform_iOS_ShellRenderer class];
	__xamarin_class_map [4330].handle = [Xamarin_Forms_Platform_iOS_ShellSectionRootHeader_ShellSectionHeaderCell class];
	__xamarin_class_map [4331].handle = [Xamarin_Forms_Platform_iOS_ShellSectionRootHeader class];
	__xamarin_class_map [4332].handle = [Xamarin_Forms_Platform_iOS_ShellSectionRootRenderer class];
	__xamarin_class_map [4333].handle = [Xamarin_Forms_Platform_iOS_ShellSectionRenderer_GestureDelegate class];
	__xamarin_class_map [4334].handle = [Xamarin_Forms_Platform_iOS_ShellSectionRenderer_NavDelegate class];
	__xamarin_class_map [4335].handle = [Xamarin_Forms_Platform_iOS_ShellSectionRenderer class];
	__xamarin_class_map [4336].handle = [Xamarin_Forms_Platform_iOS_ShellTableViewSource_SeparatorView class];
	__xamarin_class_map [4337].handle = [Xamarin_Forms_Platform_iOS_ShellTableViewSource class];
	__xamarin_class_map [4338].handle = [Xamarin_Forms_Platform_iOS_ImageButtonRenderer class];
	__xamarin_class_map [4339].handle = [Xamarin_Forms_Platform_iOS_SwipeViewRenderer class];
	__xamarin_class_map [4340].handle = [Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_PrimaryToolbarItem class];
	__xamarin_class_map [4341].handle = [Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem_SecondaryToolbarItemContent class];
	__xamarin_class_map [4342].handle = [Xamarin_Forms_Platform_iOS_ToolbarItemExtensions_SecondaryToolbarItem class];
	__xamarin_class_map [4343].handle = [Xamarin_Forms_Platform_iOS_NavigationRenderer_SecondaryToolbar class];
	__xamarin_class_map [4344].handle = [Xamarin_Forms_Platform_iOS_NavigationRenderer_ParentingViewController class];
	__xamarin_class_map [4345].handle = [Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewNavigationDelegate class];
	__xamarin_class_map [4346].handle = [Xamarin_Forms_Platform_iOS_WkWebViewRenderer_CustomWebViewUIDelegate class];
	__xamarin_class_map [4347].handle = [Plugin_FirebasePushNotification_FirebasePushNotificationManager class];
	__xamarin_class_map [4348].handle = [FIRMessagingMessageInfo class];
	__xamarin_class_map [4349].handle = [ApiDefinition__Firebase_CloudMessaging_MessagingDelegate class];
	__xamarin_class_map [4350].handle = [FIRMessagingExtensionHelper class];
	__xamarin_class_map [4351].handle = [FIRMessagingRemoteMessage class];
	__xamarin_class_map [4352].handle = [FIRMessaging class];
	__xamarin_class_map [4353].handle = [FIRApp class];
	__xamarin_class_map [4354].handle = [FIRConfiguration class];
	__xamarin_class_map [4355].handle = [FIROptions class];
	__xamarin_class_map [4356].handle = [FIRInstallationsAuthTokenResult class];
	__xamarin_class_map [4357].handle = [FIRInstallations class];
	__xamarin_class_map [4358].handle = [FIRInstanceIDResult class];
	__xamarin_class_map [4359].handle = [FIRInstanceID class];
	__xamarin_class_map [4360].handle = [Xamarin_Essentials_ShareActivityItemSource class];
	__xamarin_class_map [4361].handle = [Xamarin_Essentials_AuthManager class];
	__xamarin_class_map [4362].handle = [Xamarin_Essentials_SingleLocationListener class];
	__xamarin_class_map [4363].handle = [Xamarin_Essentials_Contacts_ContactPickerDelegate class];
	__xamarin_class_map [4364].handle = [Xamarin_Essentials_FilePicker_PickerDelegate class];
	__xamarin_class_map [4365].handle = [Xamarin_Essentials_MediaPicker_PhotoPickerDelegate class];
	__xamarin_class_map [4366].handle = [Xamarin_Essentials_Platform_UIPresentationControllerDelegate class];
	__xamarin_class_map [4367].handle = [Xamarin_Essentials_WebAuthenticator_NativeSFSafariViewControllerDelegate class];
	__xamarin_class_map [4368].handle = [Xamarin_Essentials_WebAuthenticator_ContextProvider class];
	__xamarin_class_map [4369].handle = [Xamarin_Essentials_Permissions_LocationWhenInUse_ManagerDelegate class];
	__xamarin_class_map [4370].handle = [OpenTK_Platform_iPhoneOS_CADisplayLinkTimeSource class];
	__xamarin_class_map [4371].handle = [OpenTK_Platform_iPhoneOS_iPhoneOSGameView class];
	__xamarin_class_map [4372].handle = [Xamarin_Forms_PancakeView_iOS_PancakeViewRenderer class];
	__xamarin_class_map [4373].handle = [Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeRoundedStackView class];
	__xamarin_class_map [4374].handle = [Xamarin_CommunityToolkit_iOS_UI_Views_SideMenuViewRenderer class];
	__xamarin_class_map [4375].handle = [Xamarin_CommunityToolkit_iOS_Effects_TouchEventsGestureRecognizer class];
	__xamarin_class_map [4376].handle = [Xamarin_CommunityToolkit_iOS_Effects_ShouldRecognizeSimultaneouslyRecognizerDelegate class];
	__xamarin_class_map [4377].handle = [Xamarin_CommunityToolkit_UI_Views_PhotoCaptureDelegate class];
	__xamarin_class_map [4378].handle = [Xamarin_CommunityToolkit_UI_Views_MediaElementRenderer class];
	__xamarin_class_map [4379].handle = [Xamarin_CommunityToolkit_UI_Views_SemanticOrderViewRenderer class];
	__xamarin_class_map [4380].handle = [Xamarin_CommunityToolkit_UI_Views_ImageSwitcherRenderer class];
	__xamarin_class_map [4381].handle = [Xamarin_CommunityToolkit_UI_Views_TextSwitcherRenderer class];
	__xamarin_class_map [4382].handle = [Xamarin_CommunityToolkit_UI_Views_Helpers_PaddedLabel class];
	__xamarin_class_map [4383].handle = [Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBar_BaseSnackBarView class];
	__xamarin_class_map [4384].handle = [Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_SnackBarViews_MessageSnackBarView class];
	__xamarin_class_map [4385].handle = [Xamarin_CommunityToolkit_UI_Views_Helpers_iOS_ActionMessageSnackBarView class];
	__xamarin_class_map [4386].handle = [Xamarin_CommunityToolkit_Views_Snackbar_Helpers_NativeSnackButton class];
	__xamarin_class_map [4387].handle = [Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizer class];
	__xamarin_class_map [4388].handle = [Xamarin_CommunityToolkit_iOS_Effects_TouchUITapGestureRecognizerDelegate class];
	__xamarin_class_map [4389].handle = [Xamarin_CommunityToolkit_UI_Views_CameraViewRenderer class];
	__xamarin_class_map [4390].handle = [Xamarin_CommunityToolkit_UI_Views_FormsCameraView class];
	__xamarin_class_map [4391].handle = [Xamarin_CommunityToolkit_UI_Views_DrawingViewRenderer class];
	__xamarin_class_map [4392].handle = [Xamarin_CommunityToolkit_UI_Views_PopupRenderer_PopoverDelegate class];
	__xamarin_class_map [4393].handle = [Xamarin_CommunityToolkit_UI_Views_PopupRenderer class];
	__xamarin_class_map [4394].handle = [ImageCircle_Forms_Plugin_iOS_ImageCircleRenderer class];
	__xamarin_class_map [4395].handle = [AiForms_Effects_iOS_NumberPickerSource class];
	__xamarin_class_map [4396].handle = [AiForms_Effects_iOS_PaddingLabel class];
	__xamarin_class_map [4397].handle = [AiForms_Effects_iOS_NoCaretField class];
	__xamarin_class_map [4398].handle = [AiForms_Effects_iOS_TouchEffectGestureRecognizer class];
	__xamarin_class_map [4399].handle = [AiForms_Effects_iOS_AlwaysSimultaneouslyGestureRecognizerDelegate class];
	__xamarin_class_map [4400].handle = [IQKeyboardManager class];
	__xamarin_class_map [4401].handle = [IQKeyboardReturnKeyHandler class];
	__xamarin_class_map [4402].handle = [Xamarin_IQBarButtonItem_IQBarButtonItemAppearance class];
	__xamarin_class_map [4403].handle = [IQBarButtonItem class];
	__xamarin_class_map [4404].handle = [Xamarin_IQPreviousNextView_IQPreviousNextViewAppearance class];
	__xamarin_class_map [4405].handle = [IQPreviousNextView class];
	__xamarin_class_map [4406].handle = [Xamarin_IQTextView_IQTextViewAppearance class];
	__xamarin_class_map [4407].handle = [IQTextView class];
	__xamarin_class_map [4408].handle = [Xamarin_IQTitleBarButtonItem_IQTitleBarButtonItemAppearance class];
	__xamarin_class_map [4409].handle = [IQTitleBarButtonItem class];
	__xamarin_class_map [4410].handle = [Xamarin_IQToolbar_IQToolbarAppearance class];
	__xamarin_class_map [4411].handle = [IQToolbar class];
	__xamarin_class_map [4412].handle = [Xamarin_UIView_IQToolbarAddition_UIView_IQToolbarAdditionAppearance class];
	__xamarin_class_map [4413].handle = [SVG_Forms_Plugin_iOS_SvgImageRenderer class];
	__xamarin_class_map [4414].handle = [Syncfusion_SfPdfViewer_XForms_iOS_InkViewPanGestureDelegate class];
	__xamarin_class_map [4415].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBorder class];
	__xamarin_class_map [4416].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CustomViewBubble class];
	__xamarin_class_map [4417].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CustomViewHolder class];
	__xamarin_class_map [4418].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CustomViewSelection class];
	__xamarin_class_map [4419].handle = [Syncfusion_SfPdfViewer_XForms_iOS_StampIcon class];
	__xamarin_class_map [4420].handle = [Syncfusion_SfPdfViewer_XForms_iOS_TextBubbleView class];
	__xamarin_class_map [4421].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SelectionBorderView class];
	__xamarin_class_map [4422].handle = [Syncfusion_SfPdfViewer_XForms_iOS_TextSelectionView class];
	__xamarin_class_map [4423].handle = [Syncfusion_SfPdfViewer_XForms_iOS_TextView class];
	__xamarin_class_map [4424].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ListPopupView class];
	__xamarin_class_map [4425].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PopupListCell class];
	__xamarin_class_map [4426].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PopupListSource class];
	__xamarin_class_map [4427].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfWidget class];
	__xamarin_class_map [4428].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfTextField class];
	__xamarin_class_map [4429].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfTextFieldDelegate class];
	__xamarin_class_map [4430].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfCheckBox class];
	__xamarin_class_map [4431].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfComboBox class];
	__xamarin_class_map [4432].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfListBox class];
	__xamarin_class_map [4433].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ListBoxSource class];
	__xamarin_class_map [4434].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfRadioButton class];
	__xamarin_class_map [4435].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectBorderView class];
	__xamarin_class_map [4436].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ShapeSelectionView class];
	__xamarin_class_map [4437].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SignaturePad class];
	__xamarin_class_map [4438].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SignatureView class];
	__xamarin_class_map [4439].handle = [PdfContentView class];
	__xamarin_class_map [4440].handle = [CurrentHighlightedView class];
	__xamarin_class_map [4441].handle = [Syncfusion_SfPdfViewer_XForms_iOS_AlertViewDelegate class];
	__xamarin_class_map [4442].handle = [Syncfusion_SfPdfViewer_XForms_iOS_AlertViewTextBoxDelegate class];
	__xamarin_class_map [4443].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CustomSearchRenderer class];
	__xamarin_class_map [4444].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CustomPageRenderer class];
	__xamarin_class_map [4445].handle = [Syncfusion_SfPdfViewer_XForms_iOS_EditTextPopup class];
	__xamarin_class_map [4446].handle = [Syncfusion_SfPdfViewer_XForms_iOS_HyperlinkAnnotation class];
	__xamarin_class_map [4447].handle = [Syncfusion_SfPdfViewer_XForms_iOS_BubbleView class];
	__xamarin_class_map [4448].handle = [Syncfusion_SfPdfViewer_XForms_iOS_InkSetting class];
	__xamarin_class_map [4449].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SelectBorderView class];
	__xamarin_class_map [4450].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SelectionView class];
	__xamarin_class_map [4451].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PasswordDialogView class];
	__xamarin_class_map [4452].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SfLabelRendererIOS class];
	__xamarin_class_map [4453].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SfFontButtonRenderer class];
	__xamarin_class_map [4454].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SfPdfDocumentViewRenderer class];
	__xamarin_class_map [4455].handle = [Syncfusion_SfPdfViewer_XForms_iOS_MaterialSfPdfDocumentViewRenderer class];
	__xamarin_class_map [4456].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CustomStackLayoutRendereriOS class];
	__xamarin_class_map [4457].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SliderCustomRenderer class];
	__xamarin_class_map [4458].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ImageAndCanvasContainer class];
	__xamarin_class_map [4459].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PageScrollView class];
	__xamarin_class_map [4460].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PageScrollViewContainer class];
	__xamarin_class_map [4461].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SinglePageViewer class];
	__xamarin_class_map [4462].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SfPdfVieweriOS class];
	__xamarin_class_map [4463].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PasswordTextFieldDelegate class];
	__xamarin_class_map [4464].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PdfButton class];
	__xamarin_class_map [4465].handle = [Syncfusion_SfPdfViewer_XForms_iOS_StampRendererView class];
	__xamarin_class_map [4466].handle = [Syncfusion_SfPdfViewer_XForms_iOS_SignatureField class];
	__xamarin_class_map [4467].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ArrowAnnotationSettings class];
	__xamarin_class_map [4468].handle = [Syncfusion_SfPdfViewer_XForms_iOS_CircleAnnotationSettings class];
	__xamarin_class_map [4469].handle = [Syncfusion_SfPdfViewer_XForms_iOS_DummyView class];
	__xamarin_class_map [4470].handle = [Syncfusion_SfPdfViewer_XForms_iOS_LineAnnotationSettings class];
	__xamarin_class_map [4471].handle = [Syncfusion_SfPdfViewer_XForms_iOS_PolygonAnnotationView class];
	__xamarin_class_map [4472].handle = [Syncfusion_SfPdfViewer_XForms_iOS_RectangleAnnotationSettings class];
	__xamarin_class_map [4473].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ShapeBubbleView class];
	__xamarin_class_map [4474].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ImageViewEx class];
	__xamarin_class_map [4475].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ScrollHead class];
	__xamarin_class_map [4476].handle = [Syncfusion_SfPdfViewer_XForms_iOS_ScrollViewEx class];
	__xamarin_class_map [4477].handle = [Syncfusion_SfPdfViewer_XForms_iOS_StackViewEx class];
	__xamarin_class_map [4478].handle = [TransparentCanvas class];
	__xamarin_class_map [4479].handle = [Syncfusion_SfPdfViewer_XForms_iOS_InkGroup class];
	__xamarin_class_map [4480].handle = [Bubble class];
	__xamarin_class_map [4481].handle = [SfBusyIndicator class];
	__xamarin_class_map [4482].handle = [Syncfusion_SfBusyIndicator_iOS_SFBusyIndicator class];
	__xamarin_class_map [4483].handle = [Syncfusion_XForms_iOS_Graphics_SfGradientViewRenderer class];
	__xamarin_class_map [4484].handle = [Syncfusion_XForms_iOS_Shimmer_SfShimmerRenderer class];
	__xamarin_class_map [4485].handle = [Syncfusion_XForms_iOS_Shimmer_ShimmerViewRenderer class];
	__xamarin_class_map [4486].handle = [Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorderRenderer class];
	__xamarin_class_map [4487].handle = [Syncfusion_XForms_iOS_TextInputLayout_InputLayoutToggleViewRenderer class];
	__xamarin_class_map [4488].handle = [Syncfusion_XForms_iOS_TextInputLayout_SfTextInputLayoutRenderer class];
	__xamarin_class_map [4489].handle = [Syncfusion_XForms_iOS_TextInputLayout_InputLayoutBorder class];
	__xamarin_class_map [4490].handle = [Syncfusion_XForms_iOS_TextInputLayout_InputLayoutClearButtonViewRenderer class];
	__xamarin_class_map [4491].handle = [Syncfusion_XForms_iOS_Core_FontIconLabelRenderer class];
	__xamarin_class_map [4492].handle = [Syncfusion_XForms_iOS_EffectsView_SfEffectsViewLayer class];
	__xamarin_class_map [4493].handle = [Syncfusion_XForms_iOS_Shimmer_ShimmerWaveLayer class];
	__xamarin_class_map [4494].handle = [Syncfusion_XForms_iOS_Border_SfBorderRenderer class];
	__xamarin_class_map [4495].handle = [Syncfusion_XForms_iOS_EffectsView_SfEffectsViewRenderer class];
	__xamarin_class_map [4496].handle = [Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderRenderer class];
	__xamarin_class_map [4497].handle = [Syncfusion_SfRangeSlider_XForms_iOS_SfRangeSliderVisualRenderer class];
	__xamarin_class_map [4498].handle = [Syncfusion_SfRangeSlider_iOS_SfLabelItems class];
	__xamarin_class_map [4499].handle = [Syncfusion_SfRangeSlider_iOS_SFLabelItems class];
	__xamarin_class_map [4500].handle = [Syncfusion_SfRangeSlider_iOS_SfRangeKnobLayer class];
	__xamarin_class_map [4501].handle = [SfRangeSlider class];
	__xamarin_class_map [4502].handle = [Syncfusion_SfRangeSlider_iOS_SFRangeSlider class];
	__xamarin_class_map [4503].handle = [Syncfusion_SfRangeSlider_iOS_SfRangeTickLayer class];
	__xamarin_class_map [4504].handle = [Syncfusion_SfRangeSlider_iOS_SfRangeTracker class];
	__xamarin_class_map [4505].handle = [Syncfusion_SfRangeSlider_iOS_SfThumb class];
	__xamarin_class_map [4506].handle = [Syncfusion_SfRangeSlider_iOS_SFThumb class];
	__xamarin_class_map [4507].handle = [Syncfusion_SfRangeSlider_iOS_SfThumbItem class];
	__xamarin_class_map [4508].handle = [Syncfusion_SfRangeSlider_iOS_SFThumbItem class];
	__xamarin_class_map [4509].handle = [Syncfusion_SfRangeSlider_iOS_CustomRangePanGesture class];
	__xamarin_class_map [4510].handle = [Syncfusion_SfRangeSlider_iOS_BalloonLayer class];
	__xamarin_class_map [4511].handle = [XamForms_Controls_iOS_CalendarButtonRenderer class];
	xamarin_add_registration_map (&__xamarin_registration_map, false);
}


} /* extern "C" */
